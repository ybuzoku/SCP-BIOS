     1                                  [map all ./Source/scpbios.map]
     2                                  ;-----------------------------------SCPBIOS-----------------------------------
     3                                  %include "./Source/Include/equates.inc"
     4                              <1> ;------------------------------------Equates------------------------------------
     5                              <1> permissionflags equ 003h    ;Page table Permission flags
     6                              <1> codedescriptor     equ 0008h
     7                              <1> 
     8                              <1> BIOSStartAddr   equ 00110000h   ;Start just after HMA + 16 bytes
     9                              <1> BIOSInitAddr    equ 800h
    10                              <1> 
    11                              <1> e820Seg         equ 1000h
    12                              <1> e820SizeOff     equ 0000h    ;First word is # of entries
    13                              <1> e820BaseOff     equ e820SizeOff + 2
    14                              <1> e820SizeAddr    equ (e820Seg<<4) + e820SizeOff
    15                              <1> ;---------------------PIC Chip IO values---------------------
    16                              <1> pic1command     equ 020h        ;Command port
    17                              <1> pic2command     equ 0A0h        ;Command port
    18                              <1> pic1data        equ 021h        ;Data port
    19                              <1> pic2data        equ 0A1h        ;Data port
    20                              <1> ;------------------------------------------------------------
    21                              <1> ;-----------------PS/2 IO port commands----------------------
    22                              <1> ps2command      equ 64h            ;Command Port (write)
    23                              <1> ps2status       equ 64h            ;Status Port  (read)
    24                              <1> ps2data         equ 60h           ;Data Port     (read/write)
    25                              <1> ;------------------------------------------------------------
    26                              <1> ;--------------------Serial port equates---------------------
    27                              <1> com1_base       equ 03F8h
    28                              <1> com2_base       equ 02F8h
    29                              <1> com3_base       equ 03E8h
    30                              <1> com4_base       equ 02E8h
    31                              <1> ;------------------------------------------------------------
    32                              <1> ;---------------------PIT port equates-----------------------
    33                              <1> PITbase         equ 40h
    34                              <1> PIT0            equ PITbase
    35                              <1> PIT1            equ PITbase + 1
    36                              <1> PIT2            equ PITbase + 2
    37                              <1> PITcommand      equ PITbase + 3
    38                              <1> ;------------------------------------------------------------
    39                              <1> ;---------------------CMOS port equates----------------------
    40                              <1> cmos_base        equ 70h
    41                              <1> cmos_data        equ 71h
    42                              <1> ;------------------------------------------------------------
    43                              <1> ;--------------------Keyboard equates------------------------
    44                              <1> kb_flag_rshift   equ    01h    ;Right Shift is being held
    45                              <1> kb_flag_lshift   equ    02h    ;Left Shift is being held
    46                              <1> kb_flag_ctrl     equ    04h    ;Ctrl is being held
    47                              <1> kb_flag_alt      equ    08h    ;Alt is being held
    48                              <1> kb_flag_scrlset  equ    10h    ;Scroll lock is set
    49                              <1> kb_flag_numset   equ    20h    ;Num lock is set
    50                              <1> kb_flag_capsset  equ    40h    ;Caps lock is set
    51                              <1> kb_flag_insset   equ    80h    ;Insert mode is set
    52                              <1> 
    53                              <1> kb_flag2_e1      equ    01h    ;0E1h scancode procedure being processed
    54                              <1> kb_flag2_e0      equ    02h    ;0E0h scancode procedure being processed
    55                              <1> ;------------------------------------------------------------
    56                              <1> ;--------------------Screen equates--------------------------
    57                              <1> vga_index        equ    03D4h
    58                              <1> vga_data         equ    03D5h
    59                              <1> ;---------------- New Equates ----------------
    60                              <1> vga_aindex       equ    03B4h    ;Alt (MDA) IO Base
    61                              <1> vga_adata        equ    03B5h
    62                              <1> ;These equates are SEGMENTS, need to be SHL 4 to become addrs
    63                              <1> vga_bpage0       equ    0A0000h
    64                              <1> vga_bpage1       equ    0B0000h
    65                              <1> vga_bpage2       equ    0B8000h
    66                              <1> ;------------------------------------------------------------
    67                              <1> ;----------------------PCI equates---------------------------
    68                              <1> pci_index        equ    0CF8h
    69                              <1> pci_data         equ    0CFCh
    70                              <1> ;------------------------------------------------------------
    71                              <1> ;----------------------USB equates---------------------------
    72                              <1> usb_class        equ    0Ch    ;pci class
    73                              <1> usb_subclass     equ    03h    ;pci subclase
    74                              <1> uhci_interface   equ    00h    ;usb 1.0
    75                              <1> uhcimask         equ    10h
    76                              <1> ohci_interface   equ    10h    ;usb 1.0 alt
    77                              <1> ohcimask         equ    20h
    78                              <1> ehci_interface   equ    20h    ;usb 2.0
    79                              <1> ehcimask         equ    40h
    80                              <1> xhci_interface   equ    30h    ;usb 3.0
    81                              <1> xhcimask         equ    80h
    82                              <1> lousbtablesize   equ    0000E000h    ;Location of the table size, uword
    83                              <1> lousbtablebase   equ    lousbtablesize + 2 ;base of the table, tword entries
    84                              <1> debounceperiod   equ 200 ;double 200ms as per Windows, for inaccuracies
    85                              <1> ;                ------EHCI equates------
    86                              <1> ehcicaplength    equ    00h    ;Add this to base addr in table to find opparams
    87                              <1> ehciversion      equ    02h    ;Interface Version number
    88                              <1> ehcistrucparams  equ    04h    ;Structural Parameters
    89                              <1> ehcihccparams    equ    08h    ;Capability Parameters
    90                              <1> ehciportroute    equ    0Ch    ;Companion Port Route Description (v1 ignore)
    91                              <1> 
    92                              <1> ;Operational registers below
    93                              <1> 
    94                              <1> ehcicmd          equ    00h    ;USB command register
    95                              <1> ehcists          equ    04h    ;USB status register
    96                              <1> ehciintr         equ    08h    ;USB Interrupt Enable
    97                              <1> ehcifrindex      equ    0Ch    ;USB Frame Index
    98                              <1> ehcictrlseg      equ    10h    ;4Gb Segment Selector
    99                              <1> ehciperiodbase   equ    14h    ;Frame List Base Address
   100                              <1> ehciasyncaddr    equ    18h    ;Next Asynchronus List Address
   101                              <1> ehciconfigflag   equ    40h    ;Configured Flag Register
   102                              <1> ehciportsc       equ    44h    ;Read = 1 - # of ports, Write = port ctrl
   103                              <1> ;                ------------------------
   104                              <1> ;                -------MSD equates------
   105                              <1> setupReset       equ 0FFh
   106                              <1> setupGetMaxLUN   equ 0FEh
   107                              <1> ;                ------------------------
   108                              <1> ;                ------Bulk Storage equates------
   109                              <1> CBWSig           equ    043425355h
   110                              <1> CSWSig           equ 053425355h
   111                              <1> CBWFlagOut       equ    00h    ;Switch to send to device
   112                              <1> CBWFlagIn        equ    80h    ;Switch to recieve from
   113                              <1> bCSWPassed       equ    00h
   114                              <1> bCSWFailed       equ    01h
   115                              <1> bCSWPhase        equ    02h
   116                              <1> ;                ------------------------
   117                              <1> ;------------------USB Device table entry sizes------------------
   118                              <1> msdDevTblEntrySize    equ 10h
   119                              <1> hubDevTblEntrySize    equ 8h
   120                              <1> usbDevTblEntrySize    equ 3h
   121                              <1> usbMaxDevices         equ 10
   122                              <1> ;                ------------------------
   123                              <1> ;------------------EHCI Transfer Descriptor size------------------
   124                              <1> ehciSizeOfQH    equ 60h
   125                              <1> ehciSizeOfTD    equ 40h
   126                              <1> ;------------------------------------------------------------
   127                              <1> ;----------------------ATA equates---------------------------
   128                              <1> ata0_base       equ    1F0h
   129                              <1> ata0_ctrl       equ    3F6h
   130                              <1> ata1_base       equ    170h
   131                              <1> ata1_ctrl       equ    376h
   132                              <1> 
   133                              <1> msd_class       equ    01h
   134                              <1> ide_subclass    equ    01h
   135                              <1> sata_subclass   equ    06h
   136                              <1> ;------------------------------------------------------------
   137                              <1> ;----------------------IDE equates---------------------------
   138                              <1> ideTableEntrySize     equ 10h
   139                              <1> ;----------------------FDD equates---------------------------
   140                              <1> fdd_base        equ    3F0h
   141                              <1> ;----------------------ATA equates---------------------------
   142                              <1> struc fdiskEntry
   143 00000000 ??                  <1>     .signature  resb 1 
   144                              <1>     ;CHS really shouldnt be used
   145 00000001 ????                <1>     .wHeads     resw 1  ;Number of CHS Heads
   146 00000003 ????                <1>     .wCylinder  resw 1  ;Number of CHS Cylinders
   147 00000005 ????                <1>     .wSecTrc    resw 1  ;Number of CHS Sectors per Track
   148 00000007 ????????            <1>     .lbaMax     resd 1  ;Number of maximum sector accessible by LBA28
   149 0000000B ????????????????    <1>     .lbaMax48   resq 1  ;Number of maximum sector accessible by LBA48
   150 00000013 ????                <1>     .ioBase     resw 1  ;IO Base address
   151 00000015 ??                  <1>     .msBit      resb 1  ;Master Slave bit in 0A0h/0B0h format
   152                              <1> endstruc
   153                              <1> ;.signature is as follows:
   154                              <1> ;.signature[0] set = Device present and OK to use.
   155                              <1> ;.signature[1] set = LBA 28 supported, detected by non-zero LBA28 field
   156                              <1> ;.signature[2] set = LBA 48 supported, detected by bit set AND non-zero 
   157                              <1> ;                       LBA 48 sectors field
   158                              <1> ;.signature[7:3] = Reserved
   159                              <1> ;Bitfield equates
   160                              <1>     fdePresent  equ 1
   161                              <1>     fdeLBA28    equ 2
   162                              <1>     fdeLBA48    equ 4
   163                              <1> 
   164                              <1> ;Equates for the ATA identify command
   165                              <1>     idCurrCyl   equ 2*54    ;54th word
   166                              <1>     idCurrHed   equ 2*55    ;55th word
   167                              <1>     idCurrSecTk equ 2*56    ;56th word
   168                              <1>     idLBASectrs equ 2*60    ;60th word
   169                              <1>     idLBA48Sec  equ 2*100   ;100th word
   170                              <1> ;----------------------Int 33h Equates-----------------------
   171                              <1> int33TblEntrySize     equ 10h
   172                              <1> ;------------------------------------------------------------
   173                              <1> ;------------------------------------------------------------
   174                              <1> ;------------------------Misc--------------------------------
   175                              <1> port61h         equ 61h         ;I/O port 61h
   176                              <1> EOI             equ 20h         ;End of interrupt signal
   177                              <1> waitp           equ 80h         ;debug port used to wait for io cycles
   178                              <1> bochsout        equ 0E9h        ;Emulator debug port
   179                              <1> BREAKPOINT      equ 0CCh        ;Use to manually encode breakpoints in program
   180                              <1> sizeOfMCPAlloc  equ 800h        ;2Kb allocated space
   181                              <1> ;------------------------------------------------------------
     4                                  ;----------------------------------------------------------------
     5                                  ;                 BIOS SYSTEM TABLE AREA                        :
     6                                  ;----------------------------------------------------------------
     7                                  Segment BIOSTables nobits start=BIOSStartAddr align=1
     8                                  %include "./Source/BSS/gtables.asm"
     9                              <1> ;Global Data BIOS tables
    10 00000000 <res 1000h>         <1> BIOSIDTable     resq 2*256  ;256 paragraph entries reserved for IDT
    11 00001000 <res 6000h>         <1> BIOSPageTbl     resq 0C00h  ;6000 bytes for page tables
    12 00007000 <res 18h>           <1> BIOSGDTable     resq 3      ;3 entries in basic GDT
    13 00007018 ????????????????    <1>                 resq 1      ;Alignment qword
     9                                  ;----------------------------------------------------------------
    10                                  ;                    BIOS DATA AREA STARTS HERE                 :
    11                                  ;----------------------------------------------------------------
    12                                  Segment data nobits follows=BIOSTables align=1 
    13                                  %include "./Source/BSS/bda.asm"
    14                              <1> ;Refer to MEMMAP.TXT for memory address reference!
    15                              <1> ;If Interrupt call is faulty, Carry will be set AND either:
    16                              <1> ;                    ah=80h => Invalid function.
    17                              <1> ;                    ah=86h => Not (yet) supported.
    18                              <1> ;------------------------------Data Area-------------------------
    19 00000000 ????                <1> IDTlength       resw 1 ;Maximum number of Interrupts is 256
    20                              <1> IDTpointer:
    21 00000002 ????                <1> .Limit          resw 1
    22 00000004 ????????????????    <1> .Base           resq 1
    23                              <1> 
    24 0000000C ????                <1> GDTlength       resw 1
    25                              <1> GDTpointer:
    26 0000000E ????                <1> .Limit          resw 1
    27 00000010 ????????????????    <1> .Base           resq 1
    28                              <1> 
    29 00000018 ????????????????    <1> pageTablePtr:   resq 1
    30                              <1> ;----------------------------------------
    31                              <1> ;       Spurious Interrupt counter      :
    32                              <1> ;----------------------------------------
    33 00000020 ??                  <1> spurint1        resb 1    ;Keep track of how many spur ints on pic1
    34 00000021 ??                  <1> spurint2        resb 1    ;pic 2
    35                              <1> ;----------------------------------------
    36                              <1> ;            Keyboard Data Area         :
    37                              <1> ;----------------------------------------
    38 00000022 <res 20h>           <1> kb_buffer       resw 10h
    39 00000042 ????????????????    <1> kb_buf_head     resq 1    ;Pointer to Keyboard buffer head
    40 0000004A ????????????????    <1> kb_buf_tail     resq 1    ;Pointer to Keyboard buffer tail 
    41 00000052 ????????????????    <1> kb_buf_start    resq 1    ;Pointer for circular buffer start
    42 0000005A ????????????????    <1> kb_buf_end      resq 1    ;Ditto..., for end
    43 00000062 ??                  <1> kb_flags        resb 1    ;Keyboard state flags
    44 00000063 ??                  <1> kb_flags_1      resb 1    ;Extended flags, empty for now
    45 00000064 ??                  <1> kb_flags_2      resb 1    ;Bit 0 = E1 present, Bit 1 = E0 present
    46 00000065 ??                  <1> break_flag      resb 1    ;Well, its not for the Print Screen key
    47                              <1> ;----------------------------------------
    48                              <1> ;            Serial Data Area           :
    49                              <1> ;----------------------------------------
    50 00000066 ??                  <1> numCOM          resb 1  ;Number of Serial Ports
    51 00000067 ????????????????    <1> com_addresses   resw 4     ;Space for 4 IO addresses
    52                              <1> 
    53                              <1> comX_buffer:
    54 0000006F <res 10h>           <1> com1_buffer     resb 10h 
    55 0000007F <res 10h>           <1> com2_buffer     resb 10h
    56 0000008F <res 10h>           <1> com3_buffer     resb 10h
    57 0000009F <res 10h>           <1> com4_buffer     resb 10h
    58                              <1> 
    59                              <1> comX_buf_head:
    60 000000AF ????????????????    <1> com1_buf_head   resq 1
    61 000000B7 ????????????????    <1> com2_buf_head   resq 1
    62 000000BF ????????????????    <1> com3_buf_head   resq 1
    63 000000C7 ????????????????    <1> com4_buf_head   resq 1
    64                              <1> 
    65                              <1> comX_buf_tail:
    66 000000CF ????????????????    <1> com1_buf_tail   resq 1
    67 000000D7 ????????????????    <1> com2_buf_tail   resq 1
    68 000000DF ????????????????    <1> com3_buf_tail   resq 1
    69 000000E7 ????????????????    <1> com4_buf_tail   resq 1
    70                              <1> 
    71                              <1> comX_buf_start:
    72 000000EF ????????????????    <1> com1_buf_start  resq 1
    73 000000F7 ????????????????    <1> com2_buf_start  resq 1
    74 000000FF ????????????????    <1> com3_buf_start  resq 1
    75 00000107 ????????????????    <1> com4_buf_start  resq 1
    76                              <1> 
    77                              <1> comX_buf_end:
    78 0000010F ????????????????    <1> com1_buf_end    resq 1
    79 00000117 ????????????????    <1> com2_buf_end    resq 1
    80 0000011F ????????????????    <1> com3_buf_end    resq 1
    81 00000127 ????????????????    <1> com4_buf_end    resq 1
    82                              <1> 
    83                              <1> ;----------------------------------------
    84                              <1> ;            Printer Data Area          :
    85                              <1> ;----------------------------------------
    86 0000012F ????????????        <1> prt_addresses   resw 3    ;Space for 3 IO addresses
    87                              <1> ;----------------------------------------
    88                              <1> ;            Timer Data Area            :
    89                              <1> ;----------------------------------------
    90 00000135 ????                <1> pit_divisor     resw 1
    91 00000137 ????????            <1> pit_ticks       resd 1    ;Similar to IBM PC, only with default divisor
    92                              <1> ;[31]=OF cnt, [30:21]=Res [20:16]=Hi cnt, [15,0]=Lo cnt
    93 0000013B ????????????????    <1> rtc_ticks       resq 1
    94                              <1> ;----------------------------------------
    95                              <1> ;            Screen Data Area           :
    96                              <1> ;----------------------------------------
    97 00000143 <res 10h>           <1> scr_curs_pos    resw 8    ;Cursor pos, hi byte = row / lo byte = column
    98 00000153 ??                  <1> scr_cols        resb 1    ;80 Cols
    99 00000154 ??                  <1> scr_rows        resb 1    ;25 Rows
   100 00000155 ????                <1> scr_curs_shape  resw 1    ;Packed start/end scan line
   101 00000157 ??                  <1> scr_char_attr   resb 1    ;Grey text on black background
   102 00000158 ??                  <1> scr_mode        resb 1    ;80x25, 16 colours default
   103 00000159 ??                  <1> scr_active_page resb 1    ;Mode dependent
   104 0000015A ????                <1> scr_crtc_base   resw 1    ;03D4h for Graphics, 03B4h for MDA
   105 0000015C ????????            <1> scr_page_addr   resd 1    ;CRTC Register 12 changes base address accessed
   106 00000160 ????????????????    <1> scr_mode_params resq 1    ;Stub pointer location for future mode parameters
   107 00000168 <res 40h>           <1> scr_vga_ptrs    resq 8  ;VGA pointers
   108                              <1> ;----------------------------------------
   109                              <1> ;       Mass storage Data Area          :
   110                              <1> ;----------------------------------------
   111 000001A8 ??                  <1> i33Devices      resb 1  ;Number of devices Int 33h is aware of
   112 000001A9 ??                  <1> msdStatus       resb 1  ;Status byte. Used by BIOS for all transfers with Int 33h.
   113 000001AA ??                  <1> fdiskNum        resb 1  ;Number of fixed disks
   114 000001AB ??                  <1> ata0CmdByte     resb 1  ;Contains bitfield of instructions, Bit 0 is master/slave, Bit 1 is Data Mutex
   115 000001AC ??                  <1> ata0Status      resb 1  ;Contains the status of the last transaction
   116 000001AD ??                  <1> ata1CmdByte     resb 1
   117 000001AE ??                  <1> ata1Status      resb 1
   118 000001AF ????????????????    <1> diskDptPtr      resq 1
   119 000001B7 ????????????????    <1> fdiskDptPtr     resq 1
   120                              <1> ;----------------------------------------
   121                              <1> ;            SysInit Data Area          :
   122                              <1> ;----------------------------------------
   123 000001BF ????????????????    <1> nextFilePtr     resq 1  ;Pointer to next file to load
   124 000001C7 ????                <1> numSectors      resw 1  ;Number of sectors to copy 
   125                              <1> ;----------------------------------------
   126                              <1> ;            Memory Data Area           :
   127                              <1> ;----------------------------------------
   128 000001C9 ????                <1> MachineWord     resw 1    ;Really Legacy Hardware Bitfield
   129 000001CB ????                <1> convRAM         resw 1  ;Conventional memory word
   130 000001CD ????????????????    <1> userBase        resq 1    ;Start address of the user space
   131 000001D5 ??                  <1> bigmapSize      resb 1    ;First byte, in units of 24 bytes
   132 000001D6 ????????????????    <1> srData          resw 4  ;4 words for memory64MB word 0 is ax word 1 is bx etc.
   133 000001DE ????                <1> srData1         resw 1  ;Reserve 1 word for memory16MB
   134 000001E0 ????????????????    <1> sysMem          resq 1  ;Size of usable system RAM (without SCP/BIOS)
   135 000001E8 ????????            <1> scpSize         resd 1  ;Size of SCP/BIOS allocation
   136                              <1> ;----------------------------------------
   137                              <1> ;            MCP Data Area              :
   138                              <1> ;----------------------------------------
   139 000001EC ????????????????    <1> mcpUserBase     resq 1  ;Pointer to register save space
   140 000001F4 ????????????????    <1> mcpUserRip      resq 1  ;Save the custom user RIP for new jumps
   141 000001FC ????????????????    <1> mcpUserkeybf    resq 1  ;Pointer to the keyboard buffer
   142 00000204 ????????????????    <1> mcpUserRaxStore resq 1  ;Temp rax save space
   143 0000020C ????????????????    <1> mcpStackPtr     resq 1  ;Address of base of user Stack Pointer
   144                              <1> ;----------------------------------------
   145                              <1> ;            USB Data Area              :
   146                              <1> ;----------------------------------------
   147 00000214 ??                  <1> eControllers    resb 1    ;Number of EHCI controllers
   148 00000215 <res 20h>           <1> eControllerList resq 4    ;Entry = PCI space addr|MMIO addrs
   149 00000235 ??                  <1> usbDevices      resb 1    ;Max value, 10 for now!
   150 00000236 ????????????????    <1> eHCErrorHandler resq 1  ;Address of default error handler
   151                              <1> ;----------------------------------------
   152                              <1> ;            EHCI Async Area            :
   153                              <1> ;----------------------------------------
   154 0000023E ????????????????    <1> eCurrAsyncHead  resq 1      ;Point to the current head of the async list
   155 00000246 ??                  <1> eNewBus         resb 1      ;Default to 0, if 1, a new bus was selected
   156 00000247 ??                  <1> eActiveCtrlr    resb 1        ;Current working controller (default -1)
   157 00000248 ??                  <1> eActiveInt      resb 1        ;Gives a copy of the usbsts intr bits
   158 00000249 ??                  <1> eAsyncMutex     resb 1    
   159                              <1>     ;Mutex, x1b=data NOT ready, wait. x0b=ready, data ready to access.
   160                              <1>     ;        1xb=Internal buffer. 0xb=user provided buffer.
   161                              <1>     ;        bits [7:2], number of interrupts to ignore (if any)
   162                              <1>     ;            a value of 0 means dont ignore
   163                              <1> ;----------------------------------------
   164                              <1> ;            MSD Data Area              :
   165                              <1> ;----------------------------------------
   166 0000024A ??                  <1> cbwTag          resb 1        ;cbw transaction unique id (inc post use)
   167 0000024B ??                  <1> numMSD          resb 1        ;Number of MSD devices
   168                              <1> ;----------------------------------------
   169                              <1> ;           USB Tables                  :
   170                              <1> ;----------------------------------------
   171 0000024C <res 1Eh>           <1> usbDevTbl       resb 10*usbDevTblEntrySize
   172                              <1> usbDevTblEnd    equ $
   173                              <1> usbDevTblE      equ ($ - usbDevTbl)/usbDevTblEntrySize ;Number of Entries
   174                              <1> ;Byte 0 = Dev Addr, Byte 1 = Root hub, Byte 2 = Class Code (USB standard)
   175                              <1> ; i.e. 08h=MSD, 09h=Hub
   176 0000026A <res 50h>           <1> hubDevTbl       resb 10*hubDevTblEntrySize
   177                              <1> hubDevTblEnd    equ $
   178                              <1> hubDevTblE      equ ($ - hubDevTbl)/hubDevTblEntrySize
   179                              <1> ;bAddress - The assigned device address
   180                              <1> ;bBus - Host Bus [Root hub]
   181                              <1> ;bHostHub - Address of Hub we are attached to or 0 for Root
   182                              <1> ;bHubPort - Port number we are inserted in
   183                              <1> ;bMaxPacketSize0 - Max packet size to endpoint 0
   184                              <1> ;bNumPorts - Number of downstream ports on hub
   185                              <1> ;bPowerOn2PowerGood - Time in units of 2ms for device on port to turn on
   186                              <1> ;bRes- Endpoint address, for when we add interrupt eps
   187                              <1> ;   If bNumPorts=0 => Hub needs to undergo Hub Config
   188 000002BA <res A0h>           <1> msdDevTbl       resb 10*msdDevTblEntrySize
   189                              <1> msdDevTblEnd    equ $
   190                              <1> msdDevTblE      equ    ($ - msdDevTbl)/msdDevTblEntrySize
   191                              <1> ;bAddress - The assigned device address [+ 0]
   192                              <1> ;bBus - Host Bus [Root hub] [+ 1]
   193                              <1> ;bHostHub - Address of Hub we are attached to or 0 for Root [+ 2]
   194                              <1> ;bHubPort - Port number we are inserted in  [+ 3]
   195                              <1> ;bInerfaceNumber - Interface number being used  [+ 4]
   196                              <1> ;bInterfaceSubclass - 00h (defacto SCSI), 06h (SCSI), 04h (UFI)     [+ 5]
   197                              <1> ;bInterfaceProtocol - 50h (BBB), 00h (CBI), 01h (CBI w/o interrupt) [+ 6]
   198                              <1> ;bMaxPacketSize0 - Max packet size to endpoint 0                    [+ 7]
   199                              <1> ;bEndpointInAddress - 4 bit address of IN EP                        [+ 8]
   200                              <1> ;wMaxPacketSizeIn - Max packet size to chosen In endpoint           [+ 9]
   201                              <1> ;bEndpointOutAddress - 4 bit address of OUT EP                      [+ 11]
   202                              <1> ;wMaxPacketSizeOut - Max packet size to OUT endpoint                [+ 12]
   203                              <1> ;bInEPdt - In Endpoints' dt bit                                     [+ 14]
   204                              <1> ;bOutEPdt - Out Endpoints' dt bit                                   [+ 15]
   205                              <1> ;These past two bytes are temporarily kept separate! Will bitstuff later
   206                              <1> ;----------------------------------------
   207                              <1> ;           IDE Tables                  :
   208                              <1> ;----------------------------------------
   209                              <1> ;Support up to two IDE controllers
   210 0000035A ??                  <1> ideNumberOfControllers: resb 1
   211 0000035B <res 20h>           <1> ideControllerTable:     resb  2*ideTableEntrySize ;Max 2 controllers
   212                              <1> ;dPCIAddress   - PCI IO address of controller   [+0]
   213                              <1> ;dPCIBAR4 - PCI BAR4, the Bus Mastery address [+4]
   214                              <1> ; Note that this address is given with the bottom nybble indicating
   215                              <1> ; if the address is IO or MMIO. Bit set => IO
   216                              <1> ;----------------------------------------
   217                              <1> ;           ATA Tables                  :
   218                              <1> ;----------------------------------------
   219 0000037B <res 58h>           <1> fdiskTable:     resb 4*fdiskEntry_size  ;Max 4 fixed disks
   220                              <1> ;----------------------------------------
   221                              <1> ;            Int33h Table Area          :
   222                              <1> ;----------------------------------------
   223 000003D3 <res A0h>           <1> diskDevices:    resb 10*int33TblEntrySize
   224                              <1> diskDevicesE    equ ($ - diskDevices)/int33TblEntrySize
   225                              <1> ;bDevType - 0 = Unasigned, 1 = MSD EHCI, 2 = MSD xHCI, 3 = Floppy Physical,
   226                              <1> ;           4 = ATA device, 5 = ATAPI device   [+ 0]
   227                              <1> ;wDeviceAddress - USB Address/Bus pair OR local device table address  [+ 1]
   228                              <1> ;dBlockSize - Dword size of LBA block (should be 512 for remdev) [+ 3]
   229                              <1> ;qLastLBANum - Last LBA address (OS MAY minus 1 to avoid crashing device) [+ 7]
   230                              <1> ;bEPSize - 1 = 64 byte, 2 = 512 byte (EP size for sector transfer)  [+ 15]
   231                              <1> ;NOTE: LBA SECTOR 0 IS CHS SECTOR 0,0,1 !!
   232                              <1> ;----------------------------------------------------------------
    14                                  ;----------------------------------------------------------------
    15                                  ;                   MCP Transaction area                        :
    16                                  ;----------------------------------------------------------------
    17                                  Segment MCPseg nobits follows=codeResident align=1
    18 00000000 <res 800h>                              resb sizeOfMCPAlloc   ;2KB space
    19                                  MCPsegEnd:  ;Pointer to the end of the segment
    20                                  ;----------------------------------------------------------------
    21                                  ;                  BIOS Transaction area                        :
    22                                  ;                                                               :
    23                                  ;                   Must be the last segment                    :
    24                                  ;----------------------------------------------------------------
    25                                  Segment xdata nobits follows=MCPseg align=40h    ;eXtra data seg
    26                                  %include "./Source/BSS/xbda.asm"
    27                              <1> ;eXtended BDA area for data transfers
    28                              <1> 
    29                              <1> ;This segment comes after the resident code and is the transaction
    30                              <1> ;area. The ehci async schedule (and eventually periodic) live here.
    31                              <1> ;They are BOTH always postfixed by the big memory map.
    32                              <1> ehciAschedule:                  ;Static label for head of the asyncschedule
    33 00000000 <res 60h>           <1> ehciQHead0      resb ehciSizeOfQH ;96 bytes, for address 0 device only
    34 00000060 <res 20h>           <1>     alignb 40h
    35 00000080 <res 60h>           <1> ehciQHead1      resb ehciSizeOfQH ;Used for cmds with an addressed usb device
    36 000000E0 <res 20h>           <1>     alignb 40h
    37 00000100 <res 280h>          <1> ehciTDSpace     resb 10*ehciSizeOfTD   ;640 bytes of transfer space
    38                              <1>     alignb 40h
    39 00000380 <res 20h>           <1> ehciDataOut     resb 20h               ;32 bytes
    40 000003A0 <res 20h>           <1>     alignb 40h
    41                              <1> sectorbuffer:                       ;Same buffer for multiple purposes
    42 000003C0 <res 200h>          <1> ehciDataIn      resb 200h           ;512 bytes, to get as much data as needed
    43                              <1>     alignb 40h
    44 000005C0 <res 10h>           <1> msdCSW          resb 10h                
    45                              <1> ;13 bytes, special, to be saved after each transfer
    46 000005D0 <res 10h>           <1>     alignb 20h      
    47 000005E0 <res 10h>           <1> prdt:           resq 2      ;2 entries in the prdt
    48                              <1> bigmapptr:                        ;Pointer to big mem map
    27                                  ;----------------------------------------------------------------
    28                                  ;                      SysInit Table                            :
    29                                  ;----------------------------------------------------------------
    30                                  Segment SysInitParams   nobits start=600h
    31                                  ;Use the bootsector reload space (600h-800h) as a temporary stack
    32                                  ; and a storage space for the SysInit table
    33                                  SysInitTable:
    34 00000000 ????                    .numSecW        resw 1
    35 00000002 ????????????????        .FileLBA        resq 1
    36 0000000A ????                    loMachineWord   resw 1
    37                                  ;----------------------------------------------------------------
    38                                  ;                      Real Mode Stack                          :
    39                                  ;----------------------------------------------------------------
    40                                  Segment lowStack    nobits  start=700h
    41 00000000 <res 100h>                              resb 100h
    42                                  lowStackPtr:
    43                                  ;----------------------------------------------------------------
    44                                  ORG 800h
    45                                  ;----------------------------------------------------------------
    46                                  ;                    INIT CODE STARTS HERE                      :
    47                                  ;----------------------------------------------------------------
    48                                  Segment codeInit start=BIOSInitAddr align=1
    49                                  BITS 16
    50                                  %include "./Source/Init/RealInit.asm"
    51                              <1> ;First set stack and save the SysInit Ptr, then set A20, check CPUID and 
    52                              <1> ; exended features. Then tell BIOS that we are going long and perhaps 
    53                              <1> ; protected then get the Int 11h word, store at 0:800h
    54                              <1> realInit:
    55                              <1> ;The Caller Far Jumps to set cs to 0
    56 00000000 FA                  <1>     cli     ;Stop interrupts as we dont know where the stack is
    57 00000001 31C0                <1>     xor ax, ax
    58 00000003 8ED8                <1>     mov ds, ax
    59 00000005 8ED0                <1>     mov ss, ax
    60 00000007 BC[0001]            <1>     mov sp, lowStackPtr ;Set up stack pointer
    61 0000000A FB                  <1>     sti
    62 0000000B 26803F0C            <1>     cmp byte [es:bx], 0Ch   ;Check length
    63 0000000F 0F85ED00            <1>     jne .fail   ;If thats not it, error 0
    64 00000013 268B4701            <1>     mov ax, word [es:bx + 1]    ;Get number of sectors into ax 
    65 00000017 B92A00              <1>     mov cx, 42  ;42 sectors maximum
    66 0000001A 39C8                <1>     cmp ax, cx
    67 0000001C 0F43C1              <1>     cmovnb ax, cx
    68 0000001F A3[0000]            <1>     mov word [SysInitTable.numSecW], ax
    69 00000022 26668B4704          <1>     mov eax, dword [es:bx + 4]      ;Get low dword
    70 00000027 66A3[0200]          <1>     mov dword [SysInitTable.FileLBA], eax
    71 0000002B 26668B4708          <1>     mov eax, dword [es:bx + 8]      ;Get high dword
    72 00000030 66A3[0600]          <1>     mov dword [SysInitTable.FileLBA + 4], eax
    73 00000034 06                  <1>     push es
    74                              <1> .a20Proc:
    75 00000035 50                  <1>     push ax
    76 00000036 51                  <1>     push cx ;preserve ax and cx
    77 00000037 31C9                <1>     xor cx, cx ;clear to use as a timeout counter
    78                              <1>     
    79                              <1> .a20FastEnable:
    80 00000039 E492                <1>     in al, 92h
    81 0000003B A802                <1>     test al, 2
    82 0000003D 750B                <1>     jnz .no92
    83 0000003F 0C02                <1>     or al, 2
    84 00000041 24FE                <1>     and al, 0FEh
    85 00000043 E692                <1>     out 92h, al
    86                              <1>     
    87 00000045 FEC1                <1>     inc cl    ;increments the time out counter
    88 00000047 E94900              <1>     jmp .a20Check
    89                              <1>     
    90                              <1> .no92:
    91 0000004A B104                <1>     mov cl, 4
    92 0000004C E96A00              <1>     jmp .a20Fail
    93                              <1>     
    94                              <1> .a20KeybEnable: ;communicating with the keyboard controller
    95 0000004F FA                  <1>     cli
    96                              <1>  
    97 00000050 E83200              <1>     call .a20wait
    98 00000053 B0AD                <1>     mov al,0ADh
    99 00000055 E664                <1>     out 64h,al ;disable the keyboard
   100 00000057 E82B00              <1>     call .a20wait
   101 0000005A B0D0                <1>     mov al,0D0h
   102 0000005C E664                <1>     out 64h,al ;read from the keyboard input
   103 0000005E E82B00              <1>     call .a20wait2
   104 00000061 E460                <1>     in al,60h
   105 00000063 6650                <1>     push eax    ;get the keyboard data and push it to the stack
   106 00000065 E81D00              <1>     call .a20wait
   107 00000068 B0D1                <1>     mov al,0D1h
   108 0000006A E664                <1>     out 64h,al    ;output the command to prep to go a20 
   109 0000006C E81600              <1>     call .a20wait
   110 0000006F 6658                <1>     pop eax    ;need this be eax and not just ax?
   111 00000071 0C02                <1>     or  al,2
   112 00000073 E660                <1>     out 60h,al    ;output to go a20
   113 00000075 E80D00              <1>     call .a20wait
   114 00000078 B0AE                <1>     mov al,0AEh
   115 0000007A E664                <1>     out 64h,al    ;reenable keyboard
   116 0000007C E80600              <1>     call .a20wait    ;done!
   117 0000007F FB                  <1>     sti
   118                              <1> 
   119 00000080 FEC1                <1>     inc cl    ;increments the time out counter
   120 00000082 E90E00              <1>     jmp .a20Check
   121                              <1>     
   122                              <1> .a20wait:
   123 00000085 E464                <1>     in al,64h
   124 00000087 A802                <1>     test al,2
   125 00000089 75FA                <1>     jnz .a20wait
   126 0000008B C3                  <1>     ret
   127                              <1>  
   128                              <1> .a20wait2: 
   129 0000008C E464                <1>     in al,64h
   130 0000008E A801                <1>     test al,1
   131 00000090 74FA                <1>     jz .a20wait2
   132 00000092 C3                  <1>     ret
   133                              <1> 
   134                              <1> .a20Check:
   135 00000093 B8FFFF              <1>     mov ax, 0FFFFh
   136 00000096 50                  <1>     push ax
   137 00000097 07                  <1>     pop es ;es to FFFF
   138 00000098 BF1000              <1>     mov di, 0010h ;FFFF:0010 == 0000:0000
   139 0000009B 31F6                <1>     xor si, si    ;remember ds = 0000
   140 0000009D 268A05              <1>     mov al, byte [es:di]
   141 000000A0 3E3804              <1>     cmp byte [ds:si], al
   142 000000A3 7414                <1>     je .a20Fail
   143 000000A5 FEC0                <1>     inc al    ;make change to al
   144 000000A7 3E8804              <1>     mov byte [ds:si], al ;al is now incremented and saved at address 0000:0000
   145 000000AA 263805              <1>     cmp byte [es:di], al ;check against overflown version
   146 000000AD 740A                <1>     je .a20Fail
   147                              <1>     
   148                              <1> .a20Pass:
   149 000000AF FEC8                <1>     dec al    ;return al to its original value
   150 000000B1 3E8804              <1>     mov byte [ds:si], al ;return to original position
   151                              <1>     
   152 000000B4 59                  <1>     pop cx
   153 000000B5 58                  <1>     pop ax
   154 000000B6 07                  <1>     pop es
   155 000000B7 EB11                <1>     jmp short .a20Exit
   156                              <1>     
   157                              <1> .a20Fail:
   158 000000B9 80F903              <1>     cmp cl, 3
   159 000000BC 0F8E79FF            <1>     jle .a20FastEnable
   160 000000C0 80F906              <1>     cmp cl, 6
   161 000000C3 7E8A                <1>     jle .a20KeybEnable
   162                              <1>     
   163 000000C5 59                  <1>     pop cx
   164 000000C6 58                  <1>     pop ax
   165 000000C7 07                  <1>     pop es
   166 000000C8 EB2E                <1>     jmp short .noa20
   167                              <1> 
   168                              <1> .a20Exit:
   169 000000CA 669C                <1>     pushfd
   170 000000CC 6658                <1>     pop eax
   171 000000CE 6689C1              <1>     mov ecx, eax ;save original flag state for later
   172 000000D1 663500002000        <1>     xor eax, 00200000h ;21st bit - CPUID bit, switch it!!
   173 000000D7 6650                <1>     push eax
   174 000000D9 669D                <1>     popfd
   175                              <1>     
   176 000000DB 669C                <1>     pushfd
   177 000000DD 6658                <1>     pop eax
   178 000000DF 6685C8              <1>     test eax, ecx ; compare the registers. If they are the same
   179 000000E2 7416                <1>     je .noCPUID
   180 000000E4 6651                <1>     push ecx
   181 000000E6 669D                <1>     popfd
   182                              <1> 
   183                              <1> .extCheck:
   184 000000E8 66B800000080        <1>     mov eax, 80000000h
   185 000000EE 0FA2                <1>     cpuid
   186 000000F0 663D01000080        <1>     cmp eax, 80000001h ;If this is true, CPU supports extended functionality
   187 000000F6 733C                <1>     jae tellBIOS
   188                              <1> .noa20:
   189 000000F8 B401                <1>     mov ah, 1    ;noa20 error code
   190                              <1> .noCPUID:
   191 000000FA B402                <1>     mov ah, 2    ;noCPUID error code
   192 000000FC EB02                <1>     jmp short .fail
   193 000000FE B403                <1>     mov ah, 3    ;no Extended functionality error code
   194                              <1> .fail:
   195 00000100 88E2                <1>     mov dl, ah    ;store ax to get error code printed
   196 00000102 BE[2801]            <1>     mov si, .msg
   197 00000105 E81100              <1>     call .write
   198 00000108 88D0                <1>     mov al, dl
   199 0000010A BB0700              <1>     mov bx, 0007h    ;Attribs
   200 0000010D B40E                <1>     mov ah, 0Eh        ;TTY print char
   201 0000010F 0430                <1>     add al, 30h        ;add '0' to digit
   202 00000111 CD10                <1>     int 10h
   203 00000113 31C0                <1>     xor ax, ax
   204 00000115 CD16                <1>     int 16h    ;await keystroke
   205 00000117 CD18                <1>     int 18h
   206                              <1> ;Error codes: 
   207                              <1> ;   00h - Bad SysInit Data
   208                              <1> ;   01h - No A20 Line
   209                              <1> ;   02h - No CPUID 
   210                              <1> ;   03h - No Extended Functionality
   211                              <1> .write: ;destroys registers ax and bx
   212 00000119 AC                  <1>     lodsb
   213 0000011A 3C00                <1>     cmp al, 0 ;check for zero
   214 0000011C 7409                <1>     je .return
   215 0000011E B40E                <1>     mov ah, 0Eh    ;TTY output
   216 00000120 BB0700              <1>     mov bx, 0007h ;colour
   217 00000123 CD10                <1>     int 10h
   218 00000125 EBF2                <1>     jmp short .write
   219                              <1> .return:
   220 00000127 C3                  <1>     ret
   221 00000128 426F6F74206572726F- <1> .msg: db 'Boot error:',0
   221 00000131 723A00              <1>
   222                              <1> tellBIOS:
   223 00000134 66B800EC0000        <1>     mov eax, 0EC00h ;Tell BIOS we are going long
   224 0000013A B303                <1>     mov bl, 03h     ;Both Long and Protected modes
   225 0000013C CD15                <1>     int 15h         ;Ignore response
   226 0000013E CD11                <1>     int 11h
   227 00000140 A3[0A00]            <1>     mov word [loMachineWord], ax
   228                              <1> ;Getting Memory Map
   229                              <1> rmE820Map:
   230 00000143 06                  <1>     push es
   231 00000144 1E                  <1>     push ds
   232 00000145 B80010              <1>     mov ax, e820Seg
   233 00000148 8ED8                <1>     mov ds, ax
   234 0000014A 8EC0                <1>     mov es, ax
   235 0000014C BF0200              <1>     mov di,    e820BaseOff
   236 0000014F 6631DB              <1>     xor ebx, ebx
   237 00000152 31ED                <1>     xor bp,bp
   238 00000154 66BA50414D53        <1>     mov edx, 0534D4150h    ;Magic dword
   239 0000015A 66B820E80000        <1>     mov eax, 0E820h
   240 00000160 2666C7451401000000  <1>     mov dword [es:di + 20], 1
   241 00000169 66B918000000        <1>     mov ecx, 24            ;Get 24 bytes
   242 0000016F CD15                <1>     int 15h
   243 00000171 7257                <1>     jc .mapfail            ;Carry set => Fail
   244 00000173 66BA50414D53        <1>     mov edx, 0534D4150h    ;Magic dword
   245 00000179 6639D0              <1>     cmp eax, edx        ;Must be equal on success
   246 0000017C 754C                <1>     jne .mapfail
   247 0000017E 6685DB              <1>     test ebx, ebx         ;One table entry, bad
   248 00000181 7447                <1>     jz .mapfail
   249 00000183 EB1F                <1>     jmp short .map1
   250                              <1> .map0:
   251 00000185 66B820E80000        <1>     mov eax, 0E820h
   252 0000018B 2666C7451401000000  <1>     mov dword  [es:di + 20], 1
   253 00000194 66B918000000        <1>     mov ecx, 24
   254 0000019A CD15                <1>     int 15h
   255 0000019C 722C                <1>     jc .mapexit
   256 0000019E 66BA50414D53        <1>     mov edx, 0534D4150h
   257                              <1> .map1:
   258 000001A4 E31D                <1>     jcxz .map3
   259 000001A6 80F914              <1>     cmp cl, 20
   260 000001A9 7607                <1>     jbe .map2
   261 000001AB 26F6451401          <1>     test byte [es:di + 20], 1
   262 000001B0 7411                <1>     je .map3
   263                              <1> .map2:
   264 000001B2 26668B4D08          <1>     mov ecx, dword [es:di + 8]
   265 000001B7 26660B4D0C          <1>     or ecx, [es:di + 12]
   266 000001BC 7405                <1>     jz .map3
   267 000001BE 45                  <1>     inc bp
   268 000001BF 81C71800            <1>     add di, 24
   269                              <1> .map3:
   270 000001C3 6685DB              <1>     test ebx, ebx
   271 000001C6 75BD                <1>     jne .map0
   272 000001C8 EB00                <1>     jmp short .mapexit
   273                              <1> .mapfail:
   274                              <1> .mapexit:
   275 000001CA 26892E0000          <1>     mov word [es:e820SizeOff], bp  ;Num entries in var space (3 qwords/entry)
   276                              <1> ;Second memory test
   277 000001CF 31C9                <1>     xor cx, cx
   278 000001D1 31D2                <1>     xor dx, dx
   279 000001D3 B801E8              <1>     mov ax, 0E801h
   280 000001D6 CD15                <1>     int 15h
   281 000001D8 7216                <1>     jc .badmem2
   282 000001DA 80FC86              <1>     cmp ah, 86h    ;unsupported command
   283 000001DD 7411                <1>     je .badmem2
   284 000001DF 3D8000              <1>     cmp ax, 80h    ;invalid command
   285 000001E2 740C                <1>     je .badmem2
   286                              <1> .mem2write:
   287 000001E4 AB                  <1>     stosw
   288 000001E5 89D8                <1>     mov ax, bx
   289 000001E7 AB                  <1>     stosw
   290 000001E8 89C8                <1>     mov ax, cx
   291 000001EA AB                  <1>     stosw
   292 000001EB 89D0                <1>     mov ax, dx
   293 000001ED AB                  <1>     stosw
   294 000001EE EB0B                <1>     jmp short .mem3test
   295                              <1> .badmem2:
   296 000001F0 31C0                <1>     xor ax, ax
   297 000001F2 31DB                <1>     xor bx, bx
   298 000001F4 31C9                <1>     xor cx, cx
   299 000001F6 31D2                <1>     xor dx, dx
   300 000001F8 E9E9FF              <1>     jmp .mem2write
   301                              <1> .mem3test:
   302 000001FB F8                  <1>     clc
   303 000001FC B488                <1>     mov ah, 88h
   304 000001FE CD15                <1>     int 15h
   305 00000200 31DB                <1>     xor bx, bx 
   306 00000202 0F42C3              <1>     cmovc ax, bx    ;if error, store zero
   307 00000205 3D8600              <1>     cmp ax, 86h
   308 00000208 0F44C3              <1>     cmovz ax, bx
   309 0000020B 3D8000              <1>     cmp ax, 80h
   310 0000020E 0F44C3              <1>     cmovz ax, bx
   311 00000211 AB                  <1>     stosw
   312                              <1> .finalmemtest:
   313 00000212 F8                  <1>     clc
   314 00000213 CD12                <1>     int 12h
   315 00000215 0F42C3              <1>     cmovc ax, bx    ;If carry on, store a zero
   316 00000218 AB                  <1>     stosw    ;Store the word
   317                              <1> rmGetFontPointers:
   318                              <1> ;Get ROM Font Pointers, immediately after Memory map
   319                              <1> ;Each entry is 8 bytes long: es=Seg, bp=Off, cx=bytes/char, dx=# of rows - 1
   320 00000219 31DB                <1>     xor bx, bx         ;Clear bh
   321                              <1> .gfp1:    
   322                              <1> ;Over protective routine in the event that the BIOS routine clobbers registers
   323 0000021B BE0010              <1>     mov si, 1000h    ;Save segment loader
   324 0000021E 31C9                <1>     xor cx, cx
   325 00000220 31D2                <1>     xor dx, dx
   326 00000222 31ED                <1>     xor bp, bp
   327 00000224 53                  <1>     push bx            ;Save bx
   328                              <1> 
   329 00000225 B83011              <1>     mov ax, 1130h    ;Get font pointer function
   330 00000228 CD10                <1>     int 10h
   331                              <1> 
   332 0000022A 8CC0                <1>     mov ax, es        ;Get segment into ax to store
   333 0000022C 8EC6                <1>     mov es, si        ;Reload segment for stos to work
   334 0000022E AB                  <1>     stosw
   335 0000022F 89E8                <1>     mov ax, bp        ;Get offset
   336 00000231 AB                  <1>     stosw
   337 00000232 89C8                <1>     mov ax, cx        ;bytes/char
   338 00000234 AB                  <1>     stosw
   339 00000235 88D0                <1>     mov al, dl        ;dl contains # of rows, but zero extended for alignment
   340 00000237 30E4                <1>     xor ah, ah
   341 00000239 AB                  <1>     stosw
   342 0000023A 5B                  <1>     pop bx            ;Get the count back
   343 0000023B FEC7                <1>     inc bh
   344 0000023D 80FF07              <1>     cmp bh, 7
   345 00000240 76D9                <1>     jbe .gfp1        ;Once above 7, fall through
   346                              <1> 
   347 00000242 1F                  <1>     pop ds
   348 00000243 07                  <1>     pop es    ;Bring back original es value
   349                              <1> rmSetTables:
   350                              <1> ;Memory tables live in 0:8000h - 0:E000h range
   351 00000244 66BF00800000        <1>     mov edi, 8000h
   352 0000024A 0F22DF              <1>     mov cr3, edi    ;Cannot lsh cr3
   353 0000024D B90030              <1>     mov cx, 3000h    ;6000h bytes (6x4Kb) of zero to clear table area
   354 00000250 57                  <1>     push di
   355 00000251 31C0                <1>     xor ax, ax
   356 00000253 F3AB                <1>     rep stosw        ;Store 3000h words of zero
   357                              <1> 
   358 00000255 5F                  <1>     pop di            ;Return zero to the head of the table, at 08000h
   359 00000256 B80390              <1>     mov ax, 9000h|permissionflags    ;9000h is the low word of the address.
   360 00000259 AB                  <1>     stosw    ;store the low word of the address
   361 0000025A 81C7FE0F            <1>     add di, 0FFEh
   362 0000025E B90400              <1>     mov cx, 4
   363                              <1> rmUtables:            ;di should point to 8000h
   364 00000261 050010              <1>     add ax, 1000h
   365 00000264 AB                  <1>     stosw    ;ax is now A003h,B003h,C003h,D003h
   366 00000265 81C70600            <1>     add di, 6    ;qword alignment
   367 00000269 49                  <1>     dec cx
   368 0000026A 75F5                <1>     jnz rmUtables
   369                              <1> 
   370 0000026C B90008              <1>     mov cx, 800h    ;4x512 consecutive entries
   371 0000026F 31C0                <1>     xor ax, ax
   372 00000271 50                  <1>     push ax            ;push for algorithm to work
   373 00000272 BF00A0              <1>     mov di, 0A000h
   374                              <1> rmPDTentries:
   375 00000275 B88300              <1>     mov ax, 83h        ;bit 7|permission flags
   376 00000278 AB                  <1>     stosw            ;di incremented twice
   377 00000279 58                  <1>     pop ax            ;get current address
   378 0000027A AB                  <1>     stosw            ;di incremented twice. store the address
   379 0000027B 052000              <1>     add ax, 20h        ;add the offset to the next page
   380 0000027E 50                  <1>     push ax            ;push current address into memory
   381 0000027F 81C70400            <1>     add di, 4        ;qword Align
   382 00000283 49                  <1>     dec cx
   383 00000284 75EF                <1>     jnz rmPDTentries
   384                              <1> 
   385 00000286 0F20E0              <1>     mov eax, cr4                 
   386 00000289 660DA0000000        <1>     or eax, 0A0h ;Set PAE and PGE, for glbl page and physical page extensions
   387 0000028F 0F22E0              <1>     mov cr4, eax 
   388                              <1>     
   389 00000292 66B9800000C0        <1>     mov ecx, 0C0000080h    ;Read EFER MSD into EDX:EAX
   390 00000298 0F32                <1>     rdmsr    ; Read information from the msr.
   391 0000029A 660D00010000        <1>     or eax, 00000100h ; Set the Long mode bit!
   392 000002A0 0F30                <1>     wrmsr  ; Write the data back
   393                              <1>     
   394 000002A2 FA                  <1>     cli
   395 000002A3 B0FF                <1>     mov al, 0FFh             ; Out 0xFF to 0xA1 and 0x21 to disable all IRQs.
   396 000002A5 E6A1                <1>     out 0A1h, al
   397 000002A7 E621                <1>     out 21h, al
   398                              <1> 
   399 000002A9 0F0116[DA02]        <1>     lgdt [GDT.Pointer] ;Load the Global Descriptor Table pointer
   400                              <1> 
   401 000002AE 0F20C0              <1>     mov eax, cr0
   402 000002B1 660D01000080        <1>     or eax, 80000001h ;Set the Paging and Protected Mode bits (Bits 31 and 0)
   403 000002B7 0F22C0              <1>     mov cr0, eax  ;write it back!
   404 000002BA EA[E402]0800        <1>     jmp GDT.Code:longmode_ep
   405                              <1> 
   406                              <1> GDT:                    ;Global Descriptor Table (64-bit).
   407                              <1> .Null: equ $ - GDT      ;The null descriptor.
   408 000002BF 0000000000000000    <1>     dq 0
   409                              <1> .Code: equ $ - GDT      ;The 32-bit code descriptor. Limit = FFFFFh, Base=0
   410 000002C7 FFFF                <1>     dw 0FFFFh           ;Limit 0:15
   411 000002C9 0000                <1>     dw 00000h           ;Base 0:15
   412 000002CB 00                  <1>     db 00h              ;Base 16:23
   413 000002CC 9A                  <1>     db 09Ah             ;Access Byte
   414 000002CD 3F                  <1>     db 03Fh             ;Limit 16:19
   415 000002CE 00                  <1>     db 00b              ;Base 24:31
   416                              <1> 
   417                              <1> .Data: equ $ - GDT      ;The 32-bit data descriptor. 
   418 000002CF FFFF                <1>     dw 0FFFFh           ;Limit 0:15
   419 000002D1 0000                <1>     dw 00000h           ;Base 0:15
   420 000002D3 00                  <1>     db 0h               ;Base 16:23
   421 000002D4 92                  <1>     db 092h             ;Access Byte
   422 000002D5 1F                  <1>     db 01Fh             ;Limit 16:19 then Flags
   423 000002D6 00                  <1>     db 00h              ;Base 24:31
   424 000002D7 90                  <1> ALIGN 4
   425 000002D8 0000                <1>     dw 0
   426 000002DA 1A00                <1> .Pointer    dw $ - GDT - 1      ; GDT pointer.
   427 000002DC [BF02000000000000]  <1> .Base       dq GDT                 ; GDT offset.
   428                              <1> ;----------------------------------------------------------------
    51                                  BITS 64
    52                                  %include "./Source/Init/LongInit.asm"
    53                              <1> ;----------------------------------------------------------------
    54                              <1> ;                    Long Mode Initialisation                   :
    55                              <1> ;----------------------------------------------------------------
    56                              <1> ;----------------------------------------------------------------
    57                              <1> ; Sets up Segment registers, copies the resident portion of SCPBIOS
    58                              <1> ; high, initialises the BDA, copies data from real mode BIOS to 
    59                              <1> ; SCPBIOS internal area, Identity maps the first 4 Gb, creates 
    60                              <1> ; an IVT and moves the GDT to its final resting place,
    61                              <1> ; and directs cr3, gdtr and idtr to the BDA vars and reinits the video
    62                              <1> ; to VGA Mode 3. Finish by printing boot message and memory sizes.
    63                              <1> ;----------------------------------------------------------------
    64                              <1> longmode_ep:
    65 000002E4 66B81000            <1>     mov ax, 10h
    66 000002E8 668ED8              <1>     mov ds, ax
    67 000002EB 668EC0              <1>     mov es, ax
    68 000002EE 668EE0              <1>     mov fs, ax
    69 000002F1 668EE8              <1>     mov gs, ax
    70 000002F4 668ED0              <1>     mov ss, ax
    71                              <1> ;-----------------Write BDA constants-----------------
    72 000002F7 48BF-               <1>     mov rdi, section.data.start
    72 000002F9 [0000000000000000]  <1>
    73 00000301 66B80001            <1>     mov ax, 100h
    74 00000305 66AB                <1>     stosw            ;IDT Length
    75 00000307 66B8FF0F            <1>     mov ax, (100h*10h) - 1    ;IDT Limit
    76 0000030B 66AB                <1>     stosw
    77 0000030D 48B8-               <1>     mov rax, BIOSIDTable    ;IDT Base
    77 0000030F [0000000000000000]  <1>
    78 00000317 48AB                <1>     stosq
    79 00000319 66B80300            <1>     mov ax, 3h
    80 0000031D 66AB                <1>     stosw
    81 0000031F 66B81700            <1>     mov ax, (3h*8h)-1
    82 00000323 66AB                <1>     stosw
    83 00000325 48B8-               <1>     mov rax, BIOSGDTable
    83 00000327 [0070000000000000]  <1>
    84 0000032F 48AB                <1>     stosq
    85 00000331 48B8-               <1>     mov rax, BIOSPageTbl
    85 00000333 [0010000000000000]  <1>
    86 0000033B 48AB                <1>     stosq
    87 0000033D 31C0                <1>     xor eax, eax    ;Clears upper dword too
    88                              <1> ;Clear spur int counters
    89 0000033F 66AB                <1>     stosw
    90                              <1> ;Keyboard area
    91 00000341 B904000000          <1>     mov ecx, 4h
    92 00000346 F348AB              <1>     rep stosq    ;Clear kb buffer for 16 words
    93 00000349 48B8-               <1>     mov rax, kb_buffer
    93 0000034B [2200000000000000]  <1>
    94 00000353 66B90300            <1>     mov cx, 3h    ;Circular pointers
    95 00000357 F348AB              <1>     rep stosq
    96 0000035A 480520000000        <1>     add rax, 20h    ;End of buffer pointer
    97 00000360 48AB                <1>     stosq
    98 00000362 31C0                <1>     xor eax, eax
    99 00000364 AB                  <1>     stosd    ;Store keyboard flags bytes
   100                              <1> ;Serial Area
   101 00000365 AA                  <1>     stosb   ;Clear number of COM devices byte
   102 00000366 48AB                <1>     stosq    ;Clear com_addresses (4 words)
   103 00000368 66B90800            <1>     mov cx, 8
   104 0000036C F348AB              <1>     rep stosq    ;Store 8 qwords for COM buffers
   105                              <1> ;Buffer heads
   106 0000036F 48B8-               <1>     mov rax, com1_buffer
   106 00000371 [6F00000000000000]  <1>
   107 00000379 48AB                <1>     stosq
   108 0000037B 480510000000        <1>     add rax, 10h    ;Com2
   109 00000381 48AB                <1>     stosq
   110 00000383 480510000000        <1>     add rax, 10h    ;Com3
   111 00000389 48AB                <1>     stosq
   112 0000038B 480510000000        <1>     add rax, 10h    ;Com4
   113 00000391 48AB                <1>     stosq
   114                              <1> ;Buffer Tails
   115 00000393 482D30000000        <1>     sub rax, 30h
   116 00000399 48AB                <1>     stosq
   117 0000039B 480510000000        <1>     add rax, 10h    ;Com2
   118 000003A1 48AB                <1>     stosq
   119 000003A3 480510000000        <1>     add rax, 10h    ;Com3
   120 000003A9 48AB                <1>     stosq
   121 000003AB 480510000000        <1>     add rax, 10h    ;Com4
   122 000003B1 48AB                <1>     stosq
   123                              <1> ;Buffer start
   124 000003B3 482D30000000        <1>     sub rax, 30h
   125 000003B9 48AB                <1>     stosq
   126 000003BB 480510000000        <1>     add rax, 10h    ;Com2
   127 000003C1 48AB                <1>     stosq
   128 000003C3 480510000000        <1>     add rax, 10h    ;Com3
   129 000003C9 48AB                <1>     stosq
   130 000003CB 480510000000        <1>     add rax, 10h    ;Com4
   131 000003D1 48AB                <1>     stosq
   132                              <1> ;Buffer end
   133 000003D3 482D20000000        <1>     sub rax, 20h
   134 000003D9 48AB                <1>     stosq
   135 000003DB 480510000000        <1>     add rax, 10h    ;Com2
   136 000003E1 48AB                <1>     stosq
   137 000003E3 480510000000        <1>     add rax, 10h    ;Com3
   138 000003E9 48AB                <1>     stosq
   139 000003EB 480510000000        <1>     add rax, 10h    ;Com4
   140 000003F1 48AB                <1>     stosq
   141                              <1> ;Printer area
   142 000003F3 31C0                <1>     xor eax, eax
   143 000003F5 66B90300            <1>     mov cx, 3h
   144 000003F9 F366AB              <1>     rep stosw
   145                              <1> ;Timers area
   146 000003FC 66AB                <1>     stosw   ;Default pit_divisor, 0 = 65536
   147 000003FE AB                  <1>     stosd    ;pit_ticks
   148 000003FF 48AB                <1>     stosq    ;rtc_ticks
   149                              <1> ;Screen area
   150 00000401 66B90200            <1>     mov cx, 2h
   151 00000405 F348AB              <1>     rep stosq    ;rax, is 0
   152 00000408 66B85000            <1>     mov ax, 50h
   153 0000040C AA                  <1>     stosb
   154 0000040D 66B81900            <1>     mov ax, 19h
   155 00000411 AA                  <1>     stosb
   156 00000412 6631C0              <1>     xor ax, ax
   157 00000415 66AB                <1>     stosw
   158 00000417 66B80700            <1>     mov ax, 07
   159 0000041B AA                  <1>     stosb
   160 0000041C 66B80300            <1>     mov ax, 03
   161 00000420 AA                  <1>     stosb
   162 00000421 6631C0              <1>     xor ax, ax
   163 00000424 AA                  <1>     stosb
   164 00000425 66B8D403            <1>     mov ax, vga_index
   165 00000429 66AB                <1>     stosw
   166 0000042B B800800B00          <1>     mov eax, vga_bpage2
   167 00000430 AB                  <1>     stosd
   168 00000431 31C0                <1>     xor eax, eax    ;zero rax
   169                              <1> ;Store scr_mode_params and scr_vga_ptrs
   170 00000433 B909000000          <1>     mov ecx, 9
   171 00000438 F348AB              <1>     rep stosq
   172                              <1> ;HDD/FDD data area
   173 0000043B 31C0                <1>     xor eax, eax
   174 0000043D 66AB                <1>     stosw   ;Int 33h entries and msdStatus
   175 0000043F AA                  <1>     stosb   ;Fixed disk entries
   176 00000440 AB                  <1>     stosd   ;Hard drive status entries
   177 00000441 48B8-               <1>     mov rax, diskdpt
   177 00000443 [8A1A000000000000]  <1>
   178 0000044B 48AB                <1>     stosq   ;Store the address of the default remdev format table
   179 0000044D 48B8-               <1>     mov rax, fdiskdpt
   179 0000044F [951A000000000000]  <1>
   180 00000457 48AB                <1>     stosq
   181 00000459 31C0                <1>     xor eax, eax
   182                              <1> ;SysInit area
   183 0000045B 488B0425[02000000]  <1>     mov rax, qword [SysInitTable.FileLBA]
   184 00000463 48AB                <1>     stosq   ;NextFileLBA
   185 00000465 0FB70425[00000000]  <1>     movzx eax, word [SysInitTable.numSecW] 
   186 0000046D 66AB                <1>     stosw   ;numSectors Word
   187 0000046F 31C0                <1>     xor eax, eax
   188                              <1> ;Memory Data area
   189 00000471 AB                  <1>     stosd    ;0 MachineWord and convRAM 
   190 00000472 48AB                <1>     stosq   ;0 userBase
   191 00000474 AA                  <1>     stosb    ;0 bigmapSize
   192 00000475 48AB                <1>     stosq   ;0 srData, 4 words
   193 00000477 66AB                <1>     stosw   ;0 srData1, 1 word
   194 00000479 48AB                <1>     stosq   ;0 sysMem, 1 qword
   195 0000047B AB                  <1>     stosd   ;0 scpSize, 1 dword
   196                              <1> ;MCP data area
   197 0000047C 48C70425[EC010000]- <1>     mov qword [mcpUserBase], section.MCPseg.start
   197 00000484 [00000000]          <1>
   198 00000488 48C70425[F4010000]- <1>     mov qword [mcpUserRip], section.MCPseg.start + 180h
   198 00000490 [80010000]          <1>
   199 00000494 48C70425[FC010000]- <1>     mov qword [mcpUserkeybf], section.MCPseg.start + 100h
   199 0000049C [00010000]          <1>
   200 000004A0 48C70425[0C020000]- <1>     mov qword [mcpStackPtr], MCPsegEnd
   200 000004A8 [00080000]          <1>
   201 000004AC 48C70425[04020000]- <1>     mov qword [mcpUserRaxStore], 0
   201 000004B4 00000000            <1>
   202 000004B8 4881C728000000      <1>     add rdi, 5*8    ;Go forwards by 5 entries
   203                              <1> ;USB Area
   204 000004BF AA                  <1>     stosb
   205 000004C0 66B90400            <1>     mov cx, 4
   206 000004C4 F348AB              <1>     rep stosq    ;eControllerList
   207 000004C7 AA                  <1>     stosb
   208 000004C8 48B8-               <1>     mov rax, USB.ehciCriticalErrorHandler ;Get the critical error handler ptr
   208 000004CA [0A3A000000000000]  <1>
   209 000004D2 48AB                <1>     stosq       ;Install eHCErrorHandler
   210 000004D4 31C0                <1>     xor eax, eax    ;Rezero rax
   211 000004D6 66FFC8              <1>     dec ax
   212 000004D9 48AB                <1>     stosq       ;eCurrAsyncHead
   213 000004DB AA                  <1>     stosb       ;eActiveAddr
   214 000004DC AA                  <1>     stosb        ;eActiveCtrlr
   215 000004DD 66FFC0              <1>     inc ax
   216 000004E0 AB                  <1>     stosd
   217                              <1> ;USB Tables
   218 000004E1 66B91E00            <1>     mov cx, 10*usbDevTblEntrySize
   219 000004E5 F3AA                <1>     rep stosb
   220 000004E7 66B95000            <1>     mov cx, 10*hubDevTblEntrySize
   221 000004EB F3AA                <1>     rep stosb
   222 000004ED 66B9A000            <1>     mov cx, 10*msdDevTblEntrySize
   223 000004F1 F3AA                <1>     rep stosb
   224                              <1> ;IDE and Int 33h stuff
   225 000004F3 AA                  <1>     stosb       ;ideNumberOfControllers
   226 000004F4 66B92000            <1>     mov cx, 2*ideTableEntrySize ;ideControllerTable
   227 000004F8 F3AA                <1>     rep stosb
   228 000004FA 66B95800            <1>     mov cx, 4*fdiskEntry_size
   229 000004FE F3AA                <1>     rep stosb
   230 00000500 66B9A000            <1>     mov cx, 10*int33TblEntrySize
   231 00000504 F3AA                <1>     rep stosb
   232                              <1> ;End of BDA variable init
   233                              <1> 
   234                              <1> ;Copy the resident portion of SCPBIOS.SYS to its offset
   235                              <1> Relocate:
   236 00000506 48BE-               <1>     mov rsi, section.codeResident.start
   236 00000508 [0000000000000000]  <1>
   237 00000510 48BF-               <1>     mov rdi, section.codeResident.vstart    ;address for the end of the section
   237 00000512 [0000000000000000]  <1>
   238 0000051A 48B9F90A0000000000- <1>     mov rcx, (residentLength/8) + 1
   238 00000523 00                  <1>
   239 00000524 F348A5              <1>     rep movsq    ;Copy resident portion high
   240                              <1> 
   241                              <1> ;Copy machine word into var from 600h
   242 00000527 668B0425[0A000000]  <1>     mov ax, word [loMachineWord]
   243 0000052F 66890425[C9010000]  <1>     mov word [MachineWord], ax
   244                              <1> 
   245                              <1> ;Copy Memory Maps DIRECTLY after USB dynamic space.
   246 00000537 48BF-               <1>     mov rdi, bigmapptr
   246 00000539 [F005000000000000]  <1>
   247                              <1> .move820_0:    ;Add to the end
   248 00000541 48BE00000100000000- <1>     mov rsi, e820SizeAddr
   248 0000054A 00                  <1>
   249 0000054B 66AD                <1>     lodsw    ;Get number of entries for big map
   250 0000054D 480FB6C0            <1>     movzx rax, al    ;zero extend
   251 00000551 488D0C40            <1>     lea rcx, qword [rax + 2*rax]    ;Save 3*#of entries for countdown loop
   252                              <1> .mv0:
   253 00000555 F348A5              <1>     rep movsq    ;Transfer 3*al qwords
   254 00000558 0402                <1>     add al, 2    ;Two more entries for BIOS
   255 0000055A 880425[D5010000]    <1>     mov byte [bigmapSize], al    ;Save entries in al
   256                              <1> ;Compute the size of BIOS allocation + space for two more entries up to next KB
   257 00000561 4881C718000000      <1>     add rdi, 3*8 ;rdi now points to start of last allocated entry (added)
   258 00000568 4889FB              <1>     mov rbx, rdi 
   259 0000056B 4881C318000000      <1>     add rbx, 3*8h   ;Add size of last new entry
   260                              <1> ;Round to nearest KB
   261 00000572 4881E300FCFFFF      <1>     and rbx, ~3FFh
   262 00000579 4881C300040000      <1>     add rbx, 400h
   263 00000580 48891C25[CD010000]  <1>     mov qword [userBase], rbx    ;Save userbase
   264 00000588 4881EB00001100      <1>     sub rbx, BIOSStartAddr 
   265 0000058F 891C25[E8010000]    <1>     mov dword [scpSize], ebx    ;Save Size
   266                              <1> ;Calculate amount of system RAM available
   267                              <1> .readSystemSize:
   268 00000596 48BB-               <1>     mov rbx, bigmapptr
   268 00000598 [F005000000000000]  <1>
   269 000005A0 48BA01000000010000- <1>     mov rdx, 0000000100000001h      ;Valid entry signature
   269 000005A9 00                  <1>
   270 000005AA 0FB6C8              <1>     movzx ecx, al       ;Get the number of 24 byte entries
   271 000005AD 81E902000000        <1>     sub ecx, 2          ;Remove the allocated entries from the count
   272 000005B3 31C0                <1>     xor eax, eax                    ;Zero rax, use to hold cumulative sum
   273                              <1> .rss1:
   274 000005B5 48395310            <1>     cmp qword [rbx + 2*8], rdx   ;Check valid entry
   275 000005B9 7504                <1>     jnz .rss2
   276 000005BB 48034308            <1>     add rax, qword [rbx + 8]    ;Add size to rax
   277                              <1> .rss2:
   278 000005BF 4881C318000000      <1>     add rbx, 3*8                ;Goto next entry
   279 000005C6 FFC9                <1>     dec ecx                     ;Decrement count
   280 000005C8 75EB                <1>     jnz .rss1                   ;Not at zero, keep going
   281 000005CA 48890425[E0010000]  <1>     mov qword [sysMem], rax
   282                              <1> ;Create and insert new entry. If no space found for new, just add to end
   283                              <1> .addEntry:
   284 000005D2 0FB60C25[D5010000]  <1>     movzx ecx, byte [bigmapSize]
   285 000005DA 81E902000000        <1>     sub ecx, 2          ;Remove the allocated entries from the count   
   286 000005E0 31D2                <1>     xor edx, edx    ;Use as index pointer
   287                              <1> .ae0:
   288 000005E2 4881BA[F0050000]00- <1>     cmp qword [bigmapptr+rdx], 100000h    ;Start of extended memory
   288 000005EA 001000              <1>
   289 000005ED 7438                <1>     je .ae1
   290 000005EF 4881C218000000      <1>     add rdx, 18h    ;Go to next entry
   291 000005F6 FFC9                <1>     dec ecx 
   292 000005F8 75E8                <1>     jnz .ae0
   293                              <1> ;If address not found, just add it to the end, deal with that here
   294                              <1> ;Ignore the extra calculated allocated entry
   295                              <1> ;rdi points to last new entry, so sub rdi to point to second to last entry
   296 000005FA 4881EF18000000      <1>     sub rdi, 3*8h
   297 00000601 48C70700001100      <1>     mov qword [rdi], BIOSStartAddr
   298 00000608 488B0425[E8010000]  <1>     mov rax, qword [scpSize]
   299 00000610 48894708            <1>     mov qword [rdi + 8h], rax
   300 00000614 48B802000000010000- <1>     mov rax, 100000002h
   300 0000061D 00                  <1>
   301 0000061E 48894708            <1>     mov qword [rdi + 8h], rax
   302 00000622 E99F000000          <1>     jmp .altRAM
   303                              <1> .ae1:
   304                              <1> ;Address found, add new entry
   305                              <1> ;ecx contains number of entries that need to be shifted + 1
   306 00000627 56                  <1>     push rsi
   307 00000628 57                  <1>     push rdi
   308 00000629 4889FE              <1>     mov rsi, rdi
   309 0000062C 4881EE30000000      <1>     sub rsi, 2*18h
   310 00000633 FFC9                <1>     dec ecx
   311 00000635 89C8                <1>     mov eax, ecx    ;Use eax as row counter
   312                              <1> .ae2:
   313 00000637 B903000000          <1>     mov ecx, 3      ;3 8 byte entries
   314 0000063C F348A5              <1>     rep movsq
   315 0000063F 4881EE30000000      <1>     sub rsi, 2*18h
   316 00000646 4881EF30000000      <1>     sub rdi, 2*18h
   317 0000064D FFC8                <1>     dec eax
   318 0000064F 75E6                <1>     jnz .ae2
   319 00000651 5F                  <1>     pop rdi
   320 00000652 5E                  <1>     pop rsi
   321                              <1> ;Values copied, time to change values
   322                              <1> ;Change HMA entry
   323 00000653 4881C2[F0050000]    <1>     add rdx, bigmapptr    ;Add offset into table to rdx
   324 0000065A 488B4A08            <1>     mov rcx, qword [rdx + 8h]       ;Save size from entry into rax
   325 0000065E 48C7420800000100    <1>     mov qword [rdx + 8h], 10000h    ;Free 64Kb entry (HMA)
   326 00000666 4881C218000000      <1>     add rdx, 3*8h   ;Move to new SCP reserved entry
   327                              <1> ;Now Create the SCPBIOS Space Entry
   328 0000066D 48C70200001100      <1>     mov qword [rdx], BIOSStartAddr
   329 00000674 31DB                <1>     xor ebx, ebx
   330 00000676 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]
   331 0000067D 48895A08            <1>     mov qword [rdx + 8h], rbx
   332 00000681 48BB02000000010000- <1>     mov rbx, 100000002h
   332 0000068A 00                  <1>
   333 0000068B 48895A10            <1>     mov qword [rdx + 10h], rbx  ;Reserved flags
   334 0000068F 4881C218000000      <1>     add rdx, 3*8h
   335                              <1> ;Now modify the Free space entry
   336 00000696 488B0425[CD010000]  <1>     mov rax, qword [userBase]
   337 0000069E 488902              <1>     mov qword [rdx], rax
   338 000006A1 31C0                <1>     xor eax, eax
   339 000006A3 8B0425[E8010000]    <1>     mov eax, dword [scpSize]
   340 000006AA 4829C1              <1>     sub rcx, rax
   341 000006AD 4881E900000100      <1>     sub rcx, 10000h ;Sub HMA size
   342 000006B4 48894A08            <1>     mov qword [rdx + 8h], rcx    ;Put entry back
   343 000006B8 48BB01000000010000- <1>     mov rbx, 100000001h
   343 000006C1 00                  <1>
   344 000006C2 48895A10            <1>     mov qword [rdx + 10h], rbx  ;Free flags
   345                              <1> .altRAM:
   346                              <1> ;Copy Alt RAM values
   347 000006C6 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]
   348 000006CD C1EB0A              <1>     shr ebx, 0Ah    ;Rescale from byts to KB
   349 000006D0 81C340000000        <1>     add ebx, 40h    ;Add the HMA (64Kb)
   350 000006D6 48BF-               <1>     mov rdi, srData    ;Save qword in srData ah=E801h
   350 000006D8 [D601000000000000]  <1>
   351 000006E0 48AD                <1>     lodsq    ;Get into rax, inc rsi
   352 000006E2 6629D8              <1>     sub ax, bx      ;bx preserved, contains number of KB's plus 1
   353 000006E5 48C1C820            <1>     ror rax, 20h    ;Rotate over 32 bits
   354 000006E9 6629D8              <1>     sub ax, bx
   355 000006EC 48C1C820            <1>     ror rax, 20h    ;Rotate over 32 bits again
   356 000006F0 48AB                <1>     stosq            ;Save, inc rdi
   357 000006F2 48BF-               <1>     mov rdi, srData1    ;Save word for ah=88h
   357 000006F4 [DE01000000000000]  <1>
   358 000006FC 66A5                <1>     movsw    ;Save value, then reduce by BIOS size
   359 000006FE 66295FFE            <1>     sub word [rdi - 2], bx    ;Reduce the size of the previous stored val
   360 00000702 48BF-               <1>     mov rdi, convRAM    ;Int 12h value
   360 00000704 [CB01000000000000]  <1>
   361 0000070C 66A5                <1>     movsw
   362                              <1> ;Copy VGA fonts to Internal Int 30h area
   363 0000070E 48BF-               <1>     mov rdi, scr_vga_ptrs
   363 00000710 [6801000000000000]  <1>
   364 00000718 48B908000000000000- <1>     mov rcx, 8
   364 00000721 00                  <1>
   365 00000722 F348A5              <1>     rep movsq
   366                              <1> ;-----------------Write Long Mode Page Tables-----------------
   367                              <1> ;Creates a 4Gb ID mapped page 
   368 00000725 48BF-               <1>     mov rdi, BIOSPageTbl
   368 00000727 [0010000000000000]  <1>
   369 0000072F 57                  <1>     push rdi
   370                              <1> Ptablefinal:
   371 00000730 48B9000C0000000000- <1>     mov rcx, 6000h/8;6000h bytes (6x4Kb) of zero to clear table area
   371 00000739 00                  <1>
   372 0000073A 57                  <1>     push rdi
   373 0000073B 4831C0              <1>     xor rax, rax
   374 0000073E F348AB              <1>     rep stosq        ;Clear the space
   375                              <1> 
   376 00000741 5F                  <1>     pop rdi            ;Return zero to the head of the table, at 08000h
   377 00000742 4889F8              <1>     mov rax, rdi    ;Load rax with the PML4 table location
   378 00000745 480500100000        <1>     add rax, 1000h  ;Move rax to point to PDPT
   379 0000074B 480D03000000        <1>     or rax, permissionflags    ;Write the PDPT entry as present and r/w
   380 00000751 48AB                <1>     stosq    ;store the low word of the address
   381 00000753 4881C7F80F0000      <1>     add rdi, 0FF8h
   382 0000075A B904000000          <1>     mov ecx, 4
   383                              <1> .utables:
   384 0000075F 480500100000        <1>     add rax, 1000h  ;Write four entries in PDPT for each GB range
   385 00000765 48AB                <1>     stosq
   386 00000767 FFC9                <1>     dec ecx
   387 00000769 75F4                <1>     jnz .utables
   388                              <1> 
   389 0000076B 4881C7E00F0000      <1>     add rdi, 0FE0h  ;rdi points to the new page tables, copy!
   390 00000772 48BE00A00000000000- <1>     mov rsi, 0A000h ;Get the first Page table
   390 0000077B 00                  <1>
   391 0000077C B900080000          <1>     mov ecx, 4000h/8 ;Number of bytes to copy 
   392 00000781 F348A5              <1>     rep movsq       ;Get the 4Gb tables into place
   393 00000784 5F                  <1>     pop rdi            ;Bring back Table base
   394 00000785 0F22DF              <1>     mov cr3, rdi    ;Finalise change in paging address
   395                              <1> 
   396                              <1> ;----------------------Write Interrupts----------------------
   397 00000788 48B900010000000000- <1>     mov rcx, 0100h    ;256 entries
   397 00000791 00                  <1>
   398 00000792 48B8-               <1>     mov rax, dummy_return_64
   398 00000794 [9657000000000000]  <1>
   399 0000079C BB08000000          <1>     mov ebx, codedescriptor
   400 000007A1 31F6                <1>     xor esi, esi
   401 000007A3 66BA008F            <1>     mov dx, 8F00h    
   402                              <1>     ;Toggle attribs. 8F = Interrupt Present, accessable from ring 0 and greater,
   403                              <1>     ;0 (so collectively 08h) and gate type 0Fh (64-bit trap gate (gate which 
   404                              <1>     ;leaves interrupts on))
   405                              <1> idtFillDummy:
   406 000007A7 E8(CB000000)        <1>     call idtWriteEntry
   407 000007AC 66FFC9              <1>     dec cx
   408 000007AF 75F6                <1>     jnz idtFillDummy
   409                              <1> 
   410 000007B1 31F6                <1>     xor esi, esi
   411 000007B3 48B940000000000000- <1>     mov rcx, ((IDT_TABLE_Length >> 3))
   411 000007BC 00                  <1>
   412 000007BD 48BD-               <1>     mov rbp, IDT_TABLE
   412 000007BF [481A000000000000]  <1>
   413                              <1> idtLoop:
   414 000007C7 488B44F500          <1>     mov rax, qword [rbp+(rsi*8)]
   415 000007CC E8(CB000000)        <1>     call idtWriteEntry
   416 000007D1 48FFC9              <1>     dec rcx
   417 000007D4 75F1                <1>     jnz idtLoop
   418                              <1> 
   419 000007D6 48BC00000800000000- <1>     mov rsp, 80000h    ;Realign stack pointer
   419 000007DF 00                  <1>
   420                              <1> ;Reload the interrupt table
   421 000007E0 0F011C25[02000000]  <1>     lidt [IDTpointer]
   422                              <1> ;Write GDT to its final High location
   423 000007E8 48BE-               <1>     mov rsi, GDT
   423 000007EA [BF02000000000000]  <1>
   424 000007F2 48BF-               <1>     mov rdi, BIOSGDTable
   424 000007F4 [0070000000000000]  <1>
   425 000007FC 48B903000000000000- <1>     mov rcx, 3
   425 00000805 00                  <1>
   426 00000806 F348A5              <1>     rep movsq    ;copy the three descriptors high
   427                              <1> ;Reload the GDT Pointer
   428 00000809 0F011425[0E000000]  <1>     lgdt [GDTpointer]
   429                              <1> 
   430                              <1> ;Video Initialisation: VGA mode, CRTC at 3D4h, Mode 03h, 128k VRAM
   431                              <1> ;For now, only unlock upper WO CRTC registers, by using undocumented 
   432                              <1> ; CRTC register 11h.
   433 00000811 668B1425[5A010000]  <1>     mov dx, word [scr_crtc_base]    ;Get current set CRTC index register
   434 00000819 B011                <1>     mov al, 11h     ;Register 11
   435 0000081B 88D8                <1>     mov al, bl
   436 0000081D EE                  <1>     out dx, al
   437 0000081E E680                <1>     out waitp, al   ;Wait an I/O cycle
   438 00000820 66FFC2              <1>     inc dx  ;Point to data register
   439 00000823 EC                  <1>     in al, dx   ;get register 11h
   440 00000824 247F                <1>     and al, 7Fh ;Clear upper bit
   441 00000826 86C3                <1>     xchg al, bl ;Get address back into al, save new register value in bl  
   442 00000828 66FFCA              <1>     dec dx  ;Return to index
   443 0000082B EE                  <1>     out dx, al
   444 0000082C FEC2                <1>     inc dl
   445 0000082E 86C3                <1>     xchg al, bl
   446 00000830 EE                  <1>     out dx, al  ;Output new byte, unlock upper WO CRTC registers for use!
   447                              <1> ;Boot message/Verification of successful VGA card reset!
   448                              <1> ;Print Boot Message
   449 00000831 66B80413            <1>     mov ax, 1304h
   450 00000835 48BD-               <1>     mov rbp, startboot
   450 00000837 [8217000000000000]  <1>
   451 0000083F CD30                <1>     int 30h
   452                              <1> 
   453 00000841 E830100000          <1>     call memprint    ;Print Memory status
   454                              <1> 
   455                              <1> ;----------------------------------------------------------------
   456                              <1> ;                        End of Initialisation                  :
   457                              <1> ;----------------------------------------------------------------
    53                                  %include "./Source/Init/Hardware/PIC/picinit.asm"
    54                              <1> ;----------------------------------------------------------------
    55                              <1> ;                PIC Initialisation procedure                   :
    56                              <1> ;----------------------------------------------------------------
    57                              <1> ;Remapping the IO ports to Interrupt 0x40
    58                              <1> PICremap:
    59 00000846 B011                <1>     mov al, 11h        ;bit 10h and 1h = Start initialisation
    60 00000848 E620                <1>     out pic1command, al
    61 0000084A E680                <1>     out waitp, al    
    62 0000084C E6A0                <1>     out pic2command, al
    63 0000084E E680                <1>     out waitp, al    
    64                              <1>     
    65 00000850 B020                <1>     mov al, 20h       ;PIC1 to take Int 20h - 27h
    66 00000852 E621                <1>     out pic1data, al
    67 00000854 E680                <1>     out waitp, al    
    68 00000856 0408                <1>     add al, 8        ;PIC2 to take Int 28h - 2Fh
    69 00000858 E6A1                <1>     out pic2data, al 
    70 0000085A E680                <1>     out waitp, al    
    71                              <1>     
    72 0000085C B004                <1>     mov al, 4
    73 0000085E E621                <1>     out pic1data, al    ;Tell PIC 1 that there is a PIC 2 at IRQ2 (00000100)
    74 00000860 E680                <1>     out waitp, al    
    75 00000862 FEC8                <1>     dec al
    76 00000864 FEC8                <1>     dec al
    77 00000866 E6A1                <1>     out pic2data, al    ;Tell PIC 2 its cascade identity (00000010)
    78 00000868 E680                <1>     out waitp, al
    79                              <1>     
    80 0000086A B001                <1>     mov al, 01h        ;Initialise in 8086 mode
    81 0000086C E621                <1>     out pic1data, al
    82 0000086E E680                <1>     out waitp, al    
    83 00000870 E6A1                <1>     out pic2data, al
    84 00000872 E680                <1>     out waitp, al    
    85                              <1>     
    86 00000874 B0FF                <1>     mov al, 0FFh    ;Mask all interrupts 
    87 00000876 E621                <1>     out pic1data, al
    88 00000878 E6A1                <1>     out pic2data, al
    89                              <1> 
    90                              <1> ;Ensure that interrupts are still masked
    91                              <1> ;----------------------------------------------------------------
    92                              <1> ;                        End of Initialisation                  :
    93                              <1> ;----------------------------------------------------------------
    54                                  %include "./Source/Init/Hardware/PCI/init.asm"
    55                              <1> ;----------------------------------------------------------------
    56                              <1> ;                            PCI Enumeration                    :
    57                              <1> ;----------------------------------------------------------------
    58                              <1> ; This proc enumerates only the PCI devices we care for
    59                              <1> ;----------------------------------------------------------------
    60 0000087A 4831ED              <1>     xor rbp, rbp
    61 0000087D 66892C2500E00000    <1>     mov word [lousbtablesize], bp
    62 00000885 4889E9              <1>     mov rcx, rbp    ;reset cx now too, for below
    63                              <1> pci_scan:    ;Enumerate PCI devices (formerly, USB devices)
    64 00000888 4831DB              <1>     xor rbx, rbx       ;Used to save the value of eax temporarily
    65 0000088B 48B808000081000000- <1>     mov rax, 81000008h ;Set bit 31 and lower byte to 2, for register 2/offset 8
    65 00000894 00                  <1>
    66                              <1>                        ;also make it the largest register so that we enumerate 
    67                              <1>                        ;backwards and set up USB controllers in order from 
    68                              <1>                        ;newest to oldest.
    69                              <1> .u1:
    70 00000895 2D00010000          <1>     sub eax, 100h      ;mov eax into valid PCI range, go to next device
    71 0000089A 66BAF80C            <1>     mov dx, pci_index  ;PCI index register
    72 0000089E EF                  <1>     out dx, eax   ;output the next packed bus,device,function,register combo
    73                              <1> 
    74 0000089F 89C3                <1>     mov ebx, eax       ;save to be used later, to access PCI BARS
    75                              <1>     
    76 000008A1 66BAFC0C            <1>     mov dx, pci_data   ;PCI data register
    77 000008A5 ED                  <1>     in eax, dx    ;Get Class, subclass and interface value in upper three bytes
    78                              <1>     
    79 000008A6 C1E808              <1>     shr eax, 8                ;shift down the details by a byte
    80                              <1> ;IF any of these are satisfied, remember ebx has the device index
    81 000008A9 3D00030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+uhci_interface)
    82 000008AE 0F844B010000        <1>     je .uhci_found
    83 000008B4 3D10030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+ohci_interface)
    84 000008B9 0F8482010000        <1>     je .ohci_found
    85 000008BF 3D20030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+ehci_interface)
    86 000008C4 0F8481010000        <1>     je .ehci_found
    87 000008CA 3D30030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+xhci_interface)
    88 000008CF 0F84D5010000        <1>     je .xhci_found
    89 000008D5 50                  <1>     push rax
    90 000008D6 C1E808              <1>     shr eax, 8              ;roll over rid of function number
    91 000008D9 3D01010000          <1>     cmp eax, (msd_class << 8) + (ide_subclass)
    92 000008DE 7452                <1>     je .idePCIEnum
    93 000008E0 3D06010000          <1>     cmp eax, (msd_class << 8) + (sata_subclass)
    94 000008E5 7414                <1>     je .sataPCIEnum
    95 000008E7 58                  <1>     pop rax
    96                              <1> .u11:    ;After a device found, jump here to continue enumeration
    97 000008E8 6681E50F00          <1>     and bp, 000Fh       ;Zero the upper nybble again.
    98 000008ED 89D8                <1>     mov eax, ebx        ;Return pci value into eax
    99 000008EF 3D08000080          <1>     cmp eax, 80000008h  ;The lowest value
   100 000008F4 7F9F                <1>     jg .u1
   101 000008F6 E9AE040000          <1>     jmp pciExit
   102                              <1> .sataPCIEnum:
   103 000008FB 58                  <1>     pop rax
   104 000008FC 50                  <1>     push rax
   105 000008FD 55                  <1>     push rbp
   106 000008FE 66B80413            <1>     mov ax, 1304h
   107 00000902 48BD-               <1>     mov rbp, .spemsg
   107 00000904 [1509000000000000]  <1>
   108 0000090C CD30                <1>     int 30h
   109 0000090E 5D                  <1>     pop rbp
   110 0000090F 58                  <1>     pop rax
   111 00000910 E9D3FFFFFF          <1>     jmp .u11
   112 00000915 0A0D41484349205341- <1> .spemsg: db 0Ah, 0Dh, "AHCI SATA controller found", 0
   112 0000091E 544120636F6E74726F- <1>
   112 00000927 6C6C657220666F756E- <1>
   112 00000930 6400                <1>
   113                              <1> .idePCIEnum:
   114 00000932 58                  <1>     pop rax
   115 00000933 50                  <1>     push rax
   116 00000934 55                  <1>     push rbp
   117 00000935 66B80413            <1>     mov ax, 1304h
   118 00000939 48BD-               <1>     mov rbp, .ipemsg
   118 0000093B [AD09000000000000]  <1>
   119 00000943 CD30                <1>     int 30h
   120 00000945 5D                  <1>     pop rbp
   121 00000946 58                  <1>     pop rax
   122 00000947 50                  <1>     push rax
   123 00000948 B404                <1>     mov ah, 04h
   124 0000094A CD30                <1>     int 30h
   125 0000094C 58                  <1>     pop rax
   126                              <1> ;If function is 80h, then it will respond to default IO addresses
   127 0000094D A880                <1>     test al, 80h ;Check if bus mastery is enabled. Only support DMA transfers
   128 0000094F 7497                <1>     jz .u11      ;Exit if not enabled
   129 00000951 3C80                <1>     cmp al, 80h  ;If 80h, device hardwired bus master legacy mode, all good.
   130 00000953 742B                <1>     je .ipeWriteTable
   131                              <1> ;Bit bash, and reread, if it works, yay, if not, fail cancel
   132 00000955 66BAF80C            <1>     mov dx, pci_index
   133 00000959 89D8                <1>     mov eax, ebx
   134 0000095B EF                  <1>     out dx, eax     ;Register offset 8
   135 0000095C 6681C20400          <1>     add dx, 4       ;Point to pci_data
   136 00000961 25FFFAFFFF          <1>     and eax, 0FFFFFAFFh     ;Zero bits 0 and 2 of nybble 3
   137 00000966 EF                  <1>     out dx, eax
   138 00000967 6681EA0400          <1>     sub dx, 4
   139 0000096C 89D8                <1>     mov eax, ebx
   140 0000096E EF                  <1>     out dx, eax
   141 0000096F 6681C20400          <1>     add dx, 4
   142 00000974 ED                  <1>     in eax, dx
   143 00000975 A900050000          <1>     test eax, 00000500h  ;Test bits 0 and 2 of nybble 3 have been zeroed
   144 0000097A 0F8568FFFFFF        <1>     jnz .u11    ;IF not, fail
   145                              <1> .ipeWriteTable:
   146                              <1> ;Now the controller and devices have been set to legacy, they should
   147                              <1> ; respond to the default IO addresses and IRQ. Save BAR 5 for Bus mastering.
   148 00000980 50                  <1>     push rax
   149 00000981 55                  <1>     push rbp
   150 00000982 48BD-               <1>     mov rbp, .ipemsg2
   150 00000984 [D009000000000000]  <1>
   151 0000098C 66B80413            <1>     mov ax, 1304h
   152 00000990 CD30                <1>     int 30h
   153 00000992 5D                  <1>     pop rbp
   154 00000993 58                  <1>     pop rax
   155 00000994 89D8                <1>     mov eax, ebx    
   156 00000996 B020                <1>     mov al, 20h ;BAR4 Address
   157 00000998 66BAF80C            <1>     mov dx, pci_index
   158 0000099C EF                  <1>     out dx, eax
   159 0000099D 6681C20400          <1>     add dx, 4
   160 000009A2 ED                  <1>     in eax, dx  ;Get BAR 4 address
   161 000009A3 E8420A0000          <1>     call IDE.addControllerTable ;Function will not add if we maxed out controllers
   162 000009A8 E93BFFFFFF          <1>     jmp .u11
   163 000009AD 0A0D49444520415441- <1> .ipemsg:    db 0Ah, 0Dh,"IDE ATA Controller found. Type: ", 0
   163 000009B6 20436F6E74726F6C6C- <1>
   163 000009BF 657220666F756E642E- <1>
   163 000009C8 20547970653A2000    <1>
   164 000009D0 0A0D49444520415441- <1> .ipemsg2:   db 0Ah, 0Dh, "IDE ATA Controller set to compatibility mode",0
   164 000009D9 20436F6E74726F6C6C- <1>
   164 000009E2 65722073657420746F- <1>
   164 000009EB 20636F6D7061746962- <1>
   164 000009F4 696C697479206D6F64- <1>
   164 000009FD 6500                <1>
   165                              <1> ;bp lo = status register, 
   166                              <1> ;bp hi = controller being serviced (ie 1000xxxx => xHCI being serviced)
   167                              <1> .uhci_found:
   168 000009FF 6681CD1100          <1>     or bp, 00010001b    ;set bit 0/mask = 1
   169 00000A04 55                  <1>     push rbp
   170 00000A05 50                  <1>     push rax
   171 00000A06 53                  <1>     push rbx
   172 00000A07 66B80413            <1>     mov ax, 1304h
   173 00000A0B 30FF                <1>     xor bh, bh
   174 00000A0D 48BD-               <1>     mov rbp, .uhci_succ
   174 00000A0F [210A000000000000]  <1>
   175 00000A17 CD30                <1>     int 30h
   176 00000A19 5B                  <1>     pop rbx
   177 00000A1A 58                  <1>     pop rax
   178 00000A1B 5D                  <1>     pop rbp
   179 00000A1C E9A6000000          <1>     jmp .controlController
   180 00000A21 0A0D5548434920636F- <1> .uhci_succ:    db    0Ah, 0Dh,'UHCI controller found on IRQ ', 0
   180 00000A2A 6E74726F6C6C657220- <1>
   180 00000A33 666F756E64206F6E20- <1>
   180 00000A3C 4952512000          <1>
   181                              <1> .ohci_found:
   182 00000A41 6681CD2200          <1>     or bp, 00100010b    ;set bit 1/mask = 2
   183 00000A46 E99DFEFFFF          <1>     jmp .u11
   184                              <1> .ehci_found:
   185 00000A4B 6681CD4400          <1>     or bp, 01000100b    ;set bit 2/mask = 4
   186 00000A50 55                  <1>     push rbp
   187 00000A51 50                  <1>     push rax
   188 00000A52 53                  <1>     push rbx
   189 00000A53 66B80413            <1>     mov ax, 1304h
   190 00000A57 30FF                <1>     xor bh, bh
   191 00000A59 48BD-               <1>     mov rbp, .ehci_succ
   191 00000A5B [6A0A000000000000]  <1>
   192 00000A63 CD30                <1>     int 30h
   193 00000A65 5B                  <1>     pop rbx
   194 00000A66 58                  <1>     pop rax
   195 00000A67 5D                  <1>     pop rbp
   196 00000A68 EB5D                <1>     jmp short .controlController
   197 00000A6A 0A0D4548434920636F- <1> .ehci_succ:    db    0Ah, 0Dh,'EHCI controller found on IRQ ', 0
   197 00000A73 6E74726F6C6C657220- <1>
   197 00000A7C 666F756E64206F6E20- <1>
   197 00000A85 4952512000          <1>
   198 00000A8A 0A0D7848434920636F- <1> .xhci_succ:    db    0Ah, 0Dh,'xHCI controller found on IRQ ', 0
   198 00000A93 6E74726F6C6C657220- <1>
   198 00000A9C 666F756E64206F6E20- <1>
   198 00000AA5 4952512000          <1>
   199                              <1> .xhci_found:
   200 00000AAA 55                  <1>     push rbp
   201 00000AAB 50                  <1>     push rax
   202 00000AAC 53                  <1>     push rbx
   203 00000AAD 66B80413            <1>     mov ax, 1304h
   204 00000AB1 30FF                <1>     xor bh, bh
   205 00000AB3 48BD-               <1>     mov rbp, .xhci_succ
   205 00000AB5 [8A0A000000000000]  <1>
   206 00000ABD CD30                <1>     int 30h
   207 00000ABF 5B                  <1>     pop rbx
   208 00000AC0 58                  <1>     pop rax
   209 00000AC1 5D                  <1>     pop rbp
   210 00000AC2 6681CD8800          <1>     or bp, 10001000b    ;set bit 3/mask = 8
   211                              <1> 
   212                              <1> .controlController:
   213                              <1> ;This for now will get the IRQ line for all controllers,
   214                              <1> ;and install a USB handler there, then disabling the HC rather than just the 
   215                              <1> ;legacy support.
   216                              <1> ;EAX doesnt need to be saved since the first instruction of .u11 is to move the 
   217                              <1> ;value of ebx back into eax.
   218                              <1> ;EDX doesnt need to be saved since the port data gets loaded in the proc above
   219                              <1> ;DO NOT MODIFY EBX
   220 00000AC7 31D2                <1>     xor edx, edx
   221 00000AC9 89D8                <1>     mov eax, ebx    ;Move a copy of ebx, the PCI config space device address
   222 00000ACB B03C                <1>     mov al, 3Ch     ;offset 3C has interrupt masks in lower word
   223 00000ACD 66BAF80C            <1>     mov dx, pci_index
   224 00000AD1 EF                  <1>     out dx, eax       ;set to give interrupt masks
   225 00000AD2 66BAFC0C            <1>     mov dx, pci_data
   226 00000AD6 ED                  <1>     in eax, dx        ;Get info into eax (formally, al)
   227 00000AD7 50                  <1>     push rax
   228 00000AD8 240F                <1>     and al, 0Fh
   229 00000ADA B404                <1>     mov ah, 04h
   230 00000ADC CD30                <1>     int 30h
   231 00000ADE 58                  <1>     pop rax
   232 00000ADF 66F7C54000          <1>     test bp, 40h      ;Check if EHCI
   233 00000AE4 0F8490000000        <1>     jz .cc1           ;Skip mapping
   234 00000AEA 240F                <1>     and al, 0Fh       ;Clear upper nybble for good measure
   235 00000AEC 3C10                <1>     cmp al, 10h
   236 00000AEE 0F8786000000        <1>     ja .cc1           ;Cant map it
   237 00000AF4 3C08                <1>     cmp al, 08h        
   238 00000AF6 733E                <1>     jae .cc0
   239 00000AF8 56                  <1>     push rsi
   240 00000AF9 52                  <1>     push rdx
   241 00000AFA 50                  <1>     push rax
   242 00000AFB 53                  <1>     push rbx
   243 00000AFC 480FB6F0            <1>     movzx rsi, al
   244 00000B00 81C620000000        <1>     add esi, 20h
   245 00000B06 66BA008F            <1>     mov dx, 8F00h
   246 00000B0A 48B8-               <1>     mov rax, ehci_IRQ.pic1    ;PIC1 ep
   246 00000B0C [030B000000000000]  <1>
   247 00000B14 BB08000000          <1>     mov ebx, codedescriptor
   248 00000B19 E8(CB000000)        <1>     call idtWriteEntry
   249 00000B1E 5B                  <1>     pop rbx
   250 00000B1F 58                  <1>     pop rax
   251 00000B20 5A                  <1>     pop rdx
   252 00000B21 5E                  <1>     pop rsi
   253 00000B22 51                  <1>     push rcx
   254 00000B23 88C1                <1>     mov cl, al
   255 00000B25 B001                <1>     mov al, 1
   256 00000B27 D2E0                <1>     shl al, cl          ;Shift bit to appropriate position
   257 00000B29 F6D0                <1>     not al              ;Turn into a bitmask
   258 00000B2B 88C4                <1>     mov ah, al          ;Save in ah
   259 00000B2D E421                <1>     in al, pic1data
   260 00000B2F 20E0                <1>     and al, ah          ;Add bitmask to current mask
   261 00000B31 E621                <1>     out pic1data, al    ;Unmask this line
   262 00000B33 59                  <1>     pop rcx
   263 00000B34 EB44                <1>     jmp short .cc1
   264                              <1> .cc0:
   265 00000B36 56                  <1>     push rsi
   266 00000B37 52                  <1>     push rdx
   267 00000B38 50                  <1>     push rax
   268 00000B39 53                  <1>     push rbx
   269 00000B3A 480FB6F0            <1>     movzx rsi, al
   270 00000B3E 81C620000000        <1>     add esi, 20h    ;Start of PIC range
   271 00000B44 66BA008F            <1>     mov dx, 8F00h
   272 00000B48 48B8-               <1>     mov rax, ehci_IRQ
   272 00000B4A [FC0A000000000000]  <1>
   273 00000B52 BB08000000          <1>     mov ebx, codedescriptor
   274 00000B57 E8(CB000000)        <1>     call idtWriteEntry
   275 00000B5C 5B                  <1>     pop rbx
   276 00000B5D 58                  <1>     pop rax
   277 00000B5E 5A                  <1>     pop rdx
   278 00000B5F 5E                  <1>     pop rsi
   279 00000B60 51                  <1>     push rcx
   280 00000B61 2C08                <1>     sub al, 8
   281 00000B63 88C1                <1>     mov cl, al
   282 00000B65 E421                <1>     in al, pic1data
   283 00000B67 24FB                <1>     and al, 0FBh  ;Clear Cascade bit
   284 00000B69 E621                <1>     out pic1data, al
   285 00000B6B B001                <1>     mov al, 1
   286 00000B6D D2E0                <1>     shl al, cl    ;Shift bit to appropriate position
   287 00000B6F F6D0                <1>     not al        ;Turn into a bitmask
   288 00000B71 88C4                <1>     mov ah, al    ;Save in ah
   289 00000B73 E4A1                <1>     in al, pic2data
   290 00000B75 20E0                <1>     and al, ah    ;Add bitmask to current mask
   291 00000B77 E6A1                <1>     out pic2data, al    ;Unmask this line
   292 00000B79 59                  <1>     pop rcx
   293                              <1> .cc1:
   294 00000B7A 89D8                <1>     mov eax, ebx    ;Bring back a copy of ebx, the PCI config space addr to eax
   295 00000B7C B010                <1>     mov al, 10h     ;Change the register from Class code to BAR0
   296                              <1>     
   297 00000B7E 66BAF80C            <1>     mov dx, pci_index
   298 00000B82 EF                  <1>     out dx, eax        ;Set to give BAR0
   299 00000B83 66BAFC0C            <1>     mov dx, pci_data
   300 00000B87 ED                  <1>     in eax, dx        ;get unrefined BAR0/BASE pointer into eax
   301                              <1> 
   302 00000B88 2500FFFFFF          <1>     and eax, 0FFFFFF00h    ;refine eax into an mmio register
   303 00000B8D 50                  <1>     push rax    ;push BASE pointer onto stack
   304                              <1> 
   305                              <1> ;Write USB controller table:
   306                              <1> ;Each table entry (tword), as follows:
   307                              <1> ;Offset:
   308                              <1> ; 00h - hci type (bp) [word]
   309                              <1> ; 02h - PCI address (ebx) [dword]
   310                              <1> ; 06h - MMIO address (eax) [dword]
   311                              <1> ;ALL REGISTERS PRESERVED, data stored at usbtablebase, size at usbtablesize
   312 00000B8E 56                  <1>     push rsi
   313 00000B8F 51                  <1>     push rcx
   314 00000B90 0FB70C2500E00000    <1>     movzx ecx, word [lousbtablesize]    ;get number of table entries
   315 00000B98 89CE                <1>     mov esi, ecx
   316 00000B9A D1E1                <1>     shl ecx, 1    ;Multiply by 2
   317 00000B9C 678DB4F102E00000    <1>     lea esi, [8*esi + ecx + lousbtablebase] 
   318                              <1>     ;multiply esi by 10 to get table offset & add to table base
   319                              <1>     ;store table offset back in esi
   320 00000BA4 6667892E            <1>     mov word [esi], bp    ;Store controller type
   321 00000BA8 81C602000000        <1>     add esi, 2
   322 00000BAE 67891E              <1>     mov dword [esi], ebx    
   323                              <1>         ;Store PCI device config space address (set to register 2)
   324 00000BB1 81C604000000        <1>     add esi, 4
   325 00000BB7 678906              <1>     mov dword [esi], eax    ;Store device MMIO Address (refined BAR0 value)
   326 00000BBA 59                  <1>     pop rcx
   327 00000BBB 5E                  <1>     pop rsi
   328 00000BBC 66FF042500E00000    <1>     inc word [lousbtablesize]
   329                              <1> 
   330 00000BC4 6681FD8000          <1>     cmp bp, 80h    ;Are we servicing xHCI, EHCI or UHCI?
   331 00000BC9 7D7A                <1>     jge .controlxHCI
   332 00000BCB 6681FD4000          <1>     cmp bp, 40h    ;Are we servicing EHCI or UHCI? 
   333 00000BD0 0F8DC9000000        <1>     jge .controlEHCI
   334                              <1> ;If neither of these, collapse into UHCI
   335                              <1> .controlUHCI:
   336                              <1> ;eax points to the refined base pointer
   337 00000BD6 53                  <1>     push rbx                    ;temp stack save 
   338 00000BD7 89D8                <1>     mov eax, ebx     ;get the current packed bus,device,function,register combo
   339 00000BD9 2500F8FFFF          <1>     and eax, 0FFFFF800h         ;Clear bottom 10 bytes.
   340 00000BDE 0DC0020000          <1>     or eax, 2C0h                ;Function 2, register offset C0h
   341                              <1> 
   342 00000BE3 50                  <1>     push rax                    ;temp save address value on stack
   343                              <1> 
   344 00000BE4 66BAF80C            <1>     mov dx, pci_index
   345 00000BE8 EF                  <1>     out dx, eax
   346 00000BE9 80C204              <1>     add dl, 4                   ;dx now points to pci_index
   347 00000BEC ED                  <1>     in eax, dx                  ;Bring register value into eax
   348                              <1> 
   349 00000BED 66B8008F            <1>     mov ax, 8F00h               ;Clear all SMI bits (no SMI pls)
   350 00000BF1 89C3                <1>     mov ebx, eax                ;save temporarily in ebx
   351                              <1> 
   352 00000BF3 58                  <1>     pop rax                     ;bring back address value from stack
   353                              <1> 
   354 00000BF4 80EA04              <1>     sub dl, 4                   ;put dx back to pci_index
   355 00000BF7 EF                  <1>     out dx, eax                 ;select legsup register
   356                              <1> 
   357 00000BF8 80C204              <1>     add dl, 4                   ;aim dx back to pci_data
   358 00000BFB 89D8                <1>     mov eax, ebx                ;bring back new legsup value
   359 00000BFD EF                  <1>     out dx, eax                 ;send it back!
   360                              <1> 
   361                              <1> ;Now set bit 6 of the command register to 1 (semaphore)
   362 00000BFE 5B                  <1>     pop rbx                     ;Return original ebx value
   363 00000BFF 89D8                <1>     mov eax, ebx  ;Move a copy of ebx, PCI config space device address (index)
   364 00000C01 B020                <1>     mov al, 20h                 ;Change the register from Class code to BAR4 
   365 00000C03 6681EA0400          <1>     sub dx, 4                   ;Point dx back to pci_index
   366 00000C08 EF                  <1>     out dx, eax                 ;Get the data we want!
   367 00000C09 6681C20400          <1>     add dx, 4
   368 00000C0E ED                  <1>     in eax, dx              ;Bring the value of BAR4 into eax, to add to BASE
   369 00000C0F 25FCFFFFFF          <1>     and eax, 0FFFFFFFCh         ;Refine the IO address that we got
   370 00000C14 6689C2              <1>     mov dx, ax                  ;Mov the base IO address into dx
   371                              <1> ;dx contains the base io address!
   372 00000C17 66B80200            <1>     mov ax, 0002h               ;Reset the HC
   373 00000C1B 66EF                <1>     out dx, ax
   374 00000C1D 51                  <1>     push rcx
   375                              <1> .cu0:
   376 00000C1E 4831C9              <1>     xor rcx, rcx
   377 00000C21 FEC9                <1>     dec cl
   378                              <1> .cu1:
   379 00000C23 E2FE                <1>     loop .cu1    ;wait
   380                              <1> 
   381 00000C25 66ED                <1>     in ax, dx    ;Bring value in
   382 00000C27 66250200            <1>     and ax, 0002h
   383 00000C2B 75F1                <1>     jnz .cu0     ;Reset still in progress, loop again
   384 00000C2D 59                  <1>     pop rcx
   385                              <1> 
   386 00000C2E 6631C0              <1>     xor ax, ax
   387 00000C31 6681C20400          <1>     add dx, 4   ;point to USBINTR
   388 00000C36 66EF                <1>     out dx, ax
   389 00000C38 6681EA0400          <1>     sub dx, 4   ;return to cmd
   390 00000C3D 66EF                <1>     out dx, ax  ;zero everything.
   391                              <1> 
   392 00000C3F 58                  <1>     pop rax     ;Get BASE (dereferenced BAR0) value back (stack align)
   393 00000C40 E9A3FCFFFF          <1>     jmp .u11                     ;return
   394                              <1> ;End UHCI
   395                              <1> 
   396                              <1> .controlxHCI:
   397                              <1> ;mov HCCPARAMS1 into edx, eax contains BASE pointer from BAR0 (offset 10h for 
   398                              <1> ; register)
   399 00000C45 678B5010            <1>     mov edx, dword [eax + 10h]    
   400 00000C49 81E20000FFFF        <1>     and edx, 0FFFF0000h
   401                              <1> ;mov hi word into lo word and shl by 2 to adjust that we are in units of DWORDS
   402 00000C4F C1EA0E              <1>     shr edx, 0Eh            
   403 00000C52 01D0                <1>     add eax, edx            ;add offset from base onto base
   404                              <1>                             ;eax now pointing at USBLEGSUP
   405                              <1> .suohoc0: 
   406 00000C54 678B10              <1>     mov edx, dword [eax]    ;store upper byte of USBLEGSUP into dl
   407 00000C57 81CA00000001        <1>     or edx, (1<<24)         ;Set the HCOSSEM Semaphore
   408 00000C5D 678910              <1>     mov dword [eax], edx    ;replace the upper byte with HCOSSEM set
   409                              <1> 
   410 00000C60 51                  <1>     push rcx                ;push poll counter
   411 00000C61 4831C9              <1>     xor rcx, rcx            
   412                              <1> .suohoc1:    ;Remove control from BIOS and check for confirmation
   413 00000C64 66FFC9              <1>     dec cx                  ;drop counter by one
   414 00000C67 0F84DE000000        <1>     jz .weirdEHCI1          ;temporary label
   415 00000C6D F390                <1>     pause                   ;wait
   416 00000C6F 678B10              <1>     mov edx, dword [eax]    ;Check if owned by BIOS
   417 00000C72 81E200000100        <1>     and edx, (1<<16)
   418 00000C78 75EA                <1>     jnz .suohoc1            ;not zero, keep polling
   419                              <1> 
   420 00000C7A 66B9FFFF            <1>     mov cx, 0FFFFh
   421                              <1> .suohoc2:    ;Check if control to OS has been given
   422 00000C7E 66FFC9              <1>     dec cx
   423 00000C81 740D                <1>     jz .suohoc21            ;timeout, assume it has.
   424 00000C83 F390                <1>     pause                
   425 00000C85 678B10              <1>     mov edx, dword [eax]
   426 00000C88 81E200000001        <1>     and edx, (1<<24)
   427 00000C8E 74EE                <1>     jz .suohoc2             ;if zero, keep polling until bit set => owned by OS
   428                              <1> .suohoc21:    ;Check for legsup being present, assume for now.
   429 00000C90 59                  <1>     pop rcx                   ;return poll counter
   430                              <1> .suohoc3:
   431 00000C91 67C7400400000000    <1>     mov dword [eax + 4], 0    ;Set all SMI bytes to 0 so no SMIs will be set.
   432 00000C99 58                  <1>     pop rax                   ;Bring back BAR0 into eax
   433 00000C9A E949FCFFFF          <1>     jmp .u11                  ;return
   434                              <1> 
   435                              <1> .controlEHCI:
   436 00000C9F 678B5008            <1>     mov edx, dword [eax + 8h]
   437 00000CA3 81E200FF0000        <1>     and edx, 0000FF00h
   438 00000CA9 66C1EA08            <1>     shr dx, 8
   439 00000CAD 81FA40000000        <1>     cmp edx, 40h        
   440 00000CB3 7C05                <1>     jl .ce0            ;No EECP pointer present, skip BIOS/OS EHCI handover
   441 00000CB5 E81B000000          <1>     call .ehcieecpsetup
   442                              <1> .ce0:
   443 00000CBA 31D2                <1>     xor edx, edx       ;clear edx
   444 00000CBC 58                  <1>     pop rax            ;Bring back refined base into eax
   445 00000CBD 678B10              <1>     mov edx, dword [eax]
   446 00000CC0 81E2FF000000        <1>     and edx, 000000FFh
   447 00000CC6 01D0                <1>     add eax, edx
   448 00000CC8 67816040FEFFFFFF    <1>     and dword [eax + 40h], 0FFFFFFFEh
   449                              <1>                             ;located at offset 40 of the opregs.
   450                              <1> 
   451 00000CD0 E913FCFFFF          <1>     jmp .u11                ;return
   452                              <1> .ehcieecpsetup:
   453                              <1> ;eax has hccparams
   454                              <1> ;ebx has pci register, to get class code
   455 00000CD5 50                  <1>     push rax
   456 00000CD6 52                  <1>     push rdx
   457 00000CD7 53                  <1>     push rbx
   458 00000CD8 51                  <1>     push rcx
   459 00000CD9 88D3                <1>     mov bl, dl       ;Move EECP pointer into low byte of PCI address
   460 00000CDB 89D8                <1>     mov eax, ebx     ;Move this address to eax
   461 00000CDD 66BAF80C            <1>     mov dx, pci_index
   462 00000CE1 EF                  <1>     out dx, eax      ;Return EHCI EECP register
   463 00000CE2 66BAFC0C            <1>     mov dx, pci_data
   464 00000CE6 ED                  <1>     in eax, dx       ;Get this register into eax
   465 00000CE7 0D00000001          <1>     or eax, 1000000h ;Set bit 24, to tell bios to give up control!
   466 00000CEC 93                  <1>     xchg eax, ebx    ;Swap these two temporarily
   467 00000CED 66BAF80C            <1>     mov dx, pci_index
   468 00000CF1 EF                  <1>     out dx, eax
   469 00000CF2 93                  <1>     xchg eax, ebx    ;Bring back out value to eax
   470 00000CF3 66BAFC0C            <1>     mov dx, pci_data
   471 00000CF7 EF                  <1>     out dx, eax      ;Tell BIOS who is boss of the EHCI controller
   472                              <1>     
   473 00000CF8 4831C9              <1>     xor rcx, rcx
   474 00000CFB 89D8                <1>     mov eax, ebx     ;Get address back into eax
   475                              <1> .ees1:
   476 00000CFD 66FFC9              <1>     dec cx
   477 00000D00 7449                <1>     jz .weirdEHCI1
   478 00000D02 E680                <1>     out waitp, al    ;Wait a bit, for device to process request
   479                              <1> 
   480 00000D04 66BAF80C            <1>     mov dx, pci_index
   481 00000D08 EF                  <1>     out dx, eax
   482 00000D09 66BAFC0C            <1>     mov dx, pci_data
   483 00000D0D ED                  <1>     in eax, dx       ;Get word back into eax
   484 00000D0E 2500000100          <1>     and eax, 10000h  ;BIOS should set this bit to zero
   485 00000D13 75E8                <1>     jnz .ees1        ;Not zero yet, try again!
   486                              <1> 
   487 00000D15 4831C9              <1>     xor rcx, rcx
   488 00000D18 89D8                <1>     mov eax, ebx    ;Get address back into eax    
   489                              <1> .ees2:
   490 00000D1A 66FFC9              <1>     dec cx
   491 00000D1D 742C                <1>     jz .weirdEHCI1
   492 00000D1F E680                <1>     out waitp, al    ;Wait a bit, for device to process request
   493                              <1> 
   494 00000D21 66BAF80C            <1>     mov dx, pci_index
   495 00000D25 EF                  <1>     out dx, eax
   496 00000D26 66BAFC0C            <1>     mov dx, pci_data
   497 00000D2A ED                  <1>     in eax, dx        ;Get word back into eax
   498 00000D2B 2500000001          <1>     and eax, 1000000h    ;This should set this bit to one now (OS control)
   499 00000D30 74E8                <1>     jz .ees2        ;Not set yet, try again!
   500                              <1> ;Now we have control! :D Finally, now lets clear SMI bits
   501 00000D32 81C304000000        <1>     add ebx, 4h
   502 00000D38 89D8                <1>     mov eax, ebx
   503 00000D3A 66BAF80C            <1>     mov dx, pci_index
   504 00000D3E EF                  <1>     out dx, eax
   505 00000D3F 31C0                <1>     xor eax, eax
   506 00000D41 66BAFC0C            <1>     mov dx, pci_data
   507 00000D45 EF                  <1>     out dx, eax        ;NO MORE SMI INTERRUPTS
   508                              <1> 
   509 00000D46 59                  <1>     pop rcx
   510 00000D47 5B                  <1>     pop rbx
   511 00000D48 5A                  <1>     pop rdx
   512 00000D49 58                  <1>     pop rax
   513 00000D4A C3                  <1>     ret
   514                              <1> 
   515                              <1> .weirdEHCI1:
   516 00000D4B 48B804130000000000- <1>     mov rax, 1304h
   516 00000D54 00                  <1>
   517 00000D55 48BB07000000000000- <1>     mov rbx, 0007h
   517 00000D5E 00                  <1>
   518 00000D5F 48B931000000000000- <1>     mov rcx, failmsglen
   518 00000D68 00                  <1>
   519 00000D69 48BD-               <1>     mov rbp, .failmsg
   519 00000D6B [780D000000000000]  <1>
   520 00000D73 CD30                <1>     int 30h    ; write strng
   521 00000D75 F390                <1>     pause
   522 00000D77 F4                  <1>     hlt
   523 00000D78 0A0D78484349206F72- <1> .failmsg: db 0Ah,0Dh,"xHCI or EHCI controller fail, halting system", 0Ah, 0Dh, 0
   523 00000D81 204548434920636F6E- <1>
   523 00000D8A 74726F6C6C65722066- <1>
   523 00000D93 61696C2C2068616C74- <1>
   523 00000D9C 696E67207379737465- <1>
   523 00000DA5 6D0A0D00            <1>
   524                              <1> failmsglen    equ    $ - .failmsg
   525                              <1> 
   526                              <1> pciExit:
   527                              <1> ;----------------------------------------------------------------
   528                              <1> ;                            End Proc                           :
   529                              <1> ;----------------------------------------------------------------
    55                                  %include "./Source/Init/Hardware/Timers/pitinit.asm"
    56                              <1> ;----------------------------------------------------------------
    57                              <1> ;                PIT Initialisation procedure                   :
    58                              <1> ;----------------------------------------------------------------
    59                              <1> PITreset:       ;Set Timer 0 to trigger every 55ms
    60 00000DA9 B036                <1>     mov al, 36h    ;Set bitmap for frequency write to channel 0 of pit
    61 00000DAB E643                <1>     out PITcommand, al    ;43h = PIT command register
    62 00000DAD 668B0425[35010000]  <1>     mov ax, word [pit_divisor]
    63 00000DB5 E640                <1>     out PIT0, al    ;mov low byte into divisor register
    64 00000DB7 88E0                <1>     mov al, ah      ;bring hi byte into low byte
    65 00000DB9 E640                <1>     out PIT0, al    ;mov hi byte into divisor register
    66                              <1> ;PIT unmasked below
    67                              <1> ;----------------------------------------------------------------
    68                              <1> ;                     End of Initialisation                     :
    69                              <1> ;----------------------------------------------------------------
    56                                  %include "./Source/Init/Hardware/Timers/rtcinit.asm"
    57                              <1> ;----------------------------------------------------------------
    58                              <1> ;                RTC Initialisation procedure                   :
    59                              <1> ;----------------------------------------------------------------
    60                              <1> rtc_init:
    61                              <1> ;Set tick rate to 1024Hz and ensure RTC doesnt generate IRQ8
    62 00000DBB 66B88A8A            <1>     mov ax, 8A8Ah    ;Status A register with NMI disable
    63 00000DBF E670                <1>     out cmos_base, al
    64 00000DC1 E680                <1>     out waitp, al    ;Latch wait
    65 00000DC3 EB00                <1>     jmp short $+2
    66 00000DC5 B026                <1>     mov al, 00100110b ;32KHz timebase, 1024Hz square wave output
    67 00000DC7 E671                <1>     out cmos_data, al
    68                              <1> ;Now ensure NO interrupts are cooked
    69 00000DC9 FEC4                <1>     inc ah    ;ah=8Bh
    70 00000DCB 88E0                <1>     mov al, ah
    71 00000DCD E670                <1>     out cmos_base, al
    72 00000DCF E680                <1>     out waitp, al  ;Latch wait
    73 00000DD1 EB00                <1>     jmp short $+2
    74 00000DD3 B002                <1>     mov al, 02h    ;Zero all int bits, time: BCD, 24hr, Daylight saving off
    75 00000DD5 E671                <1>     out cmos_data, al
    76                              <1> ;Clear any cooked IRQs
    77 00000DD7 FEC4                <1>     inc ah    ;ah=8Ch
    78 00000DD9 88E0                <1>     mov al, ah
    79 00000DDB E670                <1>     out cmos_base, al
    80 00000DDD E680                <1>     out waitp, al    ;Latch wait
    81 00000DDF EB00                <1>     jmp short $+2
    82 00000DE1 E471                <1>     in al, cmos_data
    83                              <1> ;Get final CMOS RAM status byte
    84 00000DE3 B00D                <1>     mov al, 0Dh     ;Status D register with NMI enable
    85 00000DE5 E670                <1>     out cmos_base, al
    86 00000DE7 E680                <1>     out waitp, al    ;Latch wait
    87 00000DE9 EB00                <1>     jmp short $+2
    88 00000DEB E471                <1>     in al, cmos_data
    89                              <1> ;Unmask RTC and PIT here!
    90 00000DED E4A1                <1>     in al, pic2data    ;Get current state
    91 00000DEF 24FE                <1>     and al, 0FEh    ;Unmask RTC
    92 00000DF1 E6A1                <1>     out pic2data, al
    93 00000DF3 E421                <1>     in al, pic1data
    94 00000DF5 24FA                <1>     and al, 0FAh    ;Unmask PIT and Cascade
    95 00000DF7 E621                <1>     out pic1data, al
    96 00000DF9 FB                  <1>     sti             ;Enable maskable interrupts
    97                              <1> ;----------------------------------------------------------------
    98                              <1> ;                     End of Initialisation                     :
    99                              <1> ;----------------------------------------------------------------
    57                                  %include "./Source/Init/Hardware/Timers/beepOK.asm"
    58                              <1>     ;This is a short routine to just confirm 
    59                              <1>     ;that the timer initialisation worked fine
    60 00000DFA 48B9C8000000000000- <1>     mov rcx, 200    ;Beep for a 200ms
    60 00000E03 00                  <1>
    61 00000E04 BBA9040000          <1>     mov ebx, 04A9h  ;Frequency divisor for 1000Hz tone
    62 00000E09 66B800C5            <1>     mov ax, 0C500h
    63 00000E0D CD35                <1>     int 35h
    58                                  %include "./Source/Init/Hardware/Serial/rs232ini.asm"
    59                              <1> ;----------------------------------------------------------------
    60                              <1> ;                Serial Port Initialisation procedure           :
    61                              <1> ;----------------------------------------------------------------
    62                              <1> ;Initial init procedure, check which ports exist and 
    63                              <1> ; write the address to Data area
    64 00000E0F 66B85A5A            <1>     mov ax, 5A5Ah
    65 00000E13 4831C9              <1>     xor rcx, rcx
    66 00000E16 48BD-               <1>     mov rbp, com_addresses
    66 00000E18 [6700000000000000]  <1>
    67                              <1> checkCOM:
    68 00000E20 668B9409[6B1D0000]  <1>     mov dx, word [serial_abt + rcx*2]    ;Multiplied by 2 for word offsets
    69 00000E28 6681C20700          <1>     add dx, 7    ;Scratch register
    70 00000E2D EE                  <1>     out dx, al    ;Output
    71 00000E2E EB00                <1>     jmp short $ + 2
    72 00000E30 EC                  <1>     in al, dx    ;Read the value
    73 00000E31 38C4                <1>     cmp ah, al   ;Check if theyre the same 
    74 00000E33 7514                <1>     jne COMinitproceed ;Scratch register non-existant, IO registers not present
    75 00000E35 6681EA0700          <1>     sub dx, 7    ;point dx back to base
    76 00000E3A 66899409[67000000]  <1>     mov word [com_addresses + rcx*2], dx    ;Save dx into data area table
    77 00000E42 FEC1                <1>     inc cl
    78 00000E44 80F904              <1>     cmp cl, 4
    79 00000E47 75D7                <1>     jne checkCOM    ;Keep looping
    80                              <1> COMinitproceed:
    81                              <1> ;Sets all active COM ports to 2400,N,8,1, FIFO on, hware handshaking
    82 00000E49 880C25[66000000]    <1>     mov byte [numCOM], cl
    83 00000E50 30C9                <1>     xor cl, cl
    84                              <1> serialinit:
    85 00000E52 668B9409[67000000]  <1>     mov dx, word [com_addresses + rcx*2]  ;get the serial port base addr in dx
    86 00000E5A 6685D2              <1>     test dx, dx
    87 00000E5D 743E                <1>     jz COMinitexit    ;invalid address, port doesnt exist, init complete
    88                              <1> ;Disable interrupts
    89 00000E5F 66FFC2              <1>     inc dx        ;point at base + 1
    90 00000E62 30C0                <1>     xor al, al    ;get zero to out it to the interrupt register
    91 00000E64 EE                  <1>     out dx, al    ;Disable all interrupts
    92                              <1> ;Set DLAB
    93 00000E65 6681C20200          <1>     add dx, 2    ;point dx to the Line Control register (LCR)
    94 00000E6A EC                  <1>     in al, dx    ;get the LCR byte into al
    95 00000E6B 0C80                <1>     or al, 10000000b    ;set bit 7, DLAB bit on
    96 00000E6D EE                  <1>     out dx, al    ;output the set bit
    97                              <1> ;Set baud rate
    98 00000E6E 6681EA0300          <1>     sub dx, 3    ;word of baud divisor
    99 00000E73 66B83000            <1>     mov ax, 0030h    ;the divisor for 2400 baud (cf table below)
   100 00000E77 66EF                <1>     out dx, ax    ;out put the divisor word
   101                              <1> ;Clear DLAB, set the parity, break stop and word length
   102 00000E79 6681C20300          <1>     add dx, 3    ;repoint at LCR (base + 3)
   103 00000E7E B003                <1>     mov al, 00000011b  ;DLAB off, 8,n,1, no break, no stick
   104 00000E80 EE                  <1>     out dx, al    ;out that byte
   105                              <1> ;Clear FIFO
   106 00000E81 66FFCA              <1>     dec dx        ;base + 2, FIFO register
   107 00000E84 B006                <1>     mov al, 00000110b    ;Clear FIFO, set char mode
   108 00000E86 EE                  <1>     out dx, al    ;out that stuff
   109                              <1> ;Enable interrupts and RTS/DTR
   110 00000E87 66FFCA              <1>     dec dx        ;base + 1, Interrupt Enable Register
   111 00000E8A B001                <1>     mov al, 1     ;ONLY set the data receive interrupt, none of the other 
   112                              <1>                   ; status or transmit type interrupts
   113 00000E8C EE                  <1>     out dx, al
   114                              <1> 
   115 00000E8D 6681C20300          <1>     add dx, 3    ;base + 4, Modem control register
   116 00000E92 EC                  <1>     in al, dx    ;preserve reserved upper bits
   117 00000E93 24E0                <1>     and al, 11100000b
   118 00000E95 0C0B                <1>     or al, 00001011b    ;Set OUT2 (ie IRQ enable), set RTS/DTR.
   119 00000E97 EE                  <1>     out dx, al
   120 00000E98 66FFC1              <1>     inc cx
   121 00000E9B EBB5                <1>     jmp short serialinit
   122                              <1> COMinitexit:
   123                              <1> ;Unmask com ports here!
   124 00000E9D E421                <1>     in al, pic1data
   125 00000E9F 24E7                <1>     and al, 0E7h    ;Unmask Com lines 1 and 2 (bits 3 and 4)
   126 00000EA1 E621                <1>     out pic1data, al
   127                              <1> ;----------------------------------------------------------------
   128                              <1> ;                     End of Initialisation                     :
   129                              <1> ;----------------------------------------------------------------
    59                                  %include "./Source/Init/Hardware/PS2/ps2init.asm"
    60                              <1> ;----------------------------------------------------------------
    61                              <1> ;             PS/2 Keyboard Initialisation procedure            :
    62                              <1> ;----------------------------------------------------------------
    63                              <1> keybsetup:    ;proc near
    64 00000EA3 66B80A0E            <1>     mov ax, 0E0Ah
    65 00000EA7 CD30                <1>     int 30h
    66 00000EA9 66B80D0E            <1>     mov ax, 0E0Dh
    67 00000EAD CD30                <1>     int 30h    ;Send a crlf to con
    68                              <1> 
    69 00000EAF 66B80413            <1>     mov ax, 1304h
    70 00000EB3 30FF                <1>     xor bh, bh
    71 00000EB5 48BD-               <1>     mov rbp, ps2stage.startMsg ;Prompt to strike a key
    71 00000EB7 [E011000000000000]  <1>
    72 00000EBF CD30                <1>     int 30h
    73                              <1> 
    74 00000EC1 B05F                <1>     mov al, 05Fh        ;PS/2 Stage signature
    75 00000EC3 E680                <1>     out waitp, al
    76 00000EC5 E6E9                <1>     out bochsout, al    
    77                              <1> 
    78 00000EC7 4D31C0              <1>     xor r8, r8          ;use as an stage counter 
    79 00000ECA E926000000          <1>     jmp .step1
    80                              <1> .kbscdetermine:
    81 00000ECF B0F0                <1>     mov al, 0F0h    
    82 00000ED1 E8C5020000          <1>     call ps2talk.p3
    83 00000ED6 E8AB020000          <1>     call ps2talk.p1
    84 00000EDB 3CFA                <1>     cmp al, 0FAh        ;ACK?
    85 00000EDD 75F0                <1>     jne .kbscdetermine  ;Not ack, try again
    86                              <1> .pt1:
    87 00000EDF 30C0                <1>     xor al, al
    88 00000EE1 E8B5020000          <1>     call ps2talk.p3
    89 00000EE6 E89B020000          <1>     call ps2talk.p1     ;Get ack into al, 
    90 00000EEB 3CFA                <1>     cmp al, 0FAh
    91 00000EED 75F0                <1>     jne .pt1
    92 00000EEF E892020000          <1>     call ps2talk.p1     ;Get scancode into al
    93 00000EF4 C3                  <1>     ret
    94                              <1> 
    95                              <1> ;----------------------------------------------------------------
    96                              <1> ;Do all writes using ps2talk:
    97                              <1> ;    ah = 0 - Read Status port into al
    98                              <1> ;    ah = 1 - Read Data port into al
    99                              <1> ;    ah = 2 - Write al into Command port 
   100                              <1> ;    ah = 3 - Write al into Data port
   101                              <1> ;----------------------------------------------------------------
   102                              <1> ; Step 1) Disable ps2 port 1 using command word ADh and port 2 using command 
   103                              <1> ;  word A7h.
   104                              <1> ; Step 2) Flush buffer and check bit 2 is set (else fail)
   105                              <1> ; Step 3) Read controller configuration byte (command word 20h)
   106                              <1> ; Step 4) Disable IRQs bits 0,1 (clear bit 0,1) [and manually disable second 
   107                              <1> ;  ps2 port (bit 5 set)]
   108                              <1> ; Step 5) Write controller config byte back (command word 60h)
   109                              <1> ; Step 6) Test controller using AAh command word. Return 55h or fail.
   110                              <1> ; Step 7) Test ps2 port 1 using ABh command word. Return 00h or fail.
   111                              <1> ; Step 8) Enable ps2 port 1 using AEh command word. Enable IRQ by setting bit 0 
   112                              <1> ;  of the config byte.
   113                              <1> ; Step 9) Reset ps2 port 1 device using FFh data word. If AAh returned, 
   114                              <1> ;  proceed, else if ACK (FAh), await AAh. FCh and FDh indicate fail. FEh = 
   115                              <1> ;  resend command.
   116                              <1> ; Step 10) Reset scan code set to 1 using F0h data word with 01h data word. If 
   117                              <1> ;  ACK (FAh) proceed, if RESEND (FEh), resend 10h tries.
   118                              <1> ; Setp 11) Enable scanning (ie keyboard sends scan codes) using data word F4h.
   119                              <1> ;----------------------------------------------------------------
   120                              <1> ;Step 1
   121                              <1> .step1:
   122 00000EF5 B0AD                <1>     mov al, 0ADh
   123 00000EF7 E897020000          <1>     call ps2talk.p2
   124 00000EFC B0A7                <1>     mov al, 0A7h        ;Cancel second interface if it exists (DO NOT REENABLE)
   125 00000EFE E890020000          <1>     call ps2talk.p2
   126                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   127 00000F03 49FFC0              <1>     inc r8           ;Checkpoint 1
   128 00000F06 E8CB020000          <1>     call ps2stage    ;print which stage is complete
   129                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   130                              <1> ;Step 2
   131                              <1> 
   132 00000F0B E460                <1>     in al, ps2data     ;manually flush ps2data port
   133                              <1>     
   134                              <1> ;Step 3
   135                              <1> keyb0:
   136 00000F0D B020                <1>     mov al, 20h
   137 00000F0F E87F020000          <1>     call ps2talk.p2    ;out ps2command, al
   138 00000F14 E86D020000          <1>     call ps2talk.p1    ;Read config byte into al
   139                              <1> ;Step 4
   140 00000F19 88C3                <1>     mov bl, al         ;copy al into bl to check for bit 2
   141 00000F1B 80E3BC              <1>     and bl, 10111100b  ;Disable translation, enable later if needed
   142                              <1> ;Step 5
   143 00000F1E B060                <1>     mov al, 60h
   144 00000F20 E86E020000          <1>     call ps2talk.p2    ;Write config byte command
   145 00000F25 88D8                <1>     mov al, bl
   146 00000F27 E86F020000          <1>     call ps2talk.p3    ;Out new config byte
   147                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   148 00000F2C 49FFC0              <1>     inc r8             ;Checkpoint 2
   149 00000F2F E8A2020000          <1>     call ps2stage      ;print which stage is complete
   150                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   151                              <1> ;Step 6
   152 00000F34 B0AA                <1>     mov al, 0AAh ;Can reset the config byte, out bl to ps2data at end of stage
   153 00000F36 E858020000          <1>     call ps2talk.p2
   154 00000F3B E846020000          <1>     call ps2talk.p1
   155 00000F40 3C55                <1>     cmp al, 55h
   156 00000F42 0F855B020000        <1>     jne ps2error
   157                              <1>     
   158 00000F48 B060                <1>     mov al, 60h  ;Previous code may have reset our new config byte, resend it!
   159 00000F4A E844020000          <1>     call ps2talk.p2            ;Write config byte command
   160 00000F4F 88D8                <1>     mov al, bl
   161 00000F51 E845020000          <1>     call ps2talk.p3            ;Out new config byte
   162                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   163 00000F56 49FFC0              <1>     inc r8             ;Checkpoint 3
   164 00000F59 E878020000          <1>     call ps2stage      ;print which stage is complete
   165                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   166                              <1> ;Step 7
   167 00000F5E B0AB                <1>     mov al, 0ABh            ;Test controller 1
   168 00000F60 E82E020000          <1>     call ps2talk.p2
   169 00000F65 E81C020000          <1>     call ps2talk.p1
   170 00000F6A 84C0                <1>     test al, al                ;Check al is zero
   171 00000F6C 0F8531020000        <1>     jnz ps2error
   172                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   173 00000F72 49FFC0              <1>     inc r8             ;Checkpoint 4
   174 00000F75 E85C020000          <1>     call ps2stage      ;print which stage is complete
   175                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   176                              <1> ;Step 8
   177 00000F7A B0AE                <1>     mov al, 0AEh
   178 00000F7C E812020000          <1>     call ps2talk.p2
   179                              <1> 
   180                              <1> ;Set IRQ 1 to connect to port 1
   181 00000F81 B020                <1>     mov al, 20h
   182 00000F83 E80B020000          <1>     call ps2talk.p2        ;Write
   183 00000F88 E8F9010000          <1>     call ps2talk.p1        ;Read
   184 00000F8D 0C01                <1>     or al, 00000001b    ;Set bit 0
   185 00000F8F 24EF                <1>     and al, 11101111b    ;Zero bit 4, First port Clock
   186 00000F91 88C3                <1>     mov bl, al
   187 00000F93 B060                <1>     mov al, 60h
   188 00000F95 E8F9010000          <1>     call ps2talk.p2
   189 00000F9A 88D8                <1>     mov al, bl
   190 00000F9C E8FA010000          <1>     call ps2talk.p3
   191                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   192 00000FA1 49FFC0              <1>     inc r8           ;Checkpoint 5
   193 00000FA4 E82D020000          <1>     call ps2stage    ;print which stage is complete
   194                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   195                              <1> ;Step 9
   196 00000FA9 6631C9              <1>     xor cx, cx
   197                              <1> keyb1:
   198 00000FAC 66FFC9              <1>     dec cx ;timeout counter
   199 00000FAF 0F84EE010000        <1>     jz ps2error
   200 00000FB5 B0FF                <1>     mov al, 0FFh
   201 00000FB7 E8DF010000          <1>     call ps2talk.p3
   202                              <1> .k1:
   203 00000FBC E8C5010000          <1>     call ps2talk.p1 ;read from ps2data
   204 00000FC1 3CAA                <1>     cmp al, 0AAh    ;success
   205 00000FC3 7409                <1>     je keyb20
   206 00000FC5 3CFA                <1>     cmp al, 0FAh    ;ACK    
   207 00000FC7 74F3                <1>     je .k1          ;Loop if ACK recieved, just read ps2data
   208 00000FC9 E9DEFFFFFF          <1>     jmp keyb1       ;Else, loop whole thing (assume fail recieved)
   209                              <1> ;Step 10
   210                              <1> keyb20:
   211                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   212 00000FCE 49FFC0              <1>     inc r8           ;Checkpoint 6
   213 00000FD1 E800020000          <1>     call ps2stage    ;print which stage is complete
   214                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   215 00000FD6 31C9                <1>     xor ecx, ecx
   216                              <1> keyb2:
   217 00000FD8 FFC9                <1>     dec ecx
   218 00000FDA 0F84C3010000        <1>     jz ps2error
   219                              <1> .k0:
   220 00000FE0 B0F0                <1>     mov al, 0F0h
   221 00000FE2 E8B4010000          <1>     call ps2talk.p3
   222                              <1>     
   223 00000FE7 B401                <1>     mov ah, 01h
   224 00000FE9 E898010000          <1>     call ps2talk.p1
   225 00000FEE 3CFE                <1>     cmp al, 0FEh    ;Did we recieve an resend?
   226 00000FF0 74EE                <1>     je .k0          ;Resend the data!
   227 00000FF2 3CFA                <1>     cmp al, 0FAh    ;Compare to Ack?
   228 00000FF4 75E2                <1>     jne keyb2       ;If not equal, dec one from the loop counter and try again
   229                              <1>     
   230 00000FF6 B001                <1>     mov al, 01h     ;write 01 to data port (set scan code set 1)
   231 00000FF8 E89E010000          <1>     call ps2talk.p3
   232                              <1> .k1:
   233 00000FFD E884010000          <1>     call ps2talk.p1    ;read data port for ACK or resend response
   234 00001002 3CFA                <1>     cmp al, 0FAh
   235 00001004 7407                <1>     je keyb30    ;IF ack revieved, scancode set, advance.
   236 00001006 E2F5                <1>     loop .k1     ;Keep polling port
   237 00001008 E9CBFFFFFF          <1>     jmp keyb2
   238                              <1> ;Step 11
   239                              <1> keyb30:
   240                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   241 0000100D 49FFC0              <1>     inc r8           ;Checkpoint 7
   242 00001010 E8C1010000          <1>     call ps2stage    ;print which stage is complete
   243                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   244 00001015 31C9                <1>     xor ecx, ecx
   245                              <1> keyb3:
   246 00001017 66FFC9              <1>     dec cx
   247 0000101A 0F8483010000        <1>     jz ps2error
   248                              <1>     
   249 00001020 B0F4                <1>     mov al, 0F4h
   250 00001022 E874010000          <1>     call ps2talk.p3
   251                              <1> .k1:
   252 00001027 E85A010000          <1>     call ps2talk.p1 ;read data port for ACK or resend response
   253 0000102C 3CFA                <1>     cmp al, 0FAh
   254 0000102E 7407                <1>     je keyb40
   255 00001030 E2F5                <1>     loop .k1        ;Keep polling port
   256 00001032 E9E0FFFFFF          <1>     jmp keyb3       ;Fail, retry the whole process
   257                              <1>     
   258                              <1> ;Step 12
   259                              <1> keyb40:
   260                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   261 00001037 49FFC0              <1>     inc r8           ;Checkpoint 8
   262 0000103A E897010000          <1>     call ps2stage    ;print which stage is complete
   263                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   264                              <1> keyb4:
   265 0000103F B0ED                <1>     mov al, 0EDh     ;Set lights
   266 00001041 E855010000          <1>     call ps2talk.p3
   267 00001046 E83B010000          <1>     call ps2talk.p1  ;get response, remember ps2talk does its own timeout
   268 0000104B 3CFA                <1>     cmp al, 0FAh
   269 0000104D 75F0                <1>     jne keyb4        ;No ack, try again.
   270                              <1> .k1:
   271 0000104F B000                <1>     mov al, 00h        ;Flash lock on and off
   272 00001051 E845010000          <1>     call ps2talk.p3
   273 00001056 E82B010000          <1>     call ps2talk.p1    ;flush, remember ps2talk does its own timeout
   274                              <1>     
   275                              <1> ;End Proc
   276                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   277 0000105B 49FFC0              <1>     inc r8           ;Checkpoint 9
   278 0000105E E873010000          <1>     call ps2stage    ;print which stage is complete
   279                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   280                              <1> 
   281                              <1> keyb5:
   282 00001063 B0EE                <1>     mov al, 0EEh     ;Echo command
   283 00001065 E831010000          <1>     call ps2talk.p3
   284 0000106A 30C0                <1>     xor al, al       ;Zero al to ensure that the result is EEh
   285                              <1> .k1:
   286 0000106C E815010000          <1>     call ps2talk.p1
   287 00001071 3CEE                <1>     cmp al, 0EEh
   288 00001073 7429                <1>     je .k2           ;If equal, continue
   289 00001075 48BD-               <1>     mov rbp, .noecho
   289 00001077 [8B10000000000000]  <1>
   290 0000107F 66B80413            <1>     mov ax, 1304h
   291 00001083 30FF                <1>     xor bh, bh
   292 00001085 CD30                <1>     int 30h
   293 00001087 F390                <1>     pause
   294 00001089 EB13                <1>     jmp short .k2
   295 0000108B 4E6F204563686F2072- <1> .noecho:        db    "No Echo recieved", 0Ah, 0Dh, 0
   295 00001094 656369657665640A0D- <1>
   295 0000109D 00                  <1>
   296                              <1> .k2:
   297                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   298 0000109E 49FFC0              <1>     inc r8           ;Checkpoint 0Ah
   299 000010A1 E830010000          <1>     call ps2stage    ;print which stage is complete
   300                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   301                              <1> keyb6:    ;Set typematic rate/delay, 250ms, 30 reports/second
   302 000010A6 B0F3                <1>     mov al, 0F3h     ;Set typematic rate
   303 000010A8 E8EE000000          <1>     call ps2talk.p3
   304 000010AD 30C0                <1>     xor al, al       ;Set rate
   305 000010AF E8E7000000          <1>     call ps2talk.p3
   306 000010B4 6631C9              <1>     xor cx, cx
   307                              <1> .k1:
   308 000010B7 66FFC9              <1>     dec cx
   309 000010BA 0F84E3000000        <1>     jz ps2error
   310 000010C0 E8C1000000          <1>     call ps2talk.p1
   311 000010C5 3CFA                <1>     cmp al, 0FAh    ;Ack?
   312 000010C7 75EE                <1>     jnz .k1
   313                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   314 000010C9 49FFC0              <1>     inc r8           ;Checkpoint 0Bh
   315 000010CC E805010000          <1>     call ps2stage    ;print which stage is complete
   316                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   317                              <1> scancode_faff:
   318 000010D1 B020                <1>     mov al, 20h      ;Get command byte from command port
   319 000010D3 E8BB000000          <1>     call ps2talk.p2  ;al should contain command byte
   320 000010D8 88C4                <1>     mov ah, al       ;temp save cmd byte in ah
   321                              <1> 
   322 000010DA 31C9                <1>     xor ecx, ecx
   323                              <1> .p1:
   324 000010DC 66FFC9              <1>     dec cx
   325 000010DF 7439                <1>     jz keybflushe
   326 000010E1 E8E9FDFFFF          <1>     call keybsetup.kbscdetermine ;Get the current scancode set id
   327 000010E6 80CC01              <1>     or ah, 00000001b    ;Do basic or, ie set IRQ for port 1
   328                              <1> 
   329                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   330 000010E9 49FFC0              <1>     inc r8           ;Checkpoint 0Ch
   331 000010EC E8E5000000          <1>     call ps2stage    ;print which stage is complete
   332                              <1> ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
   333                              <1> 
   334 000010F1 3C43                <1>     cmp al, 43h      ;43h is sc1 signature
   335 000010F3 740B                <1>     je .writeback
   336 000010F5 3C01                <1>     cmp al, 01h      ;Untranslated value
   337 000010F7 7407                <1>     je .writeback
   338 000010F9 3CFA                <1>     cmp al, 0FAh     ;Got an ACK for some reason, manually get next byte
   339 000010FB 7416                <1>     je .get_next_byte
   340                              <1> 
   341 000010FD 80CC40              <1>     or ah, 01000000b    ;Neither value passed the test, invoke translation
   342                              <1> .writeback:
   343 00001100 4989C7              <1>     mov r15, rax     ;Save the scancode value to print later
   344 00001103 B060                <1>     mov al, 60h
   345 00001105 E889000000          <1>     call ps2talk.p2
   346 0000110A 88E0                <1>     mov al, ah       ;return command byte
   347 0000110C E88A000000          <1>     call ps2talk.p3
   348 00001111 EB0B                <1>     jmp short keybflush
   349                              <1> .get_next_byte:
   350 00001113 E86E000000          <1>     call ps2talk.p1  ;Get the byte safely into al!
   351 00001118 EBC2                <1>     jmp short .p1    ;Recheck the scancode signature
   352                              <1> 
   353                              <1> keybflushe:
   354 0000111A 4180CFF0            <1>     or r15b,0F0h    ;Add signature to scancode value denoting error
   355                              <1> keybflush:    ;Flush internal ram of random bytes before enabling IRQ1
   356 0000111E 66B91000            <1>     mov cx, 10h
   357                              <1> .kbf1:
   358 00001122 66FFC9              <1>     dec cx
   359 00001125 7404                <1>     jz keybinitend
   360 00001127 E460                <1>     in al, ps2data        ;Read 16 bytes out (even if empty) and discard
   361 00001129 EBF7                <1>     jmp short .kbf1
   362                              <1> 
   363                              <1> keybinitend:
   364 0000112B 30FF                <1>     xor bh, bh  ;We are on page 0
   365 0000112D B403                <1>     mov ah, 03h ;Get current cursor row number in dh 
   366 0000112F CD30                <1>     int 30h
   367 00001131 B211                <1>     mov dl, 17  ;End of PS/2 Keyboard message at column 17
   368 00001133 30FF                <1>     xor bh, bh  ;Page 0
   369 00001135 B402                <1>     mov ah, 02h ;Set cursor
   370 00001137 CD30                <1>     int 30h
   371                              <1> 
   372 00001139 52                  <1>     push rdx    ;Save row/column in dx on stack
   373 0000113A B91B000000          <1>     mov ecx, 27 ;27 chars in keystrike message
   374                              <1> .kbe0:
   375 0000113F B8200E0000          <1>     mov eax, 0E20h 
   376 00001144 CD30                <1>     int 30h
   377 00001146 E2F7                <1>     loop .kbe0
   378                              <1> 
   379 00001148 5A                  <1>     pop rdx
   380 00001149 30FF                <1>     xor bh, bh  ;Page 0
   381 0000114B B402                <1>     mov ah, 02h ;Set cursor
   382 0000114D CD30                <1>     int 30h
   383                              <1> 
   384 0000114F 48BD-               <1>     mov rbp, ps2stage.okMsg
   384 00001151 [0F12000000000000]  <1>
   385 00001159 48B804130000000000- <1>     mov rax, 1304h    ;print 0 terminated string
   385 00001162 00                  <1>
   386 00001163 30FF                <1>     xor bh, bh
   387 00001165 CD30                <1>     int 30h
   388                              <1> 
   389                              <1> ;Unmask IRQ1 here
   390 00001167 E421                <1>     in al, pic1data
   391 00001169 24FD                <1>     and al, 0FDh    ;Unmask bit 1
   392 0000116B E621                <1>     out pic1data, al
   393                              <1> 
   394 0000116D E9A0000000          <1>     jmp endPS2Init
   395                              <1> ;Relevant Procs for PS/2 keyboard setup
   396                              <1> ps2talk:
   397                              <1> ;   ah = 0 - Read Status port into al
   398                              <1> ;   ah = 1 - Read Data port into al
   399                              <1> ;   ah = 2 - Write al into Command port 
   400                              <1> ;   ah = 3 - Write al into Data port
   401 00001172 84E4                <1>     test ah, ah
   402 00001174 740D                <1>     jz .p0
   403 00001176 FECC                <1>     dec ah
   404 00001178 740C                <1>     jz .p1
   405 0000117A FECC                <1>     dec ah
   406 0000117C 7415                <1>     jz .p2
   407 0000117E E918000000          <1>     jmp .p3
   408                              <1> .p0:
   409 00001183 E464                <1>     in al, ps2status
   410 00001185 C3                  <1>     ret
   411                              <1> .p1:
   412 00001186 EB00                <1>     jmp short $ + 2
   413 00001188 E464                <1>     in al, ps2status
   414 0000118A A801                <1>     test al, 1    ;Can something be read from KB?
   415 0000118C 74F8                <1>     jz .p1        ;Zero if no. Not zero = read.
   416 0000118E EB00                <1>     jmp short $ + 2
   417 00001190 E460                <1>     in al, ps2data  ;Read it in
   418 00001192 C3                  <1>     ret
   419                              <1> .p2:
   420 00001193 E8(B6000000)        <1>     call ps2wait    ;preserves ax
   421 00001198 E664                <1>     out ps2command, al
   422 0000119A C3                  <1>     ret
   423                              <1> .p3:
   424 0000119B E8(B6000000)        <1>     call ps2wait
   425 000011A0 E660                <1>     out ps2data, al
   426 000011A2 C3                  <1>     ret
   427                              <1> ps2error:
   428 000011A3 48BD-               <1>     mov rbp, .ps2errormsg
   428 000011A5 [B911000000000000]  <1>
   429 000011AD 66B80413            <1>     mov ax, 1304h
   430 000011B1 30FF                <1>     xor bh, bh
   431 000011B3 CD30                <1>     int 30h
   432                              <1> .loop:
   433 000011B5 F390                <1>     pause
   434 000011B7 EBFC                <1>     jmp short .loop
   435 000011B9 0A0D50532F32207374- <1> .ps2errormsg: db 0Ah, 0Dh,"PS/2 stage init error...", 0Ah, 0Dh, 0
   435 000011C2 61676520696E697420- <1>
   435 000011CB 6572726F722E2E2E0A- <1>
   435 000011D4 0D00                <1>
   436                              <1> 
   437                              <1> ps2stage:
   438                              <1> ;Outputs r8b to waitport and Bochs out
   439 000011D6 50                  <1>     push rax
   440 000011D7 4488C0              <1>     mov al, r8b
   441 000011DA E680                <1>     out waitp, al
   442 000011DC E6E9                <1>     out bochsout, al
   443 000011DE 58                  <1>     pop rax
   444 000011DF C3                  <1>     ret
   445 000011E0 0A0D50532F32204B65- <1> .startMsg db 0Ah, 0Dh,'PS/2 Keyboard... Strike a key to continue...',0 
   445 000011E9 79626F6172642E2E2E- <1>
   445 000011F2 20537472696B652061- <1>
   445 000011FB 206B657920746F2063- <1>
   445 00001204 6F6E74696E75652E2E- <1>
   445 0000120D 2E00                <1>
   446 0000120F 4F4B00              <1> .okMsg db 'OK', 0 ;This should go 17 chars in
   447                              <1> endPS2Init:
   448                              <1> ;----------------------------------------------------------------
   449                              <1> ;                      End of Initialisation                    :
   450                              <1> ;----------------------------------------------------------------
    60                                  %include "./Source/Sysdebug/init.asm"
    61                              <1> ;----------------------------------------------------------------
    62                              <1> ;              Debugger Initialisation procedures               :
    63                              <1> ;----------------------------------------------------------------
    64                              <1> debuggerInit:
    65                              <1> ;Int 40h can be used by the Debugger to return to it or if a DOS present, 
    66                              <1> ; to return to DOS.
    67 00001212 48B8-               <1>     mov rax, MCP_int ;The application return point
    67 00001214 [A623000000000000]  <1>
    68 0000121C 48BE40000000000000- <1>     mov rsi, 40h
    68 00001225 00                  <1>
    69 00001226 66BA008F            <1>     mov dx, 8F00h    ;Attribs
    70 0000122A BB08000000          <1>     mov ebx, codedescriptor
    71 0000122F E8(CB000000)        <1>     call idtWriteEntry    
    61                                  ;----------------------------------------------------------------
    62                                  ;              Drive Enum and Initialisation procedures         :
    63                                  ;----------------------------------------------------------------
    64                                  %include "./Source/Init/Hardware/IDE/ideinit.asm"
    65                              <1> 
    66                              <1> IDE:
    67                              <1> .ideInitialisation:
    68                              <1> ;Check primary and secondary bus for master and slave drives
    69                              <1> ; Maximum of 4 "fixed" ATA drives
    70                              <1> ;Due to being in compatibility mode, they respond to 
    71                              <1> ; default addresses.
    72                              <1> ;By default BIOS numbers will be assigned as follows: 
    73                              <1> ;               80h = Ctrlr 1, Master
    74                              <1> ;               81h = Ctrlr 1, Slave
    75                              <1> ;               82h = Ctrlr 2, Master
    76                              <1> ;               83h = Ctrlr 2, Slave
    77                              <1> 
    78                              <1> ;To make algorithm work, set ataXCmdByte to 1
    79 00001234 C60425[AB010000]01  <1>     mov byte [ata0CmdByte], 1
    80 0000123C C60425[AD010000]01  <1>     mov byte [ata1CmdByte], 1
    81                              <1> 
    82                              <1> ;Here, consider resetting drives on both channels
    83                              <1>     ;ATA Channel 0 Master
    84 00001244 488D1C25[7B030000]  <1>     lea rbx, fdiskTable
    85 0000124C B0A0                <1>     mov al, 0A0h
    86 0000124E 88C4                <1>     mov ah, al  ;Save in ah
    87 00001250 BAF0010000          <1>     mov edx, ata0_base
    88 00001255 E8(46350000)        <1>     call ATA.selectDrive    ;Ignore status for master
    89 0000125A 88E0                <1>     mov al, ah  ;Bring back
    90 0000125C 7205                <1>     jc .ii0    ;If Master failed to select, ignore trying to identify it
    91 0000125E E879000000          <1>     call .identifyDrive ;Master ata0
    92                              <1> .ii0:
    93                              <1>     ;ATA Channel 0 Slave
    94 00001263 4881C316000000      <1>     add rbx, fdiskEntry_size
    95 0000126A 0C10                <1>     or al, 10h ;Change from A0h to B0h
    96 0000126C 88C4                <1>     mov ah, al
    97 0000126E E8(46350000)        <1>     call ATA.selectDrive ;Master should set slave status to 0 if non-existent
    98 00001273 7302                <1>     jnc .ii1   ;If slave successfully was selected, skip the next line
    99 00001275 30C0                <1>     xor al, al  ;Mock the "00" response that would be placed on the bus by the master
   100                              <1> .ii1:
   101 00001277 84C0                <1>     test al, al
   102 00001279 88E0                <1>     mov al, ah  ;Bring back
   103 0000127B 7405                <1>     jz .ii2 ;If al was zero, skip slave identification
   104 0000127D E85A000000          <1>     call .identifyDrive  ;Slave ata0
   105                              <1> 
   106                              <1> .ii2:
   107                              <1>     ;ATA Channel 1 Master
   108 00001282 4881C316000000      <1>     add rbx, fdiskEntry_size
   109 00001289 BA70010000          <1>     mov edx, ata1_base
   110 0000128E 24EF                <1>     and al, 0EFh    ;Clear bit 4
   111 00001290 88C4                <1>     mov ah, al  ;Save in ah
   112 00001292 E8(46350000)        <1>     call ATA.selectDrive    ;Ignore status for master
   113 00001297 88E0                <1>     mov al, ah  ;Bring back
   114 00001299 7205                <1>     jc .ii3     ;If Master failed to select, ignore trying to identify it
   115 0000129B E83C000000          <1>     call .identifyDrive ;Master ata1
   116                              <1> .ii3:
   117                              <1>     ;ATA Channel 1 Slave
   118 000012A0 4881C316000000      <1>     add rbx, fdiskEntry_size
   119 000012A7 0C10                <1>     or al, 10h ;Change from A0h to B0h
   120 000012A9 88C4                <1>     mov ah, al
   121 000012AB E8(46350000)        <1>     call ATA.selectDrive ;Master should set slave status to 0 if non-existent
   122 000012B0 7302                <1>     jnc .ii4   ;If slave successfully was selected, skip the next line
   123 000012B2 30C0                <1>     xor al, al  ;Mock the "00" response that would be placed on the bus by the master
   124                              <1> .ii4:
   125 000012B4 84C0                <1>     test al, al
   126 000012B6 88E0                <1>     mov al, ah  ;Bring back
   127 000012B8 7405                <1>     jz .ii5 ;If al was zero, skip slave identification
   128 000012BA E81D000000          <1>     call .identifyDrive ;Slave ata1
   129                              <1> .ii5:
   130                              <1> ;Now return the control of each host to the master drives
   131                              <1> 
   132 000012BF B0A0                <1>     mov al, 0A0h
   133 000012C1 BAF0010000          <1>     mov edx, ata0_base
   134 000012C6 E8(46350000)        <1>     call ATA.selectDrive
   135                              <1> 
   136 000012CB B0A0                <1>     mov al, 0A0h
   137 000012CD BA70010000          <1>     mov edx, ata1_base
   138 000012D2 E8(46350000)        <1>     call ATA.selectDrive
   139                              <1> 
   140 000012D7 E944010000          <1>     jmp .ideInitEnd
   141                              <1> ;===========================
   142                              <1> ;     Callable procs       :
   143                              <1> ;===========================
   144                              <1> .identifyDrive:
   145                              <1> ;Zeros out the sector buffer entries we check
   146                              <1> ; and calls identify device. If it succeeds, it then
   147                              <1> ; proceeds to add the entry to the appropriate position
   148                              <1> ; in the table.
   149                              <1> ;If it fails, doesnt inc the fixed drives number counter
   150                              <1> ;Called with:   dx = ataX base register
   151                              <1> ;               rbx = Points to table entry to write
   152                              <1> ;               al = A0h for master, B0h for slave
   153                              <1> 
   154 000012DC 50                  <1>     push rax
   155 000012DD 52                  <1>     push rdx
   156 000012DE 31C9                <1>     xor ecx, ecx
   157 000012E0 488D3C25[C0030000]  <1>     lea rdi, sectorbuffer
   158                              <1>     ;Clean entries we want to read before hand
   159 000012E8 66894F6C            <1>     mov word [rdi + idCurrCyl], cx     ;Clear current cylinders
   160 000012EC 66894F6E            <1>     mov word [rdi + idCurrHed], cx     ;Clear current heads
   161 000012F0 66894F70            <1>     mov word [rdi + idCurrSecTk], cx   ;Clear current sectors/track
   162 000012F4 66898FA6000000      <1>     mov word [rdi + 83*2], cx          ;Clear LBA48 supported bit word
   163 000012FB 894F78              <1>     mov dword [rdi + idLBASectrs], ecx ;Clear UserAddressableSectors
   164 000012FE 48898FC8000000      <1>     mov qword [rdi + idLBA48Sec], rcx  ;Clear UserAddressableSectors for LBA48
   165 00001305 57                  <1>     push rdi
   166 00001306 E8(E9340000)        <1>     call ATA.identifyDevice
   167 0000130B 5F                  <1>     pop rdi
   168 0000130C 0F82D5000000        <1>     jc .idExit  ;If the carry flag set, the device timed out
   169                              <1>     ;Now get information and build tables here
   170 00001312 C60300              <1>     mov byte [rbx + fdiskEntry.signature], 0    ;Clear signature byte in table
   171 00001315 66895313            <1>     mov word [rbx + fdiskEntry.ioBase], dx      ;Add iobase and masterslave status
   172 00001319 884315              <1>     mov byte [rbx + fdiskEntry.msBit], al       
   173                              <1> ;CHS, none of CHS is allowed to be 0 but may be because obsolete on new drives
   174 0000131C 668B476C            <1>     mov ax, word [rdi + idCurrCyl]
   175 00001320 6685C0              <1>     test ax, ax
   176 00001323 741E                <1>     jz .id0
   177 00001325 66894303            <1>     mov word [rbx + fdiskEntry.wCylinder], ax
   178 00001329 668B476E            <1>     mov ax, word [rdi + idCurrHed]
   179 0000132D 6685C0              <1>     test ax, ax
   180 00001330 7411                <1>     jz .id0
   181 00001332 66894301            <1>     mov word [rbx + fdiskEntry.wHeads], ax
   182 00001336 668B4770            <1>     mov ax, word [rdi + idCurrSecTk]
   183 0000133A 6685C0              <1>     test ax, ax
   184 0000133D 7404                <1>     jz .id0
   185 0000133F 66894305            <1>     mov word [rbx + fdiskEntry.wSecTrc], ax
   186                              <1> .id0:
   187                              <1> ;LBA28
   188 00001343 8B4778              <1>     mov eax, dword [rdi + idLBASectrs]
   189 00001346 85C0                <1>     test eax, eax   ;Is this number 0? Check LBA48 or solely on CHS
   190 00001348 740D                <1>     jz .id1
   191 0000134A A9000000F0          <1>     test eax, 0F0000000h ;Test if we above max LBA 28 number
   192 0000134F 7506                <1>     jnz .id1 ;If above, ignore LBA28
   193 00001351 800B02              <1>     or byte [rbx + fdiskEntry.signature], fdeLBA28 ;Set LBA28 present bit
   194 00001354 894307              <1>     mov dword [rbx + fdiskEntry.lbaMax], eax
   195                              <1> .id1:
   196                              <1> ;LBA48
   197                              <1> ;Check LBA48 bit first
   198 00001357 66F787A60000000004  <1>     test word [rdi + 83*2], 400h    ;If bit 10 set, LBA48 supported
   199 00001360 741A                <1>     jz .id2
   200 00001362 488B87C8000000      <1>     mov rax, qword [rdi + idLBA48Sec]
   201 00001369 480FC8              <1>     bswap rax   ;Bring high word low
   202 0000136C 66A9FFFF            <1>     test ax, 0FFFFh ;Test if high word was set
   203 00001370 480FC8              <1>     bswap rax
   204 00001373 7507                <1>     jnz .id2    ;If above, ignore LBA 48
   205 00001375 4889430B            <1>     mov qword [rbx + fdiskEntry.lbaMax48], rax
   206 00001379 800B04              <1>     or byte [rbx + fdiskEntry.signature], fdeLBA48
   207                              <1> .id2:
   208                              <1> ;Now check if either LBA28 or LBA48 are set or CHS is non-zero
   209 0000137C F60306              <1>     test byte [rbx + fdiskEntry.signature], fdeLBA28 | fdeLBA48
   210 0000137F 755C                <1>     jnz .idDeviceOK ;If either LBA28 or 48 set, confirm device OK!
   211                              <1>     ;We arrive here ONLY IF LBA 28 or LBA 48 not set
   212                              <1>     ; That means drive must be small, so floating bus values in CHS
   213                              <1>     ; cannot be valid.
   214                              <1>     ;Check C/H/S values are all non-zero
   215                              <1>     ;If any are zero, then device not configured for use
   216                              <1>     ;If any values dont make sense (such as 7F7Fh FFFFh) then fail those too
   217 00001381 0FB74303            <1>     movzx eax, word [rbx + fdiskEntry.wCylinder]
   218 00001385 85C0                <1>     test eax, eax
   219 00001387 7434                <1>     jz .id3 ;If zero, dont confirm device
   220 00001389 663DFFFF            <1>     cmp ax, 0FFFFh
   221 0000138D 742E                <1>     je .id3
   222 0000138F 663D7F7F            <1>     cmp ax, 07F7Fh
   223 00001393 7428                <1>     je .id3
   224 00001395 0FB74301            <1>     movzx eax, word [rbx + fdiskEntry.wHeads]
   225 00001399 85C0                <1>     test eax, eax
   226 0000139B 7420                <1>     jz .id3 ;If zero, dont confirm device
   227 0000139D 663DFFFF            <1>     cmp ax, 0FFFFh
   228 000013A1 741A                <1>     je .id3
   229 000013A3 663D7F7F            <1>     cmp ax, 07F7Fh
   230 000013A7 7414                <1>     je .id3
   231 000013A9 0FB74305            <1>     movzx eax, word [rbx + fdiskEntry.wSecTrc]
   232 000013AD 85C0                <1>     test eax, eax
   233 000013AF 740C                <1>     jz .id3
   234 000013B1 663DFFFF            <1>     cmp ax, 0FFFFh
   235 000013B5 7406                <1>     je .id3
   236 000013B7 663D7F7F            <1>     cmp ax, 7F7Fh
   237 000013BB 7520                <1>     jne .idDeviceOK ;Values are probably sane, all ok
   238                              <1> .id3:
   239                              <1> ;Only arrive here if none of CHS, LBA28 or LBA48 were verified as ok
   240                              <1> ;Clean any data that mightve been copied (from Floating Bus reads perhaps)
   241 000013BD 31C0                <1>     xor eax, eax
   242 000013BF 8803                <1>     mov byte [rbx + fdiskEntry.signature], al
   243 000013C1 894307              <1>     mov dword [rbx + fdiskEntry.lbaMax], eax
   244 000013C4 4889430B            <1>     mov qword [rbx + fdiskEntry.lbaMax48], rax
   245 000013C8 66894303            <1>     mov word [rbx + fdiskEntry.wCylinder], ax
   246 000013CC 66894301            <1>     mov word [rbx + fdiskEntry.wHeads], ax
   247 000013D0 66894305            <1>     mov word [rbx + fdiskEntry.wSecTrc], ax
   248 000013D4 66894313            <1>     mov word [rbx + fdiskEntry.ioBase], ax
   249 000013D8 884315              <1>     mov byte [rbx + fdiskEntry.msBit], al
   250 000013DB EB0A                <1>     jmp short .idExit
   251                              <1> .idDeviceOK:
   252 000013DD 800B01              <1>     or byte [rbx + fdiskEntry.signature], fdePresent
   253 000013E0 FE0425[AA010000]    <1>     inc byte [fdiskNum] ;Number of usable fixed disks increased
   254                              <1> .idExit:
   255 000013E7 5A                  <1>     pop rdx
   256 000013E8 58                  <1>     pop rax
   257 000013E9 C3                  <1>     ret
   258                              <1> 
   259                              <1> .addControllerTable:
   260                              <1> ;Adds a PCI IDE controller to the internal data tables, if there is space
   261                              <1> ; If there is no space, returns with carry set.
   262                              <1> ;Input: eax = BAR5 address
   263                              <1> ;       ebx = PCI IO address
   264                              <1> ;Output: CF=NC, all ok, CF=CY, device not added.
   265 000013EA 56                  <1>     push rsi
   266 000013EB 803C25[5A030000]02  <1>     cmp byte [ideNumberOfControllers], 2
   267 000013F3 7428                <1>     je .actfail ;If it is 2, fail
   268 000013F5 FE0425[5A030000]    <1>     inc byte [ideNumberOfControllers]
   269 000013FC 48BE-               <1>     mov rsi, ideControllerTable
   269 000013FE [5B03000000000000]  <1>
   270 00001406 803E00              <1>     cmp byte [rsi], 0   ;Is the first entry empty?
   271 00001409 7407                <1>     jz .act0    ;If yes, write entry
   272 0000140B 4881C610000000      <1>     add rsi, ideTableEntrySize  ;Else, goto second entry space
   273                              <1> .act0:
   274 00001412 891E                <1>     mov dword [rsi], ebx    ;Move first PCI IO addr
   275 00001414 C60600              <1>     mov byte [rsi], 0       ;Zero the register index
   276 00001417 894604              <1>     mov dword [rsi + 4], eax    ;Move next data
   277 0000141A F8                  <1>     clc
   278                              <1> .actexit:
   279 0000141B 5E                  <1>     pop rsi
   280 0000141C C3                  <1>     ret
   281                              <1> .actfail:
   282 0000141D F9                  <1>     stc
   283 0000141E EBFB                <1>     jmp short .actexit
   284                              <1> 
   285                              <1> ;============================
   286                              <1> ;     Exit target label     :
   287                              <1> ;============================
   288                              <1> .ideInitEnd:
    65                                  %include "./Source/Init/Hardware/USB/EHCI/ehciinit.asm"
    66                              <1> ;            ------------USB section below------------
    67                              <1> ;                   ---- PCI table parse ----
    68                              <1> ;Parse the PCI tables for ehci controllers
    69                              <1> hciParse:
    70 00001420 C60425[4B020000]00  <1>     mov byte [numMSD], 0
    71 00001428 4C0FB70C2500E00000  <1>     movzx r9, word [lousbtablesize]
    72 00001431 BE02E00000          <1>     mov esi, lousbtablebase
    73 00001436 BF[15020000]        <1>     mov edi, eControllerList
    74                              <1> .hcip1:
    75 0000143B 6667F7064000        <1>     test word [esi], ehcimask    ;check if we at a ehci mask
    76 00001441 7418                <1>     jz .hcip2   ;If not, skip adding to ehci table
    77                              <1>     ;First catch all clause (temporary for version 1 of BIOS with max 4 
    78                              <1>     ; controllers)
    79 00001443 803C25[14020000]04  <1>     cmp byte [eControllers], 4
    80 0000144B 7430                <1>     je .pr0    ;escape this whole setup proc if at 4 controllers
    81 0000144D 67488B4602          <1>     mov rax, qword [esi + 2]    ;take pci and mmio address into rax
    82 00001452 48AB                <1>     stosq                        ;store into rdi and inc rdi by 8 to next entry
    83 00001454 FE0425[14020000]    <1>     inc byte [eControllers]    ;increase the number of controllers variable
    84                              <1> .hcip2:
    85                              <1> ;Any additional data saving occurs here
    86 0000145B 81C60A000000        <1>     add esi, 10    ;Goto next table entry
    87 00001461 41FEC9              <1>     dec r9b     ;Once all table entries exhausted, fall through
    88 00001464 75D5                <1>     jnz .hcip1
    89                              <1>     
    90                              <1> ;               ---- EHCI controller enumeration ----
    91                              <1> ;Enumerate each ehci ctrlr root hub for valid usb devices (hubs and valid MSD)
    92 00001466 8A0C25[14020000]    <1>     mov cl, byte [eControllers]
    93 0000146D 66B80413            <1>     mov ax, 1304h
    94 00001471 48BD-               <1>     mov rbp, .echiInitMsg
    94 00001473 [F214000000000000]  <1>
    95 0000147B CD30                <1>     int 30h
    96                              <1> .pr0:   ;If ctrlr failure or ports exhausted, ret to here for next ctrlr
    97 0000147D 84C9                <1>     test cl, cl
    98 0000147F 0F8496000000        <1>     jz .noEHCI    ;No EHCI controllers or last controler?
    99 00001485 FEC9                <1>     dec cl    ;Undo the absolute count from above
   100 00001487 88C8                <1>     mov al, cl
   101 00001489 E8(3E3A0000)        <1>     call USB.setupEHCIcontroller
   102 0000148E 72ED                <1>     jc .pr0    ;Continue to next controller
   103 00001490 E8(B93B0000)        <1>     call USB.ehciRunCtrlr       ;Activate online controller
   104 00001495 72E6                <1>     jc .pr0
   105 00001497 E8(1A3C0000)        <1>     call USB.ehciAdjustAsyncSchedCtrlr ;Start schedule and lock ctrlr as online
   106 0000149C 72DF                <1>     jc .pr0
   107 0000149E E8(973C0000)        <1>     call USB.ehciCtrlrGetNumberOfPorts
   108 000014A3 88C2                <1>     mov dl, al      ;Save the number of ports in dl
   109 000014A5 8A3425[47020000]    <1>     mov dh, byte [eActiveCtrlr]    ;Save current active ctrlr in dh
   110 000014AC 4D31D2              <1>     xor r10, r10    ;Host hub 0 [ie Root Hub enum only] (for enum)
   111                              <1> .pr1:
   112 000014AF FECA                <1>     dec dl
   113 000014B1 49BC03000000000000- <1>     mov r12, 3      ;Attempt three times to enumerate
   113 000014BA 00                  <1>
   114                              <1> .pr11:
   115 000014BB E8(33400000)        <1>     call USB.ehciEnumerateRootPort
   116 000014C0 7413                <1>     jz .pr2
   117 000014C2 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h  ;General Controller Failure
   118 000014CA 0F84(033A0000)      <1>     je USB.ehciCriticalErrorWrapper
   119 000014D0 49FFCC              <1>     dec r12
   120 000014D3 75E6                <1>     jnz .pr11
   121                              <1> .pr2:
   122 000014D5 84D2                <1>     test dl, dl
   123 000014D7 75D6                <1>     jnz .pr1
   124 000014D9 84C9                <1>     test cl, cl ;Once cl is zero we have gone through all controllers
   125 000014DB 75A0                <1>     jnz .pr0
   126                              <1> 
   127 000014DD B804130000          <1>     mov eax, 1304h
   128 000014E2 48BD-               <1>     mov rbp, remDevInit.ok  ;Reuse the OK from the other proc
   128 000014E4 [F815000000000000]  <1>
   129 000014EC 30FF                <1>     xor bh, bh
   130 000014EE CD30                <1>     int 30h
   131 000014F0 EB2E                <1>     jmp short .exit
   132 000014F2 0A0D496E697469616C- <1> .echiInitMsg db 0Ah,0Dh,"Initialising USB and EHCI root hubs...",0
   132 000014FB 6973696E6720555342- <1>
   132 00001504 20616E642045484349- <1>
   132 0000150D 20726F6F7420687562- <1>
   132 00001516 732E2E2E00          <1>
   133                              <1> .noEHCI:
   134                              <1> ;If no EHCI, skip MSD search on EHCI bus. Goto Int 33h init
   135 0000151B E95F010000          <1>     jmp int33hinit.i33iend  ;Could go to int33hinit, but this is minutely faster
   136                              <1> .exit:
    66                                  %include "./Source/Init/Hardware/USB/MSD/msdinit.asm"
    67                              <1> remDevInit:
    68                              <1> ;Devices on root hubs have been enumerated, and added to tables,
    69                              <1> ;Now we reset them (in the case of MSD) and enumerate further (on Hubs)
    70 00001520 66B80413            <1>     mov ax, 1304h
    71 00001524 80F70B              <1>     xor bh, 0bh
    72 00001527 48BD-               <1>     mov rbp, .rmhmsg
    72 00001529 [DC15000000000000]  <1>
    73 00001531 CD30                <1>     int 30h
    74                              <1> .hubs_init:
    75 00001533 48BE-               <1>     mov rsi, hubDevTbl
    75 00001535 [6A02000000000000]  <1>
    76                              <1> ;First we scan for hubs only
    77                              <1> .redi1:
    78 0000153D 803E00              <1>     cmp byte [rsi], 0   ;Not an entry
    79 00001540 7417                <1>     jz .hubnextentry
    80 00001542 807E0500            <1>     cmp byte [rsi + 5], 0   ;If number of ports on hub is 0, dev uncofigured
    81 00001546 7511                <1>     jnz .hubnextentry  ;Device must be already enumerated
    82                              <1> 
    83 00001548 8A4601              <1>     mov al, byte [rsi + 1]  ;Get bus number into al
    84                              <1> 
    85 0000154B E8(1A3C0000)        <1>     call USB.ehciAdjustAsyncSchedCtrlr
    86 00001550 7207                <1>     jc .hubnextentry
    87                              <1> 
    88 00001552 E8(82460000)        <1>     call USB.ehciDevSetupHub  ;Only needs a valid device in rsi
    89 00001557 7200                <1>     jc .hubnextentry
    90                              <1> .hubnextentry:
    91 00001559 4881C608000000      <1>     add rsi, hubDevTblEntrySize ;Goto next table entry
    92 00001560 4881FE[BA020000]    <1>     cmp rsi, hubDevTbl + 10*hubDevTblEntrySize  ;End of table address
    93 00001567 72D4                <1>     jb .redi1  ;We are still in table
    94                              <1> .hub_rescan:
    95                              <1> ;Now we check that all hubs are initialised
    96 00001569 48BE-               <1>     mov rsi, hubDevTbl  ;Return to head of table
    96 0000156B [6A02000000000000]  <1>
    97                              <1> ;Leave as a stub for now. Dont support deeper than 1 level of devices
    98                              <1> ;The specification allows for a maximum of 7 levels of depth.
    99                              <1> .msds_init:
   100 00001573 66B80413            <1>     mov ax, 1304h
   101 00001577 80F70B              <1>     xor bh, 0bh
   102 0000157A 48BD-               <1>     mov rbp, .ok
   102 0000157C [F815000000000000]  <1>
   103 00001584 CD30                <1>     int 30h
   104 00001586 66B80413            <1>     mov ax, 1304h
   105 0000158A 80F70B              <1>     xor bh, 0bh
   106 0000158D 48BD-               <1>     mov rbp, .msdmsg
   106 0000158F [FC15000000000000]  <1>
   107 00001597 CD30                <1>     int 30h
   108 00001599 48BE-               <1>     mov rsi, msdDevTbl
   108 0000159B [BA02000000000000]  <1>
   109                              <1> .msd1:
   110 000015A3 803E00              <1>     cmp byte [rsi], 0   ;Not an entry
   111 000015A6 740F                <1>     jz .msdNextEntry
   112 000015A8 E8(114A0000)        <1>     call USB.ehciMsdInitialise
   113 000015AD 7308                <1>     jnc .msdNextEntry
   114 000015AF FEC8                <1>     dec al
   115 000015B1 0F84(033A0000)      <1>     jz USB.ehciCriticalErrorWrapper ;al = 1 => Host error, 
   116                              <1> ;                                    al = 2 => Bad dev, removed from MSD tables
   117                              <1> .msdNextEntry:
   118 000015B7 4881C610000000      <1>     add rsi, msdDevTblEntrySize ;Goto next entry
   119 000015BE 4881FE[5A030000]    <1>     cmp rsi, msdDevTbl + 10*msdDevTblEntrySize
   120 000015C5 75DC                <1>     jne .msd1
   121                              <1> .rediexit:
   122 000015C7 66B80413            <1>     mov ax, 1304h
   123 000015CB 80F70B              <1>     xor bh, 0bh
   124 000015CE 48BD-               <1>     mov rbp, .ok
   124 000015D0 [F815000000000000]  <1>
   125 000015D8 CD30                <1>     int 30h
   126 000015DA EB3E                <1>     jmp short .exit
   127 000015DC 0A0D496E697469616C- <1> .rmhmsg db 0Ah,0Dh,"Initialising USB ports...",0
   127 000015E5 6973696E6720555342- <1>
   127 000015EE 20706F7274732E2E2E- <1>
   127 000015F7 00                  <1>
   128 000015F8 204F4B00            <1> .ok db " OK",0
   129 000015FC 0A0D496E697469616C- <1> .msdmsg db 0Ah,0Dh,"Initialising MSD devices...",0
   129 00001605 6973696E67204D5344- <1>
   129 0000160E 20646576696365732E- <1>
   129 00001617 2E2E00              <1>
   130                              <1> .exit:
    67                                  %include "./Source/Init/Hardware/MSD/i33init.asm"
    68                              <1> ;----------------------------------------------------------------
    69                              <1> ;                      Int 33h Initialisation                   :
    70                              <1> ;----------------------------------------------------------------    
    71                              <1> int33hinit:
    72                              <1> ;Create Int 33h data table entry for each MSD/floppy device using steps 1-3.
    73                              <1> ;Go through MSD table and add devices to diskDevices
    74 0000161A 48BD-               <1>     mov rbp, usbDevTbl
    74 0000161C [4C02000000000000]  <1>
    75 00001624 48BF-               <1>     mov rdi, diskDevices
    75 00001626 [D303000000000000]  <1>
    76                              <1> .i33i1:
    77 0000162E 807D0208            <1>     cmp byte [rbp + 2], 08h ;MSD USB Class code
    78 00001632 7525                <1>     jne .i33proceed
    79                              <1> ;Successfully found a valid MSD device. Talk to it
    80 00001634 668B4500            <1>     mov ax, word [rbp]  ;Get address/bus pair
    81 00001638 E8(EB440000)        <1>     call USB.ehciGetDevicePtr    ;Get pointer to MSD dev in rsi
    82 0000163D E8(F6190000)        <1>     call disk_io.deviceInit
    83 00001642 3C01                <1>     cmp al, 1   ;Critical error
    84 00001644 0F84(033A0000)      <1>     je USB.ehciCriticalErrorWrapper
    85 0000164A 3C02                <1>     cmp al, 2   ;Device stopped responding, remove from USB data tables
    86 0000164C 7420                <1>     je .i33ibad 
    87 0000164E 3C03                <1>     cmp al, 3   ;Device not added to data tables
    88 00001650 7407                <1>     je .i33proceed
    89                              <1> ;Valid device added, increment rdi to next diskDevices table entry
    90 00001652 4881C710000000      <1>     add rdi, int33TblEntrySize
    91                              <1> .i33proceed:
    92 00001659 4881FD[6A020000]    <1>     cmp rbp, usbDevTblEnd
    93 00001660 741D                <1>     je .i33iend
    94 00001662 4881C503000000      <1>     add rbp, usbDevTblEntrySize
    95 00001669 E9C0FFFFFF          <1>     jmp .i33i1
    96                              <1> .i33ibad:   ;If it goes here, clear table entry
    97 0000166E 48C70700000000      <1>     mov qword [rdi], 0  ;Remove from diskDevice table
    98 00001675 668B06              <1>     mov ax, word [rsi]
    99 00001678 E8(76430000)        <1>     call USB.ehciRemoveDevFromTables    ;Remove from USB tables
   100 0000167D EBDA                <1>     jmp short .i33proceed ;Goto next device
   101                              <1> .i33iend:
   102 0000167F 8A0425[4B020000]    <1>     mov al, byte [numMSD]
   103 00001686 000425[A8010000]    <1>     add byte [i33Devices], al   ;Add the number of MSD devices to Int 33h total
   104 0000168D 8A0425[AA010000]    <1>     mov al, byte [fdiskNum]
   105 00001694 000425[A8010000]    <1>     add byte [i33Devices], al   ;Add the number of Fixed Disks to Int 33h total
    68                                  ;----------------------------------------------------------------
    69                                  ;                         End of Enum                           :
    70                                  ;----------------------------------------------------------------    
    71                                  %include "./Source/Init/InitEnd.asm"
    72                              <1> ;----------------------------------------------------------------
    73                              <1> ;                End of Enum and Initialisation                 :
    74                              <1> ;----------------------------------------------------------------   
    75                              <1> end:
    76                              <1> ;Finally, unmask all IRQ lines for usage
    77 0000169B 30C0                <1>     xor al, al
    78 0000169D E6A1                <1>     out pic2data, al
    79 0000169F E621                <1>     out pic1data, al
    80                              <1> 
    81 000016A1 66B80413            <1>     mov ax, 1304h
    82 000016A5 48BD-               <1>     mov rbp, dbgmsg
    82 000016A7 [2818000000000000]  <1>
    83 000016AF CD30                <1>     int 30h
    84 000016B1 8A0425[4B020000]    <1>     mov al, byte [numMSD]
    85 000016B8 B404                <1>     mov ah, 04h
    86 000016BA CD30                <1>     int 30h
    87                              <1> 
    88 000016BC 66B80413            <1>     mov ax, 1304h
    89 000016C0 48BD-               <1>     mov rbp, dbgmsg4
    89 000016C2 [6018000000000000]  <1>
    90 000016CA CD30                <1>     int 30h
    91 000016CC 8A0425[AA010000]    <1>     mov al, byte [fdiskNum]
    92 000016D3 B404                <1>     mov ah, 04h
    93 000016D5 CD30                <1>     int 30h
    94                              <1> 
    95 000016D7 66B80413            <1>     mov ax, 1304h
    96 000016DB 48BD-               <1>     mov rbp, dbgmsg2
    96 000016DD [3E18000000000000]  <1>
    97 000016E5 CD30                <1>     int 30h
    98 000016E7 8A0425[A8010000]    <1>     mov al, byte [i33Devices]
    99 000016EE B404                <1>     mov ah, 04h
   100 000016F0 CD30                <1>     int 30h
   101                              <1> 
   102 000016F2 66B80413            <1>     mov ax, 1304h
   103 000016F6 48BD-               <1>     mov rbp, dbgmsg3
   103 000016F8 [5218000000000000]  <1>
   104 00001700 CD30                <1>     int 30h
   105 00001702 8A0425[66000000]    <1>     mov al, byte [numCOM]
   106 00001709 B404                <1>     mov ah, 04h
   107 0000170B CD30                <1>     int 30h
   108                              <1> 
   109 0000170D 803C25[A8010000]00  <1>     cmp byte [i33Devices], 0    ;If there are no i33 devices, skip bootstrap
   110 00001715 7402                <1>     jz endNoDevFound
   111                              <1> 
   112 00001717 CD39                <1>     int 39h             ;Bootstrap loader
   113                              <1> endNoDevFound:
   114 00001719 48BD-               <1>     mov rbp, endboot
   114 0000171B [9817000000000000]  <1>
   115 00001723 66B80413            <1>     mov ax, 1304h
   116 00001727 CD30                <1>     int 30h
   117                              <1>     
   118 00001729 6631C0              <1>     xor ax, ax  ;Pause for any key
   119 0000172C CD36                <1>     int 36h
   120                              <1> 
   121 0000172E 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   122 00001732 E8(F7000000)        <1>     call cls
   123                              <1> 
   124 00001737 6631C9              <1>     xor cx, cx
   125 0000173A 6631D2              <1>     xor dx, dx
   126 0000173D B402                <1>     mov ah, 2
   127 0000173F 30FF                <1>     xor bh, bh
   128 00001741 CD30                <1>     int 30h 
   129                              <1> 
   130 00001743 66B80413            <1>     mov ax, 1304h
   131 00001747 48BD-               <1>     mov rbp, endboot2
   131 00001749 [0818000000000000]  <1>
   132 00001751 CD30                <1>     int 30h
   133                              <1> 
   134 00001753 4831C0              <1>     xor rax, rax
   135 00001756 4831DB              <1>     xor rbx, rbx
   136 00001759 4831C9              <1>     xor rcx, rcx
   137 0000175C 4831D2              <1>     xor rdx, rdx
   138 0000175F 4831F6              <1>     xor rsi, rsi
   139 00001762 4831FF              <1>     xor rdi, rdi
   140 00001765 4831ED              <1>     xor rbp, rbp
   141 00001768 4D31C0              <1>     xor r8, r8
   142 0000176B 4D31C9              <1>     xor r9, r9
   143 0000176E 4D31D2              <1>     xor r10, r10
   144 00001771 4D31DB              <1>     xor r11, r11
   145 00001774 4D31E4              <1>     xor r12, r12
   146 00001777 4D31ED              <1>     xor r13, r13
   147 0000177A 4D31F6              <1>     xor r14, r14
   148 0000177D 4D31FF              <1>     xor r15, r15
   149                              <1> 
   150 00001780 CD38                <1>     int 38h
   151                              <1> 
   152                              <1> 
   153 00001782 4C6F6164696E672053- <1> startboot:  db "Loading SCP/BIOS...", 0Ah, 0Dh, 0
   153 0000178B 43502F42494F532E2E- <1>
   153 00001794 2E0A0D00            <1>
   154 00001798 0A0D5343502F42494F- <1> endboot:    db    0Ah,0Dh,"SCP/BIOS system initialisation complete", 0Ah, 0Dh 
   154 000017A1 532073797374656D20- <1>
   154 000017AA 696E697469616C6973- <1>
   154 000017B3 6174696F6E20636F6D- <1>
   154 000017BC 706C6574650A0D      <1>
   155 000017C3 4E6F204F7065726174- <1>         db "No Operating System detected. Strike any key to launch SYSDEBUG."
   155 000017CC 696E67205379737465- <1>
   155 000017D5 6D2064657465637465- <1>
   155 000017DE 642E20537472696B65- <1>
   155 000017E7 20616E79206B657920- <1>
   155 000017F0 746F206C61756E6368- <1>
   155 000017F9 205359534445425547- <1>
   155 00001802 2E                  <1>
   156 00001803 2E2E0A0D00          <1>             db "..",0Ah, 0Dh,0
   157 00001808 5374617274696E6720- <1> endboot2:   db "Starting SCP/BIOS SYSDEBUG...",0Ah,0Dh,0
   157 00001811 5343502F42494F5320- <1>
   157 0000181A 53595344454255472E- <1>
   157 00001823 2E2E0A0D00          <1>
   158 00001828 0A0A0D555342205265- <1> dbgmsg:     db 0Ah,0Ah,0Dh,"USB Rem. Devices: ",0
   158 00001831 6D2E20446576696365- <1>
   158 0000183A 733A2000            <1>
   159 0000183E 0A0D496E7420333368- <1> dbgmsg2:    db 0Ah,0Dh,"Int 33h Devices: ",0
   159 00001847 20446576696365733A- <1>
   159 00001850 2000                <1>
   160 00001852 0A0D434F4D20506F72- <1> dbgmsg3:    db 0Ah,0Dh,"COM Ports: ",0
   160 0000185B 74733A2000          <1>
   161 00001860 0A0D41544120466978- <1> dbgmsg4:    db 0Ah,0Dh,"ATA Fixed Devices: ", 0
   161 00001869 656420446576696365- <1>
   161 00001872 733A2000            <1>
   162                              <1> memprint:
   163                              <1> ;Simple proc to print memory status
   164 00001876 6631DB              <1>     xor bx, bx 
   165 00001879 48BD-               <1>     mov rbp, .convmemmsg
   165 0000187B [CF19000000000000]  <1>
   166 00001883 66B80413            <1>     mov ax, 1304h
   167 00001887 CD30                <1>     int 30h
   168 00001889 CD32                <1>     int 32h    ;Get conv Size
   169 0000188B 25FFFF0000          <1>     and eax, 0FFFFh ;Clear upper bits
   170 00001890 E8F4000000          <1>     call .printdecimalword
   171 00001895 48BD-               <1>     mov rbp, .kb
   171 00001897 [461A000000000000]  <1>
   172 0000189F 66B80413            <1>     mov ax, 1304h
   173 000018A3 CD30                <1>     int 30h
   174                              <1> 
   175 000018A5 66B801E8            <1>     mov ax, 0E801h
   176 000018A9 CD35                <1>     int 35h
   177 000018AB 25FFFF0000          <1>     and eax, 0FFFFh
   178 000018B0 81E3FFFF0000        <1>     and ebx, 0FFFFh
   179 000018B6 81E1FFFF0000        <1>     and ecx, 0FFFFh
   180 000018BC 81E2FFFF0000        <1>     and edx, 0FFFFh
   181 000018C2 53                  <1>     push rbx
   182 000018C3 52                  <1>     push rdx
   183 000018C4 4839C8              <1>     cmp rax, rcx
   184 000018C7 740C                <1>     je .sense1    ;Sensible
   185 000018C9 4885C0              <1>     test rax, rax
   186 000018CC 480F44C1            <1>     cmovz rax, rcx
   187 000018D0 4885C0              <1>     test rax, rax
   188 000018D3 7427                <1>     jz .pt2
   189                              <1> .sense1:
   190 000018D5 50                  <1>     push rax
   191 000018D6 48BD-               <1>     mov rbp, .extmemmsg
   191 000018D8 [EC19000000000000]  <1>
   192 000018E0 66B80413            <1>     mov ax, 1304h
   193 000018E4 CD30                <1>     int 30h
   194 000018E6 58                  <1>     pop rax
   195 000018E7 E89D000000          <1>     call .printdecimalword
   196 000018EC 48BD-               <1>     mov rbp, .kb
   196 000018EE [461A000000000000]  <1>
   197 000018F6 66B80413            <1>     mov ax, 1304h
   198 000018FA CD30                <1>     int 30h
   199                              <1> .pt2:
   200 000018FC 58                  <1>     pop rax
   201 000018FD 59                  <1>     pop rcx
   202 000018FE 4839C8              <1>     cmp rax, rcx
   203 00001901 740C                <1>     je .sense2    ;Sensible
   204 00001903 4885C0              <1>     test rax, rax
   205 00001906 480F44C1            <1>     cmovz rax, rcx
   206 0000190A 4885C0              <1>     test rax, rax
   207 0000190D 742B                <1>     jz .pt3
   208                              <1> .sense2:
   209 0000190F 50                  <1>     push rax
   210 00001910 48BD-               <1>     mov rbp, .extmemmsg2
   210 00001912 [0A1A000000000000]  <1>
   211 0000191A 66B80413            <1>     mov ax, 1304h
   212 0000191E CD30                <1>     int 30h
   213 00001920 58                  <1>     pop rax
   214                              <1> 
   215 00001921 48C1E006            <1>     shl rax, 6    ;Turn 64Kb into Kb
   216 00001925 E85F000000          <1>     call .printdecimalword
   217 0000192A 48BD-               <1>     mov rbp, .kb
   217 0000192C [461A000000000000]  <1>
   218 00001934 66B80413            <1>     mov ax, 1304h
   219 00001938 CD30                <1>     int 30h
   220                              <1> .pt3:   ;Read total free size from big map
   221 0000193A 50                  <1>     push rax
   222 0000193B 48BD-               <1>     mov rbp, .totalmem
   222 0000193D [291A000000000000]  <1>
   223 00001945 B804130000          <1>     mov eax, 1304h
   224 0000194A CD30                <1>     int 30h
   225 0000194C 58                  <1>     pop rax
   226 0000194D 488B0425[E0010000]  <1>     mov rax, qword [sysMem]
   227 00001955 31DB                <1>     xor ebx, ebx
   228 00001957 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]
   229 0000195E 4829D8              <1>     sub rax, rbx
   230 00001961 48C1E80A            <1>     shr rax, 0Ah                ;Get number of Kb's free
   231 00001965 E81F000000          <1>     call .printdecimalword  
   232 0000196A 48BD-               <1>     mov rbp, .kb
   232 0000196C [461A000000000000]  <1>
   233 00001974 66B80413            <1>     mov ax, 1304h
   234 00001978 CD30                <1>     int 30h
   235                              <1> 
   236 0000197A B80A0E0000          <1>     mov eax, 0E0Ah
   237 0000197F CD30                <1>     int 30h
   238 00001981 B80D0E0000          <1>     mov eax, 0E0Dh   ;CR/LF
   239 00001986 CD30                <1>     int 30h
   240                              <1> 
   241 00001988 C3                  <1>     ret
   242                              <1> 
   243                              <1> .printdecimalword:
   244                              <1> ;Takes the qword in rax and prints its decimal representation
   245 00001989 52                  <1>     push rdx
   246 0000198A 51                  <1>     push rcx
   247 0000198B 53                  <1>     push rbx
   248 0000198C 50                  <1>     push rax
   249 0000198D 55                  <1>     push rbp
   250 0000198E 4831C9              <1>     xor rcx, rcx
   251 00001991 6631ED              <1>     xor bp, bp    ;Use bp as #of digits counter
   252 00001994 48BB0A000000000000- <1>     mov rbx, 0Ah  ;Divide by 10
   252 0000199D 00                  <1>
   253                              <1> .pdw0:
   254 0000199E FFC5                <1>     inc ebp
   255 000019A0 48C1E108            <1>     shl rcx, 8    ;Space for next nybble
   256 000019A4 31D2                <1>     xor edx, edx
   257 000019A6 48F7F3              <1>     div rbx
   258 000019A9 80C230              <1>     add dl, '0'
   259 000019AC 80FA39              <1>     cmp dl, '9'
   260 000019AF 7603                <1>     jbe .pdw1
   261 000019B1 80C207              <1>     add dl, 'A'-'0'-10
   262                              <1> .pdw1:
   263 000019B4 88D1                <1>     mov cl, dl    ;Save remainder byte
   264 000019B6 4885C0              <1>     test rax, rax
   265 000019B9 75E3                <1>     jnz .pdw0
   266                              <1> .pdw2:
   267 000019BB 88C8                <1>     mov al, cl    ;Get most sig digit into al
   268 000019BD 48C1E908            <1>     shr rcx, 8    ;Get next digit down
   269 000019C1 B40E                <1>     mov ah, 0Eh
   270 000019C3 CD30                <1>     int 30h
   271 000019C5 FFCD                <1>     dec ebp
   272 000019C7 75F2                <1>     jnz .pdw2
   273                              <1> 
   274 000019C9 5D                  <1>     pop rbp
   275 000019CA 58                  <1>     pop rax
   276 000019CB 5B                  <1>     pop rbx
   277 000019CC 59                  <1>     pop rcx
   278 000019CD 5A                  <1>     pop rdx
   279 000019CE C3                  <1>     ret
   280 000019CF 0A0D4672656520436F- <1> .convmemmsg:        db 0Ah,0Dh,"Free Conventional Memory: ",0
   280 000019D8 6E76656E74696F6E61- <1>
   280 000019E1 6C204D656D6F72793A- <1>
   280 000019EA 2000                <1>
   281 000019EC 0A0D546F74616C204C- <1> .extmemmsg:         db 0Ah,0Dh,"Total Low Extended Memory: ",0    
   281 000019F5 6F7720457874656E64- <1>
   281 000019FE 6564204D656D6F7279- <1>
   281 00001A07 3A2000              <1>
   282 00001A0A 0A0D546F74616C2048- <1> .extmemmsg2:        db 0Ah,0Dh,"Total High Extended Memory: ",0
   282 00001A13 69676820457874656E- <1>
   282 00001A1C 646564204D656D6F72- <1>
   282 00001A25 793A2000            <1>
   283 00001A29 0A0D546F74616C2046- <1> .totalmem:          db 0Ah,0Dh,"Total Free System Memory: ",0
   283 00001A32 726565205379737465- <1>
   283 00001A3B 6D204D656D6F72793A- <1>
   283 00001A44 2000                <1>
   284 00001A46 4B00                <1> .kb:                db "K",0
    72                                  %include "./Source/Init/IntTable.asm"
    73                              <1> ;----------------------Interrupt Tables--------------------------
    74                              <1> IDT_TABLE:
    75                              <1> CPU_IDT:
    76 00001A48 [7753000000000000]  <1>     dq i0
    77 00001A50 [7F53000000000000]  <1>     dq i1
    78 00001A58 [8E53000000000000]  <1>     dq i2
    79 00001A60 [9D53000000000000]  <1>     dq i3
    80 00001A68 [AC53000000000000]  <1>     dq i4
    81 00001A70 [BB53000000000000]  <1>     dq i5
    82 00001A78 [CA53000000000000]  <1>     dq i6
    83 00001A80 [D953000000000000]  <1>     dq i7
    84 00001A88 [E853000000000000]  <1>     dq i8
    85 00001A90 [F753000000000000]  <1>     dq i9
    86 00001A98 [0654000000000000]  <1>     dq i10
    87 00001AA0 [1554000000000000]  <1>     dq i11
    88 00001AA8 [2454000000000000]  <1>     dq i12
    89 00001AB0 [3354000000000000]  <1>     dq i13
    90 00001AB8 [3F54000000000000]  <1>     dq i14
    91 00001AC0 [4B54000000000000]  <1>     dq i15
    92 00001AC8 [5754000000000000]  <1>     dq i16
    93 00001AD0 [6354000000000000]  <1>     dq i17
    94 00001AD8 [6F54000000000000]  <1>     dq i18
    95 00001AE0 [7B54000000000000]  <1>     dq i19
    96 00001AE8 [8754000000000000]  <1>     dq i20
    97 00001AF0 [9354000000000000]  <1>     dq i21
    98 00001AF8 [9657000000000000]- <1>     times 0Ah dq dummy_return_64    ;just return, reserved interrupts!
    98 00001AF8 <rep Ah>            <1>
    99                              <1> HW_IDT:
   100                              <1> ;--------PIC1--------:    ;Int 20h-27h
   101 00001B48 [0F01000000000000]  <1>     dq timer_IRQ0
   102 00001B50 [4F01000000000000]  <1>     dq kb_IRQ1
   103 00001B58 [9057000000000000]  <1>     dq dummy_interrupt.pic1
   104 00001B60 [CF09000000000000]  <1>     dq ser_IRQ3
   105 00001B68 [E109000000000000]  <1>     dq ser_IRQ4
   106 00001B70 [9057000000000000]  <1>     dq dummy_interrupt.pic1
   107 00001B78 [AA0A000000000000]  <1>     dq fdd_IRQ6
   108 00001B80 [7E0B000000000000]  <1>     dq default_IRQ7
   109                              <1> ;--------PIC2--------:    ;Int 28h-2Fh
   110 00001B88 [B20A000000000000]  <1>     dq rtc_IRQ8
   111 00001B90 [8957000000000000]  <1>     dq dummy_interrupt.pic2
   112 00001B98 [8957000000000000]  <1>     dq dummy_interrupt.pic2
   113 00001BA0 [8957000000000000]  <1>     dq dummy_interrupt.pic2
   114 00001BA8 [8957000000000000]  <1>     dq dummy_interrupt.pic2
   115 00001BB0 [8957000000000000]  <1>     dq dummy_interrupt.pic2
   116 00001BB8 [E50A000000000000]  <1>     dq hdd_IRQ14
   117 00001BC0 [9D0B000000000000]  <1>     dq default_IRQ15
   118                              <1> SW_IDT:    ;Int 30h onwards!
   119 00001BC8 [770C000000000000]  <1>     dq scr_io            ;Int 30h, VGA Screen drawing/TTY functions
   120 00001BD0 [0113000000000000]  <1>     dq machineWord_io    ;Int 31h, Give the BIOS hardware bitfield
   121 00001BD8 [3813000000000000]  <1>     dq convRAM_io        ;Int 32h, Give conv memory available
   122 00001BE0 [5B13000000000000]  <1>     dq disk_io           ;Int 33h, Storage device Functions
   123 00001BE8 [731D000000000000]  <1>     dq serial_io         ;Int 34h, Serial Port Functions
   124 00001BF0 [E11E000000000000]  <1>     dq misc_io           ;Int 35h, Misc functions
   125 00001BF8 [8322000000000000]  <1>     dq kb_io             ;Int 36h, Keyboard functions
   126 00001C00 [0523000000000000]  <1>     dq printer_io        ;Int 37h, Reserved [Who uses parallel anymore?]
   127 00001C08 [A623000000000000]  <1>     dq MCP_int           ;Int 38h, launch MCP, and install its "API" handle
   128 00001C10 [AD31000000000000]  <1>     dq bootstrapInt      ;Int 39h, restart the PC using an interrupt
   129 00001C18 [4632000000000000]  <1>     dq timerInt          ;Int 3Ah, Time of day
   130 00001C20 [B134000000000000]  <1>     dq ctrlbreak_io      ;Int 3Bh, user Break
   131 00001C28 [9657000000000000]  <1>     dq dummy_return_64   ;Int 3Ch, user IRQ0 hook
   132 00001C30 [B334000000000000]  <1>     dq scr_params_io     ;Int 3Dh, Screen Mode parameters return function
   133 00001C38 [BF34000000000000]  <1>     dq disk_params_io    ;Int 3Eh, disk parameters return function
   134 00001C40 [D134000000000000]  <1>     dq cga_ret_io        ;Int 3Fh, video extention return function
   135                              <1> IDT_TABLE_Length equ $ - IDT_TABLE
    73                                  seg0len equ ($ - $$)
    74                                  
    75                                  ;----------------------------------------------------------------
    76                                  ;                BIOS RESIDENT CODE AREA STARTS HERE            :
    77                                  ;----------------------------------------------------------------
    78                                  Segment codeResident follows=codeInit vfollows=data align=1 valign=1
    79                                  %include "./Source/Resident/Misc/Procs/common.asm"
    80                              <1> ;A file containing common procs
    81                              <1> 
    82                              <1> ;---------------------------------Procs--------------------------
    83                              <1> e820print:
    84 00000000 56                  <1>     push rsi
    85 00000001 52                  <1>     push rdx
    86 00000002 51                  <1>     push rcx
    87 00000003 53                  <1>     push rbx
    88 00000004 50                  <1>     push rax
    89 00000005 48BE-               <1>     mov rsi, bigmapptr
    89 00000007 [F005000000000000]  <1>
    90 0000000F 480FB61425-         <1>     movzx rdx, byte [bigmapSize]    ;Get the number of 24 byte entries
    90 00000014 [D5010000]          <1>
    91                              <1> .e0:
    92 00000018 48AD                <1>     lodsq
    93 0000001A E82D000000          <1>     call .printqword
    94 0000001F E845000000          <1>     call .printpipe
    95 00000024 48AD                <1>     lodsq
    96 00000026 E821000000          <1>     call .printqword
    97 0000002B E839000000          <1>     call .printpipe
    98 00000030 48AD                <1>     lodsq   
    99 00000032 E815000000          <1>     call .printqword
   100 00000037 E844000000          <1>     call .printcrlf
   101 0000003C 6631C0              <1>     xor ax, ax
   102 0000003F CD36                <1>     int 36h
   103 00000041 48FFCA              <1>     dec rdx
   104 00000044 75D2                <1>     jnz .e0
   105 00000046 58                  <1>     pop rax
   106 00000047 5B                  <1>     pop rbx
   107 00000048 59                  <1>     pop rcx
   108 00000049 5A                  <1>     pop rdx
   109 0000004A 5E                  <1>     pop rsi
   110 0000004B C3                  <1>     ret
   111                              <1> .printqword:
   112 0000004C 4889C3              <1>     mov rbx, rax
   113 0000004F 480FCB              <1>     bswap rbx
   114 00000052 48B908000000000000- <1>     mov rcx, 8
   114 0000005B 00                  <1>
   115                              <1> .pq1:
   116 0000005C 88D8                <1>     mov al, bl
   117 0000005E B404                <1>     mov ah, 04h
   118 00000060 CD30                <1>     int 30h
   119 00000062 48C1EB08            <1>     shr rbx, 8
   120 00000066 E2F4                <1>     loop .pq1
   121 00000068 C3                  <1>     ret
   122                              <1> .printpipe:
   123 00000069 55                  <1>     push rbp
   124 0000006A 48BD-               <1>     mov rbp, .pipestr
   124 0000006C [7C00000000000000]  <1>
   125 00000074 66B80413            <1>     mov ax, 1304h
   126 00000078 CD30                <1>     int 30h
   127 0000007A 5D                  <1>     pop rbp
   128 0000007B C3                  <1>     ret
   129 0000007C 207C2000            <1> .pipestr:   db " | ",0
   130                              <1> .printcrlf:
   131 00000080 55                  <1>     push rbp
   132 00000081 48BD-               <1>     mov rbp, .crlfstr
   132 00000083 [9300000000000000]  <1>
   133 0000008B 66B80413            <1>     mov ax, 1304h
   134 0000008F CD30                <1>     int 30h
   135 00000091 5D                  <1>     pop rbp
   136 00000092 C3                  <1>     ret
   137 00000093 0A0D00              <1> .crlfstr: db 0Ah,0Dh, 0
   138                              <1> beep:
   139                              <1> ;Destroys old PIT2 divisor.
   140                              <1> ;Input: 
   141                              <1> ;   bx = Frequency divisor to use for tone
   142                              <1> ;   rcx = # of ms to beep for
   143                              <1> ;All registers preserved
   144 00000096 50                  <1>     push rax
   145 00000097 B0B6                <1>     mov al, 0B6h ;Get PIT command bitfield, PIT2, lo/hi, Mode 3, Binary
   146 00000099 E643                <1>     out PITcommand, al
   147                              <1> 
   148 0000009B 6689D8              <1>     mov ax, bx       ;Move frequency divisor into ax
   149 0000009E E642                <1>     out PIT2, al     ;Output lo byte of divisor
   150 000000A0 88E0                <1>     mov al, ah
   151 000000A2 E642                <1>     out PIT2, al     ;Output hi byte of divisor
   152                              <1> 
   153 000000A4 E461                <1>     in al, port61h  ;Save original state of port 61h in ah
   154 000000A6 0C03                <1>     or al, 3        ;Set bits 0 and 1 to turn on the speaker
   155 000000A8 E661                <1>     out port61h, al
   156                              <1> 
   157 000000AA B486                <1>     mov ah, 86h     ;Wait for beep to complete
   158 000000AC CD35                <1>     int 35h
   159                              <1> 
   160 000000AE E461                <1>     in al, port61h    ;Read state of port 61h afresh
   161 000000B0 24FC                <1>     and al, ~3        ;Clear bits 0 and 1 to turn off the speaker
   162 000000B2 E661                <1>     out port61h, al
   163                              <1> 
   164 000000B4 58                  <1>     pop rax
   165 000000B5 C3                  <1>     ret
   166                              <1> 
   167                              <1> ps2wait:
   168 000000B6 50                  <1>     push rax
   169                              <1> .wnok:
   170 000000B7 EB00                <1>     jmp short $ + 2
   171 000000B9 E464                <1>     in al, ps2status
   172 000000BB A801                <1>     test al, 1    ;Can something be read from KB?
   173 000000BD 7406                <1>     jz .wok       ;Zero = no, so loop back. Not zero = proceed to check if 
   174                              <1>                   ; something can be written
   175 000000BF EB00                <1>     jmp short $ + 2
   176 000000C1 E460                <1>     in al, ps2data    ;Read it in
   177 000000C3 EBF2                <1>     jmp short .wnok
   178                              <1> .wok:
   179 000000C5 A802                <1>     test al, 2   ;Can something be written to KB?
   180 000000C7 75EE                <1>     jnz .wnok    ;Zero if yes and proceed.
   181 000000C9 58                  <1>     pop rax
   182 000000CA C3                  <1>     ret
   183                              <1>     
   184                              <1> idtWriteEntry:
   185                              <1> ;----------------------------------------------------------------
   186                              <1> ;This proc writes an interrupt handler to a particular IDT entry.
   187                              <1> ; rax = Interrupt handler ptr    (qword)
   188                              <1> ; rsi = Interrupt Number         (qword)
   189                              <1> ; dx = Attributes word           (word)
   190                              <1> ; bx = Segment selector          (word)
   191                              <1> ;On return:
   192                              <1> ; rsi incremented by 1
   193                              <1> ; Entry written
   194                              <1> ;----------------------------------------------------------------
   195 000000CB 56                  <1>     push rsi
   196 000000CC 48C1E604            <1>     shl rsi, 4h     ;Multiply IDT entry number by 16
   197 000000D0 48033425[04000000]  <1>     add rsi, qword [IDTpointer.Base]    ;rsx points to IDT entry
   198 000000D8 668906              <1>     mov word [rsi], ax  ;Get low word into offset 15...0
   199 000000DB 66895E02            <1>     mov word [rsi + 2], bx  ;Move segment selector into place
   200 000000DF 66895604            <1>     mov word [rsi + 4], dx  ;Move attribute word into place
   201 000000E3 48C1E810            <1>     shr rax, 10h    ;Bring next word low
   202 000000E7 66894606            <1>     mov word [rsi + 6], ax  ;Get low word into offset 31...16
   203 000000EB 48C1E810            <1>     shr rax, 10h    ;Bring last dword low
   204 000000EF 894608              <1>     mov dword [rsi + 8], eax
   205 000000F2 5E                  <1>     pop rsi
   206 000000F3 48FFC6              <1>     inc rsi         ;rsi contains number of next interrupt handler
   207 000000F6 C3                  <1>     ret
   208                              <1>     
   209                              <1> cls:    ;Clear the screen, bl attrib, always clear active scr
   210 000000F7 50                  <1>     push rax
   211 000000F8 52                  <1>     push rdx
   212 000000F9 B40F                <1>     mov ah, 0Fh
   213 000000FB CD30                <1>     int 30h ;Get current active page
   214                              <1> 
   215 000000FD B402                <1>     mov ah, 02h    ;Set cursor pos
   216 000000FF 6631D2              <1>     xor dx, dx
   217 00000102 CD30                <1>     int 30h
   218 00000104 88DF                <1>     mov bh, bl
   219                              <1> ;No need for coordinates since al=00 means reset fullscreen
   220 00000106 66B80006            <1>     mov ax, 0600h
   221 0000010A CD30                <1>     int 30h    ;scroll page with grey on black
   222 0000010C 5A                  <1>     pop rdx
   223 0000010D 58                  <1>     pop rax
   224 0000010E C3                  <1>     ret
    80                                  ;--------------------Interrupt Service routines------------------
    81                                  
    82                                  ;======================HARDWARE INTERRUPTS=======================
    83                                  %include "./Source/Resident/Hardware/Timers/pitInt.asm"
    84                              <1> ;----------------Timer Interrupt IRQ 0/Int 20h-------------------
    85                              <1> ;This interrupt simply increments an internal timer and 
    86                              <1> ; calls a software interrupt (5Ch) which can be used by user 
    87                              <1> ; applications.
    88                              <1> ;----------------------------------------------------------------
    89                              <1> timer_IRQ0:
    90 0000010F FB                  <1>     sti    
    91 00000110 50                  <1>     push rax
    92 00000111 FF0425[37010000]    <1>     inc dword [pit_ticks]
    93 00000118 8B0425[37010000]    <1>     mov eax, dword [pit_ticks]
    94 0000011F 25FFFF1F00          <1>     and eax, 1FFFFFh    ;Clear OF bit [mask on bits 20:0]
    95 00000124 3DB0001800          <1>     cmp eax, 1800B0h    ;Ticks in one full day
    96 00000129 7519                <1>     jnz .tret            ;Not quite there
    97 0000012B 66C70425[37010000]- <1>     mov word [pit_ticks], 0     ;Zero lo count
    97 00000133 0000                <1>
    98 00000135 C60425[39010000]00  <1>     mov byte [pit_ticks + 2], 0    ;Zero hi count
    99 0000013D FE0425[3A010000]    <1>     inc byte [pit_ticks + 3]    ;Increment day OF counter    
   100                              <1> .tret:
   101 00000144 CD3C                <1>     int 3Ch        ;Call user handler
   102                              <1> 
   103 00000146 B020                <1>     mov al, EOI
   104 00000148 E620                <1>     out pic1command, al
   105 0000014A E680                <1>     out waitp, al    ;allow one io cycle to run
   106                              <1> 
   107 0000014C 58                  <1>     pop rax
   108 0000014D 48CF                <1>     iretq
   109                              <1> ;-------------------------End of Interrupt-----------------------
    84                                  %include "./Source/Resident/Hardware/PS2/keybInt.asm"
    85                              <1> ;----------------Keyboard Interrupt IRQ 1/Int 21h----------------
    86                              <1> ;This interrupt takes scancodes from the PC keyboard, translates 
    87                              <1> ; them into scancode/ASCII char pair and stores the pair into 
    88                              <1> ; the buffer for the software keyboard interrupt to use.
    89                              <1> ;----------------------------------------------------------------
    90                              <1> kb_IRQ1:
    91 0000014F FB                  <1>     sti        ;Reenable interrupts
    92 00000150 50                  <1>     push rax
    93 00000151 53                  <1>     push rbx
    94 00000152 51                  <1>     push rcx
    95 00000153 57                  <1>     push rdi
    96 00000154 4831C0              <1>     xor rax, rax
    97                              <1> 
    98                              <1> .k0:
    99 00000157 E460                <1>     in al, ps2data    ;Get the scancode (Set 1)
   100 00000159 4885C0              <1>     test rax, rax    ;Check to see if we got an error code from the keyboard.
   101 0000015C 0F84A0020000        <1>     jz .kb_error
   102 00000162 483D80000000        <1>     cmp rax, 80h
   103 00000168 0F8ED8000000        <1>     jle .basickey    ;A normal keypress, nothing too magical.
   104 0000016E 483DE0000000        <1>     cmp rax, 0E0h    ;Compare against special keys
   105 00000174 7472                <1>     je .special_keys
   106 00000176 483DE1000000        <1>     cmp rax, 0E1h    ;Pause
   107 0000017C 747D                <1>     je .pause
   108 0000017E 483DAA000000        <1>     cmp rax, 0AAh    ;LShift released
   109 00000184 0F8490000000        <1>     je .lshift_released
   110 0000018A 483DB6000000        <1>     cmp rax, 0B6h    ;RShift released
   111 00000190 0F8488000000        <1>     je .rshift_released
   112 00000196 483DB8000000        <1>     cmp rax, 0B8h    ;Alt Shift released
   113 0000019C 7474                <1>     je .alt_shift_released
   114 0000019E 483D9D000000        <1>     cmp rax, 9Dh    ;Ctrl Shift released
   115 000001A4 7470                <1>     je .ctrl_shift_released
   116 000001A6 483D2B0D0000        <1>     cmp rax, 0D2Bh    ;Toggle Insert
   117 000001AC 7460                <1>     je .insert_released
   118 000001AE EB25                <1>     jmp short .kb1_exit    ;Just exit if something weird gets sent
   119                              <1> 
   120                              <1> .kb_store_in_buffer:
   121 000001B0 488B1C25[4A000000]  <1>     mov rbx, qword [kb_buf_tail]    ;point rbx to tail
   122 000001B8 4889DF              <1>     mov rdi, rbx ;Save bx in di for storing the data in AX after bx gets inc 
   123 000001BB E82C210000          <1>     call kb_io.kb_ptr_adv            ;safely advance the pointer
   124 000001C0 483B1C25[42000000]  <1>     cmp rbx, qword [kb_buf_head]    ;Have we wrapped around?
   125 000001C8 745F                <1>     je .kb_buf_full_beep            ;discard and beep
   126 000001CA 668907              <1>     mov word [rdi], ax                ;mov scancode/ascii pair into buffer
   127 000001CD 48891C25[4A000000]  <1>     mov qword [kb_buf_tail], rbx    ;store new pointer back into tail
   128                              <1> 
   129                              <1> .kb1_exit:
   130 000001D5 B0FC                <1>     mov al, ~(kb_flag2_e0 | kb_flag2_e1)        ;move the notted version into al
   131 000001D7 200425[64000000]    <1>     and byte [kb_flags_2], al        ;Nullify the e0 and e1 flag
   132                              <1> .kb1_exit_e0:
   133 000001DE B020                <1>     mov al, EOI
   134 000001E0 E620                <1>     out pic1command, al    ;End of interrupt to pic1 command port
   135                              <1> 
   136 000001E2 5F                  <1>     pop rdi
   137 000001E3 59                  <1>     pop rcx
   138 000001E4 5B                  <1>     pop rbx
   139 000001E5 58                  <1>     pop rax
   140 000001E6 48CF                <1>     iretq
   141                              <1> 
   142                              <1> .special_keys:    ;An E0 process
   143 000001E8 B002                <1>     mov al, kb_flag2_e0         ;Set the bit for the flag
   144 000001EA 080425[64000000]    <1>     or byte [kb_flags_2], al    ;Set the flag
   145 000001F1 802425[64000000]FE  <1>     and byte [kb_flags_2], ~kb_flag2_e1    ;clear the E1 bit
   146 000001F9 EBE3                <1>     jmp short .kb1_exit_e0      ;Exit from IRQ without resetting flags 
   147                              <1> .pause:    ;An E1 process
   148 000001FB B001                <1>     mov al, kb_flag2_e1         ;Set the bit for the flag
   149 000001FD 080425[64000000]    <1>     or byte [kb_flags_2], al    ;Toggle the flag, since 9D and C5 will be 
   150                              <1>                                 ; ignored by the Int handler
   151 00000204 802425[64000000]FD  <1>     and byte [kb_flags_2], ~kb_flag2_e0    ;clear the E0 bit
   152 0000020C EBD0                <1>     jmp short .kb1_exit_e0
   153                              <1> 
   154                              <1> .insert_released:
   155 0000020E B07F                <1>     mov al, ~kb_flag_insset     ;Flag negation
   156 00000210 EB0E                <1>     jmp short .shift_release_common
   157                              <1> .alt_shift_released:
   158 00000212 B0F7                <1>     mov al, ~kb_flag_alt        ;Flag negation
   159 00000214 EB0A                <1>     jmp short .shift_release_common
   160                              <1> .ctrl_shift_released:
   161 00000216 B0FB                <1>     mov al, ~kb_flag_ctrl       ;Flag negation
   162 00000218 EB06                <1>     jmp short .shift_release_common
   163                              <1> .lshift_released:
   164 0000021A B0FD                <1>     mov al, ~kb_flag_lshift     ;Flag negation
   165 0000021C EB02                <1>     jmp short .shift_release_common
   166                              <1> .rshift_released:
   167 0000021E B0FE                <1>     mov al, ~kb_flag_rshift     ;Flag negation
   168                              <1> .shift_release_common:
   169 00000220 200425[62000000]    <1>     and byte [kb_flags], al     ;Clear the relevant bit
   170 00000227 EBAC                <1>     jmp short .kb1_exit
   171                              <1> 
   172                              <1> 
   173                              <1> .kb_buf_full_beep:
   174 00000229 53                  <1>     push rbx
   175 0000022A 51                  <1>     push rcx
   176 0000022B BBA9040000          <1>     mov ebx, 04A9h ;Frequency divisor for 1000Hz tone
   177 00000230 48B9F4010000000000- <1>     mov rcx, 500   ;Beep for a 1/2 second
   177 00000239 00                  <1>
   178 0000023A E857FEFFFF          <1>     call beep
   179 0000023F 59                  <1>     pop rcx
   180 00000240 5B                  <1>     pop rbx
   181 00000241 E98FFFFFFF          <1>     jmp .kb1_exit
   182                              <1> 
   183                              <1> .basickey:          ;al contains the scancode
   184 00000246 483D46000000        <1>     cmp rax, 46h
   185 0000024C 0F8421010000        <1>     je .e0special   ;ctrl+break checker (E0 46h is make for break haha)
   186                              <1> .kbbk1:
   187 00000252 483D2A000000        <1>     cmp rax, 2Ah    ;Left Shift scancode
   188 00000258 0F84E4000000        <1>     je .lshift_pressed
   189 0000025E 483D36000000        <1>     cmp rax, 36h    ;Right Shift scancode
   190 00000264 0F84DC000000        <1>     je .rshift_pressed
   191 0000026A 483D38000000        <1>     cmp rax, 38h    ;Alt Shift key scancode
   192 00000270 0F84C4000000        <1>     je .alt_shift_pressed
   193 00000276 483D1D000000        <1>     cmp rax, 1Dh    ;Ctrl Shift key scancode
   194 0000027C 0F84BC000000        <1>     je .ctrl_shift_pressed
   195                              <1>     
   196 00000282 483D3A000000        <1>     cmp rax, 3Ah    ;Caps lock key
   197 00000288 0F84CA000000        <1>     je .caps_lock
   198 0000028E 483D45000000        <1>     cmp rax, 45h    ;Num lock key
   199 00000294 0F84C2000000        <1>     je .num_lock
   200                              <1> ;    cmp rax, 46h    ;Scroll lock key
   201                              <1> ;    je .scroll_lock
   202 0000029A 483D52000000        <1>     cmp rax, 52h    ;Insert key pressed
   203 000002A0 0F84AE000000        <1>     je .ins_toggle    
   204 000002A6 483D53000000        <1>     cmp rax, 53h    ;Delete key, for CTRL+ALT+DEL
   205 000002AC 0F8408010000        <1>     je .ctrl_alt_del
   206                              <1> .keylookup:
   207 000002B2 48BB-               <1>     mov rbx, .kb_sc_ascii_lookup
   207 000002B4 [3F04000000000000]  <1>
   208                              <1>                     ; upper 7 bytes of rax are completely clear
   209 000002BC 66C1E004            <1>     shl ax, 4       ;multiply ax, the scancode, by 16, to offset to correct row
   210 000002C0 4801C3              <1>     add rbx, rax    ;offset rbx to the correct row
   211                              <1> ;Now check shift states, to align with column. rax is free again
   212 000002C3 8A0425[62000000]    <1>     mov al, byte [kb_flags]
   213                              <1> 
   214 000002CA A802                <1>     test al, kb_flag_lshift
   215 000002CC 7525                <1>     jnz .addshiftvalue            ;If that bit is set, jump!
   216 000002CE A801                <1>     test al, kb_flag_rshift
   217 000002D0 7521                <1>     jnz .addshiftvalue
   218 000002D2 A804                <1>     test al, kb_flag_ctrl
   219 000002D4 752E                <1>     jnz .addctrlvalue
   220 000002D6 A808                <1>     test al, kb_flag_alt
   221 000002D8 7533                <1>     jnz .addaltvalue
   222 000002DA A820                <1>     test al, kb_flag_numset
   223 000002DC 7538                <1>     jnz .addnumvalue
   224 000002DE A840                <1>     test al, kb_flag_capsset
   225 000002E0 753D                <1>     jnz .addcapsvalue
   226                              <1> 
   227                              <1> .keyget:
   228 000002E2 668B03              <1>     mov ax, word [rbx] ;Get correct word into ax!
   229 000002E5 6685C0              <1>     test ax, ax        ;check if the value is zero, if so, dont store in buffer
   230 000002E8 0F84E7FEFFFF        <1>     jz .kb1_exit
   231 000002EE E9BDFEFFFF          <1>     jmp .kb_store_in_buffer
   232                              <1> 
   233                              <1> .addshiftvalue:    ;first check if we shift with caps or num
   234 000002F3 A820                <1>     test al, kb_flag_numset
   235 000002F5 753A                <1>     jnz .addshiftnum
   236 000002F7 A840                <1>     test al, kb_flag_capsset
   237 000002F9 752D                <1>     jnz .addshiftcaps
   238                              <1>     ;Collapse through, it is just shift, add 2 to rbx
   239 000002FB 4881C302000000      <1>     add rbx, 1h*2h
   240 00000302 EBDE                <1>     jmp short .keyget
   241                              <1> .addctrlvalue:
   242 00000304 4881C304000000      <1>     add rbx, 2h*2h
   243 0000030B EBD5                <1>     jmp short .keyget
   244                              <1> .addaltvalue:
   245 0000030D 4881C306000000      <1>     add rbx, 3h*2h
   246 00000314 EBCC                <1>     jmp short .keyget
   247                              <1> .addnumvalue:
   248 00000316 4881C308000000      <1>     add rbx, 4h*2h
   249 0000031D EBC3                <1>     jmp short .keyget
   250                              <1> .addcapsvalue:
   251 0000031F 4881C30A000000      <1>     add rbx, 5h*2h
   252 00000326 EBBA                <1>     jmp short .keyget
   253                              <1> .addshiftcaps:
   254 00000328 4881C30C000000      <1>     add rbx, 6h*2h
   255 0000032F EBB1                <1>     jmp short .keyget
   256                              <1> .addshiftnum:
   257 00000331 4881C30E000000      <1>     add rbx, 7h*2h
   258 00000338 EBA8                <1>     jmp short .keyget
   259                              <1> 
   260                              <1> .alt_shift_pressed:
   261 0000033A B008                <1>     mov al, kb_flag_alt
   262 0000033C EB0A                <1>     jmp short .shift_pressed_common
   263                              <1> .ctrl_shift_pressed:
   264 0000033E B004                <1>     mov al, kb_flag_ctrl
   265 00000340 EB06                <1>     jmp short .shift_pressed_common
   266                              <1> .lshift_pressed:
   267 00000342 B002                <1>     mov al, kb_flag_lshift
   268 00000344 EB02                <1>     jmp short .shift_pressed_common
   269                              <1> .rshift_pressed:
   270 00000346 B001                <1>     mov al, kb_flag_rshift
   271                              <1> .shift_pressed_common:
   272 00000348 080425[62000000]    <1>     or byte [kb_flags], al    ;toggle flag bits
   273 0000034F E981FEFFFF          <1>     jmp .kb1_exit             ;Exit
   274                              <1> 
   275                              <1> .ins_toggle:
   276 00000354 B080                <1>     mov al, kb_flag_insset
   277 00000356 EB0A                <1>     jmp short .lock_common
   278                              <1> .caps_lock:
   279 00000358 B040                <1>     mov al, kb_flag_capsset
   280 0000035A EB06                <1>     jmp short .lock_common
   281                              <1> .num_lock:
   282 0000035C B020                <1>     mov al, kb_flag_numset
   283 0000035E EB02                <1>     jmp short .lock_common
   284                              <1> .scroll_lock:
   285 00000360 B010                <1>     mov al, kb_flag_scrlset
   286                              <1> .lock_common:
   287 00000362 300425[62000000]    <1>     xor byte [kb_flags], al    ;toggle bit
   288 00000369 E875000000          <1>     call .set_kb_lights
   289 0000036E E962FEFFFF          <1>     jmp .kb1_exit
   290                              <1> 
   291                              <1> .e0special:
   292 00000373 F60425[64000000]02  <1>     test byte [kb_flags_2], 00000010b    ;Check for E0 set
   293 0000037B 7505                <1>     jnz .ctrl_break
   294 0000037D E9DEFFFFFF          <1>     jmp .scroll_lock    ;Assume scroll lock set
   295                              <1> .ctrl_break:
   296 00000382 800C25[65000000]01  <1>     or byte [break_flag], 1        ;set break_flag
   297 0000038A 6631C0              <1>     xor ax, ax
   298 0000038D 53                  <1>     push rbx
   299 0000038E 48BB-               <1>     mov rbx, kb_buffer            ;mov the buffer addr to rbx
   299 00000390 [2200000000000000]  <1>
   300 00000398 48891C25[42000000]  <1>     mov qword [kb_buf_head], rbx
   301 000003A0 48891C25[4A000000]  <1>     mov qword [kb_buf_tail], rbx
   302 000003A8 668903              <1>     mov word [rbx], ax    ;Store zero as the first two bytes of the
   303 000003AB 5B                  <1>     pop rbx
   304 000003AC CD3B                <1>     int 3Bh                      ;Call the CTRL+Break handler
   305 000003AE 200425[65000000]    <1>     and byte [break_flag], al    ;clear break_flag
   306 000003B5 E91BFEFFFF          <1>     jmp .kb1_exit        ;return clearing E0
   307                              <1> 
   308                              <1> .ctrl_alt_del:
   309 000003BA 50                  <1>     push rax    ;save scancode
   310 000003BB 8A0425[64000000]    <1>     mov al, byte [kb_flags_2]
   311 000003C2 A802                <1>     test al, kb_flag2_e0    ;Delete scancode is E0, 53, check if we first had E0
   312 000003C4 7417                <1>     jz .ctrl_alt_del_no_reset
   313                              <1> 
   314 000003C6 8A0425[62000000]    <1>     mov al, byte [kb_flags]
   315 000003CD 240C                <1>     and al,  kb_flag_ctrl | kb_flag_alt
   316 000003CF 3C0C                <1>     cmp al, kb_flag_ctrl | kb_flag_alt    ;Test if Ctrl + Alt is being pressed
   317 000003D1 750A                <1>     jne .ctrl_alt_del_no_reset
   318                              <1> .ctrl_alt_del_killPC:
   319 000003D3 E464                <1>     in al, 64h    ;Check if the input buffer is empty
   320 000003D5 A802                <1>     test al, 2    ;Check if clear
   321 000003D7 75FA                <1>     jne .ctrl_alt_del_killPC    ;keep waiting
   322 000003D9 B0FE                <1>     mov al, 0FEh    ;Pulse kill lines
   323 000003DB E664                <1>     out 64h, al    
   324                              <1>     ;PC dead, time to reboot!
   325                              <1> .ctrl_alt_del_no_reset:
   326 000003DD 58                  <1>     pop rax        ;return the OG scancode and proceed as normal
   327 000003DE E9CFFEFFFF          <1>     jmp .keylookup
   328                              <1> 
   329                              <1> 
   330                              <1> .set_kb_lights:
   331 000003E3 50                  <1>     push rax
   332                              <1> 
   333 000003E4 E8CDFCFFFF          <1>     call ps2wait
   334                              <1> 
   335 000003E9 B0ED                <1>     mov al, 0EDh
   336 000003EB E660                <1>     out ps2data, al
   337                              <1> 
   338 000003ED E8C4FCFFFF          <1>     call ps2wait
   339                              <1>     
   340 000003F2 8A0425[62000000]    <1>     mov al, byte [kb_flags]    ;get flag into al
   341 000003F9 C0E804              <1>     shr al, 4
   342 000003FC 2407                <1>     and al, 111b    ;mask Insert bit off to isolate the NUM,CAPS,SCRL status 
   343                              <1>                     ; bits <=> LED status.
   344 000003FE E660                <1>     out ps2data, al    ;send the led status away
   345                              <1> 
   346 00000400 58                  <1>     pop rax
   347 00000401 C3                  <1>     ret
   348                              <1> 
   349                              <1> .kb_error:     ;If error recieved from Keyboard, hang the system, cold reboot 
   350                              <1>                ; needed.
   351 00000402 FA                  <1>     cli        ;Disable interrupts/Further keystrokes
   352 00000403 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   353 00000407 E8EBFCFFFF          <1>     call cls    ;clear the screen
   354 0000040C 66B80413            <1>     mov ax, 1304h
   355 00000410 30FF                <1>     xor bh, bh
   356 00000412 48BD-               <1>     mov rbp, .kb_error_msg
   356 00000414 [2204000000000000]  <1>
   357 0000041C CD30                <1>     int 30h
   358                              <1> .kber1:
   359 0000041E F390                <1>     pause
   360 00000420 EBFC                <1>     jmp short .kber1
   361 00000422 4B6579626F61726420- <1> .kb_error_msg:    db    "Keyboard Error. Halting...", 0Ah, 0Dh, 0
   361 0000042B 4572726F722E204861- <1>
   361 00000434 6C74696E672E2E2E0A- <1>
   361 0000043D 0D00                <1>
   362                              <1> 
   363                              <1> .kb_sc_ascii_lookup:    ;Scancodes 00h-58h
   364                              <1> ; Scancodes 00h-0Fh
   365                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   366 0000043F 000000000000000000- <1>  dw 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h ;NUL
   366 00000448 00000000000000      <1>
   367 0000044F 1B011B011B011B011B- <1>  dw 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh ;Esc
   367 00000458 011B011B011B01      <1>
   368 0000045F 310221020000007831- <1>  dw 0231h, 0221h, 0000h, 7800h, 0231h, 0231h, 0221h, 0221h ;1 !
   368 00000468 02310221022102      <1>
   369 0000046F 320322030003007932- <1>  dw 0332h, 0322h, 0300h, 7900h, 0332h, 0332h, 0322h, 0322h ;2 "
   369 00000478 03320322032203      <1>
   370 0000047F 33049C040000007A33- <1>  dw 0433h, 049Ch, 0000h, 7A00h, 0433h, 0433h, 049Ch, 049Ch ;3 
   370 00000488 0433049C049C04      <1>
   371 0000048F 340524050000007B34- <1>  dw 0534h, 0524h, 0000h, 7B00h, 0534h, 0534h, 0524h, 0524h ;4 $
   371 00000498 05340524052405      <1>
   372 0000049F 350625060000007C35- <1>  dw 0635h, 0625h, 0000h, 7C00h, 0635h, 0635h, 0625h, 0625h ;5 %
   372 000004A8 06350625062506      <1>
   373 000004AF 36075E071E07007D36- <1>  dw 0736h, 075Eh, 071Eh, 7D00h, 0736h, 0736h, 075Eh, 075Eh ;6 ^
   373 000004B8 0736075E075E07      <1>
   374 000004BF 370826080000007E37- <1>  dw 0837h, 0826h, 0000h, 7E00h, 0837h, 0837h, 0826h, 0826h ;7 &
   374 000004C8 08370826082608      <1>
   375 000004CF 38092A090000007F38- <1>  dw 0938h, 092Ah, 0000h, 7F00h, 0938h, 0938h, 092Ah, 092Ah ;8 *
   375 000004D8 0938092A092A09      <1>
   376 000004DF 390A280A0000008039- <1>  dw 0A39h, 0A28h, 0000h, 8000h, 0A39h, 0A39h, 0A28h, 0A28h ;9 (
   376 000004E8 0A390A280A280A      <1>
   377 000004EF 300B290B0000008130- <1>  dw 0B30h, 0B29h, 0000h, 8100h, 0B30h, 0B30h, 0B29h, 0B29h ;0 )
   377 000004F8 0B300B290B290B      <1>
   378 000004FF 2D0C5F0C000000822D- <1>  dw 0C2Dh, 0C5Fh, 0000h, 8200h, 0C2Dh, 0C2Dh, 0C5Fh, 0C5Fh ;- _
   378 00000508 0C2D0C5F0C5F0C      <1>
   379 0000050F 3D0D2B0D000000833D- <1>  dw 0D3Dh, 0D2Bh, 0000h, 8300h, 0D3Dh, 0D3Dh, 0D2Bh, 0D2Bh ;= +
   379 00000518 0D3D0D2B0D2B0D      <1>
   380 0000051F 080E080E7F0E000008- <1>  dw 0E08h, 0E08h, 0E7Fh, 0000h, 0E08h, 0E08h, 0E08h, 0E08h ;bksp (ctrl -> del)
   380 00000528 0E080E080E080E      <1>
   381 0000052F 090F000F0000000009- <1>  dw 0F09h, 0F00h, 0000h, 0000h, 0F09h, 0F09h, 0F00h, 0F00h ;L2R Horizontal Tab
   381 00000538 0F090F000F000F      <1>
   382                              <1> 
   383                              <1> ; Scancodes 10h-1Fh
   384                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   385 0000053F 711051101110001071- <1>  dw 1071h, 1051h, 1011h, 1000h, 1071h, 1051h, 1071h, 1051h ;q Q
   385 00000548 10511071105110      <1>
   386 0000054F 771157111711001177- <1>  dw 1177h, 1157h, 1117h, 1100h, 1177h, 1157h, 1177h, 1157h ;w W
   386 00000558 11571177115711      <1>
   387 0000055F 651245120512001265- <1>  dw 1265h, 1245h, 1205h, 1200h, 1265h, 1245h, 1265h, 1245h ;e E
   387 00000568 12451265124512      <1>
   388 0000056F 721352131213001372- <1>  dw 1372h, 1352h, 1312h, 1300h, 1372h, 1352h, 1372h, 1352h ;r R
   388 00000578 13521372135213      <1>
   389 0000057F 741454141414001474- <1>  dw 1474h, 1454h, 1414h, 1400h, 1474h, 1454h, 1474h, 1454h ;t T
   389 00000588 14541474145414      <1>
   390 0000058F 791559151915001579- <1>  dw 1579h, 1559h, 1519h, 1500h, 1579h, 1559h, 1579h, 1559h ;y Y
   390 00000598 15591579155915      <1>
   391 0000059F 751655161516001675- <1>  dw 1675h, 1655h, 1615h, 1600h, 1675h, 1655h, 1675h, 1655h ;u U
   391 000005A8 16551675165516      <1>
   392 000005AF 691749170917001769- <1>  dw 1769h, 1749h, 1709h, 1700h, 1769h, 1749h, 1769h, 1749h ;i I
   392 000005B8 17491769174917      <1>
   393 000005BF 6F184F180F1800186F- <1>  dw 186Fh, 184Fh, 180Fh, 1800h, 186Fh, 184Fh, 186Fh, 184Fh ;o O
   393 000005C8 184F186F184F18      <1>
   394 000005CF 701950191019001970- <1>  dw 1970h, 1950h, 1910h, 1900h, 1970h, 1950h, 1970h, 1950h ;p P
   394 000005D8 19501970195019      <1>
   395 000005DF 5B1A7B1A1B1A00005B- <1>  dw 1A5Bh, 1A7Bh, 1A1Bh, 0000h, 1A5Bh, 1A5Bh, 1A7Bh, 1A7Bh ;[ {
   395 000005E8 1A5B1A7B1A7B1A      <1>
   396 000005EF 5D1B7D1B1D1B00005D- <1>  dw 1B5Dh, 1B7Dh, 1B1Dh, 0000h, 1B5Dh, 1B5Dh, 1B7Dh, 1B7Dh ;] }
   396 000005F8 1B5D1B7D1B7D1B      <1>
   397 000005FF 0D1C0D1C0A1C00000D- <1>  dw 1C0Dh, 1C0Dh, 1C0Ah, 0000h, 1C0Dh, 1C0Dh, 1C0Ah, 1C0Ah ;Enter (CR/LF)
   397 00000608 1C0D1C0A1C0A1C      <1>
   398 0000060F 001D001D001D001D00- <1>  dw 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h ;CTRL (left)
   398 00000618 1D001D001D001D      <1>
   399 0000061F 611E411E011E001E61- <1>  dw 1E61h, 1E41h, 1E01h, 1E00h, 1E61h, 1E41h, 1E61h, 1E41h ;a A
   399 00000628 1E411E611E411E      <1>
   400 0000062F 731F531F131F001F73- <1>  dw 1F73h, 1F53h, 1F13h, 1F00h, 1F73h, 1F53h, 1F73h, 1F53h ;s S
   400 00000638 1F531F731F531F      <1>
   401                              <1> 
   402                              <1> ; Scancodes 20h-2Fh
   403                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   404 0000063F 642044200420002064- <1>  dw 2064h, 2044h, 2004h, 2000h, 2064h, 2044h, 2064h, 2044h ;d D
   404 00000648 20442064204420      <1>
   405 0000064F 662146210621002166- <1>  dw 2166h, 2146h, 2106h, 2100h, 2166h, 2146h, 2166h, 2146h ;f F
   405 00000658 21462166214621      <1>
   406 0000065F 672247220722002267- <1>  dw 2267h, 2247h, 2207h, 2200h, 2267h, 2247h, 2267h, 2247h ;g G
   406 00000668 22472267224722      <1>
   407 0000066F 682348230823002368- <1>  dw 2368h, 2348h, 2308h, 2300h, 2368h, 2348h, 2368h, 2348h ;h H
   407 00000678 23482368234823      <1>
   408 0000067F 6A244A240A2400246A- <1>  dw 246Ah, 244Ah, 240Ah, 2400h, 246Ah, 244Ah, 246Ah, 244Ah ;j J
   408 00000688 244A246A244A24      <1>
   409 0000068F 6B254B250B2500256B- <1>  dw 256Bh, 254Bh, 250Bh, 2500h, 256Bh, 254Bh, 256Bh, 254Bh ;k K
   409 00000698 254B256B254B25      <1>
   410 0000069F 6C264C260C2600266C- <1>  dw 266Ch, 264Ch, 260Ch, 2600h, 266Ch, 264Ch, 266Ch, 264Ch ;l L
   410 000006A8 264C266C264C26      <1>
   411 000006AF 3B273A27000000003B- <1>  dw 273Bh, 273Ah, 0000h, 0000h, 273Bh, 273Bh, 273Ah, 273Ah ;; :
   411 000006B8 273B273A273A27      <1>
   412 000006BF 272840280000000027- <1>  dw 2827h, 2840h, 0000h, 0000h, 2827h, 2827h, 2840h, 2840h ;' @
   412 000006C8 28272840284028      <1>
   413 000006CF 5C297C29000000005C- <1>  dw 295Ch, 297Ch, 0000h, 0000h, 295Ch, 295Ch, 297Ch, 297Ch ;\ |
   413 000006D8 295C297C297C29      <1>
   414 000006DF 002A002A002A002A00- <1>  dw 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h ;LShift (2Ah)
   414 000006E8 2A002A002A002A      <1>
   415 000006EF 232B7E2B1C2B000023- <1>  dw 2B23h, 2B7Eh, 2B1Ch, 0000h, 2B23h, 2B23h, 2B7Eh, 2B7Eh ;# ~
   415 000006F8 2B232B7E2B7E2B      <1>
   416 000006FF 7A2C5A2C1A2C002C7A- <1>  dw 2C7Ah, 2C5Ah, 2C1Ah, 2C00h, 2C7Ah, 2C5Ah, 2C7Ah, 2C5Ah ;z Z
   416 00000708 2C5A2C7A2C5A2C      <1>
   417 0000070F 782D582D182D002D78- <1>  dw 2D78h, 2D58h, 2D18h, 2D00h, 2D78h, 2D58h, 2D78h, 2D58h ;x X
   417 00000718 2D582D782D582D      <1>
   418 0000071F 632E432E032E002E63- <1>  dw 2E63h, 2E43h, 2E03h, 2E00h, 2E63h, 2E43h, 2E63h, 2E43h ;c C
   418 00000728 2E432E632E432E      <1>
   419 0000072F 762F562F162F002F76- <1>  dw 2F76h, 2F56h, 2F16h, 2F00h, 2F76h, 2F56h, 2F76h, 2F56h ;v V
   419 00000738 2F562F762F562F      <1>
   420                              <1> 
   421                              <1> ; Scancodes 30h-3Fh
   422                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   423 0000073F 623042300230003062- <1>  dw 3062h, 3042h, 3002h, 3000h, 3062h, 3042h, 3062h, 3042h ;b B
   423 00000748 30423062304230      <1>
   424 0000074F 6E314E310E3100316E- <1>  dw 316Eh, 314Eh, 310Eh, 3100h, 316Eh, 314Eh, 316Eh, 314Eh ;n N
   424 00000758 314E316E314E31      <1>
   425 0000075F 6D324D320D3200326D- <1>  dw 326Dh, 324Dh, 320Dh, 3200h, 326Dh, 324Dh, 326Dh, 324Dh ;m M
   425 00000768 324D326D324D32      <1>
   426 0000076F 2C333C33000000002C- <1>  dw 332Ch, 333Ch, 0000h, 0000h, 332Ch, 332Ch, 333Ch, 333Ch ;, <
   426 00000778 332C333C333C33      <1>
   427 0000077F 2E343E34000000002E- <1>  dw 342Eh, 343Eh, 0000h, 0000h, 342Eh, 342Eh, 343Eh, 343Eh ;. >
   427 00000788 342E343E343E34      <1>
   428 0000078F 2F353F35000000002F- <1>  dw 352Fh, 353Fh, 0000h, 0000h, 352Fh, 352Fh, 353Fh, 353Fh ;/ ?
   428 00000798 352F353F353F35      <1>
   429 0000079F 003600360036003600- <1>  dw 3600h, 3600h, 3600h, 3600h, 3600h, 3600h, 3600h, 3600h ;RShift
   429 000007A8 36003600360036      <1>
   430 000007AF 2A370000103700002A- <1>  dw 372Ah, 0000h, 3710h, 0000h, 372Ah, 372Ah, 0000h, 0000h ;KP *
   430 000007B8 372A3700000000      <1>
   431 000007BF 003800380038003800- <1>  dw 3800h, 3800h, 3800h, 3800h, 3800h, 3800h, 3800h, 3800h ;Alt
   431 000007C8 38003800380038      <1>
   432 000007CF 203920390039000020- <1>  dw 3920h, 3920h, 3900h, 0000h, 3920h, 3920h, 3920h, 3920h ;Space
   432 000007D8 39203920392039      <1>
   433 000007DF 003A003A003A003A00- <1>  dw 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h ;Caps Lock
   433 000007E8 3A003A003A003A      <1>
   434 000007EF 003B0054005E006800- <1>  dw 3B00h, 5400h, 5E00h, 6800h, 3B00h, 3B00h, 5400h, 5400h ;F1
   434 000007F8 3B003B00540054      <1>
   435 000007FF 003C0055005F006900- <1>  dw 3C00h, 5500h, 5F00h, 6900h, 3C00h, 3C00h, 5500h, 5500h ;F2
   435 00000808 3C003C00550055      <1>
   436 0000080F 003D00560060006A00- <1>  dw 3D00h, 5600h, 6000h, 6A00h, 3D00h, 3D00h, 5600h, 5600h ;F3
   436 00000818 3D003D00560056      <1>
   437 0000081F 003E00570061006B00- <1>  dw 3E00h, 5700h, 6100h, 6B00h, 3E00h, 3E00h, 5700h, 5700h ;F4
   437 00000828 3E003E00570057      <1>
   438 0000082F 003F00580062006C00- <1>  dw 3F00h, 5800h, 6200h, 6C00h, 3F00h, 3F00h, 5800h, 5800h ;F5
   438 00000838 3F003F00580058      <1>
   439                              <1> 
   440                              <1> ; Scancodes 40h-4Fh
   441                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   442 0000083F 004000590063006D00- <1>  dw 4000h, 5900h, 6300h, 6D00h, 4000h, 4000h, 5900h, 5900h ;F6
   442 00000848 40004000590059      <1>
   443 0000084F 0041005A0064006E00- <1>  dw 4100h, 5A00h, 6400h, 6E00h, 4100h, 4100h, 5A00h, 5A00h ;F7
   443 00000858 410041005A005A      <1>
   444 0000085F 0042005B0065006F00- <1>  dw 4200h, 5B00h, 6500h, 6F00h, 4200h, 4200h, 5B00h, 5B00h ;F8
   444 00000868 420042005B005B      <1>
   445 0000086F 0043005C0066007000- <1>  dw 4300h, 5C00h, 6600h, 7000h, 4300h, 4300h, 5C00h, 5C00h ;F9
   445 00000878 430043005C005C      <1>
   446 0000087F 0044005D0067007100- <1>  dw 4400h, 5D00h, 6700h, 7100h, 4400h, 4400h, 5D00h, 5D00h ;F10
   446 00000888 440044005D005D      <1>
   447 0000088F 004500450045004500- <1>  dw 4500h, 4500h, 4500h, 4500h, 4500h, 4500h, 4500h, 4500h ;Num Lock
   447 00000898 45004500450045      <1>
   448 0000089F 004600460046004600- <1>  dw 4600h, 4600h, 4600h, 4600h, 4600h, 4600h, 4600h, 4600h ;Scroll Lock
   448 000008A8 46004600460046      <1>
   449 000008AF 004737470077000037- <1>  dw 4700h, 4737h, 7700h, 0000h, 4737h, 4700h, 4737h, 4700h ;(KP)Home
   449 000008B8 47004737470047      <1>
   450 000008BF 004838480000000038- <1>  dw 4800h, 4838h, 0000h, 0000h, 4838h, 4800h, 4838h, 4800h ;(KP)Up arrow
   450 000008C8 48004838480048      <1>
   451 000008CF 004939490084000039- <1>  dw 4900h, 4939h, 8400h, 0000h, 4939h, 4900h, 4939h, 4900h ;(KP)PgUp 
   451 000008D8 49004939490049      <1>
   452 000008DF 2D4A2D4A000000002D- <1>  dw 4A2Dh, 4A2Dh, 0000h, 0000h, 4A2Dh, 4A2Dh, 4A2Dh, 4A2Dh ;(KP)-
   452 000008E8 4A2D4A2D4A2D4A      <1>
   453 000008EF 004B344B0073000034- <1>  dw 4B00h, 4B34h, 7300h, 0000h, 4B34h, 4B00h, 4B34h, 4B00h ;(KP)Left arrow
   453 000008F8 4B004B344B004B      <1>
   454 000008FF 004C354C0000000035- <1>  dw 4C00h, 4C35h, 0000h, 0000h, 4C35h, 4C00h, 4C35h, 4C00h ;(KP)Center
   454 00000908 4C004C354C004C      <1>
   455 0000090F 004D364D0074000036- <1>  dw 4D00h, 4D36h, 7400h, 0000h, 4D36h, 4D00h, 4D36h, 4D00h ;(KP)Right arrow
   455 00000918 4D004D364D004D      <1>
   456 0000091F 2B4E2B4E000000002B- <1>  dw 4E2Bh, 4E2Bh, 0000h, 0000h, 4E2Bh, 4E2Bh, 4E2Bh, 4E2Bh ;(KP)+
   456 00000928 4E2B4E2B4E2B4E      <1>
   457 0000092F 004F314F0075000031- <1>  dw 4F00h, 4F31h, 7500h, 0000h, 4F31h, 4F00h, 4F31h, 4F00h ;(KP)End
   457 00000938 4F004F314F004F      <1>
   458                              <1> 
   459                              <1> ; Scancodes 50h-58h
   460                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   461 0000093F 005032500000000032- <1>  dw 5000h, 5032h, 0000h, 0000h, 5032h, 5000h, 5032h, 5000h ;(KB)Down arrow
   461 00000948 50005032500050      <1>
   462 0000094F 005133510076000033- <1>  dw 5100h, 5133h, 7600h, 0000h, 5133h, 5100h, 5133h, 5100h ;(KB)PgDn
   462 00000958 51005133510051      <1>
   463 0000095F 005230520000000030- <1>  dw 5200h, 5230h, 0000h, 0000h, 5230h, 5200h, 5230h, 5200h ;(KB)Ins
   463 00000968 52005230520052      <1>
   464 0000096F 00532E53000000002E- <1>  dw 5300h, 532Eh, 0000h, 0000h, 532Eh, 5300h, 532Eh, 5300h ;(KB)Del
   464 00000978 5300532E530053      <1>
   465 0000097F 005400540054005400- <1>  dw 5400h, 5400h, 5400h, 5400h, 5400h, 5400h, 5400h, 5400h ;ALT+PRTSC -> Sysreq
   465 00000988 54005400540054      <1>
   466 0000098F 000000000000000000- <1>  dw 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h ;xxxxNOTUSEDxxxx
   466 00000998 00000000000000      <1>
   467 0000099F 5C567C56000000005C- <1>  dw 565Ch, 567Ch, 0000h, 0000h, 565Ch, 565Ch, 567Ch, 567Ch ;\ |
   467 000009A8 565C567C567C56      <1>
   468 000009AF 005700000000000000- <1>  dw 5700h, 0000h, 0000h, 0000h, 5700h, 5700h, 0000h, 0000h ;F11
   468 000009B8 57005700000000      <1>
   469 000009BF 005800000000000000- <1>  dw 5800h, 0000h, 0000h, 0000h, 5800h, 5800h, 0000h, 0000h ;F12
   469 000009C8 58005800000000      <1>
   470                              <1> ;------------------------End of Interrupt------------------------
    85                                  %include "./Source/Resident/Hardware/Serial/serInt.asm"
    86                              <1> ;------------------Serial Interrupt IRQ 3/Int 23h----------------
    87                              <1> ;Serves serial ports 1 and 3 should they exist. Only considers 
    88                              <1> ; data recieving. Disregards all sending data interrupts.
    89                              <1> ;Puts recieved data into respective buffer and clears RTS 
    90                              <1> ; (base+5) if buffer full.
    91                              <1> ;----------------------------------------------------------------
    92                              <1> ser_IRQ3:
    93 000009CF FA                  <1>     cli
    94 000009D0 50                  <1>     push rax
    95 000009D1 52                  <1>     push rdx
    96 000009D2 55                  <1>     push rbp
    97 000009D3 51                  <1>     push rcx
    98 000009D4 57                  <1>     push rdi
    99 000009D5 53                  <1>     push rbx
   100                              <1> 
   101 000009D6 BB08000000          <1>     mov ebx, 8
   102 000009DB 66BAFA02            <1>     mov dx, com2_base + 2 ;Interrupt ID register
   103 000009DF EB10                <1>     jmp short ser_common
   104                              <1> ;------------------------End of Interrupt------------------------
   105                              <1> ;---------------------Serial Interrupt IRQ 3/Int 23h-------------
   106                              <1> ;Serves serial ports 1 and 3 should they exist. Only considers 
   107                              <1> ; data recieving. Disregards all sending data interrupts.
   108                              <1> ;Puts recieved data into respective buffer and clears RTS 
   109                              <1> ; (base+5) if buffer full.
   110                              <1> ;----------------------------------------------------------------
   111                              <1> ser_IRQ4:
   112 000009E1 FA                  <1>     cli
   113 000009E2 50                  <1>     push rax
   114 000009E3 52                  <1>     push rdx
   115 000009E4 55                  <1>     push rbp
   116 000009E5 51                  <1>     push rcx
   117 000009E6 57                  <1>     push rdi
   118 000009E7 53                  <1>     push rbx
   119                              <1> 
   120 000009E8 BB06000000          <1>     mov ebx, 6
   121 000009ED 66BAFA03            <1>     mov dx, com1_base + 2 ;Interrupt ID register
   122                              <1> ser_common:
   123 000009F1 EC                  <1>     in al, dx
   124 000009F2 A801                <1>     test al, 1    ;Check if bit zero is clear ie interrupt pending
   125 000009F4 741F                <1>     jz .si1       ;Clear, interrupt pending on COM 1 port
   126                              <1> .si0:
   127 000009F6 668B93[67000000]    <1>     mov dx, word [com_addresses + rbx] ;now point to HI COM Interrupt ID registr
   128 000009FD 6685D2              <1>     test dx, dx
   129 00000A00 0F8497000000        <1>     jz .siexit            ;Nothing here, exit
   130 00000A06 66FFC2              <1>     inc dx
   131 00000A09 66FFC2              <1>     inc dx                ;dx = base + 2
   132 00000A0C EC                  <1>     in al, dx
   133 00000A0D A801                <1>     test al, 1     ;Check if bit zero is clear
   134 00000A0F 0F8588000000        <1>     jnz .siexit    ;Bad behavior, or no Int on com3 after com1 processed, exit
   135                              <1> .si1:
   136                              <1> ;Confirm Data available Interrupt (ie bits 1,2,3 are 010b)
   137 00000A15 A804                <1>     test al, 00000100b
   138 00000A17 0F8480000000        <1>     jz .siexit   ;bad behavior, exit
   139 00000A1D 6681C20300          <1>     add dx, 3    ;dx = base + 5
   140                              <1> .si41:
   141 00000A22 EC                  <1>     in al, dx
   142 00000A23 2401                <1>     and al, 1
   143 00000A25 74FB                <1>     jz .si41
   144                              <1> 
   145 00000A27 6681EA0500          <1>     sub dx, 5
   146 00000A2C EC                  <1>     in al, dx    ;get char into al
   147 00000A2D 88C4                <1>     mov ah, al   ;save al in ah temporarily
   148 00000A2F 4831C9              <1>     xor rcx, rcx
   149                              <1> .si2:    ;Get offset into table structures into cx
   150 00000A32 663B9409[67000000]  <1>     cmp dx, word [com_addresses + rcx*2]    ;table of addresses, dx is at base
   151 00000A3A 740C                <1>     je .si3
   152 00000A3C 66FFC1              <1>     inc cx
   153 00000A3F 6681F90400          <1>     cmp cx, 4    ;rcx should be {0,3}
   154 00000A44 7CEC                <1>     jl .si2
   155 00000A46 EB55                <1>     jmp short .siexit    ;bad value, exit
   156                              <1> .si3:    ;Store in buffer algorithm
   157 00000A48 488B1CCD[CF000000]  <1>     mov rbx, qword [comX_buf_tail + rcx*8]
   158 00000A50 4889DF              <1>     mov rdi, rbx
   159 00000A53 48FFC3              <1>     inc rbx        ;increment by one char
   160 00000A56 483B1CCD[0F010000]  <1>     cmp rbx, qword [comX_buf_end + rcx*8]
   161 00000A5E 7508                <1>     jne .si4
   162 00000A60 488B1CCD[EF000000]  <1>     mov rbx, qword [comX_buf_start + rcx*8]    ;Wrap around buffer
   163                              <1> .si4:
   164 00000A68 483B1CCD[AF000000]  <1>     cmp rbx, qword [comX_buf_head + rcx*8]    ;Check if buffer full
   165 00000A70 740F                <1>     je .si5    ;Buffer full, indicate wait to data source
   166                              <1> 
   167 00000A72 8827                <1>     mov byte [rdi], ah    ;store char into buffer
   168 00000A74 48891CCD[CF000000]  <1>     mov qword [comX_buf_tail + rcx*8], rbx    ;store new tail into variable
   169                              <1> 
   170 00000A7C E975FFFFFF          <1>     jmp .si0    ;If com1/2, now check that com 3/4 didnt fire interrupt.
   171                              <1> 
   172                              <1> .si5:    ;Buffer full, Deassert DTR bit 
   173                              <1> ;dx points at the base register
   174 00000A81 6681C20400          <1>     add dx, 4    ;Point at Modem Control Register
   175 00000A86 EC                  <1>     in al, dx
   176 00000A87 24FE                <1>     and al, 11111110b    ;Clear the bottom bit
   177 00000A89 EE                  <1>     out dx, al    ;Set the DTR bit down (not ready to recieve data)
   178 00000A8A 6681C20300          <1>     add dx, 3    ;Point to scratch register
   179 00000A8F 88E0                <1>     mov al, ah    ;return ah into al
   180 00000A91 EE                  <1>     out dx, al    ;put the overrun char into scratch register
   181 00000A92 6681F90200          <1>     cmp cx, 2    ;If this was com1/2, now check for com 3/4.
   182 00000A97 0F8559FFFFFF        <1>     jne .si0
   183                              <1> ;exit since we dont want to take whats in the UART buffer just yet.
   184                              <1> .siexit:
   185 00000A9D B020                <1>     mov al, EOI
   186 00000A9F E620                <1>     out pic1command, al
   187                              <1> 
   188 00000AA1 5B                  <1>     pop rbx
   189 00000AA2 5F                  <1>     pop rdi
   190 00000AA3 59                  <1>     pop rcx
   191 00000AA4 5D                  <1>     pop rbp
   192 00000AA5 5A                  <1>     pop rdx
   193 00000AA6 58                  <1>     pop rax
   194 00000AA7 FB                  <1>     sti
   195 00000AA8 48CF                <1>     iretq
   196                              <1> ;------------------------End of Interrupt------------------------
    86                                  %include "./Source/Resident/Hardware/MSD/fddInt.asm"
    87                              <1> ;----------------FDD Interrupt IRQ 6/Int 26h---------------------
    88                              <1> fdd_IRQ6:
    89 00000AAA 50                  <1>     push rax
    90 00000AAB B020                <1>     mov al, EOI
    91 00000AAD E620                <1>     out pic1command, al
    92 00000AAF 58                  <1>     pop rax
    93 00000AB0 48CF                <1>     iretq
    94                              <1> ;------------------------End of Interrupt------------------------
    87                                  %include "./Source/Resident/Hardware/Timers/rtcInt.asm"
    88                              <1> ;---------------RTC Interrupt IRQ 8/Int 28h----------------------
    89                              <1> ; This IRQ should only trigger for the periodic and alarm 
    90                              <1> ; interrupts. If a programmer wishes to use the time update 
    91                              <1> ; complete interrupt feature, they should hook their own 
    92                              <1> ; interrupt handler.
    93                              <1> ;----------------------------------------------------------------
    94                              <1> rtc_IRQ8:
    95 00000AB2 50                  <1>     push rax
    96 00000AB3 FA                  <1>     cli             ;Disable interrupts
    97 00000AB4 B08C                <1>     mov al, 8Ch     ;Register C with NMI disabled
    98 00000AB6 E670                <1>     out cmos_base, al
    99 00000AB8 E680                <1>     out waitp, al    ;allow one io cycle to run
   100 00000ABA EB00                <1>     jmp short $+2
   101 00000ABC E471                <1>     in al, cmos_data    ;Get the data byte to confirm IRQ recieved
   102 00000ABE 2460                <1>     and al, 060h        ;Isolate Alarm and Periodic bits only
   103 00000AC0 A840                <1>     test al, 40h        ;Periodic?
   104 00000AC2 7408                <1>     jz .noPeriodic      ;No, skip the periodic
   105                              <1> .periodic:
   106 00000AC4 48FF0C25[3B010000]  <1>     dec qword [rtc_ticks]
   107                              <1> .noPeriodic:
   108 00000ACC A820                <1>     test al, 20h        ;Alarm?
   109 00000ACE 7402                <1>     jz .exit
   110                              <1> .alarm:
   111 00000AD0 CD6A                <1>     int 6Ah    ;User Alarm handler, behaves like Int 4Ah on 16-bit BIOS
   112                              <1> .exit:
   113 00000AD2 B00D                <1>     mov al, 0Dh     ;Read Register D and reenable NMI
   114 00000AD4 E670                <1>     out cmos_base, al
   115 00000AD6 E680                <1>     out waitp, al    ;allow one io cycle to run
   116 00000AD8 EB00                <1>     jmp short $+2
   117 00000ADA E471                <1>     in al, cmos_data    
   118 00000ADC B020                <1>     mov al, EOI
   119 00000ADE E6A0                <1>     out pic2command, al
   120 00000AE0 E620                <1>     out pic1command, al
   121 00000AE2 58                  <1>     pop rax
   122 00000AE3 48CF                <1>     iretq
   123                              <1> ;------------------------End of Interrupt------------------------
    88                                  %include "./Source/Resident/Hardware/MSD/hddInt.asm"
    89                              <1> ;---------------HDD Interrupt IRQ 14/Int 2Eh---------------------
    90                              <1> hdd_IRQ14:
    91 00000AE5 50                  <1>     push rax
    92 00000AE6 52                  <1>     push rdx
    93 00000AE7 802425[AB010000]FD  <1>     and byte [ata0CmdByte], 0FDh    ;Clear bit 1
    94 00000AEF 66BAF701            <1>     mov dx, ata0_base + 7   ;Since this interrupt ONLY occurs on ata0
    95 00000AF3 EC                  <1>     in al, dx   ;Read the status, and stop the controller from firing again
    96                              <1> 
    97 00000AF4 B020                <1>     mov al, EOI
    98 00000AF6 E620                <1>     out pic1command, al
    99 00000AF8 5A                  <1>     pop rdx
   100 00000AF9 58                  <1>     pop rax
   101 00000AFA 48CF                <1>     iretq
   102                              <1> ;------------------------End of Interrupt------------------------
    89                                  %include "./Source/Resident/Hardware/USB/EHCI/ehciInt.asm"
    90                              <1> ;-------------------EHCI Int Handler/Int 2Xh---------------------
    91                              <1> ;This is installed by the PCI proc at runtime, onto the 
    92                              <1> ; appropriate IRQ.
    93                              <1> ;
    94                              <1> ;If USB Host controller is doing transaction, this HC is 
    95                              <1> ; nominally turned off. Bits [7:2] in the eAsyncMutex identify 
    96                              <1> ; how many interrupts to ignore, before switching off the 
    97                              <1> ; Schedule. This value is nominally zero.
    98                              <1> ;----------------------------------------------------------------
    99                              <1> ehci_IRQ:
   100 00000AFC 68[89570000]        <1>     push qword dummy_interrupt.pic2
   101 00000B01 EB05                <1>     jmp short .intr
   102                              <1> .pic1:
   103 00000B03 68[90570000]        <1>     push qword dummy_interrupt.pic1
   104                              <1> .intr:
   105                              <1> ;EHCI Interrupt Handler 
   106 00000B08 53                  <1>     push rbx
   107 00000B09 50                  <1>     push rax
   108                              <1> 
   109 00000B0A 8A0425[47020000]    <1>     mov al, byte [eActiveCtrlr]
   110 00000B11 3CFF                <1>     cmp al, -1    ;Spurious case, replace with manual poll then discard proc
   111 00000B13 743F                <1>     je .spur
   112                              <1> 
   113 00000B15 E842480000          <1>     call USB.ehciGetOpBase    ;returns opreg base in rax
   114                              <1> .nonIRQmain:
   115 00000B1A 678B5804            <1>     mov ebx, dword [eax + ehcists]  ;save USBSTS and clear usb interrupt
   116 00000B1E 67095804            <1>     or dword [eax + ehcists], ebx   ;WC all interrupt status
   117 00000B22 881C25[48020000]    <1>     mov byte [eActiveInt], bl    ;save interrupt status
   118                              <1> 
   119                              <1> ;Test based on which bits are set. Higher bits have higher priority
   120                              <1>     ;test bl, 10h            ;Check if host error bit set
   121                              <1>     ;test bl, 8              ;Frame List rollover
   122                              <1>     ;test bl, 4              ;Port status change detected
   123 00000B29 F6C302              <1>     test bl, 2              ;Check if transation error bit is set
   124 00000B2C 7542                <1>     jnz .transactionError
   125 00000B2E F6C301              <1>     test bl, 1              ;Check if short packet/interrupt bit set
   126 00000B31 741E                <1>     jz .exit                ;If none of the bits were set, continue IRQ chain
   127                              <1> ;IoC and Short Packet section
   128 00000B33 8A0425[49020000]    <1>     mov al, byte [eAsyncMutex]    ;check if we should ignore interrupt
   129 00000B3A 24FC                <1>     and al, 11111100b    ;clear out bottom two bits (dont care)
   130 00000B3C 84C0                <1>     test al, al            ;Set zero flag if al is zero
   131 00000B3E 7509                <1>     jnz .usbignoreirq    ;If not zero, ignore irq (and dec counter!)
   132                              <1> 
   133 00000B40 880425[49020000]    <1>     mov byte [eAsyncMutex], al ;Wait no longer!! Data available
   134                              <1> 
   135 00000B47 EB08                <1>     jmp short .exit    ;Ignore the "ignore usb" section
   136                              <1> .usbignoreirq:
   137 00000B49 802C25[49020000]04  <1>     sub byte [eAsyncMutex], 4    ;sub the semaphore 
   138                              <1> .exit:
   139 00000B51 58                  <1>     pop rax
   140 00000B52 5B                  <1>     pop rbx
   141 00000B53 C3                  <1>     ret
   142                              <1> .spur:
   143 00000B54 30C0                <1>     xor al, al
   144                              <1> .s1:
   145 00000B56 E801480000          <1>     call USB.ehciGetOpBase
   146 00000B5B 678B5804            <1>     mov ebx, dword [eax + ehcists] ;save USBSTS and clear usb interrupt 
   147 00000B5F 67095804            <1>     or dword [eax + ehcists], ebx    ;WC all interrupt status
   148 00000B63 FEC0                <1>     inc al    ;Clear all interrupts on all controllers
   149 00000B65 3A0425[14020000]    <1>     cmp al, byte [eControllers]
   150 00000B6C 72E8                <1>     jb .s1
   151 00000B6E EBE1                <1>     jmp short .exit
   152                              <1> .transactionError:
   153 00000B70 C60425[49020000]00  <1>     mov byte [eAsyncMutex], 0   ;Unblock wait
   154 00000B78 EBD7                <1>     jmp short .exit
   155                              <1> .nonIRQep:
   156 00000B7A 53                  <1>     push rbx
   157 00000B7B 50                  <1>     push rax
   158 00000B7C EB9C                <1>     jmp short .nonIRQmain
   159                              <1> ;------------------------End of Interrupt------------------------
    90                                  %include "./Source/Resident/Hardware/spurInt.asm"
    91                              <1> ;-----------------Spurious Int Handler/Int 27h-------------------
    92                              <1> ; Catches and handles spurious interrupts on the first pic.
    93                              <1> ;----------------------------------------------------------------
    94                              <1> default_IRQ7:
    95 00000B7E 50                  <1>     push rax
    96 00000B7F B00B                <1>     mov al, 0Bh    ;Read ISR 
    97 00000B81 E620                <1>     out pic1command, al
    98 00000B83 E680                <1>     out waitp, al    ;Latch wait
    99 00000B85 EB00                <1>     jmp short $+2
   100 00000B87 E420                <1>     in al, pic1command    ;Get the ISR
   101 00000B89 A880                <1>     test al, 80h
   102 00000B8B 7509                <1>     jne .exit
   103 00000B8D FE0425[20000000]    <1>     inc byte [spurint1]
   104 00000B94 EB04                <1>     jmp short .e2    ;Avoid sending EOI
   105                              <1> .exit:
   106 00000B96 B020                <1>     mov al, EOI
   107 00000B98 E620                <1>     out pic1command, al
   108                              <1> .e2:
   109 00000B9A 58                  <1>     pop rax
   110 00000B9B 48CF                <1>     iretq
   111                              <1> 
   112                              <1> ;-----------------Spurious Int Handler/Int 2Fh-------------------
   113                              <1> ; Catches and handles spurious interrupts on the second pic.
   114                              <1> ;----------------------------------------------------------------
   115                              <1> default_IRQ15:
   116 00000B9D 50                  <1>     push rax
   117 00000B9E F60425[AD010000]01  <1>     test byte [ata1CmdByte], 1   ;Check if mutex bit set
   118 00000BA6 740F                <1>     jz .spurcheck                ;If not set, then just check spur
   119 00000BA8 802425[AD010000]FD  <1>     and byte [ata1CmdByte], 0FDh ;Clear bit 
   120 00000BB0 52                  <1>     push rdx
   121 00000BB1 66BA7701            <1>     mov dx, ata1_base + 7   ;Goto ata1 status reg
   122 00000BB5 EC                  <1>     in al, dx   ;Stop ctrlr from firing interrupts again!
   123 00000BB6 5A                  <1>     pop rdx
   124                              <1> .spurcheck:
   125 00000BB7 B00B                <1>     mov al, 0Bh    ;Read ISR 
   126 00000BB9 E6A0                <1>     out pic2command, al
   127 00000BBB E680                <1>     out waitp, al    ;Latch wait
   128 00000BBD EB00                <1>     jmp short $+2
   129 00000BBF E4A0                <1>     in al, pic2command    ;Get the ISR
   130 00000BC1 A880                <1>     test al, 80h
   131 00000BC3 B020                <1>     mov al, EOI    ;Still need to send EOI to pic1
   132 00000BC5 7509                <1>     jne .exit
   133 00000BC7 FE0425[21000000]    <1>     inc byte [spurint2]
   134 00000BCE EB02                <1>     jmp short .e2    ;Avoid sending EOI
   135                              <1> .exit:
   136 00000BD0 E6A0                <1>     out pic2command, al
   137                              <1> .e2:
   138 00000BD2 E620                <1>     out pic1command, al
   139 00000BD4 58                  <1>     pop rax
   140 00000BD5 48CF                <1>     iretq
   141                              <1> ;------------------------End of Interrupt------------------------
    91                                  ;========================SOFTWARE INTERRUPTS=====================
    92                                  %include "./Source/Resident/Services/Int30h.asm"
    93                              <1> ;----------------------Video Interrupt Int 30h-------------------
    94                              <1> scr_io_table:
    95 00000BD7 [A40C000000000000]  <1>     dq    scr_io.change_mode     ;AH = 0 -> Change Screen Mode (Currently no 
    96                              <1>                                  ; options)
    97 00000BDF [B30C000000000000]  <1>     dq    scr_io.set_curs_shape  ;AH = 1 -> Set Cursor Shape
    98 00000BE7 [C60C000000000000]  <1>     dq    scr_io.set_curs_pos    ;AH = 2 -> Set Cursor Position
    99 00000BEF [EA0C000000000000]  <1>     dq    scr_io.get_curs_pos    ;AH = 3 -> Get Cursor Position
   100 00000BF7 [0A0D000000000000]  <1>     dq    scr_io.write_register  ;AH = 4 -> Reserved, Undoc, Write al in ASCII 
   101                              <1>                                  ; at cursor 
   102 00000BFF [530D000000000000]  <1>     dq    scr_io.select_page     ;AH = 5 -> Select Active Page
   103 00000C07 [F90D000000000000]  <1>     dq    scr_io.scroll_up       ;AH = 6 -> Scroll Active Page up
   104 00000C0F [B70E000000000000]  <1>     dq    scr_io.scroll_down     ;AH = 7 -> Scroll Active Page down
   105 00000C17 [490F000000000000]  <1>     dq    scr_io.read_att_char   ;AH = 8 -> Read Attribute and Char at curs pos
   106 00000C1F [7B0F000000000000]  <1>     dq    scr_io.write_att_char  ;AH = 9 -> Write Attribute and Char at curs pos
   107 00000C27 [BB0F000000000000]  <1>     dq    scr_io.write_char      ;AH = 0Ah -> Write Char at curs position 
   108                              <1>                                  ; (using default attribute)
   109 00000C2F [0310000000000000]  <1>     dq    scr_io.gset_col_palette ;AH = 0Bh -> Graphics, Set Colour Palette
   110 00000C37 [1210000000000000]  <1>     dq    scr_io.gwritedot       ;AH = 0Ch -> Graphics, Write a Dot to screen
   111 00000C3F [2110000000000000]  <1>     dq    scr_io.greaddot        ;AH = 0Dh -> Graphics, Read a Dot from screen
   112 00000C47 [3010000000000000]  <1>     dq    scr_io.write_tty       ;AH = 0Eh -> Write Teletype
   113 00000C4F [FE10000000000000]  <1>     dq    scr_io.get_mode        ;AH = 0Fh -> Get Screen Mode (currently, no 
   114                              <1>                                  ; options)
   115 00000C57 [990C000000000000]  <1>     dq    scr_io.exitf           ;AH = 10h -> Reserved
   116 00000C5F [990C000000000000]  <1>     dq  scr_io.exitf             ;AH = 11h -> Reserved
   117 00000C67 [990C000000000000]  <1>     dq    scr_io.exitf           ;AH = 12h -> Reserved
   118 00000C6F [2711000000000000]  <1>     dq  scr_io.write_string      ;AH = 13h -> Write string
   119                              <1> scr_io_table_length    equ    $ - scr_io_table
   120                              <1> scr_io:
   121 00000C77 FC                  <1>     cld        ;set direction to read the right way
   122 00000C78 56                  <1>     push rsi
   123 00000C79 50                  <1>     push rax
   124 00000C7A C0E403              <1>     shl ah, 3  ;Use ah as offset into table
   125 00000C7D 80FC98              <1>     cmp ah, (scr_io_table_length - 8)    ;Ensure function number is within table
   126 00000C80 7717                <1>     ja .exitf
   127 00000C82 88E0                <1>     mov al, ah
   128 00000C84 480FB6C0            <1>     movzx rax, al               ;Zero extend ax into rax
   129 00000C88 4889C6              <1>     mov rsi, rax                ;Note rsi is not being saved here!
   130 00000C8B 58                  <1>     pop rax                     ;recover back into ax
   131 00000C8C 8A2425[58010000]    <1>     mov ah, byte [scr_mode]     ;Get the current mode into ah
   132 00000C93 FFA6[D70B0000]      <1>     jmp [scr_io_table + rsi]    ;Jump to correct function
   133                              <1> .exitf:
   134 00000C99 58                  <1>     pop rax
   135 00000C9A B480                <1>     mov ah, 80h ;Function not supported
   136 00000C9C 804C241801          <1>     or byte [rsp + 3*8h], 1 ;Set Carry flag, invalid function, skip rsi on stack
   137                              <1> .exit:
   138 00000CA1 5E                  <1>     pop rsi
   139 00000CA2 48CF                <1>     iretq
   140                              <1>     
   141                              <1> .change_mode:
   142 00000CA4 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   142 00000CAD 00                  <1>
   143 00000CAE E9EEFFFFFF          <1>     jmp .exit    ;Currently unsupported function    
   144                              <1> .set_curs_shape:
   145                              <1> ;Input: CH = Scan Row Start, CL = Scan Row End
   146 00000CB3 52                  <1>     push rdx
   147 00000CB4 66890C25[55010000]  <1>     mov word [scr_curs_shape], cx
   148                              <1> 
   149 00000CBC B00A                <1>     mov al, 0Ah
   150 00000CBE E86B050000          <1>     call .write_crtc_word
   151                              <1>     
   152 00000CC3 5A                  <1>     pop rdx
   153 00000CC4 EBDB                <1>     jmp short .exit
   154                              <1> .set_curs_pos:
   155                              <1> ;Input: DH = Row, DL = Column, BH = active page
   156 00000CC6 51                  <1>     push rcx
   157 00000CC7 52                  <1>     push rdx
   158                              <1>     
   159 00000CC8 53                  <1>     push rbx
   160 00000CC9 88FB                <1>     mov bl, bh
   161 00000CCB 480FB6DB            <1>     movzx rbx, bl
   162 00000CCF 6689941B[43010000]  <1>     mov word [scr_curs_pos + 2*rbx], dx
   163 00000CD7 5B                  <1>     pop rbx
   164 00000CD8 3A3C25[59010000]    <1>     cmp bh, byte [scr_active_page]
   165 00000CDF 7505                <1>     jne .scpexit    ;if the page is not the active page
   166 00000CE1 E8E3050000          <1>     call .cursor_proc
   167                              <1> .scpexit:
   168 00000CE6 5A                  <1>     pop rdx
   169 00000CE7 59                  <1>     pop rcx
   170 00000CE8 EBB7                <1>     jmp short .exit
   171                              <1>     
   172                              <1> 
   173                              <1> .get_curs_pos:
   174                              <1> ;Return: AX = 0, CH = Start scan line, CL = End scan line, DH = Row, DL = Column
   175 00000CEA 53                  <1>     push rbx
   176                              <1> 
   177 00000CEB 88FB                <1>     mov bl, bh
   178 00000CED 480FB6DB            <1>     movzx rbx, bl
   179 00000CF1 668B941B[43010000]  <1>     mov dx, word [scr_curs_pos + 2*rbx] 
   180 00000CF9 668B0C25[55010000]  <1>     mov cx, word [scr_curs_shape]    ;Get cursor shape
   181                              <1> 
   182 00000D01 5B                  <1>     pop rbx
   183 00000D02 6631C0              <1>     xor ax, ax 
   184 00000D05 E997FFFFFF          <1>     jmp .exit
   185                              <1> 
   186                              <1> .write_register:    ;al contains the byte to convert
   187 00000D0A 52                  <1>     push rdx
   188 00000D0B 53                  <1>     push rbx
   189 00000D0C 50                  <1>     push rax
   190                              <1> 
   191 00000D0D 88C2                <1>     mov dl, al           ;save byte in dl
   192 00000D0F 6625F000            <1>     and ax, 00F0h        ;Hi nybble
   193 00000D13 6681E20F00          <1>     and dx, 000Fh        ;Lo nybble
   194 00000D18 66C1E804            <1>     shr ax, 4            ;shift one hex place value pos right
   195 00000D1C E810000000          <1>     call .wrchar
   196 00000D21 6689D0              <1>     mov ax, dx           ;mov lo nybble, to print
   197 00000D24 E808000000          <1>     call .wrchar
   198                              <1> 
   199 00000D29 58                  <1>     pop rax
   200 00000D2A 5B                  <1>     pop rbx
   201 00000D2B 5A                  <1>     pop rdx
   202 00000D2C E970FFFFFF          <1>     jmp .exit
   203                              <1> .wrchar:
   204 00000D31 48BB-               <1>     mov rbx, .wrascii
   204 00000D33 [430D000000000000]  <1>
   205 00000D3B D7                  <1>     xlatb    ;point al to entry in ascii table, using al as offset into table
   206 00000D3C B40E                <1>     mov ah, 0Eh
   207 00000D3E B307                <1>     mov bl, 07h
   208 00000D40 CD30                <1>     int 30h  ;print char
   209 00000D42 C3                  <1>     ret
   210 00000D43 303132333435363738- <1> .wrascii:    db    '0123456789ABCDEF'
   210 00000D4C 39414243444546      <1>
   211                              <1> .select_page:
   212                              <1> ;ah contains the current screen mode
   213                              <1> ;al contains new screen page
   214                              <1> ;vga just returns as invalid FOR NOW
   215                              <1> ;Handled differently between vga and classic modes
   216 00000D53 80FC04              <1>     cmp ah, 04
   217 00000D56 761D                <1>     jbe .sp1
   218 00000D58 80FC07              <1>     cmp ah, 07
   219 00000D5B 7418                <1>     je .sp1
   220 00000D5D 80FC0D              <1>     cmp ah, 0Dh
   221 00000D60 0F838E000000        <1>     jae .sp_vga
   222                              <1> .spbad:
   223 00000D66 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   223 00000D6F 00                  <1>
   224 00000D70 E92CFFFFFF          <1>     jmp .exit    ;Bad argument
   225                              <1> .sp1:
   226 00000D75 3C08                <1>     cmp al, 8
   227 00000D77 73ED                <1>     jae .spbad    ;page should be 0-7
   228                              <1> .spmain:
   229 00000D79 50                  <1>     push rax
   230 00000D7A 53                  <1>     push rbx
   231 00000D7B 51                  <1>     push rcx
   232 00000D7C 52                  <1>     push rdx
   233 00000D7D 880425[59010000]    <1>     mov byte [scr_active_page], al    ;change active page
   234                              <1> ;----Modify this proc with data tables when finalised!!----
   235 00000D84 48BE00080000000000- <1>     mov rsi, 800h    ;mode 0,1 page size
   235 00000D8D 00                  <1>
   236 00000D8E 48BB00100000000000- <1>     mov rbx, 1000h    ;mode 2,3,7 page size
   236 00000D97 00                  <1>
   237 00000D98 480FB6C8            <1>     movzx rcx, al    ;Get count into rcx
   238 00000D9C 80FC02              <1>     cmp ah, 2
   239 00000D9F 480F42DE            <1>     cmovb rbx, rsi
   240 00000DA3 48BA00800B00000000- <1>     mov rdx, vga_bpage2
   240 00000DAC 00                  <1>
   241 00000DAD 48BE00000B00000000- <1>     mov rsi, vga_bpage1    ;Base addr for mode 7
   241 00000DB6 00                  <1>
   242                              <1> ;----Modify this proc with data tables when finalised!!----
   243 00000DB7 80FC07              <1>     cmp ah, 7
   244 00000DBA 480F44D6            <1>     cmove rdx, rsi
   245 00000DBE 52                  <1>     push rdx    ;Push the saved page 0 address
   246 00000DBF E307                <1>     jrcxz .spm2    ;If 0th page, dont add
   247                              <1> .spm1:
   248 00000DC1 4801DA              <1>     add rdx, rbx
   249 00000DC4 FEC9                <1>     dec cl
   250 00000DC6 75F9                <1>     jnz .spm1
   251                              <1> .spm2:
   252 00000DC8 5E                  <1>     pop rsi     ;Get saved base into rsi
   253 00000DC9 891425[5C010000]    <1>     mov dword [scr_page_addr], edx    ;Get new base addr
   254 00000DD0 4829F2              <1>     sub rdx, rsi    ;rsi has conditionally b8000 or b0000
   255 00000DD3 50                  <1>     push rax
   256 00000DD4 66D1EA              <1>     shr dx, 1    ;Divide dx by 2 to get # of PELs
   257 00000DD7 6689D1              <1>     mov cx, dx    ;Get offset from crtc base addr
   258 00000DDA 66B80C00            <1>     mov ax, 0Ch    ;6845 Start Addr register
   259 00000DDE E84B040000          <1>     call .write_crtc_word    ;Change "crtc view window"
   260                              <1> 
   261 00000DE3 58                  <1>     pop rax        ;Get original ax back for page number
   262 00000DE4 88C7                <1>     mov bh, al
   263 00000DE6 E8DE040000          <1>     call .cursor_proc    ;Move cursor on page
   264                              <1>     
   265 00000DEB 5A                  <1>     pop rdx
   266 00000DEC 59                  <1>     pop rcx
   267 00000DED 5B                  <1>     pop rbx
   268 00000DEE 58                  <1>     pop rax
   269 00000DEF E9ADFEFFFF          <1>     jmp .exit    ;Bad argument
   270                              <1> .sp_vga:
   271 00000DF4 E96DFFFFFF          <1>     jmp .spbad
   272                              <1> 
   273                              <1> .scroll_up:
   274                              <1> ;Scrolls ACTIVE SCREEN only
   275                              <1> ;Called with AL=number of lines to scroll, BH=Attribute for new area
   276                              <1> ;    CH=ycor of top of scroll, CL=xcor of top of scroll
   277                              <1> ;    DH=ycor of bottom of scroll, DL=xcor of bottom of scroll
   278                              <1> ;If AL=0 then entire window is blanked, BH is used for blank attrib
   279                              <1> ;ah contains the current screen mode
   280 00000DF9 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   281 00000DFC 7209                <1>     jb .su0
   282 00000DFE 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   283 00000E01 0F8509040000        <1>     jne .gscrollup    ;We in graphics mode, go to correct proc
   284                              <1> .su0:
   285 00000E07 55                  <1>     push rbp
   286 00000E08 57                  <1>     push rdi
   287 00000E09 50                  <1>     push rax    ;Treat AX more or less as clobbered 
   288                              <1>     
   289 00000E0A 84C0                <1>     test al, al   ;Check if zero
   290 00000E0C 747F                <1>     je .sblank    ;recall ah=06 then reset cursor and exit
   291 00000E0E 88C3                <1>     mov bl, al    ;Save number of lines to scroll in bl
   292                              <1> .su1:
   293 00000E10 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]    ;zeros upper dword
   294 00000E17 4889F7              <1>     mov rdi, rsi  ;Point both pointers at base of active page
   295 00000E1A 6689C8              <1>     mov ax, cx    ;Bottom top corner into ax
   296 00000E1D E870040000          <1>     call .offset_from_ax    ;Get the page offset of dx
   297 00000E22 480FB7C0            <1>     movzx rax, ax
   298 00000E26 48D1E0              <1>     shl rax, 1    ;Multiply by two for words
   299 00000E29 4801C7              <1>     add rdi, rax  ;point to the top left of window
   300 00000E2C 4801C6              <1>     add rsi, rax
   301 00000E2F 480FB60425-         <1>     movzx rax, byte [scr_cols]
   301 00000E34 [53010000]          <1>
   302 00000E38 48D1E0              <1>     shl rax, 1      ;number of columns * 2 for words!
   303 00000E3B 4801C6              <1>     add rsi, rax    ;Point rsi one row down
   304 00000E3E 51                  <1>     push rcx
   305 00000E3F 52                  <1>     push rdx
   306                              <1> 
   307 00000E40 28EE                <1>     sub dh, ch    ;work out number of rows to copy
   308                              <1> .su2:
   309 00000E42 56                  <1>     push rsi
   310 00000E43 57                  <1>     push rdi
   311 00000E44 E865040000          <1>     call .text_scroll_c1    ;Scroll the selected row
   312 00000E49 5F                  <1>     pop rdi
   313 00000E4A 5E                  <1>     pop rsi
   314 00000E4B 4801C7              <1>     add rdi, rax    ;goto next row
   315 00000E4E 4801C6              <1>     add rsi, rax
   316 00000E51 FECE                <1>     dec dh
   317 00000E53 75ED                <1>     jnz .su2
   318                              <1> 
   319 00000E55 5A                  <1>     pop rdx
   320 00000E56 59                  <1>     pop rcx
   321                              <1> ;Draw blank line
   322 00000E57 50                  <1>     push rax
   323 00000E58 51                  <1>     push rcx
   324 00000E59 57                  <1>     push rdi
   325                              <1> 
   326 00000E5A 6689C8              <1>     mov ax, cx
   327 00000E5D 88F4                <1>     mov ah, dh    ;Starting column from cx, starting row from dx
   328 00000E5F E82E040000          <1>     call .offset_from_ax
   329 00000E64 8B3C25[5C010000]    <1>     mov edi, dword [scr_page_addr]
   330 00000E6B 480FB7C0            <1>     movzx rax, ax
   331 00000E6F 48D1E0              <1>     shl rax, 1
   332 00000E72 01C7                <1>     add edi, eax   ;point to new line
   333 00000E74 88FC                <1>     mov ah, bh
   334 00000E76 B020                <1>     mov al, 20h    ;Blank char
   335 00000E78 4889E9              <1>     mov rcx, rbp   ;move word count into cx
   336 00000E7B F366AB              <1>     rep stosw      ;write the word bp number of times
   337 00000E7E 5F                  <1>     pop rdi
   338 00000E7F 59                  <1>     pop rcx
   339 00000E80 58                  <1>     pop rax
   340 00000E81 FECB                <1>     dec bl
   341 00000E83 758B                <1>     jnz .su1    ;Once we have done bl rows, exit
   342                              <1> 
   343                              <1> .suexit:
   344 00000E85 58                  <1>     pop rax
   345 00000E86 5F                  <1>     pop rdi
   346 00000E87 5D                  <1>     pop rbp
   347 00000E88 E914FEFFFF          <1>     jmp .exit
   348                              <1> .sblank:
   349                              <1> ;Fast clear function
   350 00000E8D 51                  <1>     push rcx
   351 00000E8E 52                  <1>     push rdx
   352                              <1> 
   353 00000E8F 88FC                <1>     mov ah, bh    ;mov attrib into ah
   354 00000E91 B020                <1>     mov al, 20h    ;Space char
   355 00000E93 8B3C25[5C010000]    <1>     mov edi, dword [scr_page_addr]
   356 00000E9A 480FB61425-         <1>     movzx rdx, byte [scr_rows]
   356 00000E9F [54010000]          <1>
   357                              <1> .sbl0:
   358 00000EA3 480FB60C25-         <1>     movzx rcx, byte [scr_cols]
   358 00000EA8 [53010000]          <1>
   359 00000EAC F366AB              <1>     rep stosw
   360 00000EAF FECA                <1>     dec dl
   361 00000EB1 75F0                <1>     jnz .sbl0
   362                              <1> 
   363 00000EB3 5A                  <1>     pop rdx
   364 00000EB4 59                  <1>     pop rcx
   365 00000EB5 EBCE                <1>     jmp short .suexit
   366                              <1> 
   367                              <1> .scroll_down:
   368                              <1> ;Scrolls ACTIVE SCREEN only
   369                              <1> ;Called with AL=number of lines to scroll, BH=Attribute for new area
   370                              <1> ;    CH=ycor of top of scroll, CL=xcor of top of scroll
   371                              <1> ;    DH=ycor of bottom of scroll, DL=xcor of bottom of scroll
   372                              <1> ;If AL=0 then entire window is blanked, BH is used for blank attrib
   373                              <1> ;ah contains the current screen mode
   374 00000EB7 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   375 00000EBA 7209                <1>     jb .sd0
   376 00000EBC 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   377 00000EBF 0F855A030000        <1>     jne .gscrolldown    ;We in graphics mode, go to correct proc
   378                              <1> .sd0:
   379 00000EC5 55                  <1>     push rbp
   380 00000EC6 57                  <1>     push rdi
   381 00000EC7 50                  <1>     push rax    ;Treat AX more or less as clobbered
   382                              <1> 
   383 00000EC8 84C0                <1>     test al, al    ;Check if zero
   384 00000ECA 74C1                <1>     je .sblank    ;recall ah=06 then reset cursor and exit
   385 00000ECC 88C3                <1>     mov bl, al    ;Save number of lines to scroll in bl
   386 00000ECE FD                  <1>     std    ;change the direction of string operations
   387                              <1> .sd1:
   388 00000ECF 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]    ;point esi to bottom
   389 00000ED6 6689D0              <1>     mov ax, dx    ;point to bottom right 
   390 00000ED9 E8B4030000          <1>     call .offset_from_ax
   391 00000EDE 480FB7C0            <1>     movzx rax, ax
   392 00000EE2 48D1E0              <1>     shl rax, 1
   393 00000EE5 4801C6              <1>     add rsi, rax
   394 00000EE8 4889F7              <1>     mov rdi, rsi
   395 00000EEB 480FB60425-         <1>     movzx rax, byte [scr_cols]
   395 00000EF0 [53010000]          <1>
   396 00000EF4 48D1E0              <1>     shl rax, 1
   397 00000EF7 4829C6              <1>     sub rsi, rax    ;Point rsi one row above rdi
   398                              <1> 
   399 00000EFA 51                  <1>     push rcx
   400 00000EFB 52                  <1>     push rdx
   401 00000EFC 28EE                <1>     sub dh, ch    ;Number of rows to copy
   402                              <1> .sd2:
   403 00000EFE 56                  <1>     push rsi
   404 00000EFF 57                  <1>     push rdi
   405 00000F00 E8A9030000          <1>     call .text_scroll_c1
   406 00000F05 5F                  <1>     pop rdi
   407 00000F06 5E                  <1>     pop rsi
   408 00000F07 4829C7              <1>     sub rdi, rax
   409 00000F0A 4829C6              <1>     sub rsi, rax
   410 00000F0D FECE                <1>     dec dh
   411 00000F0F 75ED                <1>     jnz .sd2
   412                              <1> 
   413 00000F11 5A                  <1>     pop rdx
   414 00000F12 59                  <1>     pop rcx
   415                              <1> ;Draw blank line
   416 00000F13 50                  <1>     push rax
   417 00000F14 51                  <1>     push rcx
   418 00000F15 57                  <1>     push rdi
   419                              <1> 
   420 00000F16 6689D0              <1>     mov ax, dx
   421 00000F19 88EC                <1>     mov ah, ch    ;Starting column from dx, starting row from cx
   422 00000F1B E872030000          <1>     call .offset_from_ax
   423 00000F20 8B3C25[5C010000]    <1>     mov edi, dword [scr_page_addr]
   424 00000F27 480FB7C0            <1>     movzx rax, ax
   425 00000F2B 48D1E0              <1>     shl rax, 1
   426 00000F2E 01C7                <1>     add edi, eax    ;Point to appropriate line and col
   427 00000F30 88FC                <1>     mov ah, bh
   428 00000F32 B020                <1>     mov al, 20h
   429 00000F34 4889E9              <1>     mov rcx, rbp
   430 00000F37 F366AB              <1>     rep stosw    ;Store backwards
   431 00000F3A 5F                  <1>     pop rdi
   432 00000F3B 59                  <1>     pop rcx
   433 00000F3C 58                  <1>     pop rax
   434 00000F3D FECB                <1>     dec bl
   435 00000F3F 758E                <1>     jnz .sd1
   436                              <1> 
   437                              <1> .sdexit:
   438 00000F41 58                  <1>     pop rax
   439 00000F42 5F                  <1>     pop rdi
   440 00000F43 5D                  <1>     pop rbp
   441 00000F44 E958FDFFFF          <1>     jmp .exit
   442                              <1> .read_att_char:
   443                              <1> ;Get ASCII char and attr at current cursor position on chosen page
   444                              <1> ;Called with AH=08h, BH=Page number (if supported),
   445                              <1> ;Returns, AH=Attrib, AL=Char
   446                              <1> 
   447                              <1> ;On entry, ah contains current screen mode
   448 00000F49 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   449 00000F4C 7209                <1>     jb .rac1
   450 00000F4E 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   451 00000F51 0F859B020000        <1>     jne .gread    ;We in graphics mode, go to correct proc
   452                              <1> .rac1:
   453 00000F57 80FF07              <1>     cmp bh, 7
   454 00000F5A 0F8739FDFFFF        <1>     ja .exitf    ;All A/N modes can have 8 pages, any more, fail
   455                              <1> 
   456 00000F60 88E3                <1>     mov bl, ah    ;Move screen mode into bl for function call
   457 00000F62 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   458 00000F69 E814030000          <1>     call .page_cursor_offset    ;bx preserved
   459 00000F6E 48D1E0              <1>     shl rax, 1        
   460 00000F71 4801C6              <1>     add rsi, rax    ;rsi should point to attrib/char 
   461 00000F74 66AD                <1>     lodsw            ;Load ah with attrib/char
   462 00000F76 E926FDFFFF          <1>     jmp .exit    ;Restoring rsi
   463                              <1> 
   464                              <1> .write_att_char:
   465                              <1> ;Puts ASCII char and attribute/colour at cursor
   466                              <1> ;Called with AH=09h, AL=Char, BH=Page, 
   467                              <1> ;    BL=Attrib/Color, CX=number of repeats
   468                              <1> ;Returns nothing (just prints in page)
   469                              <1> 
   470                              <1> ;When called, ah contains current screen mode
   471 00000F7B 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   472 00000F7E 7209                <1>     jb .wac1
   473 00000F80 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   474 00000F83 0F8578020000        <1>     jne .gwrite    ;We in graphics mode, go to correct proc
   475                              <1> .wac1:
   476 00000F89 80FF07              <1>     cmp bh, 7
   477 00000F8C 0F8707FDFFFF        <1>     ja .exitf    ;All A/N modes can have 8 pages, any more, fail
   478                              <1> 
   479 00000F92 86DC                <1>     xchg bl, ah ;swap attrib and scr mode bytes
   480 00000F94 57                  <1>     push rdi
   481 00000F95 50                  <1>     push rax    ;Save the char/attrib word
   482 00000F96 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   483 00000F9D E8E0020000          <1>     call .page_cursor_offset    ;bx preserved
   484 00000FA2 4889F7              <1>     mov rdi, rsi    ;Change register for string ops
   485 00000FA5 48D1E0              <1>     shl rax, 1
   486 00000FA8 4801C7              <1>     add rdi, rax    ;rsi now points to right place on right page
   487 00000FAB 58                  <1>     pop rax
   488                              <1> 
   489 00000FAC 51                  <1>     push rcx
   490 00000FAD 480FB7C9            <1>     movzx rcx, cx    ;zero upper bytes
   491 00000FB1 F366AB              <1>     rep stosw        ;Store packed ah/al cx times
   492 00000FB4 59                  <1>     pop rcx
   493 00000FB5 5F                  <1>     pop rdi
   494 00000FB6 E9E6FCFFFF          <1>     jmp .exit    ;Restoring rsi
   495                              <1> 
   496                              <1> .write_char:
   497                              <1> ;Puts ASCII char and attribute/colour at cursor
   498                              <1> ;Called with AH=0Ah, AL=Char, BH=Page, 
   499                              <1> ;    BL=Color (G modes ONLY), CX=number of repeats
   500                              <1> ;Returns nothing (just prints in page)
   501 00000FBB 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   502 00000FBE 7209                <1>     jb .wc1
   503 00000FC0 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   504 00000FC3 0F8538020000        <1>     jne .gwrite    ;We in graphics mode, go to correct proc
   505                              <1> .wc1:
   506 00000FC9 80FF07              <1>     cmp bh, 7
   507 00000FCC 0F87C7FCFFFF        <1>     ja .exitf    ;All A/N modes can have 8 pages, any more, fail
   508                              <1> 
   509 00000FD2 88E3                <1>     mov bl, ah ;mov scr mode byte into bl
   510 00000FD4 57                  <1>     push rdi
   511 00000FD5 50                  <1>     push rax    ;Save the char word
   512 00000FD6 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   513 00000FDD E8A0020000          <1>     call .page_cursor_offset    ;bx preserved
   514 00000FE2 4889F7              <1>     mov rdi, rsi    ;Change register for string ops
   515 00000FE5 48D1E0              <1>     shl rax, 1
   516 00000FE8 4801C7              <1>     add rdi, rax    ;rdi now points to right place on right page
   517 00000FEB 58                  <1>     pop rax
   518                              <1> 
   519 00000FEC 51                  <1>     push rcx
   520 00000FED 480FB7C9            <1>     movzx rcx, cx    ;zero upper bytes
   521 00000FF1 E309                <1>     jrcxz .wc3    ;If cx is zero, dont print anything, exit
   522                              <1> .wc2:
   523 00000FF3 AA                  <1>     stosb
   524 00000FF4 48FFC7              <1>     inc rdi
   525 00000FF7 48FFC9              <1>     dec rcx
   526 00000FFA 75F7                <1>     jnz .wc2
   527                              <1> .wc3:
   528 00000FFC 59                  <1>     pop rcx
   529 00000FFD 5F                  <1>     pop rdi
   530 00000FFE E99EFCFFFF          <1>     jmp .exit    ;Exit restoring rsi
   531                              <1> 
   532                              <1> .gset_col_palette:
   533 00001003 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   533 0000100C 00                  <1>
   534 0000100D E98FFCFFFF          <1>     jmp .exit    ;Currently unsupported function
   535                              <1> .gwritedot:
   536 00001012 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   536 0000101B 00                  <1>
   537 0000101C E980FCFFFF          <1>     jmp .exit    ;Currently unsupported function
   538                              <1> .greaddot:
   539 00001021 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   539 0000102A 00                  <1>
   540 0000102B E971FCFFFF          <1>     jmp .exit    ;Currently unsupported function
   541                              <1> 
   542                              <1> .write_tty:
   543                              <1> ;Called with al=char, bl=foreground color (graphics)
   544                              <1> ;When called, ah contains current screen mode
   545 00001030 51                  <1>     push rcx
   546 00001031 52                  <1>     push rdx
   547 00001032 53                  <1>     push rbx
   548 00001033 50                  <1>     push rax
   549                              <1> 
   550 00001034 8A3C25[59010000]    <1>     mov bh, byte [scr_active_page]    ;Get active page
   551 0000103B 50                  <1>     push rax
   552 0000103C B403                <1>     mov ah, 3    ;Get cursor into dx
   553 0000103E CD30                <1>     int 30h
   554 00001040 58                  <1>     pop rax
   555                              <1> 
   556 00001041 3C08                <1>     cmp al, 08h    ;Check for backspace
   557 00001043 746B                <1>     je .wttybspace
   558 00001045 3C0A                <1>     cmp al, 0Ah    ;Check for line feed
   559 00001047 747F                <1>     je .wttylf
   560 00001049 3C0D                <1>     cmp al, 0Dh    ;Check for carriage return
   561 0000104B 0F848D000000        <1>     je .wttycr
   562 00001051 3C07                <1>     cmp al, 07h    ;ASCII bell
   563 00001053 0F848C000000        <1>     je .wttybell
   564                              <1> 
   565                              <1> .wttywrite:
   566 00001059 48B901000000000000- <1>     mov rcx, 1    
   566 00001062 00                  <1>
   567 00001063 B40A                <1>     mov ah, 0Ah    ;Write 1 char w/o attrib byte
   568 00001065 CD30                <1>     int 30h    ;bh contains page to write for
   569                              <1> 
   570                              <1> .wttycursorupdate:
   571 00001067 FEC2                <1>     inc dl
   572 00001069 3A1425[53010000]    <1>     cmp dl, byte [scr_cols]
   573 00001070 730D                <1>     jae .wttycu0    ;go down by a line, and start of the line
   574                              <1> .wttycursorupdatego:
   575 00001072 B402                <1>     mov ah, 2
   576 00001074 CD30                <1>     int 30h     ;set cursor
   577                              <1> .wttyexit:
   578 00001076 58                  <1>     pop rax
   579 00001077 5B                  <1>     pop rbx
   580 00001078 5A                  <1>     pop rdx
   581 00001079 59                  <1>     pop rcx
   582 0000107A E922FCFFFF          <1>     jmp .exit
   583                              <1> 
   584                              <1> .wttycu0:
   585 0000107F 30D2                <1>     xor dl, dl    ;Return to start of line
   586 00001081 FEC6                <1>     inc dh
   587 00001083 3A3425[54010000]    <1>     cmp dh, byte [scr_rows]    ;are past the bottom of the screen?
   588 0000108A 72E6                <1>     jb .wttycursorupdatego    ;we are not past the bottom of the screen
   589                              <1> .wttyscrollupone:
   590 0000108C 53                  <1>     push rbx
   591 0000108D B408                <1>     mov ah, 08h    ;Read char/attrib at cursor
   592 0000108F CD30                <1>     int 30h
   593 00001091 88E7                <1>     mov bh, ah    ;Move attrib byte into bh
   594 00001093 4831C9              <1>     xor rcx, rcx
   595 00001096 668B1425[53010000]  <1>     mov dx, word [scr_cols]    ;word access all ok
   596 0000109E FECE                <1>     dec dh
   597 000010A0 FECA                <1>     dec dl
   598 000010A2 66B80106            <1>     mov ax, 0601h    ;scroll up one line
   599 000010A6 CD30                <1>     int 30h
   600                              <1> 
   601 000010A8 30D2                <1>     xor dl, dl 
   602 000010AA 5B                  <1>     pop rbx
   603 000010AB E9C2FFFFFF          <1>     jmp .wttycursorupdatego
   604                              <1> .wttybspace:
   605 000010B0 84D2                <1>     test dl, dl    ;compare if the column is zero
   606 000010B2 750D                <1>     jnz .wttybs1   ;if not just decrement row pos
   607 000010B4 84F6                <1>     test dh, dh    ;compare if zero row, if so do nothing
   608 000010B6 74BE                <1>     jz .wttyexit   ;at top left, just exit
   609 000010B8 FECE                <1>     dec dh
   610 000010BA 8A1425[53010000]    <1>     mov dl, byte [scr_cols]    ;move to end of prev row + 1
   611                              <1> .wttybs1:
   612 000010C1 FECA                <1>     dec dl
   613 000010C3 E9AAFFFFFF          <1>     jmp .wttycursorupdatego
   614                              <1> 
   615                              <1> .wttylf:
   616 000010C8 52                  <1>     push rdx
   617 000010C9 8A1425[54010000]    <1>     mov dl, byte [scr_rows]
   618 000010D0 FECA                <1>     dec dl
   619 000010D2 38D6                <1>     cmp dh, dl
   620 000010D4 5A                  <1>     pop rdx
   621 000010D5 74B5                <1>     je .wttyscrollupone    ;if we need to scroll, scroll
   622 000010D7 FEC6                <1>     inc dh    ;otherwise just send cursor down by one
   623 000010D9 E994FFFFFF          <1>     jmp    .wttycursorupdatego
   624                              <1> .wttycr:
   625 000010DE B200                <1>     mov dl, 0    ;Set to 0 on row
   626 000010E0 E98DFFFFFF          <1>     jmp .wttycursorupdatego
   627                              <1> .wttybell:
   628 000010E5 48B9E8030000000000- <1>     mov rcx, 1000   ;Beep for a second
   628 000010EE 00                  <1>
   629 000010EF BBA9040000          <1>     mov ebx, 04A9h  ;Frequency divisor for 1000Hz tone
   630 000010F4 E89DEFFFFF          <1>     call beep
   631 000010F9 E978FFFFFF          <1>     jmp .wttyexit
   632                              <1> 
   633                              <1> .get_mode:
   634                              <1> ;Takes no arguments
   635                              <1> ;Returns ah=Number of Columns, al=Current Screen mode, bh=active page
   636 000010FE 8A2425[53010000]    <1>     mov ah, byte [scr_cols]
   637 00001105 8A0425[58010000]    <1>     mov al, byte [scr_mode]
   638 0000110C 8A3C25[59010000]    <1>     mov bh, byte [scr_active_page]
   639 00001113 E989FBFFFF          <1>     jmp .exit
   640                              <1> 
   641                              <1> 
   642                              <1> ;Bad string argument for below function
   643                              <1> .wsbad:
   644 00001118 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   644 00001121 00                  <1>
   645 00001122 E97AFBFFFF          <1>     jmp .exit
   646                              <1> .write_string:
   647                              <1> ;bh=page to print on, bl=attribute, cx=number of chars to print
   648                              <1> ;dh=y coord to print at, dl=x coord to print at, rbp=string
   649                              <1> ;al contains subfunction
   650                              <1> ;al=0 attrib in bl, cursor NOT updated
   651                              <1> ;al=1 attrib in bl, cursor updated
   652                              <1> ;al=2 string alt attrib/char, cursor NOT updated
   653                              <1> ;al=3 string alt attrib/char, cursor updated
   654                              <1> ;al=4 print 0 terminated string
   655 00001127 3C04                <1>     cmp al, 4h
   656 00001129 0F84AA000000        <1>     je .wszero    ;If its a zero terminated string, go down
   657 0000112F E3E7                <1>     jrcxz .wsbad
   658 00001131 3C04                <1>     cmp al, 4h    ;Bad argument
   659 00001133 77E3                <1>     ja .wsbad
   660                              <1> .ws:
   661 00001135 56                  <1>     push rsi
   662 00001136 51                  <1>     push rcx
   663 00001137 52                  <1>     push rdx
   664 00001138 53                  <1>     push rbx
   665 00001139 50                  <1>     push rax
   666                              <1> 
   667 0000113A 53                  <1>     push rbx
   668 0000113B 88FB                <1>     mov bl, bh
   669 0000113D 0FB6DB              <1>     movzx ebx, bl
   670 00001140 66678BB41B-         <1>     mov si, word [scr_curs_pos + 2*ebx]    ;Fast get cursor position
   670 00001145 [43010000]          <1>
   671 00001149 5B                  <1>     pop rbx
   672 0000114A 56                  <1>     push rsi    ;Save the current cursor position
   673                              <1> 
   674 0000114B 50                  <1>     push rax
   675 0000114C B402                <1>     mov ah, 02h    ;Set cursor at dx
   676 0000114E CD30                <1>     int 30h
   677 00001150 58                  <1>     pop rax
   678                              <1> 
   679                              <1> .ws0:
   680 00001151 51                  <1>     push rcx
   681 00001152 53                  <1>     push rbx
   682 00001153 50                  <1>     push rax
   683 00001154 88C4                <1>     mov ah, al
   684 00001156 8A4500              <1>     mov al, byte [rbp] ;Get char
   685 00001159 48FFC5              <1>     inc rbp
   686 0000115C 3C07                <1>     cmp al, 07h
   687 0000115E 7462                <1>     je .wsctrlchar
   688 00001160 3C08                <1>     cmp al, 08h
   689 00001162 745E                <1>     je .wsctrlchar
   690 00001164 3C0A                <1>     cmp al, 0Ah
   691 00001166 745A                <1>     je .wsctrlchar
   692 00001168 3C0D                <1>     cmp al, 0Dh
   693 0000116A 7456                <1>     je .wsctrlchar
   694                              <1> 
   695 0000116C 80FC02              <1>     cmp ah, 2    ;Check if we need to get the char attrib too
   696 0000116F 7206                <1>     jb .ws1
   697 00001171 8A5D00              <1>     mov bl, byte [rbp]    ;Get char attrib
   698 00001174 48FFC5              <1>     inc rbp
   699                              <1> .ws1:
   700 00001177 66B90100            <1>     mov cx, 1
   701 0000117B B409                <1>     mov ah, 09h    ;Print char and attrib (either given or taken)
   702 0000117D CD30                <1>     int 30h
   703                              <1> 
   704 0000117F FEC2                <1>     inc dl
   705 00001181 3A1425[53010000]    <1>     cmp dl, byte [scr_cols]    ;Check if we passed the end of the row
   706 00001188 7515                <1>     jne .ws2    ;We havent, skip the reset
   707 0000118A 30D2                <1>     xor dl, dl    ;Reset horizontal pos
   708 0000118C FEC6                <1>     inc dh        ;Goto next row
   709 0000118E 3A3425[53010000]    <1>     cmp dh, byte [scr_cols]    ;Have we passed the last row?
   710 00001195 7508                <1>     jne .ws2    ;No, put cursor
   711 00001197 66B80A0E            <1>     mov ax, 0E0Ah    ;Yes, do  TTY Line feed
   712 0000119B CD30                <1>     int 30h
   713 0000119D FECE                <1>     dec dh        ;Mov cursor to start of last row on page
   714                              <1> .ws2:
   715 0000119F B402                <1>     mov ah, 02
   716 000011A1 CD30                <1>     int 30h    ;Put cursor at new location
   717                              <1> .ws3:
   718 000011A3 58                  <1>     pop rax
   719 000011A4 5B                  <1>     pop rbx
   720 000011A5 59                  <1>     pop rcx
   721                              <1> 
   722 000011A6 66FFC9              <1>     dec cx
   723 000011A9 75A6                <1>     jnz .ws0
   724                              <1> 
   725                              <1> .wsexitupdate:    ;Exit returning char to original position
   726 000011AB 5A                  <1>     pop rdx
   727 000011AC 3C01                <1>     cmp al, 01h
   728 000011AE 7408                <1>     je .wsexit
   729 000011B0 3C03                <1>     cmp al, 03h
   730 000011B2 7404                <1>     je .wsexit
   731                              <1> ;Exit returning char to original position    
   732 000011B4 B402                <1>     mov ah, 02h
   733 000011B6 CD30                <1>     int 30h 
   734                              <1> .wsexit:
   735 000011B8 58                  <1>     pop rax
   736 000011B9 5B                  <1>     pop rbx
   737 000011BA 5A                  <1>     pop rdx
   738 000011BB 59                  <1>     pop rcx
   739 000011BC 5E                  <1>     pop rsi
   740 000011BD E9DFFAFFFF          <1>     jmp .exit
   741                              <1> .wsctrlchar:
   742                              <1> ;Handles Control Characters: ASCII Bell, Bspace, LF and CR
   743 000011C2 B40E                <1>     mov ah, 0Eh
   744 000011C4 CD30                <1>     int 30h    ;Print control char as TTY
   745 000011C6 88FB                <1>     mov bl, bh
   746 000011C8 0FB6DB              <1>     movzx ebx, bl
   747 000011CB 66678B941B-         <1>     mov dx, word [scr_curs_pos + 2*ebx]    ;Fast get cursor position
   747 000011D0 [43010000]          <1>
   748 000011D4 E9CAFFFFFF          <1>     jmp .ws3
   749                              <1> .wszero:
   750                              <1> ;Print zero terminated string at cursor on current active page
   751                              <1> ;Called with ax=1304, rbp=pointer to string
   752 000011D9 55                  <1>     push rbp
   753 000011DA 50                  <1>     push rax
   754                              <1> .wsz1:
   755 000011DB 8A4500              <1>     mov al, byte [rbp]
   756 000011DE 84C0                <1>     test al, al    ;Check al got a zero char
   757 000011E0 7409                <1>     jz .wsz2
   758 000011E2 48FFC5              <1>     inc rbp
   759 000011E5 B40E                <1>     mov ah, 0Eh
   760 000011E7 CD30                <1>     int 30h
   761 000011E9 EBF0                <1>     jmp short .wsz1
   762                              <1> .wsz2:
   763 000011EB 58                  <1>     pop rax
   764 000011EC 5D                  <1>     pop rbp
   765 000011ED E9AFFAFFFF          <1>     jmp .exit
   766                              <1> 
   767                              <1> ;Graphics mode specific versions!
   768                              <1> .gread:
   769 000011F2 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   769 000011FB 00                  <1>
   770 000011FC E9A0FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   771                              <1> .gwrite:
   772 00001201 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   772 0000120A 00                  <1>
   773 0000120B E991FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   774                              <1> .gscrollup:
   775 00001210 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   775 00001219 00                  <1>
   776 0000121A E982FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   777                              <1> .gscrolldown:
   778 0000121F 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   778 00001228 00                  <1>
   779 00001229 E973FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   780                              <1> 
   781                              <1> .write_crtc_word: ;Writes cx to the CRTC register in al and al+1
   782 0000122E 52                  <1>     push rdx
   783                              <1> 
   784 0000122F 668B1425[5A010000]  <1>     mov dx, word [scr_crtc_base]
   785 00001237 EE                  <1>     out dx, al
   786 00001238 FEC2                <1>     inc dl
   787 0000123A 88C4                <1>     mov ah, al    ;Temp save al
   788 0000123C 88E8                <1>     mov al, ch    ;Set high bits first
   789 0000123E EE                  <1>     out dx, al
   790                              <1> 
   791 0000123F FECA                <1>     dec dl
   792 00001241 88E0                <1>     mov al, ah    ;Bring back al into al
   793 00001243 FEC0                <1>     inc al ;GOTO next CTRC address
   794                              <1> 
   795 00001245 EE                  <1>     out dx, al
   796 00001246 FEC2                <1>     inc dl
   797 00001248 88C8                <1>     mov al, cl
   798 0000124A EE                  <1>     out dx, al 
   799                              <1> 
   800 0000124B 5A                  <1>     pop rdx
   801 0000124C C3                  <1>     ret
   802                              <1> 
   803                              <1> .get_page_base:
   804                              <1> ;Returns in rsi, the base address of the selected page
   805                              <1> ;Called with BH = page number, BL=screen mode
   806                              <1> ;return RSI=Base of selected page, since rsi is already clobbered
   807 0000124D 51                  <1>     push rcx
   808 0000124E 53                  <1>     push rbx
   809                              <1> 
   810 0000124F 88F9                <1>     mov cl, bh    ;mov into cl, free bx
   811 00001251 480FB6C9            <1>     movzx rcx, cl
   812                              <1> ;----Modify this proc with data tables when finalised!!----
   813 00001255 80FB02              <1>     cmp bl, 2
   814 00001258 66BB0010            <1>     mov bx, 1000h    ;Doesnt affect flags
   815 0000125C 48BE00080000000000- <1>     mov rsi, 800h    ;si is a free register
   815 00001265 00                  <1>
   816 00001266 660F42DE            <1>     cmovb bx, si    ;if below, replace with 800h
   817 0000126A 480FB7DB            <1>     movzx rbx, bx        ;zero extend
   818 0000126E 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   819 00001275 E308                <1>     jrcxz .gpb1        ;Dont enter the loop if cx is zero
   820                              <1> .gpb0:
   821 00001277 4801DE              <1>     add rsi, rbx    ;add pagesize cx times
   822 0000127A 48FFC9              <1>     dec rcx
   823 0000127D 75F8                <1>     jnz .gpb0        ;go around
   824                              <1> 
   825                              <1> .gpb1:
   826 0000127F 5B                  <1>     pop rbx
   827 00001280 59                  <1>     pop rcx
   828 00001281 C3                  <1>     ret
   829                              <1> 
   830                              <1> .page_cursor_offset:
   831                              <1> ;Returns in rax the offset into the RAM page of the cursor
   832                              <1> ;Works for A/N modes and graphic, though must be shl by 1 for A/N modes
   833                              <1> ;bh contains page to work out address 
   834 00001282 53                  <1>     push rbx
   835 00001283 88FB                <1>     mov bl, bh    ;bring the page number from bh into bl
   836 00001285 480FB6DB            <1>     movzx rbx, bl            
   837 00001289 668B841B[43010000]  <1>     mov ax, word [scr_curs_pos + 2*rbx]    ;move cursor position into ax
   838 00001291 5B                  <1>     pop rbx
   839                              <1> .offset_from_ax:
   840                              <1> ;Same as above but now ax needs to be packed as in the cursor
   841 00001292 52                  <1>     push rdx
   842 00001293 53                  <1>     push rbx
   843 00001294 4831DB              <1>     xor rbx, rbx
   844 00001297 00C3                <1>     add bl, al    ;move columns into bl
   845 00001299 66C1E808            <1>     shr ax, 8    ;mov rows from ah to al to use 8 bit mul
   846                              <1>     
   847 0000129D F62425[53010000]    <1>     mul byte [scr_cols]    ;multiply the row we are on by columns, store in ax
   848 000012A4 6601D8              <1>     add ax, bx        ;add number of columns to this mix!
   849 000012A7 480FB7C0            <1>     movzx rax, ax
   850                              <1> 
   851 000012AB 5B                  <1>     pop rbx
   852 000012AC 5A                  <1>     pop rdx
   853 000012AD C3                  <1>     ret
   854                              <1> .text_scroll_c1:
   855                              <1> ;Common function
   856                              <1> ;Scrolls a single pair of lines from column given in cl to dl
   857                              <1> ;rsi/rdi assumed to be pointing at the right place
   858                              <1> ;Direction to be set by calling function
   859                              <1> ;All registers EXCEPT pointers preserved, rbp returns # of words
   860 000012AE 51                  <1>     push rcx
   861 000012AF 52                  <1>     push rdx
   862 000012B0 4831ED              <1>     xor rbp, rbp
   863 000012B3 88CE                <1>     mov dh, cl    ;Save upper left corner in dh, freeing cx
   864 000012B5 88D1                <1>     mov cl, dl    
   865 000012B7 28F1                <1>     sub cl, dh    ;Get correct number of words to copy into cl
   866 000012B9 480FB6C9            <1>     movzx rcx, cl
   867 000012BD 48FFC1              <1>     inc rcx    ;absolute value, not offset
   868 000012C0 4889CD              <1>     mov rbp, rcx    ;Save number of words in rbp
   869 000012C3 F366A5              <1>     rep movsw    ;Move char/attrib for one row
   870 000012C6 5A                  <1>     pop rdx
   871 000012C7 59                  <1>     pop rcx
   872 000012C8 C3                  <1>     ret
   873                              <1> .cursor_proc:
   874                              <1> ;Called with bh containing page number
   875                              <1> ;Sets cursor on page in bh
   876                              <1> ;Returns nothing
   877 000012C9 E8B4FFFFFF          <1>     call .page_cursor_offset    ;rax rets offset, no shift needed
   878                              <1> 
   879 000012CE 88F9                <1>     mov cl, bh
   880 000012D0 480FB6C9            <1>     movzx rcx, cl
   881                              <1> ;----Modify this proc with data tables when finalised!!----
   882 000012D4 6631F6              <1>     xor si, si    
   883 000012D7 66BA0008            <1>     mov dx, 800h ;Most legacy Pages are sized 800h PELs, VGA greater
   884 000012DB 803C25[58010000]02  <1>     cmp byte [scr_mode], 2
   885 000012E3 7303                <1>     jae .cp1
   886 000012E5 66D1EA              <1>     shr dx, 1    ;If in modes 0,1, 400h PELs per page
   887                              <1> .cp1:
   888 000012E8 84C9                <1>     test cl, cl
   889 000012EA 7407                <1>     jz .cpwrite
   890 000012EC 6601D6              <1>     add si, dx 
   891 000012EF FEC9                <1>     dec cl
   892 000012F1 75F5                <1>     jnz .cp1
   893                              <1> 
   894                              <1> .cpwrite:
   895 000012F3 6689C1              <1>     mov cx, ax    ;move ax into cx
   896 000012F6 6601F1              <1>     add cx, si
   897 000012F9 B00E                <1>     mov al, 0Eh    ;Cursor row
   898 000012FB E82EFFFFFF          <1>     call .write_crtc_word    ;cx has data to output, al is crtc reg
   899                              <1> 
   900 00001300 C3                  <1>     ret
   901                              <1> ;------------------------End of Interrupt------------------------
    93                                  %include "./Source/Resident/Services/Int31h.asm"
    94                              <1> ;-----------------------Basic Config Int 31h---------------------
    95                              <1> ;This interrupt returns in ax the Hardware Bitfield from the 
    96                              <1> ; data area and the mass storage device details.
    97                              <1> ;----------------------------------------------------------------
    98                              <1> machineWord_io:
    99 00001301 668B0425[C9010000]  <1>     mov ax, word [MachineWord]    ;Return the legacy bitfield
   100                              <1> 
   101 00001309 4C0FB60425-         <1>     movzx r8, byte [i33Devices] ;Get Number of i33h devices
   101 0000130E [A8010000]          <1>
   102 00001312 49C1E008            <1>     shl r8, 8   ;Shift up by a byte
   103 00001316 448A0425[4B020000]  <1>     mov r8b, byte [numMSD]  ;Get the number of Mass Storage Devices (on EHCI)
   104 0000131E 49C1E008            <1>     shl r8, 8   ;Shift up by a byte again
   105 00001322 448A0425[AA010000]  <1>     mov r8b, byte [fdiskNum]    ;Get the number of fixed disks
   106 0000132A 49C1E008            <1>     shl r8, 8  ;Shift up by a byte again
   107 0000132E 448A0425[66000000]  <1>     mov r8b, byte [numCOM]      ;Get the number of COM ports
   108                              <1> 
   109 00001336 48CF                <1>     iretq
   110                              <1> ;------------------------End of Interrupt------------------------
    94                                  %include "./Source/Resident/Services/Int32h.asm"
    95                              <1> ;------------------------Basic RAM Int 32h-----------------------
    96                              <1> ;This interrupt returns in ax amount of conventional memory in ax
    97                              <1> ;----------------------------------------------------------------
    98                              <1> convRAM_io:
    99 00001338 668B0425[CB010000]  <1>     mov ax, word [convRAM]    ;Return the amount of conventional RAM
   100 00001340 4C8B0425[CD010000]  <1>     mov r8, qword [userBase]    ;Return the userbase to a caller
   101 00001348 4C8B0C25[F0050000]  <1>     mov r9, qword [bigmapptr]   ;Return the big Map pointer 
   102 00001350 4C0FB61425-         <1>     movzx r10, byte [bigmapSize]    ;Return the number of 24 byte entries
   102 00001355 [D5010000]          <1>
   103 00001359 48CF                <1>     iretq
   104                              <1> ;------------------------End of Interrupt------------------------
    95                                  %include "./Source/Resident/Services/Int33h.asm"
    96                              <1> ;---------------------Storage Interrupt Int 33h------------------
    97                              <1> ;Input : dl = Drive number, rbx = Address of buffer, 
    98                              <1> ;        al = number of sectors, ch = Track number, 
    99                              <1> ;        cl = Sector number, dh = Head number
   100                              <1> ;Input LBA: dl = Drive Number, rbx = Address of Buffer, 
   101                              <1> ;           al = number of sectors, rcx = LBA number
   102                              <1> ;
   103                              <1> ;All registers not mentioned above, preserved
   104                              <1> ;----------------------------------------------------------------
   105                              <1> disk_io:
   106 0000135B FC                  <1>     cld ;Ensure all string reads/writes are in the right way
   107 0000135C F6C280              <1>     test dl, 80h
   108 0000135F 0F8540070000        <1>     jnz fdisk_io    ;If bit 7 set, goto Fixed disk routines
   109 00001365 52                  <1>     push rdx
   110 00001366 FEC2                <1>     inc dl          ;Inc device number count to absolute value
   111 00001368 3A1425[4B020000]    <1>     cmp dl, byte [numMSD]   ;For now, numMSD, eventually, numRemDrv
   112 0000136F 5A                  <1>     pop rdx
   113 00001370 0F8786000000        <1>     ja .baddev
   114 00001376 80FC16              <1>     cmp ah, 16h
   115 00001379 0F84E3030000        <1>     jz .deviceChanged   ;Pick it off
   116                              <1> 
   117 0000137F E8B4040000          <1>     call .busScan   ;Bus scan only in valid cases
   118 00001384 803C25[A9010000]40  <1>     cmp byte [msdStatus], 40h   ;Media seek failed
   119 0000138C 747E                <1>     je .noDevInDrive
   120                              <1> 
   121 0000138E 84E4                <1>     test ah, ah
   122 00001390 0F8484000000        <1>     jz .reset           ;ah = 00h Reset Device
   123 00001396 FECC                <1>     dec ah
   124 00001398 0F84AF000000        <1>     jz .statusreport    ;ah = 01h Get status of last op and req. sense if ok 
   125                              <1> 
   126 0000139E C60425[A9010000]00  <1>     mov byte [msdStatus], 00    ;Reset status byte for following operations
   127                              <1> 
   128 000013A6 FECC                <1>     dec ah
   129 000013A8 0F841E010000        <1>     jz .readsectors     ;ah = 02h CHS Read Sectors
   130 000013AE FECC                <1>     dec ah
   131 000013B0 0F843E010000        <1>     jz .writesectors    ;ah = 03h CHS Write Sectors
   132 000013B6 FECC                <1>     dec ah
   133 000013B8 0F8457010000        <1>     jz .verify          ;ah = 04h CHS Verify Sectors
   134 000013BE FECC                <1>     dec ah
   135 000013C0 0F8470010000        <1>     jz .format          ;ah = 05h CHS Format Track (Select Head and Cylinder)
   136                              <1> 
   137 000013C6 80FC02              <1>     cmp ah, 02h
   138 000013C9 0F84A1020000        <1>     je .formatLowLevel  ;ah = 07h (SCSI) Low Level Format Device
   139                              <1> 
   140 000013CF 80FC7D              <1>     cmp ah, 7Dh         ;ah = 82h LBA Read Sectors
   141 000013D2 0F84E5010000        <1>     je .lbaread
   142 000013D8 80FC7E              <1>     cmp ah, 7Eh         ;ah = 83h LBA Write Sectors
   143 000013DB 0F8401020000        <1>     je .lbawrite
   144 000013E1 80FC7F              <1>     cmp ah, 7Fh         ;ah = 84h LBA Verify Sectors
   145 000013E4 0F841D020000        <1>     je .lbaverify
   146 000013EA 80FC80              <1>     cmp ah, 80h         ;ah = 85h LBA Format Sectors
   147 000013ED 0F8439020000        <1>     je .lbaformat
   148 000013F3 80FC83              <1>     cmp ah, 83h         ;ah = 88h LBA Read Drive Parameters
   149 000013F6 0F8496020000        <1>     je .lbareadparams
   150                              <1> .baddev:
   151 000013FC B401                <1>     mov ah, 01h
   152 000013FE 882425[A9010000]    <1>     mov byte [msdStatus], ah   ;Invalid function requested signature
   153                              <1> .bad:
   154 00001405 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   155 0000140A 48CF                <1>     iretq
   156                              <1> .noDevInDrive:
   157 0000140C 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   158 00001413 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   159 00001418 48CF                <1>     iretq
   160                              <1> .reset: ;Device Reset
   161 0000141A 56                  <1>     push rsi
   162 0000141B 52                  <1>     push rdx
   163 0000141C E8F2020000          <1>     call .i33ehciGetDevicePtr
   164 00001421 E8F4270000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   165 00001426 E8C8360000          <1>     call USB.ehciMsdBOTResetRecovery
   166                              <1> .rrexit:
   167 0000142B 5A                  <1>     pop rdx
   168 0000142C 5E                  <1>     pop rsi
   169 0000142D 720E                <1>     jc .rrbad
   170 0000142F 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   171 00001436 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   172 0000143B 48CF                <1>     iretq
   173                              <1> .rrbad:
   174 0000143D B405                <1>     mov ah, 5   ;Reset failed
   175 0000143F 882425[A9010000]    <1>     mov byte [msdStatus], ah
   176 00001446 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   177 0000144B 48CF                <1>     iretq
   178                              <1> .statusreport:  
   179                              <1> ;If NOT a host/bus/ctrlr type error, request sense and ret code
   180 0000144D 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Get last status into ah
   181 00001454 84E4                <1>     test ah, ah ;If status is zero, exit
   182 00001456 7507                <1>     jnz .srmain
   183 00001458 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh     ;Clear CF
   184 0000145D 48CF                <1>     iretq
   185                              <1> .srmain:
   186 0000145F C60425[A9010000]00  <1>     mov byte [msdStatus], 00    ;Reset status byte
   187 00001467 80FC20              <1>     cmp ah, 20h     ;General Controller failure?
   188 0000146A 7449                <1>     je .srexit
   189 0000146C 80FC80              <1>     cmp ah, 80h     ;Timeout?
   190 0000146F 7444                <1>     je .srexit
   191                              <1> ;Issue a Request sense command
   192 00001471 56                  <1>     push rsi
   193 00001472 50                  <1>     push rax    ;Save original error code in ah on stack
   194 00001473 E89B020000          <1>     call .i33ehciGetDevicePtr
   195 00001478 E89D270000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   196 0000147D 7241                <1>     jc .srexitbad1
   197 0000147F E83B3C0000          <1>     call USB.ehciMsdBOTRequestSense
   198 00001484 E84A370000          <1>     call USB.ehciMsdBOTCheckTransaction
   199 00001489 6685C0              <1>     test ax, ax
   200 0000148C 58                  <1>     pop rax         ;Get back original error code
   201 0000148D 752D                <1>     jnz .srexitbad2
   202 0000148F 4C0FB60425-         <1>     movzx r8, byte [ehciDataIn + 13]  ;Get ASCQ into r8
   202 00001494 [CD030000]          <1>
   203 00001498 49C1E008            <1>     shl r8, 8                        ;Make space in lower byte of r8 for ASC key
   204 0000149C 448A0425[CC030000]  <1>     mov r8b, byte [ehciDataIn + 12]   ;Get ASC into r8
   205 000014A4 49C1E008            <1>     shl r8, 8                    ;Make space in lower byte of r8 for sense key
   206 000014A8 448A0425[C2030000]  <1>     mov r8b, byte [ehciDataIn + 2]  ;Get sense key into al
   207 000014B0 4180C8F0            <1>     or r8b, 0F0h                    ;Set sense signature (set upper nybble F)
   208 000014B4 5E                  <1>     pop rsi
   209                              <1> .srexit:
   210 000014B5 804C241001          <1>     or byte [rsp + 2*8h], 1 ;Non-zero error, requires CF=CY
   211 000014BA 48CF                <1>     iretq
   212                              <1> .srexitbad2:
   213 000014BC B4FF                <1>     mov ah, -1  ;Sense operation failed
   214 000014BE EB02                <1>     jmp short .srexitbad
   215                              <1> .srexitbad1:
   216 000014C0 B420                <1>     mov ah, 20h ;General Controller Failure
   217                              <1> .srexitbad:
   218 000014C2 5E                  <1>     pop rsi
   219 000014C3 882425[A9010000]    <1>     mov byte [msdStatus], ah
   220 000014CA EB21                <1>     jmp short .rsbad
   221                              <1> 
   222                              <1> .readsectors:
   223 000014CC 57                  <1>     push rdi
   224 000014CD 48BF-               <1>     mov rdi, USB.ehciMsdBOTInSector512
   224 000014CF [E351000000000000]  <1>
   225 000014D7 E8EB010000          <1>     call .sectorsEHCI
   226 000014DC 5F                  <1>     pop rdi
   227 000014DD 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   228 000014E4 7207                <1>     jc .rsbad
   229 000014E6 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   230 000014EB 48CF                <1>     iretq
   231                              <1> .rsbad:
   232 000014ED 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   233 000014F2 48CF                <1>     iretq
   234                              <1> 
   235                              <1> .writesectors:
   236 000014F4 57                  <1>     push rdi
   237 000014F5 48BF-               <1>     mov rdi, USB.ehciMsdBOTOutSector512
   237 000014F7 [9851000000000000]  <1>
   238 000014FF E8C3010000          <1>     call .sectorsEHCI
   239 00001504 5F                  <1>     pop rdi
   240 00001505 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   241 0000150C 72DF                <1>     jc .rsbad
   242 0000150E 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   243 00001513 48CF                <1>     iretq
   244                              <1> 
   245                              <1> .verify:
   246 00001515 57                  <1>     push rdi
   247 00001516 48BF-               <1>     mov rdi, USB.ehciMsdBOTVerify
   247 00001518 [7050000000000000]  <1>
   248 00001520 E8A2010000          <1>     call .sectorsEHCI   ;Verify sector by sector
   249 00001525 5F                  <1>     pop rdi
   250 00001526 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   251 0000152D 72BE                <1>     jc .rsbad
   252 0000152F 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   253 00001534 48CF                <1>     iretq
   254                              <1> .format:
   255                              <1> ;Cleans sectors on chosen track. DOES NOT Low Level Format.
   256                              <1> ;Fills sectors with fill byte from table
   257 00001536 50                  <1>     push rax
   258 00001537 53                  <1>     push rbx
   259 00001538 51                  <1>     push rcx
   260 00001539 56                  <1>     push rsi
   261 0000153A 57                  <1>     push rdi
   262 0000153B 55                  <1>     push rbp
   263                              <1> 
   264 0000153C 51                  <1>     push rcx                    ;Save ch = Cylinder number
   265 0000153D 488B3425[AF010000]  <1>     mov rsi, qword [diskDptPtr]
   266 00001545 B880000000          <1>     mov eax, 80h                 ;128 bytes
   267 0000154A 8A4E03              <1>     mov cl, byte [rsi + 3]  ;Bytes per track
   268 0000154D D3E0                <1>     shl eax, cl                  ;Multiply 128 bytes per sector by multiplier
   269 0000154F 89C1                <1>     mov ecx, eax
   270 00001551 8A4608              <1>     mov al, byte [rsi + 8]  ;Fill byte for format
   271 00001554 48BF-               <1>     mov rdi, sectorbuffer       ;Large enough buffer
   271 00001556 [C003000000000000]  <1>
   272 0000155E F3AA                <1>     rep stosb                   ;Create mock sector
   273                              <1> 
   274 00001560 8A4E04              <1>     mov cl, byte [rsi + 4]  ;Get sectors per track
   275 00001563 0FB6E9              <1>     movzx ebp, cl               ;Put number of sectors in Cylinder in ebp
   276                              <1> 
   277 00001566 59                  <1>     pop rcx                     ;Get back Cylinder number in ch
   278 00001567 B101                <1>     mov cl, 1                   ;Ensure start at sector 1 of Cylinder
   279                              <1> 
   280 00001569 E8D3010000          <1>     call .convertCHSLBA ;Converts to valid 32 bit LBA in ecx for geometry type
   281                              <1>     ;ecx now has LBA
   282                              <1> .formatcommon:
   283 0000156E E8A0010000          <1>     call .i33ehciGetDevicePtr
   284 00001573 7245                <1>     jc .fbad
   285 00001575 89CA                <1>     mov edx, ecx    ;Load edx for function call
   286                              <1> ;Replace this section with a single USB function
   287 00001577 E89E260000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   288 0000157C 48BB-               <1>     mov rbx, sectorbuffer
   288 0000157E [C003000000000000]  <1>
   289                              <1> .f0:
   290 00001586 E80D3C0000          <1>     call USB.ehciMsdBOTOutSector512
   291 0000158B 0F8277010000        <1>     jc .sebadBB
   292 00001591 FFC2                <1>     inc edx ;Inc LBA
   293 00001593 FFCD                <1>     dec ebp ;Dec number of sectors to act on
   294 00001595 75EF                <1>     jnz .f0
   295 00001597 F8                  <1>     clc
   296                              <1> .formatexit:
   297 00001598 5D                  <1>     pop rbp
   298 00001599 5F                  <1>     pop rdi
   299 0000159A 5E                  <1>     pop rsi
   300 0000159B 59                  <1>     pop rcx
   301 0000159C 5B                  <1>     pop rbx
   302 0000159D 58                  <1>     pop rax
   303 0000159E 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   304 000015A5 0F8242FFFFFF        <1>     jc .rsbad
   305 000015AB 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   306 000015B0 48CF                <1>     iretq
   307                              <1> .fbadBB:
   308 000015B2 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh  ;Unknown Error, request sense
   309                              <1> .fbad:
   310 000015BA F9                  <1>     stc
   311 000015BB EBDB                <1>     jmp short .formatexit
   312                              <1> .lbaread:
   313 000015BD 57                  <1>     push rdi
   314 000015BE 48BF-               <1>     mov rdi, USB.ehciMsdBOTInSector512
   314 000015C0 [E351000000000000]  <1>
   315 000015C8 E88D000000          <1>     call .lbaCommon
   316 000015CD 5F                  <1>     pop rdi
   317 000015CE 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   318 000015D5 0F8212FFFFFF        <1>     jc .rsbad
   319 000015DB 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   320 000015E0 48CF                <1>     iretq   
   321                              <1> .lbawrite:
   322 000015E2 57                  <1>     push rdi
   323 000015E3 48BF-               <1>     mov rdi, USB.ehciMsdBOTOutSector512
   323 000015E5 [9851000000000000]  <1>
   324 000015ED E868000000          <1>     call .lbaCommon
   325 000015F2 5F                  <1>     pop rdi
   326 000015F3 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   327 000015FA 0F82EDFEFFFF        <1>     jc .rsbad
   328 00001600 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   329 00001605 48CF                <1>     iretq
   330                              <1> .lbaverify:
   331 00001607 57                  <1>     push rdi
   332 00001608 48BF-               <1>     mov rdi, USB.ehciMsdBOTVerify
   332 0000160A [7050000000000000]  <1>
   333 00001612 E843000000          <1>     call .lbaCommon
   334 00001617 5F                  <1>     pop rdi
   335 00001618 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   336 0000161F 0F82C8FEFFFF        <1>     jc .rsbad
   337 00001625 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   338 0000162A 48CF                <1>     iretq
   339                              <1> .lbaformat:
   340 0000162C 50                  <1>     push rax
   341 0000162D 53                  <1>     push rbx
   342 0000162E 51                  <1>     push rcx
   343 0000162F 56                  <1>     push rsi
   344 00001630 57                  <1>     push rdi
   345 00001631 55                  <1>     push rbp
   346 00001632 0FB6E8              <1>     movzx ebp, al ;Save the number of sectors to format in ebp
   347 00001635 51                  <1>     push rcx
   348 00001636 52                  <1>     push rdx
   349 00001637 B900020000          <1>     mov ecx, 200h
   350 0000163C 48BF-               <1>     mov rdi, sectorbuffer
   350 0000163E [C003000000000000]  <1>
   351 00001646 488B1425[AF010000]  <1>     mov rdx, qword [diskDptPtr]
   352 0000164E 8A4208              <1>     mov al, byte [rdx + 8]  ;Fill byte for format
   353 00001651 F3AA                <1>     rep stosb
   354 00001653 5A                  <1>     pop rdx
   355 00001654 59                  <1>     pop rcx
   356 00001655 E914FFFFFF          <1>     jmp .formatcommon
   357                              <1> 
   358                              <1> .lbaCommon:
   359 0000165A 50                  <1>     push rax
   360 0000165B 56                  <1>     push rsi
   361 0000165C 53                  <1>     push rbx
   362 0000165D 51                  <1>     push rcx
   363 0000165E 52                  <1>     push rdx
   364 0000165F 55                  <1>     push rbp
   365 00001660 84C0                <1>     test al, al
   366 00001662 0F8499000000        <1>     jz .se2 ;If al=0, skip copying sectors, clears CF
   367 00001668 0FB6E8              <1>     movzx ebp, al
   368 0000166B E969000000          <1>     jmp .seCommon
   369                              <1> 
   370                              <1> ;Low level format, ah=07h
   371                              <1> .formatLowLevel:
   372 00001670 56                  <1>     push rsi
   373 00001671 50                  <1>     push rax
   374 00001672 E89C000000          <1>     call .i33ehciGetDevicePtr   ;al = bus num, rsi = ehci device structure ptr
   375 00001677 E88A390000          <1>     call USB.ehciMsdBOTFormatUnit
   376 0000167C 58                  <1>     pop rax
   377 0000167D 5E                  <1>     pop rsi
   378 0000167E 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   379 00001685 0F8262FEFFFF        <1>     jc .rsbad
   380 0000168B 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   381 00001690 48CF                <1>     iretq
   382                              <1> .lbareadparams:
   383                              <1> ;Reads drive parameters (for drive dl which is always valid at this point)
   384                              <1> ;Output: rbx = dBlockSize (Dword for LBA block size)
   385                              <1> ;        rcx = qLastLBANum (Qword address of last LBA)
   386                              <1> ;         dl = Number of removable devices 
   387                              <1> ;         ah = 0
   388 00001692 52                  <1>     push rdx
   389 00001693 50                  <1>     push rax
   390 00001694 480FB6C2            <1>     movzx rax, dl   ;Move drive number offset into rax
   391 00001698 48BA10000000000000- <1>     mov rdx, int33TblEntrySize
   391 000016A1 00                  <1>
   392 000016A2 48F7E2              <1>     mul rdx
   393 000016A5 488D90[D3030000]    <1>     lea rdx, qword [diskDevices + rax]  ;Move address into rdx
   394 000016AC 31DB                <1>     xor ebx, ebx
   395 000016AE 8B5A03              <1>     mov ebx, dword [rdx + 3]    ;Get dBlockSize for device
   396 000016B1 488B4A07            <1>     mov rcx, qword [rdx + 7]    ;Get qLastLBANum for device
   397 000016B5 58                  <1>     pop rax
   398 000016B6 5A                  <1>     pop rdx
   399 000016B7 8A1425[4B020000]    <1>     mov dl, byte [numMSD]
   400 000016BE 30E4                <1>     xor ah, ah
   401 000016C0 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   402 000016C5 48CF                <1>     iretq
   403                              <1> .sectorsEHCI:
   404                              <1> ;Input: rdi = Address of USB EHCI MSD BBB function
   405                              <1> ;Output: CF = CY: Error, exit
   406                              <1> ;        CF = NC: No Error
   407 000016C7 50                  <1>     push rax
   408 000016C8 56                  <1>     push rsi
   409 000016C9 53                  <1>     push rbx
   410 000016CA 51                  <1>     push rcx
   411 000016CB 52                  <1>     push rdx
   412 000016CC 55                  <1>     push rbp
   413 000016CD 84C0                <1>     test al, al
   414 000016CF 7430                <1>     jz .se2 ;If al=0, skip copying sectors, clears CF
   415 000016D1 0FB6E8              <1>     movzx ebp, al   ;Move the number of sectors into ebp
   416 000016D4 E868000000          <1>     call .convertCHSLBA ;Converts to valid 32 bit LBA in ecx for geometry type
   417                              <1>     ;ecx now has LBA
   418                              <1> .seCommon:  ;Entered with ebp = Number of Sectors and ecx = Start LBA
   419 000016D9 E835000000          <1>     call .i33ehciGetDevicePtr
   420 000016DE 7230                <1>     jc .sebad
   421 000016E0 4889CA              <1>     mov rdx, rcx    ;Load edx for function call
   422                              <1> ;Replace this section with a single USB function
   423 000016E3 E832250000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   424 000016E8 30C0                <1>     xor al, al      ;Sector counter
   425                              <1> .se1:
   426 000016EA FEC0                <1>     inc al  ;Inc Sector counter
   427 000016EC 50                  <1>     push rax
   428 000016ED FFD7                <1>     call rdi
   429 000016EF 58                  <1>     pop rax
   430 000016F0 7216                <1>     jc .sebadBB
   431 000016F2 4881C300020000      <1>     add rbx, 200h   ;Goto next sector
   432 000016F9 48FFC2              <1>     inc rdx ;Inc LBA
   433 000016FC FFCD                <1>     dec ebp ;Dec number of sectors to act on
   434 000016FE 75EA                <1>     jnz .se1
   435 00001700 F8                  <1>     clc
   436                              <1> .se2:
   437 00001701 5D                  <1>     pop rbp
   438 00001702 5A                  <1>     pop rdx
   439 00001703 59                  <1>     pop rcx
   440 00001704 5B                  <1>     pop rbx
   441 00001705 5E                  <1>     pop rsi
   442 00001706 58                  <1>     pop rax
   443 00001707 C3                  <1>     ret
   444                              <1> .sebadBB:
   445 00001708 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh  ;Unknown Error, request sense
   446                              <1> .sebad:
   447 00001710 F9                  <1>     stc
   448 00001711 EBEE                <1>     jmp short .se2
   449                              <1> 
   450                              <1> .i33ehciGetDevicePtr:
   451                              <1> ;Input: dl = Int 33h number whose 
   452                              <1> ;Output: rsi = Pointer to ehci msd device parameter block
   453                              <1> ;        al = EHCI bus the device is on
   454 00001713 53                  <1>     push rbx    ;Need to temporarily preserve rbx
   455 00001714 480FB6C2            <1>     movzx rax, dl   ;Move drive number offset into rax
   456 00001718 48BA10000000000000- <1>     mov rdx, int33TblEntrySize
   456 00001721 00                  <1>
   457 00001722 48F7E2              <1>     mul rdx
   458 00001725 488D90[D3030000]    <1>     lea rdx, qword [diskDevices + rax]  ;Move address into rdx
   459 0000172C 803A00              <1>     cmp byte [rdx], 0   ;Check to see if the device type is 0 (ie doesnt exist)
   460 0000172F 740E                <1>     jz .i33egdpbad ;If not, exit
   461 00001731 668B4201            <1>     mov ax, word [rdx + 1]  ;Get address/Bus pair into ax
   462 00001735 E8B12D0000          <1>     call USB.ehciGetDevicePtr   ;Get device pointer into rsi
   463 0000173A 88E0                <1>     mov al, ah          ;Get the bus into al
   464 0000173C 5B                  <1>     pop rbx
   465 0000173D F8                  <1>     clc
   466 0000173E C3                  <1>     ret
   467                              <1> .i33egdpbad:
   468 0000173F F9                  <1>     stc
   469 00001740 C3                  <1>     ret
   470                              <1> 
   471                              <1> .convertCHSLBA:
   472                              <1> ;Converts a CHS address to LBA
   473                              <1> ;Input: dl = Drive number, if dl < 80h, use diskdpt. If dl > 80h, use hdiskdpt
   474                              <1> ;       ch = Track number, cl = Sector number, dh = Head number 
   475                              <1> ;Output: ecx = LBA address
   476                              <1> ;----------Reference Equations----------
   477                              <1> ;C = LBA / (HPC x SPT)
   478                              <1> ;H = (LBA / SPT) mod HPC
   479                              <1> ;S = (LBA mod SPT) + 1
   480                              <1> ;+++++++++++++++++++++++++++++++++++++++
   481                              <1> ;LBA = (( C x HPC ) + H ) x SPT + S - 1
   482                              <1> ;---------------------------------------
   483                              <1> ;Use diskdpt.spt for sectors per track value! 
   484                              <1> ;1.44Mb geometry => H=2, C=80, S=18
   485 00001741 50                  <1>     push rax
   486 00001742 56                  <1>     push rsi
   487 00001743 488B3425[AF010000]  <1>     mov rsi, qword [diskDptPtr]
   488 0000174B D0E5                <1>     shl ch, 1   ;Multiply by HPC=2
   489 0000174D 00F5                <1>     add ch, dh  ;Add head number
   490 0000174F 88E8                <1>     mov al, ch  ;al = ch = (( C x HPC ) + H )
   491 00001751 F66604              <1>     mul byte [rsi + 4]  ;Sectors per track
   492 00001754 30ED                <1>     xor ch, ch  
   493 00001756 6601C8              <1>     add ax, cx  ;Add sector number to ax
   494 00001759 66FFC8              <1>     dec ax
   495 0000175C 0FB7C8              <1>     movzx ecx, ax
   496 0000175F 5E                  <1>     pop rsi
   497 00001760 58                  <1>     pop rax
   498 00001761 C3                  <1>     ret
   499                              <1> .deviceChanged:
   500                              <1> ;Entry: dl = Drive number
   501                              <1> ;Exit: ah = 00h, No device changed occured, CF = CN
   502                              <1> ;      ah = 01h, Device changed occured, CF = CN
   503                              <1> ;      CF = CY if an error occured or device removed
   504 00001762 53                  <1>     push rbx
   505 00001763 51                  <1>     push rcx
   506 00001764 52                  <1>     push rdx
   507 00001765 56                  <1>     push rsi
   508 00001766 57                  <1>     push rdi
   509 00001767 55                  <1>     push rbp
   510 00001768 4150                <1>     push r8
   511 0000176A 4151                <1>     push r9
   512 0000176C 4152                <1>     push r10
   513 0000176E 4153                <1>     push r11
   514                              <1> 
   515 00001770 50                  <1>     push rax
   516                              <1> 
   517 00001771 4C0FB61C25-         <1>     movzx r11, byte [msdStatus] ;Preserve the original status byte
   517 00001776 [A9010000]          <1>
   518 0000177A 0FB6EA              <1>     movzx ebp, dl               ;Save the device number in ebp
   519 0000177D E891FFFFFF          <1>     call .i33ehciGetDevicePtr   ;Get MSD dev data block ptr in rsi and bus in al
   520                              <1> ;Check port on device for status change.
   521 00001782 807E0200            <1>     cmp byte [rsi + 2], 0   ;Check if root hub
   522 00001786 0F8490000000        <1>     jz .dcRoot
   523                              <1> ;External Hub procedure
   524 0000178C 668B4601            <1>     mov ax, word [rsi + 1]  ;Get bus and host hub address
   525 00001790 86C4                <1>     xchg al, ah             ;Swap endianness
   526 00001792 4989F1              <1>     mov r9, rsi
   527 00001795 E8512D0000          <1>     call USB.ehciGetDevicePtr   ;Get the hub address in rsi
   528 0000179A 88E0                <1>     mov al, ah
   529 0000179C E879240000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   530 000017A1 C70425[C0030000]00- <1>     mov dword [ehciDataIn], 0
   530 000017A9 000000              <1>
   531 000017AC 48BAA3000000000004- <1>     mov rdx, 00040000000000A3h ;Get Port status
   531 000017B5 00                  <1>
   532 000017B6 410FB65903          <1>     movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
   533 000017BB 48C1E320            <1>     shl rbx, 4*8    ;Shift port number to right position
   534 000017BF 4809D3              <1>     or rbx, rdx
   535 000017C2 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
   536 000017C6 8A06                <1>     mov al, byte [rsi]      ;Get upstream hub address
   537 000017C8 E843260000          <1>     call USB.ehciGetRequest
   538 000017CD 7231                <1>     jc .dcError
   539                              <1> 
   540 000017CF 49B8-               <1>     mov r8, USB.ehciEnumerateHubPort    ;Store address for if bit is set
   540 000017D1 [7647000000000000]  <1>
   541 000017D9 8B1425[C0030000]    <1>     mov edx, dword [ehciDataIn]
   542 000017E0 81E200000100        <1>     and edx, 10000h ;Isolate the port status changed bit
   543 000017E6 C1EA10              <1>     shr edx, 10h    ;Shift status from bit 16 to bit 0
   544                              <1> .dcNoError:
   545 000017E9 44881C25[A9010000]  <1>     mov byte [msdStatus], r11b  ;Return back the original status byte
   546 000017F1 58                  <1>     pop rax
   547 000017F2 88D4                <1>     mov ah, dl                  ;Place return value in ah
   548 000017F4 E814000000          <1>     call .dcRetPop
   549 000017F9 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   550 000017FE 48CF                <1>     iretq
   551                              <1> .dcError:
   552 00001800 58                  <1>     pop rax ;Just return the old rax value
   553 00001801 E807000000          <1>     call .dcRetPop
   554 00001806 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   555 0000180B 48CF                <1>     iretq
   556                              <1> .dcRetPop:
   557 0000180D 415B                <1>     pop r11
   558 0000180F 415A                <1>     pop r10
   559 00001811 4159                <1>     pop r9
   560 00001813 4158                <1>     pop r8
   561 00001815 5D                  <1>     pop rbp
   562 00001816 5F                  <1>     pop rdi
   563 00001817 5E                  <1>     pop rsi
   564 00001818 5A                  <1>     pop rdx
   565 00001819 59                  <1>     pop rcx
   566 0000181A 5B                  <1>     pop rbx
   567 0000181B C3                  <1>     ret
   568                              <1> .dcRoot:
   569                              <1> ;Root hub procedure.
   570 0000181C E8F9230000          <1>     call USB.ehciAdjustAsyncSchedCtrlr  ;Reset the bus if needed
   571 00001821 E8363B0000          <1>     call USB.ehciGetOpBase      ;Get opbase into rax
   572 00001826 0FB65E03            <1>     movzx ebx, byte [rsi + 3]   ;Get MSD port number into dl
   573 0000182A FFCB                <1>     dec ebx                     ;Reduce by one
   574 0000182C 678B549844          <1>     mov edx, dword [eax + 4*ebx + ehciportsc]  ;Get port status into eax
   575 00001831 80E202              <1>     and dl, 2h      ;Only save bit 1, status changed bit
   576 00001834 D0EA                <1>     shr dl, 1       ;Shift down by one bit
   577 00001836 EBB1                <1>     jmp short .dcNoError    ;Exit
   578                              <1> .busScan:
   579                              <1> ;Will request the hub bitfield from the RMH the device is plugged in to.
   580                              <1> ;Preserves ALL registers.
   581                              <1> ;dl = Device number
   582                              <1> 
   583                              <1> ;If status changed bit set, call appropriate enumeration function.
   584                              <1> ;If enumeration returns empty device, keep current device data blocks in memory,
   585                              <1> ; but return Int 33h error 40h = Seek operation Failed.
   586 00001838 50                  <1>     push rax
   587 00001839 53                  <1>     push rbx
   588 0000183A 51                  <1>     push rcx
   589 0000183B 52                  <1>     push rdx
   590 0000183C 56                  <1>     push rsi
   591 0000183D 57                  <1>     push rdi
   592 0000183E 55                  <1>     push rbp
   593 0000183F 4150                <1>     push r8
   594 00001841 4151                <1>     push r9
   595 00001843 4152                <1>     push r10
   596 00001845 4153                <1>     push r11
   597                              <1> 
   598 00001847 4C0FB61C25-         <1>     movzx r11, byte [msdStatus] ;Preserve the original status
   598 0000184C [A9010000]          <1>
   599                              <1> 
   600 00001850 0FB6EA              <1>     movzx ebp, dl               ;Save the device number in ebp
   601 00001853 E8BBFEFFFF          <1>     call .i33ehciGetDevicePtr   ;Get MSD dev data block ptr in rsi and bus in al
   602                              <1> ;Check port on device for status change.
   603 00001858 807E0200            <1>     cmp byte [rsi + 2], 0   ;Check if root hub
   604 0000185C 0F84CE000000        <1>     jz .bsRoot
   605                              <1> ;External Hub procedure
   606 00001862 668B4601            <1>     mov ax, word [rsi + 1]  ;Get bus and host hub address
   607 00001866 86C4                <1>     xchg al, ah             ;Swap endianness
   608 00001868 4989F1              <1>     mov r9, rsi
   609 0000186B E87B2C0000          <1>     call USB.ehciGetDevicePtr   ;Get the hub address in rsi
   610 00001870 88E0                <1>     mov al, ah
   611 00001872 E8A3230000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   612 00001877 C70425[C0030000]00- <1>     mov dword [ehciDataIn], 0
   612 0000187F 000000              <1>
   613 00001882 48BAA3000000000004- <1>     mov rdx, 00040000000000A3h ;Get Port status
   613 0000188B 00                  <1>
   614 0000188C 410FB65903          <1>     movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
   615 00001891 48C1E320            <1>     shl rbx, 4*8    ;Shift port number to right position
   616 00001895 4809D3              <1>     or rbx, rdx
   617 00001898 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
   618 0000189C 8A06                <1>     mov al, byte [rsi]      ;Get upstream hub address
   619 0000189E E86D250000          <1>     call USB.ehciGetRequest
   620 000018A3 722C                <1>     jc .bsErrorExit
   621                              <1> 
   622 000018A5 49B8-               <1>     mov r8, USB.ehciEnumerateHubPort    ;Store address for if bit is set
   622 000018A7 [7647000000000000]  <1>
   623 000018AF 8B1425[C0030000]    <1>     mov edx, dword [ehciDataIn]
   624 000018B6 81E201000100        <1>     and edx, 10001h
   625 000018BC F7C200000100        <1>     test edx, 10000h
   626 000018C2 752A                <1>     jnz .bsClearPortChangeStatus    ;If top bit set, clear port change bit
   627                              <1> .bsret:
   628 000018C4 F6C201              <1>     test dl, 1h
   629 000018C7 7418                <1>     jz .bsrExit06h  ;Bottom bit not set, exit media changed Error (edx = 00000h)
   630                              <1> .bsexit:    ;The fall through is (edx = 00001h), no change to dev in port
   631 000018C9 44881C25[A9010000]  <1>     mov byte [msdStatus], r11b  ;Get back the original status byte
   632                              <1> .bsErrorExit:
   633 000018D1 415B                <1>     pop r11
   634 000018D3 415A                <1>     pop r10
   635 000018D5 4159                <1>     pop r9
   636 000018D7 4158                <1>     pop r8
   637 000018D9 5D                  <1>     pop rbp
   638 000018DA 5F                  <1>     pop rdi
   639 000018DB 5E                  <1>     pop rsi
   640 000018DC 5A                  <1>     pop rdx
   641 000018DD 59                  <1>     pop rcx
   642 000018DE 5B                  <1>     pop rbx
   643 000018DF 58                  <1>     pop rax
   644 000018E0 C3                  <1>     ret
   645                              <1> .bsrExit06h:    ;If its clear, nothing in port, return media changed error
   646 000018E1 49BB06000000000000- <1>     mov r11, 06h ;Change the msdStatus byte, media changed or removed
   646 000018EA 00                  <1>
   647 000018EB F9                  <1>     stc
   648 000018EC EBDB                <1>     jmp short .bsexit
   649                              <1> .bsClearPortChangeStatus:
   650 000018EE 52                  <1>     push rdx
   651 000018EF C70425[C0030000]00- <1>     mov dword [ehciDataIn], 0
   651 000018F7 000000              <1>
   652 000018FA 48BA23011000000000- <1>     mov rdx, 0000000000100123h  ;Set Port status
   652 00001903 00                  <1>
   653 00001904 410FB65903          <1>     movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
   654 00001909 48C1E320            <1>     shl rbx, 4*8    ;Shift port number to right position
   655 0000190D 4809D3              <1>     or rbx, rdx
   656 00001910 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
   657 00001914 8A06                <1>     mov al, byte [rsi]      ;Get device address
   658 00001916 E856240000          <1>     call USB.ehciSetNoData
   659 0000191B 5A                  <1>     pop rdx
   660 0000191C 72B3                <1>     jc .bsErrorExit  ;If error exit by destroying the old msdStatus
   661                              <1> 
   662 0000191E F6C201              <1>     test dl, 1h
   663 00001921 74BE                <1>     jz .bsrExit06h  ;Bottom bit not set, exit media changed error (edx = 10000h)
   664 00001923 EB4E                <1>     jmp short .bsCommonEP   ;Else new device in port needs enum (edx = 10001h)
   665                              <1> .bsRtNoDev:
   666 00001925 67814C984402000000  <1>     or dword [eax + 4*ebx + ehciportsc], 2  ;Clear the bit
   667 0000192E EBB1                <1>     jmp short .bsrExit06h   ;Exit with seek error
   668                              <1> .bsRoot:
   669                              <1> ;Root hub procedure.
   670 00001930 E8E5220000          <1>     call USB.ehciAdjustAsyncSchedCtrlr  ;Reset the bus if needed
   671 00001935 E8223A0000          <1>     call USB.ehciGetOpBase      ;Get opbase into rax
   672 0000193A 0FB65E03            <1>     movzx ebx, byte [rsi + 3]   ;Get MSD port number into dl
   673 0000193E FFCB                <1>     dec ebx                     ;Reduce by one
   674 00001940 678B549844          <1>     mov edx, dword [eax + 4*ebx + ehciportsc]  ;Get port status into eax
   675 00001945 80E203              <1>     and dl, 3h      ;Only save bottom two bits
   676 00001948 84D2                <1>     test dl, dl     ;No device in port  (dl=00b)
   677 0000194A 7495                <1>     jz .bsrExit06h  ;Exit media changed error
   678 0000194C FECA                <1>     dec dl          ;Device in port     (dl=01b)
   679 0000194E 0F8475FFFFFF        <1>     jz .bsexit      ;Exit, no status change
   680 00001954 FECA                <1>     dec dl          ;New device, Device removed from port   (dl=10b)
   681 00001956 74CD                <1>     jz .bsRtNoDev   ;Clear state change bit and exit Seek error
   682                              <1> ;Fallthrough case, New device, Device inserted in port  (dl=11b)
   683 00001958 67814C984402000000  <1>     or dword [eax + 4*ebx + ehciportsc], 2  ;Clear the state change bit
   684 00001961 49B8-               <1>     mov r8,  USB.ehciEnumerateRootPort   ;The enumeration function to call
   684 00001963 [3340000000000000]  <1>
   685 0000196B 4989F1              <1>     mov r9, rsi        ;Store the device pointer in r9
   686 0000196E BE00000000          <1>     mov esi, 0         ;Store 0 for root hub parameter block                 
   687                              <1> .bsCommonEP:
   688                              <1> ;Invalidate USB MSD and Int 33h table entries for device
   689                              <1> ;r9 has device pointer block and rsi has host hub pointer (if on RMH)
   690 00001973 66418B19            <1>     mov bx, word [r9]          ;bl = Address, bh = Bus
   691 00001977 88FE                <1>     mov dh, bh                 ;dh = Bus
   692 00001979 418A5103            <1>     mov dl, byte [r9 + 3]      ;dl = Device Port
   693 0000197D 4D0FB65102          <1>     movzx r10, byte [r9 + 2]   ;r10b = Host hub address (0 = Root hub)
   694 00001982 6689D8              <1>     mov ax, bx                 ;ax needs a copy for RemoveDevFromTables
   695 00001985 E8EC290000          <1>     call USB.ehciRemoveDevFromTables    ;Removes device from USB tables
   696 0000198A 87EA                <1>     xchg ebp, edx                       ;device number -><- bus/dev pair
   697 0000198C E8E5000000          <1>     call .i33removeFromTable            ;Removes device from Int 33h table
   698 00001991 87EA                <1>     xchg ebp, edx                       ;bus/dev pair -><- device number
   699                              <1> ;Devices enumerated, time to reenumerate!
   700 00001993 B903000000          <1>     mov ecx, 3
   701 00001998 85F6                <1>     test esi, esi   ;Is device on root hub?
   702 0000199A 7502                <1>     jnz .bsr0
   703 0000199C FECA                <1>     dec dl  ;Recall that device port must be device port - 1 for Root hub enum
   704                              <1> .bsr0:
   705 0000199E 41FFD0              <1>     call r8
   706 000019A1 7410                <1>     jz .bsr1
   707 000019A3 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;General Controller Failure?
   708 000019AB 7439                <1>     je .bsrFail
   709 000019AD FFC9                <1>     dec ecx
   710 000019AF 75ED                <1>     jnz .bsr0
   711 000019B1 EB33                <1>     jmp short .bsrFail
   712                              <1> .bsr1:
   713 000019B3 4C87CE              <1>     xchg r9, rsi    ;MSD parameter blk -><- Hub parameter blk (or 0 if root)
   714 000019B6 E856300000          <1>     call USB.ehciMsdInitialise
   715 000019BB 84C0                <1>     test al, al
   716 000019BD 7527                <1>     jnz .bsrFail    ;Exit if the device failed to initialise
   717                              <1> ;Multiply dl by int33TblEntrySize to get the address to write Int33h table
   718 000019BF 89EA                <1>     mov edx, ebp    ;Move the device number into edx (dl)
   719 000019C1 B810000000          <1>     mov eax, int33TblEntrySize  ;Zeros the upper bytes
   720 000019C6 F6E2                <1>     mul dl  ;Multiply dl by al. ax has offset into diskDevices table
   721 000019C8 4805[D3030000]      <1>     add rax, diskDevices
   722 000019CE 4889C7              <1>     mov rdi, rax    ;Put the offset into the table into rdi
   723 000019D1 E820000000          <1>     call .deviceInit
   724 000019D6 84C0                <1>     test al, al
   725 000019D8 0F84EBFEFFFF        <1>     jz .bsexit  ;Successful, exit!
   726 000019DE 3C03                <1>     cmp al, 3
   727 000019E0 0F84E3FEFFFF        <1>     je .bsexit  ;Invalid device type, but ignore for now
   728                              <1> .bsrFail:
   729 000019E6 49BB20000000000000- <1>     mov r11, 20h ;Change the msdStatus byte to Gen. Ctrlr Failure
   729 000019EF 00                  <1>
   730 000019F0 F9                  <1>     stc
   731 000019F1 E9D3FEFFFF          <1>     jmp .bsexit
   732                              <1> .deviceInit:    
   733                              <1> ;Further initialises an MSD device for use with the int33h interface.
   734                              <1> ;Adds device data to the allocated int33h data table.
   735                              <1> ;Input: rdi = device diskDevice ptr (given by device number*int33TblEntrySize)
   736                              <1> ;       rsi = device MSDDevTbl entry (USB address into getDevPtr)
   737                              <1> ;Output: al = 0 : Device added successfully
   738                              <1> ;        al = 1 : Bus error
   739                              <1> ;        al = 2 : Read Capacities/Reset recovary failed after 10 attempts
   740                              <1> ;        al = 3 : Invalid device type (Endpoint size too small, temporary)
   741                              <1> ;   rax destroyed
   742                              <1> ;IF DEVICE HAS MAX ENDPOINT SIZE 64, DO NOT WRITE IT TO INT 33H TABLES
   743 000019F6 51                  <1>     push rcx
   744 000019F7 B003                <1>     mov al, 3   ;Invalid EP size error code
   745 000019F9 66817E090002        <1>     cmp word [rsi + 9], 200h  ;Check IN max EP packet size
   746 000019FF 7573                <1>     jne .deviceInitExit
   747 00001A01 66817E0C0002        <1>     cmp word [rsi + 12], 200h ;Check OUT max EP packet size
   748 00001A07 756B                <1>     jne .deviceInitExit
   749                              <1> 
   750 00001A09 8A4601              <1>     mov al, byte [rsi + 1]  ;Get bus number
   751 00001A0C E809220000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   752 00001A11 B001                <1>     mov al, 1       ;Bus error exit
   753 00001A13 725F                <1>     jc .deviceInitExit
   754 00001A15 B90A000000          <1>     mov ecx, 10
   755                              <1> .deviceInitReadCaps:
   756 00001A1A E896350000          <1>     call USB.ehciMsdBOTReadCapacity10   ;Preserve al error code
   757 00001A1F 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;General Controller Failure
   758 00001A27 744B                <1>     je .deviceInitExit
   759 00001A29 E8A5310000          <1>     call USB.ehciMsdBOTCheckTransaction
   760 00001A2E 6685C0              <1>     test ax, ax     ;Clears CF
   761 00001A31 7418                <1>     jz .deviceInitWriteTableEntry   ;Success, write table entry
   762 00001A33 E8BB300000          <1>     call USB.ehciMsdBOTResetRecovery    ;Just force a device reset
   763 00001A38 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;General Controller Failure
   764 00001A40 7432                <1>     je .deviceInitExit
   765 00001A42 FFC9                <1>     dec ecx
   766 00001A44 75D4                <1>     jnz .deviceInitReadCaps
   767 00001A46 B002                <1>     mov al, 2   ;Non bus error exit
   768 00001A48 F9                  <1>     stc ;Set carry, device failed to initialise properly
   769 00001A49 EB29                <1>     jmp short .deviceInitExit
   770                              <1> .deviceInitWriteTableEntry:
   771 00001A4B C60701              <1>     mov byte [rdi], 1   ;MSD USB device signature
   772                              <1> 
   773 00001A4E 668B06              <1>     mov ax, word [rsi]  ;Get address and bus into ax
   774 00001A51 66894701            <1>     mov word [rdi + 1], ax  ;Store in Int 33h table
   775                              <1> 
   776 00001A55 8B0425[C4030000]    <1>     mov eax, dword [ehciDataIn + 4] ;Get LBA block size
   777 00001A5C 0FC8                <1>     bswap eax
   778 00001A5E 894703              <1>     mov dword [rdi + 3], eax
   779                              <1> 
   780 00001A61 8B0425[C0030000]    <1>     mov eax, dword [ehciDataIn] ;Get zx qword LastLBA
   781 00001A68 0FC8                <1>     bswap eax
   782 00001A6A 48894707            <1>     mov qword [rdi + 7], rax
   783                              <1> 
   784 00001A6E C6470F02            <1>     mov byte [rdi + 15], 2  ;Temporary, only accept devices with 200h EP sizes
   785 00001A72 30C0                <1>     xor al, al 
   786                              <1> .deviceInitExit:
   787 00001A74 59                  <1>     pop rcx
   788 00001A75 C3                  <1>     ret
   789                              <1> .i33removeFromTable:
   790                              <1> ;Uses Int 33h device number to invalidate the device table entry
   791                              <1> ;Input: dl = Device number
   792                              <1> ;Output: Nothing, device entry invalidated
   793 00001A76 50                  <1>     push rax
   794 00001A77 52                  <1>     push rdx
   795 00001A78 B010                <1>     mov al, int33TblEntrySize
   796 00001A7A F6E2                <1>     mul dl  ;Multiply tbl entry size by device number, offset in ax
   797 00001A7C 480FB7C0            <1>     movzx rax, ax
   798 00001A80 C680[D3030000]00    <1>     mov byte [diskDevices + rax], 0 ;Invalidate entry
   799 00001A87 5A                  <1>     pop rdx
   800 00001A88 58                  <1>     pop rax
   801 00001A89 C3                  <1>     ret
   802                              <1> 
   803                              <1> diskdpt:   ;Imaginary floppy disk parameter table with disk geometry. 
   804                              <1> ;For more information on layout, see Page 3-26 of IBM BIOS ref
   805                              <1> ;Assume 2 head geometry due to emulating a floppy drive
   806 00001A8A 00                  <1> .fsb:   db 0    ;First specify byte
   807 00001A8B 00                  <1> .ssb:   db 0    ;Second specify byte
   808 00001A8C 00                  <1> .tto:   db 0    ;Number of timer ticks to wait before turning off drive motors
   809 00001A8D 02                  <1> .bps:   db 2    ;Number of bytes per sector in multiples of 128 bytes, editable.
   810                              <1>                 ; 0 = 128 bytes, 1 = 256 bytes, 2 = 512 bytes etc
   811                              <1>                 ;Left shift 128 by bps to get the real bytes per sector
   812 00001A8E 09                  <1> .spt:   db 9    ;Sectors per track
   813 00001A8F 00                  <1> .gpl:   db 0    ;Gap length
   814 00001A90 00                  <1> .dtl:   db 0    ;Data length
   815 00001A91 00                  <1> .glf:   db 0    ;Gap length for format
   816 00001A92 FF                  <1> .fbf:   db 0FFh ;Fill byte for format
   817 00001A93 00                  <1> .hst:   db 0    ;Head settle time in ms
   818 00001A94 01                  <1> .mst:   db 1    ;Motor startup time in multiples of 1/8 of a second.
   819                              <1> 
   820                              <1> fdiskdpt: ;Fixed drive table, only cyl, nhd and spt are valid. 
   821                              <1> ;           This schema gives roughly 8.42Gb of storage.
   822                              <1> ;           All fields with 0 in the comments are reserved post XT class BIOS.
   823 00001A95 0004                <1> .cyl:   dw  1024    ;1024 cylinders
   824 00001A97 FF                  <1> .nhd:   db  255     ;255 heads
   825 00001A98 0000                <1> .rwc:   dw  0       ;Reduced write current cylinder, 0
   826 00001A9A FFFF                <1> .wpc:   dw  -1      ;Write precompensation number (-1=none)
   827 00001A9C 00                  <1> .ecc:   db  0       ;Max ECC burst length, 0
   828 00001A9D 08                  <1> .ctl:   db  08h     ;Control byte (more than 8 heads)
   829 00001A9E 00                  <1> .sto:   db  0       ;Standard timeout, 0
   830 00001A9F 00                  <1> .fto:   db  0       ;Formatting timeout, 0
   831 00001AA0 00                  <1> .tcd:   db  0       ;Timeout for checking drive, 0
   832 00001AA1 FF03                <1> .clz:   dw  1023    ;Cylinder for landing zone
   833 00001AA3 3F                  <1> .spt:   db  63      ;Sectors per track
   834 00001AA4 00                  <1> .res:   db  0       ;Reserved byte
   835                              <1> 
   836                              <1> ;----------------------Fixed Disk Int 33h Ext-------------------
   837                              <1> ; Subfunctions in ah
   838                              <1> ;Input:  dl = Drive number, 
   839                              <1> ;        dh = Head number,
   840                              <1> ;        rbx = Address of buffer, 
   841                              <1> ;        al = number of sectors, 
   842                              <1> ;        ch = Cylinder number (low 8 bits), 
   843                              <1> ;        cl[7:6] = Cylinder number (upper 2 bits), 
   844                              <1> ;        cl[5:0] = Sector number
   845                              <1> ;Input LBA: dl = Drive Number, rbx = Address of Buffer, 
   846                              <1> ;           al = number of sectors, rcx = LBA number
   847                              <1> ;
   848                              <1> ;All registers not mentioned above, preserved.
   849                              <1> ;Still use msdStatus as the error byte dumping ground. For now, 
   850                              <1> ; do not use the ata specific status bytes. 
   851                              <1> ; Fixed disk BIOS does NOT return how many sectors were 
   852                              <1> ; successfully transferred!
   853                              <1> ;----------------------------------------------------------------
   854                              <1> fdisk_io:
   855 00001AA5 55                  <1>     push rbp
   856 00001AA6 50                  <1>     push rax
   857 00001AA7 53                  <1>     push rbx
   858 00001AA8 51                  <1>     push rcx
   859 00001AA9 52                  <1>     push rdx
   860                              <1> ;Cherry pick status to avoid resetting status
   861 00001AAA 80FC01              <1>     cmp ah, 01h
   862 00001AAD 0F84BD000000        <1>     je .fdiskStatus
   863                              <1> 
   864 00001AB3 C60425[A9010000]00  <1>     mov byte [msdStatus], 0 ;Reset the status
   865 00001ABB E8191B0000          <1>     call ATA.getTablePointer    ;Get table pointer in rbp for all functions
   866 00001AC0 7262                <1>     jc .badFunctionRequest  ;If the device doenst exist, bad bad bad!
   867                              <1> 
   868 00001AC2 84E4                <1>     test ah, ah
   869 00001AC4 0F8489000000        <1>     jz .fdiskReset
   870 00001ACA 80FC02              <1>     cmp ah, 02h
   871 00001ACD 0F84B2000000        <1>     je .fdiskReadCHS
   872 00001AD3 80FC03              <1>     cmp ah, 03h
   873 00001AD6 0F84BB000000        <1>     je .fdiskWriteCHS
   874 00001ADC 80FC04              <1>     cmp ah, 04h
   875 00001ADF 0F84C4000000        <1>     je .fdiskVerifyCHS
   876 00001AE5 80FC05              <1>     cmp ah, 05h
   877 00001AE8 0F84CB000000        <1>     je .fdiskFormat
   878 00001AEE 80FC08              <1>     cmp ah, 08h
   879 00001AF1 0F84D2000000        <1>     je .fdiskParametersCHS
   880 00001AF7 80FC82              <1>     cmp ah, 82h
   881 00001AFA 0F84FB000000        <1>     je .fdiskReadLBA
   882 00001B00 80FC83              <1>     cmp ah, 83h
   883 00001B03 0F841B010000        <1>     je .fdiskWriteLBA
   884 00001B09 80FC84              <1>     cmp ah, 84h
   885 00001B0C 0F8437010000        <1>     je .fdiskVerifyLBA
   886 00001B12 80FC85              <1>     cmp ah, 85h
   887 00001B15 0F8453010000        <1>     je .fdiskFormatSector
   888 00001B1B 80FC88              <1>     cmp ah, 88h 
   889 00001B1E 0F846F010000        <1>     je .fdiskParametersLBA
   890                              <1> 
   891                              <1> .badFunctionRequest:
   892 00001B24 B401                <1>     mov ah, 01h
   893 00001B26 882425[A9010000]    <1>     mov byte [msdStatus], ah   ;Invalid function requested signature
   894                              <1> .badExit:
   895 00001B2D 5A                  <1>     pop rdx
   896 00001B2E 59                  <1>     pop rcx
   897 00001B2F 5B                  <1>     pop rbx
   898 00001B30 58                  <1>     pop rax
   899 00001B31 5D                  <1>     pop rbp
   900 00001B32 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   901 00001B39 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag
   902 00001B3E 48CF                <1>     iretq 
   903                              <1> .okExit:
   904 00001B40 5A                  <1>     pop rdx
   905 00001B41 59                  <1>     pop rcx
   906 00001B42 5B                  <1>     pop rbx
   907                              <1> .paramExit:
   908 00001B43 58                  <1>     pop rax
   909 00001B44 5D                  <1>     pop rbp
   910 00001B45 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   911 00001B4C 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear Carry flag    
   912 00001B51 48CF                <1>     iretq
   913                              <1> ;Misc functions
   914                              <1> .fdiskReset:
   915 00001B53 E8AD1A0000          <1>     call ATA.resetChannel
   916 00001B58 B800000000          <1>     mov eax, 0  ;No issue
   917 00001B5D BB05000000          <1>     mov ebx, 5  ;Reset failed
   918 00001B62 0F42C3              <1>     cmovc eax, ebx  ;Only move if carry set
   919 00001B65 880425[A9010000]    <1>     mov byte [msdStatus], al    ;Save status byte
   920 00001B6C 72BF                <1>     jc .badExit ;Carry is still preserved
   921 00001B6E EBD0                <1>     jmp short .okExit
   922                              <1> 
   923                              <1> .fdiskStatus:
   924 00001B70 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Save old status
   925 00001B77 C60425[A9010000]00  <1>     mov byte [msdStatus], 0     ;Clear the status
   926 00001B7F 84E4                <1>     test ah, ah
   927 00001B81 75AA                <1>     jnz .badExit    ;Set carry flag if status is non-zero
   928 00001B83 EBBB                <1>     jmp short .okExit
   929                              <1> ;CHS functions
   930                              <1> .fdiskReadCHS:
   931 00001B85 57                  <1>     push rdi
   932 00001B86 E8231C0000          <1>     call ATA.readCHS
   933 00001B8B 5F                  <1>     pop rdi
   934 00001B8C 0F8228010000        <1>     jc .fdiskError
   935 00001B92 E9A9FFFFFF          <1>     jmp .okExit
   936                              <1>     
   937                              <1> .fdiskWriteCHS:
   938 00001B97 56                  <1>     push rsi
   939 00001B98 E82F1C0000          <1>     call ATA.writeCHS
   940 00001B9D 5E                  <1>     pop rsi
   941 00001B9E 0F8216010000        <1>     jc .fdiskError
   942 00001BA4 E997FFFFFF          <1>     jmp .okExit
   943                              <1> 
   944                              <1> .fdiskVerifyCHS:
   945 00001BA9 E83C1C0000          <1>     call ATA.verifyCHS
   946 00001BAE 0F8206010000        <1>     jc .fdiskError
   947 00001BB4 E987FFFFFF          <1>     jmp .okExit
   948                              <1> 
   949                              <1> ;Format a whole "track" (for now just overwrite)
   950                              <1> .fdiskFormat:
   951 00001BB9 E8481C0000          <1>     call ATA.formatCHS
   952 00001BBE 0F82F6000000        <1>     jc .fdiskError
   953 00001BC4 E977FFFFFF          <1>     jmp .okExit
   954                              <1> 
   955                              <1> .fdiskParametersCHS:
   956                              <1> ;Reads CHS drive parameters for given drive 
   957                              <1> ;Output: dl = Number of fixed disks in system
   958                              <1> ;        dh = Max head number for chosen drive
   959                              <1> ;        ch = Cylinder number
   960                              <1> ;        cl[7:6] = High two bits of Cylinder number
   961                              <1> ;        cl[5:0] = Sectors per track
   962                              <1> ;        ebx = Dword, sector size
   963                              <1> ;        ah = 0
   964 00001BC9 5A                  <1>     pop rdx
   965 00001BCA 59                  <1>     pop rcx
   966 00001BCB 5B                  <1>     pop rbx
   967 00001BCC 0FB74501            <1>     movzx eax, word [rbp + fdiskEntry.wHeads]
   968 00001BD0 88C6                <1>     mov dh, al
   969 00001BD2 0FB74503            <1>     movzx eax, word [rbp + fdiskEntry.wCylinder]
   970 00001BD6 88C5                <1>     mov ch, al  ;Low 8 bits 
   971 00001BD8 66C1E802            <1>     shr ax, 2   ;Move bits [1:0] of ah to bits [7:6] of al
   972 00001BDC 24C0                <1>     and al, 0C0h    ;Clear lower bits [5:0]
   973 00001BDE 88C1                <1>     mov cl, al
   974 00001BE0 0FB74505            <1>     movzx eax, word [rbp + fdiskEntry.wSecTrc]
   975 00001BE4 243F                <1>     and al, 3Fh ;Save only bits [5:0]
   976 00001BE6 08C1                <1>     or cl, al   ;Add the sector per track bits here
   977 00001BE8 8A1425[AA010000]    <1>     mov dl, byte [fdiskNum] ;Get number of fixed disks in dl
   978 00001BEF 31DB                <1>     xor ebx, ebx
   979 00001BF1 BB00020000          <1>     mov ebx, 200h       ;Currently, hardcode sector size of 512 bytes
   980 00001BF6 E948FFFFFF          <1>     jmp .paramExit
   981                              <1> 
   982                              <1> ;LBA functions
   983                              <1> .fdiskReadLBA:
   984 00001BFB 57                  <1>     push rdi
   985 00001BFC 56                  <1>     push rsi
   986 00001BFD 488D3425[6D380000]  <1>     lea rsi, ATA.readLBA
   987 00001C05 488D3C25[28390000]  <1>     lea rdi, ATA.readLBA48
   988 00001C0D F6450004            <1>     test byte [rbp + fdiskEntry.signature], fdeLBA48
   989 00001C11 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
   990 00001C15 FFD7                <1>     call rdi    ;rdi is a free parameter anyway
   991 00001C17 5E                  <1>     pop rsi
   992 00001C18 5F                  <1>     pop rdi
   993 00001C19 0F829B000000        <1>     jc .fdiskError
   994 00001C1F E91CFFFFFF          <1>     jmp .okExit
   995                              <1> 
   996                              <1> .fdiskWriteLBA:
   997 00001C24 57                  <1>     push rdi
   998 00001C25 56                  <1>     push rsi
   999 00001C26 488D3425[8B380000]  <1>     lea rsi, ATA.writeLBA
  1000 00001C2E 488D3C25[46390000]  <1>     lea rdi, ATA.writeLBA48
  1001 00001C36 F6450004            <1>     test byte [rbp + fdiskEntry.signature], fdeLBA48
  1002 00001C3A 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
  1003 00001C3E FFD7                <1>     call rdi    ;rdi is a free parameter anyway
  1004 00001C40 5E                  <1>     pop rsi
  1005 00001C41 5F                  <1>     pop rdi
  1006 00001C42 7276                <1>     jc .fdiskError
  1007 00001C44 E9F7FEFFFF          <1>     jmp .okExit
  1008                              <1> 
  1009                              <1> .fdiskVerifyLBA:
  1010 00001C49 57                  <1>     push rdi
  1011 00001C4A 56                  <1>     push rsi
  1012 00001C4B 488D3425[A9380000]  <1>     lea rsi, ATA.verifyLBA
  1013 00001C53 488D3C25[64390000]  <1>     lea rdi, ATA.verifyLBA48
  1014 00001C5B F6450004            <1>     test byte [rbp + fdiskEntry.signature], fdeLBA48
  1015 00001C5F 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
  1016 00001C63 FFD7                <1>     call rdi    ;rdi is a free parameter anyway
  1017 00001C65 5E                  <1>     pop rsi
  1018 00001C66 5F                  <1>     pop rdi
  1019 00001C67 7251                <1>     jc .fdiskError
  1020 00001C69 E9D2FEFFFF          <1>     jmp .okExit
  1021                              <1> 
  1022                              <1> .fdiskFormatSector:
  1023                              <1> ;Format a series of sectors (for now just overwrite with fillbyte)
  1024 00001C6E 57                  <1>     push rdi
  1025 00001C6F 56                  <1>     push rsi
  1026 00001C70 488D3425[C7380000]  <1>     lea rsi, ATA.formatLBA
  1027 00001C78 488D3C25[82390000]  <1>     lea rdi, ATA.formatLBA48
  1028 00001C80 F6450004            <1>     test byte [rbp + fdiskEntry.signature], fdeLBA48
  1029 00001C84 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
  1030 00001C88 FFD7                <1>     call rdi    ;rdi is a free parameter anyway
  1031 00001C8A 5E                  <1>     pop rsi
  1032 00001C8B 5F                  <1>     pop rdi
  1033 00001C8C 722C                <1>     jc .fdiskError
  1034 00001C8E E9ADFEFFFF          <1>     jmp .okExit
  1035                              <1> .fdiskParametersLBA:
  1036                              <1> ;Output: 
  1037                              <1> ;        ebx = Dword, sector size
  1038                              <1> ;        rcx = qLastLBANum (Qword address of last LBA)
  1039                              <1> ;        dl = Number of fixed disks in system
  1040                              <1> ;        Fixed disks have a fixed sector size of 512 bytes
  1041                              <1> ;Recall last LBA value is the first NON-user usable LBA
  1042                              <1> ;Will return LBA48 if the device uses LBA48 in rcx
  1043 00001C93 5A                  <1>     pop rdx
  1044 00001C94 59                  <1>     pop rcx
  1045 00001C95 5B                  <1>     pop rbx
  1046 00001C96 31C9                <1>     xor ecx, ecx    ;Zero whole of rcx
  1047 00001C98 8B4D07              <1>     mov ecx, dword [rbp + fdiskEntry.lbaMax]
  1048 00001C9B 488B450B            <1>     mov rax, qword [rbp + fdiskEntry.lbaMax48]
  1049 00001C9F F6450004            <1>     test byte [rbp + fdiskEntry.signature], fdeLBA48
  1050 00001CA3 480F45C8            <1>     cmovnz rcx, rax ;Move lba48 value into rcx if LBA48 bit set
  1051 00001CA7 8A1425[AA010000]    <1>     mov dl, byte [fdiskNum] ;Number of fixed disks
  1052 00001CAE 31DB                <1>     xor ebx, ebx
  1053 00001CB0 BB00020000          <1>     mov ebx, 200h       ;Currently, hardcode sector size of 512 bytes
  1054 00001CB5 E989FEFFFF          <1>     jmp .paramExit
  1055                              <1> .fdiskError:
  1056                              <1> ;A common error handler that checks the status and error register 
  1057                              <1> ; to see what the error may have been. If nothing, then the error
  1058                              <1> ; that is in the msdStatus byte is left as is, unless it is 0
  1059                              <1> ; where a Undefined Error is placed.
  1060 00001CBA 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
  1061 00001CBE 81C207000000        <1>     add edx, 7  ;Goto status
  1062 00001CC4 E805190000          <1>     call ATA.wait400ns
  1063 00001CC9 EC                  <1>     in al, dx   ;Get status byte
  1064 00001CCA A880                <1>     test al, 80h    ;If busy is STILL set, controller failure
  1065 00001CCC 7578                <1>     jnz .fdiskCtrlrFailed
  1066 00001CCE A820                <1>     test al, 20h    ;Test drive fault error
  1067 00001CD0 7567                <1>     jnz .fdiskErrorDriveFault
  1068 00001CD2 A801                <1>     test al, 1  ;Test the error bit is set
  1069 00001CD4 7454                <1>     jz .fdiskErrorNoBit ;If not set then check if we have an error code 
  1070 00001CD6 81EA06000000        <1>     sub edx, 6  ;Goto base + 1, Error register
  1071 00001CDC EC                  <1>     in al, dx   ;Get Error register
  1072 00001CDD 84C0                <1>     test al, al 
  1073 00001CDF 743C                <1>     jz .fdiskNoErrorData
  1074 00001CE1 88C4                <1>     mov ah, al
  1075 00001CE3 80E484              <1>     and ah, 84h ;Save abort and interface crc
  1076 00001CE6 80FC84              <1>     cmp ah, 84h
  1077 00001CE9 7425                <1>     je .fdiskCRCError
  1078 00001CEB A840                <1>     test al, 40h    ;Test the uncorrectable Error bit
  1079 00001CED 7521                <1>     jnz .fdiskCRCError
  1080 00001CEF 88C4                <1>     mov ah, al
  1081 00001CF1 80E414              <1>     and ah, 14h ;If either bit is set, then it is a bad sector number
  1082 00001CF4 750D                <1>     jnz .fdiskBadAddress
  1083                              <1> .fdiskErrorUnknown: ;Fallthrough here
  1084 00001CF6 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh  ;Unknown Error code
  1085 00001CFE E92AFEFFFF          <1>     jmp .badExit
  1086                              <1> .fdiskBadAddress:
  1087 00001D03 C60425[A9010000]04  <1>     mov byte [msdStatus], 04h   ;Sector not found
  1088 00001D0B E91DFEFFFF          <1>     jmp .badExit
  1089                              <1> .fdiskCRCError:
  1090 00001D10 C60425[A9010000]10  <1>     mov byte [msdStatus], 10h   ;Uncorrectable CRC error
  1091 00001D18 E910FEFFFF          <1>     jmp .badExit
  1092                              <1> .fdiskNoErrorData:
  1093 00001D1D C60425[A9010000]E0  <1>     mov byte [msdStatus], 0E0h  ;Status error = 0
  1094 00001D25 E903FEFFFF          <1>     jmp .badExit
  1095                              <1> .fdiskErrorNoBit:
  1096 00001D2A 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
  1097 00001D31 84E4                <1>     test ah, ah
  1098 00001D33 0F85F4FDFFFF        <1>     jnz .badExit    ;If there is a code, leave it in situ and exit service
  1099                              <1> 
  1100                              <1> .fdiskErrorDriveFault:
  1101 00001D39 C60425[A9010000]07  <1>     mov byte [msdStatus], 07h  ;Drive parameter activity failed
  1102 00001D41 E9E7FDFFFF          <1>     jmp .badExit
  1103                              <1> .fdiskCtrlrFailed:
  1104 00001D46 C60425[A9010000]20  <1>     mov byte [msdStatus], 020h  ;Controller failure code
  1105 00001D4E E9DAFDFFFF          <1>     jmp .badExit
  1106                              <1> ;------------------------End of Interrupt------------------------
    96                                  %include "./Source/Resident/Services/Int34h.asm"
    97                              <1> ;------------------Serial IO Interrupts Int 34h------------------
    98                              <1> serial_baud_table:    ;DLAB devisor values
    99 00001D53 1704                <1>     dw    0417h    ;110 baud,     00
   100 00001D55 0003                <1>     dw    0300h    ;150 baud,     01
   101 00001D57 8001                <1>     dw    0180h    ;300 baud,     02
   102 00001D59 C000                <1>     dw    00C0h    ;600 baud,     03
   103 00001D5B 6000                <1>     dw    0060h    ;1200 baud,    04
   104 00001D5D 3000                <1>     dw    0030h    ;2400 baud,    05 
   105 00001D5F 1800                <1>     dw    0018h    ;4800 baud,    06
   106 00001D61 0C00                <1>     dw    000Ch    ;9600 baud,    07
   107 00001D63 0600                <1>     dw    0006h    ;19200 baud,   08
   108 00001D65 0300                <1>     dw    0003h    ;38400 baud,   09
   109 00001D67 0200                <1>     dw    0002h    ;57600 baud,   0A
   110 00001D69 0100                <1>     dw    0001h    ;115200 baud,  0B
   111                              <1> serial_abt: ;serial port address base table. List of supported addresses!
   112 00001D6B F803                <1>     dw com1_base
   113 00001D6D F802                <1>     dw com2_base
   114 00001D6F E803                <1>     dw com3_base
   115 00001D71 E802                <1>     dw com4_base
   116                              <1> serial_io:
   117 00001D73 52                  <1>     push rdx        ;Save upper 7 bytes
   118 00001D74 6681FA0400          <1>     cmp dx, 4        ;Check to see if the selected com port is within range
   119 00001D79 7D5A                <1>     jge .sbadexit1    ;Bad dx value
   120 00001D7B 480FB7D2            <1>     movzx rdx, dx    ;zero the upper 6 bytes of rdx
   121 00001D7F 668B9412[67000000]  <1>     mov dx, word [com_addresses + rdx*2]    ;get serial port base addr into dx
   122 00001D87 6685D2              <1>     test dx, dx        ;is the address zero?
   123 00001D8A 744D                <1>     jz .sbadexit2    ;com port doesnt exist
   124 00001D8C 50                  <1>     push rax        ;Saves upper 6 bytes
   125 00001D8D 52                  <1>     push rdx        ;Save base for exit algorithm
   126                              <1> 
   127 00001D8E 84E4                <1>     test ah, ah
   128 00001D90 7451                <1>     jz .userinit
   129 00001D92 FECC                <1>     dec ah 
   130 00001D94 0F848A000000        <1>     jz .transmit
   131 00001D9A FECC                <1>     dec ah
   132 00001D9C 0F84B7000000        <1>     jz .recieve
   133 00001DA2 FECC                <1>     dec ah
   134 00001DA4 741E                <1>     jz .sioexit    ;since this puts the status into ax
   135 00001DA6 FECC                <1>     dec ah
   136 00001DA8 0F842A010000        <1>     jz .extinit
   137 00001DAE FECC                <1>     dec ah
   138 00001DB0 0F8422010000        <1>     jz .extstatus
   139 00001DB6 FECC                <1>     dec ah
   140 00001DB8 0F841A010000        <1>     jz .custombaud
   141                              <1> 
   142                              <1> .badin:
   143 00001DBE 5A                  <1>     pop rdx
   144 00001DBF 58                  <1>     pop rax
   145 00001DC0 B480                <1>     mov ah, 80h    ;Invalid Function
   146 00001DC2 EB17                <1>     jmp short .sbadcommon
   147                              <1> .sioexit:
   148 00001DC4 5A                  <1>     pop rdx   ;Get base back, to know exact offset
   149 00001DC5 58                  <1>     pop rax        ;Return the upper bytes of rax into rax
   150 00001DC6 6681C20500          <1>     add dx, 5    ;point to the line status register
   151 00001DCB EC                  <1>     in al, dx    ;get status
   152 00001DCC 88C4                <1>     mov ah, al    ;save line status in ah
   153 00001DCE 66FFC2              <1>     inc dx        ;point to the modem status register
   154 00001DD1 EC                  <1>     in al, dx    ;save modem status in al
   155 00001DD2 5A                  <1>     pop rdx
   156 00001DD3 48CF                <1>     iretq
   157                              <1> 
   158                              <1> .sbadexit1:    
   159 00001DD5 B0FF                <1>     mov al, 0FFh    ;dx was too large
   160 00001DD7 EB02                <1>     jmp short .sbadcommon
   161                              <1> .sbadexit2:
   162 00001DD9 B0FE                <1>     mov al, 0FEh    ;COM port doesnt exist
   163                              <1> .sbadcommon:
   164 00001DDB 5A                  <1>     pop rdx        ;return original rdx value
   165 00001DDC 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   166 00001DE1 48CF                <1>     iretq
   167                              <1> 
   168                              <1> .userinit:
   169 00001DE3 88C4                <1>     mov ah, al    ;save the data in ah for the baud rate
   170 00001DE5 6681C20300          <1>     add dx, 3    ;Point to the line control register
   171 00001DEA 241F                <1>     and al, 00011111b   ;Zero out the upper three bits
   172 00001DEC 0C80                <1>     or al, 10000000b    ;Set the DLAB bit
   173 00001DEE EE                  <1>     out dx, al 
   174                              <1> 
   175 00001DEF 6681EA0300          <1>     sub dx, 3    ;return point to base
   176 00001DF4 66C1E80D            <1>     shr ax, 0Dh  ;0Dh=move hi bits of hi word into low bits of low word
   177 00001DF8 480FB6C0            <1>     movzx rax, al    ;zero upper 7 bytes of rax
   178 00001DFC 3C07                <1>     cmp al, 00000111b    ;Check if set to 9600baud (for extension)
   179 00001DFE 7414                <1>     je .ui2
   180                              <1> .ui1:
   181 00001E00 668B80[531D0000]    <1>     mov ax, word [serial_baud_table + rax]    ;rax is the offset into the table
   182 00001E07 66EF                <1>     out dx, ax    ;dx points to base with dlab on, set divisor! (word out)
   183                              <1> ;Disable DLAB bit now
   184 00001E09 6681C20300          <1>     add dx, 3
   185 00001E0E EC                  <1>     in al, dx    ;Get the Line Control Register (preserving the written data)
   186 00001E0F 247F                <1>     and al, 01111111b    ;Clear the DLAB bit, preserve the other bits
   187 00001E11 EE                  <1>     out dx, al    ;Clear the bit
   188                              <1> 
   189 00001E12 EBB0                <1>     jmp short .sioexit    ;exit!
   190                              <1> .ui2:    ;Check r8b to make sure it is 0-4 inclusive.
   191 00001E14 4180F804            <1>     cmp r8b, 4    ;greater than four defaults to 4
   192 00001E18 7F05                <1>     jg .ui3    ;r8b is greater than four, error!
   193 00001E1A 4400C0              <1>     add al, r8b    ;increase the offset into the table
   194 00001E1D EBE1                <1>     jmp short .ui1    ;return to the get value from table
   195                              <1> .ui3:    ;If r8b greater than 4, default to 4
   196 00001E1F 41B004              <1>     mov r8b, 4   ;Error caught, user used a value greater than 4, default to 4
   197 00001E22 EBF0                <1>     jmp short .ui2    ;return to checker
   198                              <1> 
   199                              <1> .transmit:
   200 00001E24 6681C20500          <1>     add dx, 5    ;dx contains base address, point to Line status register
   201 00001E29 88C4                <1>     mov ah, al   ;temp save char to send in ah
   202 00001E2B 51                  <1>     push rcx
   203 00001E2C 6631C9              <1>     xor cx, cx
   204                              <1> .t1:
   205 00001E2F 66FFC9              <1>     dec cx
   206 00001E32 7410                <1>     jz .t2       ;timeout
   207 00001E34 EC                  <1>     in al, dx    ;get the LSR byte in
   208 00001E35 2420                <1>     and al, 00100000b    ;Check the transmit holding register empty bit
   209 00001E37 74F6                <1>     jz .t1    ;if this is zero, keep looping until it is 1 (aka empty)
   210                              <1> 
   211 00001E39 59                  <1>     pop rcx
   212 00001E3A 88E0                <1>     mov al, ah   ;return data byte down to al
   213 00001E3C 6681EA0500          <1>     sub dx, 5    ;reaim to the IO port
   214 00001E41 EE                  <1>     out dx, al   ;output the data byte to the serial line!!
   215 00001E42 EB80                <1>     jmp short .sioexit
   216                              <1> .t2:
   217 00001E44 59                  <1>     pop rcx
   218 00001E45 5A                  <1>     pop rdx      ;Get base back, to know exact offset
   219 00001E46 58                  <1>     pop rax      ;Return the upper bytes of rax into rax
   220 00001E47 6681C20500          <1>     add dx, 5    ;point to the line status register
   221 00001E4C EC                  <1>     in al, dx    ;get status
   222 00001E4D 88C4                <1>     mov ah, al   ;save line status in ah
   223 00001E4F 80E480              <1>     and ah, 80h  ;Set error bit (bit 7)
   224 00001E52 66FFC2              <1>     inc dx       ;point to the modem status register
   225 00001E55 EC                  <1>     in al, dx    ;save modem status in al
   226 00001E56 5A                  <1>     pop rdx
   227 00001E57 48CF                <1>     iretq
   228                              <1> .recieve:
   229                              <1>     ;Gets byte out of appropriate buffer head and places it in al
   230 00001E59 5A                  <1>     pop rdx
   231 00001E5A 58                  <1>     pop rax        
   232 00001E5B 5A                  <1>     pop rdx    ;Undoes the address entry and returns COM port number into dx    
   233 00001E5C 52                  <1>     push rdx   ;Save it once more
   234 00001E5D 53                  <1>     push rbx
   235 00001E5E 480FB7D2            <1>     movzx rdx, dx
   236                              <1> 
   237 00001E62 FA                  <1>     cli    ;Entering a critical area, interrupts off
   238 00001E63 488B1CD5[AF000000]  <1>     mov rbx, qword [comX_buf_head + rdx*8]
   239 00001E6B 483B1CD5[CF000000]  <1>     cmp rbx, qword [comX_buf_tail + rdx*8]
   240 00001E73 7426                <1>     je .r1    ;We are at the head of the buffer, signal error, no char to get.
   241 00001E75 8A03                <1>     mov al, byte [rbx]    ;store byte into al
   242 00001E77 88C4                <1>     mov ah, al ;temp save al in ah
   243 00001E79 48FFC3              <1>     inc rbx    ;move buffer head
   244 00001E7C 483B1CD5[0F010000]  <1>     cmp rbx, qword [comX_buf_end + rdx*8]    ;are we at the end of the buffer
   245 00001E84 7508                <1>     jne .r0    ;no, save new position
   246 00001E86 488B1CD5[EF000000]  <1>     mov rbx, qword [comX_buf_start + rdx*8]  ;yes, wrap around
   247                              <1> .r0:
   248 00001E8E 48891CD5[AF000000]  <1>     mov qword [comX_buf_head + rdx*8], rbx   ;save new buffer position
   249 00001E96 FB                  <1>     sti
   250 00001E97 5B                  <1>     pop rbx
   251 00001E98 5A                  <1>     pop rdx
   252 00001E99 EB07                <1>     jmp short .rexit
   253                              <1> .r1:
   254 00001E9B FB                  <1>     sti
   255 00001E9C B480                <1>     mov ah, 80h    ;Equivalent to a timeout error.
   256 00001E9E 5B                  <1>     pop rbx
   257 00001E9F 5A                  <1>     pop rdx
   258 00001EA0 48CF                <1>     iretq
   259                              <1> 
   260                              <1> .rexit:    ;Line status in ah. Char was got so ensure DTR is now high again!
   261 00001EA2 668B9412[67000000]  <1>     mov dx, word [com_addresses + rdx*2]    ;Get the base address back into dx
   262 00001EAA 6681C20400          <1>     add dx, 4    ;point to the modem control register
   263 00001EAF EC                  <1>     in al, dx
   264 00001EB0 A801                <1>     test al, 1   ;Test DTR is clear
   265 00001EB2 740B                <1>     jz .getscratch
   266                              <1> .gsret:
   267 00001EB4 0C01                <1>     or al, 1    ;Set DTR bit on again
   268 00001EB6 EE                  <1>     out dx, al
   269 00001EB7 66FFC2              <1>     inc dx      ;point to the line status register
   270 00001EBA EC                  <1>     in al, dx   ;get status
   271 00001EBB 86E0                <1>     xchg ah, al ;swap them around
   272 00001EBD 48CF                <1>     iretq
   273                              <1> .getscratch:
   274 00001EBF 0C10                <1>     or al, 00010000b    ;Enable loopback mode with DTR on
   275 00001EC1 EE                  <1>     out dx, al
   276 00001EC2 6681C20300          <1>     add dx, 3    ;Point to scratch register
   277 00001EC7 EC                  <1>     in al, dx    ;Get overrun char
   278 00001EC8 6681EA0700          <1>     sub dx, 7    ;transmit register
   279 00001ECD EE                  <1>     out dx, al   ;send the char (no need to play with DTR, we sending to 
   280                              <1>                  ; ourselves, generating an INT)
   281 00001ECE 6681C20400          <1>     add dx, 4    ;point back to modem control register again!
   282 00001ED3 EC                  <1>     in al, dx
   283 00001ED4 24EF                <1>     and al, 11101111b    ;Clear loopback mode, DTR bit gets set in main proc
   284 00001ED6 EBDC                <1>     jmp short .gsret    
   285                              <1> 
   286                              <1> .extinit:
   287                              <1> .extstatus:
   288                              <1> .custombaud:
   289 00001ED8 5A                  <1>     pop rdx
   290 00001ED9 58                  <1>     pop rax
   291 00001EDA B486                <1>     mov ah, 86h
   292 00001EDC E9FAFEFFFF          <1>     jmp .sbadcommon
   293                              <1> ;------------------------End of Interrupt------------------------
    97                                  %include "./Source/Resident/Services/Int35h.asm"
    98                              <1> ;-------------------Misc IO Interrupts Int 35h-------------------
    99                              <1> ;Misc features int that can be used for a variety of things.
   100                              <1> ;This will break compatibility with BIOS, since hopefully more 
   101                              <1> ; advanced features will be present.
   102                              <1> ;
   103                              <1> ; ah = 0 - 82h System Reserved
   104                              <1> ; ah = 83h -> Reserved, Event wait
   105                              <1> ; ah = 86h -> Delay rcx = # of milliseconds to wait
   106                              <1> ; ah = 88h -> Basic High Mem Map 1 (First 16MB only)
   107                              <1> ; ah = 89h to C4h - System Reserved
   108                              <1> ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   109                              <1> ; ah = C5h - FFh BIOS device class dispatcher extensions
   110                              <1> ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   111                              <1> ; ah = C5h -> Misc sys function dispatcher      (3 funct)
   112                              <1> ; ah = E8h -> Adv mem management sys dispatcher (4 funct)
   113                              <1> ; ah = F0h -> Sys data table dispatcher         (15 funct)
   114                              <1> ; ah = F1h -> EHCI system dispatcher            (4 funct)
   115                              <1> ;----------------------------------------------------------------
   116                              <1> misc_io:
   117 00001EE1 80FC86              <1>     cmp ah, 86h
   118 00001EE4 722F                <1>     jb .badFunction
   119 00001EE6 7436                <1>     jz .delay
   120 00001EE8 80FC88              <1>     cmp ah, 88h
   121 00001EEB 0F84B0000000        <1>     jz .memory16MB
   122                              <1> 
   123 00001EF1 80FCC5              <1>     cmp ah, 0C5h    ;Miscellaneous function dispatcher
   124 00001EF4 0F84B1000000        <1>     jz .miscDispatcher 
   125 00001EFA 80FCE8              <1>     cmp ah, 0E8h    ;Advanced memory management system dispatcher
   126 00001EFD 0F847E010000        <1>     jz .advSysMemDispatcher
   127 00001F03 80FCF0              <1>     cmp ah, 0F0h    ;System table dispatcher
   128 00001F06 0F84F3010000        <1>     jz .sysDataTableDispatcher
   129 00001F0C 80FCF1              <1>     cmp ah, 0F1h    ;EHCI function dispatcher
   130 00001F0F 0F843E030000        <1>     jz .ehciFunctionDispatcher
   131                              <1> .badFunction:
   132 00001F15 B480                <1>     mov ah, 80h    ;Invalid Function
   133                              <1> .badout:
   134 00001F17 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   135 00001F1C 48CF                <1>     iretq
   136                              <1> 
   137                              <1> .delay:
   138                              <1> ;Input: rcx = milliseconds to wait (rcx < 7FFFFFFFFFFFFFFFh)
   139                              <1> ;Init IRQ 8, wait for loop to end, deactivate
   140 00001F1E FA                  <1>     cli    ;NO INTERRUPTS
   141 00001F1F 4885C9              <1>     test rcx, rcx
   142 00001F22 747B                <1>     jz .return  ;Can avoid sti since we return caller flags
   143 00001F24 50                  <1>     push rax
   144                              <1> ;Ensure PIC is saved
   145 00001F25 E421                <1>     in al, pic1data
   146 00001F27 50                  <1>     push rax    ;Save unaltered pic1 value
   147 00001F28 24FB                <1>     and al, 0FBh ;Ensure Cascading pic1 line unmasked
   148 00001F2A E621                <1>     out pic1data, al
   149                              <1> 
   150 00001F2C E4A1                <1>     in al, pic2data
   151 00001F2E 50                  <1>     push rax    ;Save unaltered pic2 value
   152 00001F2F 24FE                <1>     and al, 0FEh ;Ensure line 0 of pic2 unmasked 
   153 00001F31 E6A1                <1>     out pic2data, al
   154                              <1> 
   155 00001F33 48890C25[3B010000]  <1>     mov qword [rtc_ticks], rcx
   156 00001F3B 66B88B8B            <1>     mov ax, 8B8Bh       
   157 00001F3F E670                <1>     out cmos_base, al   ;NMI disabled
   158 00001F41 E680                <1>     out waitp, al
   159 00001F43 EB00                <1>     jmp short $+2
   160 00001F45 E471                <1>     in al, cmos_data
   161 00001F47 247F                <1>     and al, 7Fh    ;Clear upper bit
   162 00001F49 0C40                <1>     or al, 40h    ;Set periodic interrupt bit
   163 00001F4B 86E0                <1>     xchg ah, al
   164 00001F4D E670                <1>     out cmos_base, al
   165 00001F4F E680                <1>     out waitp, al
   166 00001F51 EB00                <1>     jmp short $+2
   167 00001F53 86C4                <1>     xchg al, ah
   168 00001F55 E671                <1>     out cmos_data, al
   169 00001F57 B00D                <1>     mov al, 0Dh     ;Read Register D and reenable NMI
   170 00001F59 E670                <1>     out cmos_base, al
   171 00001F5B E680                <1>     out waitp, al    ;allow one io cycle to run
   172 00001F5D EB00                <1>     jmp short $+2
   173 00001F5F E471                <1>     in al, cmos_data  
   174 00001F61 FB                  <1>     sti        ;Reenable interrupts
   175                              <1> .loopdelay:
   176 00001F62 F390                <1>     pause ;allow an interrupt to occur
   177 00001F64 48813C25[3B010000]- <1>     cmp qword [rtc_ticks], 0        ;See if we at 0 yet
   177 00001F6C 00000000            <1>
   178 00001F70 7FF0                <1>     jg .loopdelay    ;If not, keep looping
   179                              <1> ;Return CMOS to default state
   180 00001F72 FA                  <1>     cli
   181 00001F73 66B88B8B            <1>     mov ax, 8B8Bh   ;NMI disabled
   182 00001F77 E670                <1>     out cmos_base, al
   183 00001F79 E680                <1>     out waitp, al
   184 00001F7B EB00                <1>     jmp short $+2
   185 00001F7D E471                <1>     in al, cmos_data
   186 00001F7F 240F                <1>     and al, 0Fh    ;Clear all upper 4 bits
   187 00001F81 86E0                <1>     xchg ah, al
   188 00001F83 E670                <1>     out cmos_base, al
   189 00001F85 E680                <1>     out waitp, al
   190 00001F87 EB00                <1>     jmp short $+2
   191 00001F89 86E0                <1>     xchg ah, al
   192 00001F8B E671                <1>     out cmos_data, al
   193 00001F8D B00D                <1>     mov al, 0Dh     ;Read Register D and reenable NMI
   194 00001F8F E670                <1>     out cmos_base, al
   195 00001F91 E680                <1>     out waitp, al    ;allow one io cycle to run
   196 00001F93 EB00                <1>     jmp short $+2
   197 00001F95 E471                <1>     in al, cmos_data  
   198                              <1> 
   199 00001F97 58                  <1>     pop rax ;Return pic2 value
   200 00001F98 E6A1                <1>     out pic2data, al
   201 00001F9A 58                  <1>     pop rax    ;Return pic1 value
   202 00001F9B E621                <1>     out pic1data, al
   203                              <1> 
   204 00001F9D 58                  <1>     pop rax    ;Return rax value
   205 00001F9E FB                  <1>     sti
   206                              <1> .return:
   207 00001F9F 48CF                <1>     iretq
   208                              <1> .memory16MB:    ;ah=88 function
   209 00001FA1 668B0425[DE010000]  <1>     mov ax, word [srData1]
   210 00001FA9 48CF                <1>     iretq
   211                              <1> 
   212                              <1> .miscDispatcher:
   213                              <1> ; ax = C500h -> Beep PC speaker
   214                              <1> ; ax = C501h -> Connect Debugger 
   215                              <1> ; ax = C502h -> Disconnect Debugger
   216 00001FAB 84C0                <1>     test al, al     ;Play a tone using PC speaker
   217 00001FAD 0F84C7000000        <1>     jz .mdBeeper
   218 00001FB3 3C01                <1>     cmp al, 01h     ;Connect Debugger
   219 00001FB5 7409                <1>     jz .mdConnectDebugger
   220 00001FB7 3C02                <1>     cmp al, 02h     ;Disconnect Debugger
   221 00001FB9 7460                <1>     jz .mdDisconnectDebugger
   222 00001FBB E955FFFFFF          <1>     jmp .badFunction
   223                              <1> .mdConnectDebugger:
   224 00001FC0 50                  <1>     push rax
   225 00001FC1 53                  <1>     push rbx
   226 00001FC2 52                  <1>     push rdx
   227 00001FC3 56                  <1>     push rsi
   228 00001FC4 BA008F0000          <1>     mov edx, 8F00h
   229 00001FC9 BB08000000          <1>     mov ebx, codedescriptor
   230 00001FCE 48B8-               <1>     mov rax, MCP_int.singleStepsEP  ;Pointer
   230 00001FD0 [2824000000000000]  <1>
   231 00001FD8 48BE01000000000000- <1>     mov rsi, 01 ;Interrupt number, Single Step
   231 00001FE1 00                  <1>
   232 00001FE2 E8E4E0FFFF          <1>     call idtWriteEntry
   233 00001FE7 48B8-               <1>     mov rax, MCP_int.debugEp  ;Pointer
   233 00001FE9 [7D24000000000000]  <1>
   234 00001FF1 48BE03000000000000- <1>     mov rsi, 03 ;Interrupt number, Software Breakpoint
   234 00001FFA 00                  <1>
   235 00001FFB E8CBE0FFFF          <1>     call idtWriteEntry
   236 00002000 48B8-               <1>     mov rax, MCP_int.debugEpHardware  ;Pointer
   236 00002002 [5D24000000000000]  <1>
   237 0000200A 48BE3B000000000000- <1>     mov rsi, 3Bh ;Interrupt number, Invoke debugger through hardware CTRL+BREAK
   237 00002013 00                  <1>
   238 00002014 E8B2E0FFFF          <1>     call idtWriteEntry
   239 00002019 EB59                <1>     jmp short .mdDebugExit
   240                              <1> .mdDisconnectDebugger:
   241 0000201B 50                  <1>     push rax
   242 0000201C 53                  <1>     push rbx
   243 0000201D 52                  <1>     push rdx
   244 0000201E 56                  <1>     push rsi
   245 0000201F BA008F0000          <1>     mov edx, 8F00h
   246 00002024 BB08000000          <1>     mov ebx, codedescriptor
   247 00002029 48B8-               <1>     mov rax, i1  ;Pointer
   247 0000202B [7F53000000000000]  <1>
   248 00002033 48BE01000000000000- <1>     mov rsi, 01 ;Interrupt number, Single Step
   248 0000203C 00                  <1>
   249 0000203D E889E0FFFF          <1>     call idtWriteEntry
   250 00002042 48B8-               <1>     mov rax, i3  ;Pointer
   250 00002044 [9D53000000000000]  <1>
   251 0000204C 48BE03000000000000- <1>     mov rsi, 03 ;Interrupt number, Software Breakpoint
   251 00002055 00                  <1>
   252 00002056 E870E0FFFF          <1>     call idtWriteEntry
   253 0000205B 48B8-               <1>     mov rax, ctrlbreak_io  ;Pointer
   253 0000205D [B134000000000000]  <1>
   254 00002065 48BE3B000000000000- <1>     mov rsi, 3Bh ;Interrupt number, CTRL+Break
   254 0000206E 00                  <1>
   255 0000206F E857E0FFFF          <1>     call idtWriteEntry
   256                              <1> .mdDebugExit:
   257 00002074 5E                  <1>     pop rsi
   258 00002075 5A                  <1>     pop rdx
   259 00002076 5B                  <1>     pop rbx
   260 00002077 58                  <1>     pop rax
   261 00002078 48CF                <1>     iretq
   262                              <1> 
   263                              <1> .mdBeeper:
   264                              <1> ;Input: 
   265                              <1> ;   bx = Frequency divisor to use for tone
   266                              <1> ;   rcx = # of ms to beep for
   267                              <1> ; All registers including ax preserved
   268 0000207A E817E0FFFF          <1>     call beep
   269 0000207F 48CF                <1>     iretq
   270                              <1> 
   271                              <1> .advSysMemDispatcher:
   272                              <1> ; ax = E800h -> Return userBase pointer
   273                              <1> ; ax = E801h -> Give RAM count, minus the size of SCPBIOS, in ax, bx, cx, dx.
   274                              <1> ; ax = E802h -> Total RAM count (without SCP/BIOS)
   275                              <1> ; ax = E820h -> Full Memory Map, including entry for SCPBIOS
   276 00002081 84C0                <1>     test al, al
   277 00002083 7411                <1>     jz .retUserBase
   278 00002085 3C01                <1>     cmp al, 01h
   279 00002087 7417                <1>     je .memory64MB
   280 00002089 3C02                <1>     cmp al, 02h
   281 0000208B 7435                <1>     je .memoryBIOSseg
   282 0000208D 3C20                <1>     cmp al, 20h
   283 0000208F 7451                <1>     je .fullMemoryMap
   284 00002091 E97FFEFFFF          <1>     jmp .badFunction
   285                              <1> 
   286                              <1> .retUserBase:
   287 00002096 488B0425[CD010000]  <1>     mov rax, qword [userBase]
   288 0000209E 48CF                <1>     iretq
   289                              <1> .memory64MB:
   290 000020A0 668B0425[D6010000]  <1>     mov ax, word [srData]
   291 000020A8 668B1C25[D8010000]  <1>     mov bx, word [srData + 2]
   292 000020B0 668B0C25[DA010000]  <1>     mov cx, word [srData + 4]
   293 000020B8 668B1425[DC010000]  <1>     mov dx, word [srData + 6]
   294 000020C0 48CF                <1>     iretq    
   295                              <1> .memoryBIOSseg:
   296                              <1> ;This gives information about the SCP/BIOS segment
   297 000020C2 48B800001100000000- <1>     mov rax, BIOSStartAddr  ;Start address of BIOS
   297 000020CB 00                  <1>
   298 000020CC 31DB                <1>     xor ebx, ebx
   299 000020CE 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]    ;Total sum of segment sizes
   300 000020D5 488B1425[E0010000]  <1>     mov rdx, qword [sysMem]     ;Get total usable memory count
   301 000020DD 4829DA              <1>     sub rdx, rbx    ;Remove SCP/BIOS allocation from the size
   302 000020E0 48CF                <1>     iretq
   303                              <1> 
   304                              <1> .fullMemoryMap:
   305 000020E2 488B0425[CD010000]  <1>     mov rax, qword [userBase]    ;Start space, returns userbase in r8
   306 000020EA 48BE-               <1>     mov rsi, bigmapptr
   306 000020EC [F005000000000000]  <1>
   307 000020F4 8A0C25[D5010000]    <1>     mov cl, byte [bigmapSize]   ;Get the number of 24 byte entries
   308 000020FB 30ED                <1>     xor ch, ch                  ;Reserve the upper byte
   309 000020FD 48CF                <1>     iretq
   310                              <1> 
   311                              <1> .sysDataTableDispatcher:
   312                              <1> ; ax = F000h, Register new GDT ptr
   313                              <1> ; ax = F001h, Register new IDT ptr
   314                              <1> ; ax = F002h, Get Current GDT ptr
   315                              <1> ; ax = F003h, Get Current IDT ptr
   316                              <1> ; ax = F004h, Register New Page Tables
   317                              <1> ; ax = F005h, Get physical address of PTables
   318                              <1> ; ax = F006h, Get pointer to BIOS Data Area
   319                              <1> ; ax = F007h, Read IDT entry
   320                              <1> ; ax = F008h, Write IDT entry
   321                              <1> ; ax = F009h, Register new Disk Parameter Table
   322                              <1> ; ax = F00Ah, Get current DPT
   323                              <1> ; ax = F00Bh, Register new Fixed Disk Parameter Table
   324                              <1> ; ax = F00Ch, Get current fDPT
   325                              <1> ; ax = F00Dh, Register new SysInit parameters 
   326                              <1> ; ax = F00Eh, Get current SysInit parameters
   327 000020FF 3C04                <1>     cmp al, 4h          
   328 00002101 725D                <1>     jb .sdtDT           ;al = 00 - 03, goto sdtDT
   329 00002103 3C04                <1>     cmp al, 4           
   330 00002105 0F8493000000        <1>     jz .sdtRegisterPage ;al = 04
   331 0000210B 3C05                <1>     cmp al, 5
   332 0000210D 0F8495000000        <1>     jz .sdtGetPagePtr   ;al = 05
   333 00002113 3C06                <1>     cmp al, 6
   334 00002115 0F8497000000        <1>     jz .sdtDataptr      ;al = 06
   335 0000211B 3C07                <1>     cmp al, 7
   336 0000211D 0F849B000000        <1>     jz .sdtReadIDTEntry ;al = 07
   337 00002123 3C08                <1>     cmp al, 8
   338 00002125 0F84C4000000        <1>     jz .sdtWriteIDTEntry    ;al = 08
   339 0000212B 3C09                <1>     cmp al, 9
   340 0000212D 0F84D4000000        <1>     jz .sdtNewDDP       ;al = 09
   341 00002133 3C0A                <1>     cmp al, 0Ah
   342 00002135 0F84E0000000        <1>     jz .sdtReadDDP      ;al = 0A
   343 0000213B 3C0B                <1>     cmp al, 0Bh         
   344 0000213D 0F84CE000000        <1>     jz .sdtNewfDDP      ;al = 0Bh
   345 00002143 3C0C                <1>     cmp al, 0Ch
   346 00002145 0F84DA000000        <1>     jz .sdtReadfDDP     ;al = 0Ch
   347 0000214B 3C0D                <1>     cmp al, 0Dh
   348 0000214D 0F84DC000000        <1>     jz .sdtNewSysInit   ;al = 0Dh
   349 00002153 3C0E                <1>     cmp al, 0Eh
   350 00002155 0F84E6000000        <1>     jz .sdtReadSysInit  ;al = 0Eh
   351 0000215B E9B5FDFFFF          <1>     jmp .badFunction
   352                              <1> 
   353                              <1> .sdtDT:
   354                              <1> ;sys data tables Descriptor Table dispatcher
   355                              <1> ;rbx has/will have I/GDT base pointer (qword)
   356                              <1> ;ecx has/will have I/GDT limit (word)
   357                              <1> ;edx has/will have Number of entries in I/GDT (word)
   358 00002160 57                  <1>     push rdi
   359 00002161 56                  <1>     push rsi
   360 00002162 48BF-               <1>     mov rdi, GDTlength
   360 00002164 [0C00000000000000]  <1>
   361 0000216C 48BE-               <1>     mov rsi, IDTlength
   361 0000216E [0000000000000000]  <1>
   362 00002176 A801                <1>     test al, 1  ;If al[0] = 1, want rdi to point to IDT area
   363 00002178 480F45FE            <1>     cmovnz rdi, rsi ;If al[0] = 0, rdi will keep pointing to GDT
   364 0000217C A802                <1>     test al, 2  ;If bit 2 is set, Get pointers
   365 0000217E 750F                <1>     jnz .sdtGet
   366 00002180 668917              <1>     mov word [rdi], dx
   367 00002183 66894F02            <1>     mov word [rdi + 2], cx
   368 00002187 48895F04            <1>     mov qword [rdi + 4], rbx
   369 0000218B 56                  <1>     push rsi
   370 0000218C 5F                  <1>     pop rdi
   371 0000218D 48CF                <1>     iretq
   372                              <1> .sdtGet:
   373 0000218F 0FB717              <1>     movzx edx, word [rdi]
   374 00002192 0FB74F02            <1>     movzx ecx, word [rdi + 2]
   375 00002196 488B5F04            <1>     mov rbx, qword [rdi + 4]
   376 0000219A 56                  <1>     push rsi
   377 0000219B 5F                  <1>     pop rdi
   378 0000219C 48CF                <1>     iretq
   379                              <1> .sdtRegisterPage:
   380 0000219E 48891C25[18000000]  <1>     mov qword [pageTablePtr], rbx   ;Registers pointer as new table space
   381 000021A6 48CF                <1>     iretq
   382                              <1> .sdtGetPagePtr:
   383 000021A8 488B1C25[18000000]  <1>     mov rbx, qword [pageTablePtr]  ;Return BIOS Page Table ptr
   384 000021B0 48CF                <1>     iretq
   385                              <1> .sdtDataptr:
   386 000021B2 48BB-               <1>     mov rbx, section.data.start        ;Get BIOS Data area ptr into rax
   386 000021B4 [0000000000000000]  <1>
   387 000021BC 48CF                <1>     iretq
   388                              <1> .sdtReadIDTEntry:
   389                              <1> ;bx = Number of interrupt handler (00h-0FFFFh), uses only bl
   390                              <1> ;Returns pointer in rbx, 
   391                              <1> ;Segment selector in ax,
   392                              <1> ;Attribute word in dx
   393 000021BE 480FB6DB            <1>     movzx rbx, bl
   394 000021C2 488B1425[04000000]  <1>     mov rdx, qword [IDTpointer.Base]    ;Get base address
   395 000021CA 48C1E304            <1>     shl rbx, 4h         ;Multiply address number by 16
   396 000021CE 4801DA              <1>     add rdx, rbx        ;rdx point to IDT entry
   397 000021D1 8B4208              <1>     mov eax, dword [rdx + 8]
   398 000021D4 48C1E020            <1>     shl rax, 20h        ;Shift dword into upper dword
   399 000021D8 668B5A06            <1>     mov bx, word [rdx + 6]
   400 000021DC C1E310              <1>     shl ebx, 10h        ;Shift word into upper word
   401 000021DF 668B1A              <1>     mov bx, word [rdx]  ;Get final word
   402 000021E2 4809C3              <1>     or rbx, rax         ;Add upper dword to rbx
   403 000021E5 668B4202            <1>     mov ax, word [rdx + 2]  ;Get Segment selector in ax
   404 000021E9 668B5204            <1>     mov dx, word [rdx + 4]  ;Get attributes word
   405 000021ED 48CF                <1>     iretq
   406                              <1> .sdtWriteIDTEntry:
   407                              <1> ;rbx = Pointer to new routine
   408                              <1> ;cx = Number of the interrupt handler (00h-0FFFFh), uses only cl
   409                              <1> ;dx = IDT entry attributes
   410                              <1> ;si = Segment selector
   411 000021EF 50                  <1>     push rax
   412 000021F0 51                  <1>     push rcx
   413 000021F1 56                  <1>     push rsi
   414 000021F2 53                  <1>     push rbx
   415 000021F3 4889D8              <1>     mov rax, rbx    ;Move pointer to new routine to rax
   416 000021F6 89F3                <1>     mov ebx, esi    ;Move Segment selector from si to bx 
   417 000021F8 480FB6F1            <1>     movzx rsi, cl   ;Movzx low byte of interrupt number into rsi
   418 000021FC E8CADEFFFF          <1>     call idtWriteEntry
   419 00002201 5B                  <1>     pop rbx
   420 00002202 5E                  <1>     pop rsi
   421 00002203 59                  <1>     pop rcx
   422 00002204 58                  <1>     pop rax
   423 00002205 48CF                <1>     iretq
   424                              <1> .sdtNewDDP:
   425 00002207 48891C25[AF010000]  <1>     mov qword [diskDptPtr], rbx
   426 0000220F 48CF                <1>     iretq
   427                              <1> .sdtNewfDDP:
   428 00002211 48891C25[B7010000]  <1>     mov qword [fdiskDptPtr], rbx
   429 00002219 48CF                <1>     iretq
   430                              <1> .sdtReadDDP:
   431 0000221B 488B1C25[AF010000]  <1>     mov rbx, qword [diskDptPtr]
   432 00002223 48CF                <1>     iretq
   433                              <1> .sdtReadfDDP:
   434 00002225 488B1C25[B7010000]  <1>     mov rbx, qword [fdiskDptPtr]
   435 0000222D 48CF                <1>     iretq
   436                              <1> .sdtNewSysInit:
   437 0000222F 48891C25[BF010000]  <1>     mov qword [nextFilePtr], rbx
   438 00002237 66891425[C7010000]  <1>     mov word [numSectors], dx
   439 0000223F 48CF                <1>     iretq
   440                              <1> .sdtReadSysInit:
   441 00002241 488B1C25[BF010000]  <1>     mov rbx, qword [nextFilePtr]
   442 00002249 668B1425[C7010000]  <1>     mov dx, word [numSectors]
   443 00002251 48CF                <1>     iretq
   444                              <1> .ehciFunctionDispatcher:
   445                              <1> ;EHCI function dispatcher 0F1h
   446                              <1> ; al = 00h -> EHCI get crit error handler
   447                              <1> ; al = 01h -> EHCI set crit error handler
   448                              <1> ; al = 02h -> Reserved, reset selected EHCI controller
   449                              <1> ; al = 03h -> Reserved, re-enumerate devices downstream of EHCI Root hub
   450 00002253 84C0                <1>     test al, al
   451 00002255 7411                <1>     jz .ehciDispGetCritPtr
   452 00002257 FEC8                <1>     dec al
   453 00002259 7417                <1>     jz .ehciDispSetCritPtr
   454 0000225B FEC8                <1>     dec al
   455 0000225D 741D                <1>     jz .ehciDispResetCtrlr
   456 0000225F FEC8                <1>     dec al
   457 00002261 7419                <1>     jz .echiDispReEnumDevices
   458 00002263 E9ADFCFFFF          <1>     jmp .badFunction
   459                              <1> 
   460                              <1> .ehciDispGetCritPtr:
   461                              <1> ;Gets the address of the current EHCI critical error handler into rbx
   462 00002268 488B1C25[36020000]  <1>     mov rbx, qword [eHCErrorHandler]
   463 00002270 48CF                <1>     iretq
   464                              <1> .ehciDispSetCritPtr:
   465                              <1> ;Sets the address of the EHCI critical error handler to the ptr in rbx
   466 00002272 48891C25[36020000]  <1>     mov qword [eHCErrorHandler], rbx
   467 0000227A 48CF                <1>     iretq
   468                              <1> .ehciDispResetCtrlr:
   469                              <1> .echiDispReEnumDevices:
   470 0000227C B486                <1>     mov ah, 86h     ;Unsupported function call
   471 0000227E E994FCFFFF          <1>     jmp .badout  
   472                              <1> ;------------------------End of Interrupt------------------------
    98                                  %include "./Source/Resident/Services/Int36h.asm"
    99                              <1> ;-------------------Keyboard Interrupt Int 36h-------------------
   100                              <1> ; Software keyboard interrupt. 
   101                              <1> ; ah = 0 -> Read the next scancode/ASCII struck from the keyboard
   102                              <1> ; ah = 1 -> Clear zero flag if there is a new char ready to be 
   103                              <1> ;           read.
   104                              <1> ; ah = 2 -> Returns the current shift status in the al register
   105                              <1> ; ax and flags changed.
   106                              <1> ;----------------------------------------------------------------
   107                              <1> kb_io:
   108 00002283 53                  <1>     push rbx
   109 00002284 FA                  <1>     cli            ;Interrupts off
   110 00002285 84E4                <1>     test ah, ah
   111 00002287 7411                <1>     jz .k0
   112 00002289 FECC                <1>     dec ah
   113 0000228B 7436                <1>     jz .k1
   114 0000228D FECC                <1>     dec ah
   115 0000228F 7450                <1>     jz .k2
   116 00002291 804C241801          <1>     or byte [rsp + 3*8h], 1    ;Set CF, invalid function, skip rbx on stack
   117 00002296 B480                <1>     mov ah, 80h    ;Invalid Function
   118 00002298 EB4E                <1>     jmp short .kexit ;ah > 2, not a valid function
   119                              <1>     
   120                              <1> .k0:    
   121                              <1> ;This one moves the head to catch up with the tail.
   122 0000229A FB                  <1>     sti
   123 0000229B F390                <1>     pause    ;Allow a keyboard interrupt to occur
   124 0000229D FA                  <1>     cli
   125 0000229E 488B1C25[42000000]  <1>     mov rbx, qword [kb_buf_head]
   126 000022A6 483B1C25[4A000000]  <1>     cmp rbx, qword [kb_buf_tail]    ;Are we at the head of the buffer?
   127 000022AE 74EA                <1>     je .k0    ;If we are, then the buffer is empty, await a keystroke
   128 000022B0 66678B03            <1>     mov ax, word [ebx]        ;move the word pointed at by rbx to ax
   129 000022B4 E833000000          <1>     call .kb_ptr_adv    ;Advance the buffer pointer
   130                              <1>     
   131 000022B9 48891C25[42000000]  <1>     mov qword [kb_buf_head], rbx    ;Move rbx into the buffer head variable
   132 000022C1 EB25                <1>     jmp short .kexit
   133                              <1> 
   134                              <1> .k1:
   135 000022C3 488B1C25[42000000]  <1>     mov rbx, qword [kb_buf_head]
   136 000022CB 483B1C25[4A000000]  <1>     cmp rbx, qword [kb_buf_tail] ;sets flags, Z is set if equal 
   137 000022D3 660F4503            <1>     cmovnz ax, word [rbx]    ;move head of buffer into ax, IF Z clear
   138 000022D7 FB                  <1>     sti     ;renable interrupts 
   139 000022D8 9C                  <1>     pushfq    ;push flags onto stack
   140 000022D9 5B                  <1>     pop rbx    ;pop them into rbx
   141 000022DA 48895C2418          <1>     mov [rsp + 3*8h], qword rbx    ;Replace with new flags, skip pushed rbx
   142 000022DF EB07                <1>     jmp short .kexit
   143                              <1>     
   144                              <1> .k2:
   145 000022E1 8A0425[62000000]    <1>     mov al, byte [kb_flags]
   146                              <1> .kexit:
   147 000022E8 FB                  <1>     sti
   148 000022E9 5B                  <1>     pop rbx
   149 000022EA 48CF                <1>     iretq
   150                              <1> 
   151                              <1> .kb_ptr_adv:
   152                              <1> ;Advance the pointer passed by rbx safely and return pointer!
   153 000022EC 48FFC3              <1>     inc rbx
   154 000022EF 48FFC3              <1>     inc rbx
   155 000022F2 483B1C25[5A000000]  <1>     cmp rbx, qword [kb_buf_end]     ;Are we at the end of the buffer space
   156 000022FA 7508                <1>     jne .kbpa1                      ;If not exit, if we are, wrap around space!
   157 000022FC 488B1C25[52000000]  <1>     mov rbx, qword [kb_buf_start]
   158                              <1> .kbpa1:
   159 00002304 C3                  <1>     ret
   160                              <1> ;------------------------End of Interrupt------------------------
    99                                  %include "./Source/Resident/Services/Int37h.asm"
   100                              <1> ;------------------------Printer Int 37h-------------------------
   101                              <1> ; Reserved for printer specific functions. Both USB and Parallel.
   102                              <1> ; Not currently supported
   103                              <1> ;----------------------------------------------------------------
   104                              <1> printer_io:
   105 00002305 B486                <1>     mov ah, 86h    ;Function not supported
   106 00002307 804C241001          <1>     or byte [rsp+ 2*8h], 1    ;Set carry
   107 0000230C 48CF                <1>     iretq
   108                              <1> ;------------------------End of Interrupt------------------------
   100                                  %include "./Source/Sysdebug/sysdeb.asm"
   101                              <1> ;---------------------MCP Interrupt Int 38h----------------------
   102                              <1> ;This interrupt superceeds the IBM BASIC routine caller. 
   103                              <1> ;This is a 64 bit port of my 16 bit MCP monitor program, 
   104                              <1> ; allowing users to "interactively" get sectors from devices 
   105                              <1> ; and run them. I might add some nicities to this version of MCP 
   106                              <1> ; such as a function to list all devices.
   107                              <1> ;----------------------------------------------------------------
   108                              <1> MCPjmptbl:  ;Function jump table
   109 0000230E [482C000000000000]  <1>     dq MCP_int.dumpMemory      ;Dump
   110 00002316 [492E000000000000]  <1>     dq MCP_int.editMemory      ;Edit
   111 0000231E [052F000000000000]  <1>     dq MCP_int.singleStep      ;Single step
   112 00002326 [B92E000000000000]  <1>     dq MCP_int.jumpProc        ;Go
   113 0000232E [142F000000000000]  <1>     dq MCP_int.proceedDefault  ;Proceed
   114 00002336 [272F000000000000]  <1>     dq MCP_int.storageRead     ;Load
   115 0000233E [2F2F000000000000]  <1>     dq MCP_int.storageWrite    ;Write
   116 00002346 [B92F000000000000]  <1>     dq MCP_int.restartMcp      ;Quit   <- To call Int 40h for DOS compatibility
   117 0000234E [BB2F000000000000]  <1>     dq MCP_int.clearscreen     ;Clear screen
   118 00002356 [2327000000000000]  <1>     dq MCP_int.xchangeReg      ;Registers
   119 0000235E [8625000000000000]  <1>     dq MCP_int.debugRegs       ;Breakpoints
   120 00002366 [F728000000000000]  <1>     dq MCP_int.hexCalc         ;Hex
   121 0000236E [3B28000000000000]  <1>     dq MCP_int.inport          ;In
   122 00002376 [8E28000000000000]  <1>     dq MCP_int.outport         ;Out
   123 0000237E [4125000000000000]  <1>     dq MCP_int.version         ;Version
   124 00002386 [052F000000000000]  <1>     dq MCP_int.singleStep      ;Single Step (Alt), temp
   125 0000238E [1224000000000000]  <1>     dq MCP_int.memoryMap       ;Print memory map
   126 00002396 [DA24000000000000]  <1>     dq MCP_int.connect         ;Connect Debugger
   127 0000239E [0C25000000000000]  <1>     dq MCP_int.disconnect      ;Disconnect Debugger
   128                              <1> MCP_int:
   129                              <1>     ;Entry point from external programs
   130 000023A6 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
   131 000023AE 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   132 000023B6 48896008            <1>     mov qword [rax + 08h], rsp
   133 000023BA E8080C0000          <1>     call .storeMainRegisters    ;Save main registers
   134                              <1> .z11:
   135 000023BF 488B2425[0C020000]  <1>     mov rsp, qword [mcpStackPtr]  ;Point sp to new stack
   136 000023C7 B804130000          <1>     mov eax, 1304h    ;Zero extends to rax
   137 000023CC 48BD-               <1>     mov rbp, .prompt
   137 000023CE [A431000000000000]  <1>
   138 000023D6 30FF                <1>     xor bh, bh
   139 000023D8 CD30                <1>     int 30h
   140                              <1> .z2:
   141 000023DA 6631C0              <1>     xor ax, ax 
   142 000023DD CD36                <1>     int 36h
   143 000023DF 3C08                <1>     cmp al, 08h        ;If backspace, ignore
   144 000023E1 74F7                <1>     je .z2
   145 000023E3 E8910D0000          <1>     call .print        ;Print input char
   146 000023E8 FD                  <1>     std
   147 000023E9 48BF-               <1>     mov rdi, .prompt    ;end of lst is prompt
   147 000023EB [A431000000000000]  <1>
   148 000023F3 48B914000000000000- <1>     mov rcx, .lstl + 1
   148 000023FC 00                  <1>
   149 000023FD F2AE                <1>     repne scasb
   150 000023FF FC                  <1>     cld
   151 00002400 0F85AC000000        <1>     jne .bad_command    ;Char not found!
   152                              <1> .prog_sel:    ;Choose program
   153 00002406 68[BF230000]        <1>     push MCP_int.z11    ;to allow RETurning to application
   154 0000240B FF24CD[0E230000]    <1>     jmp qword [MCPjmptbl + 8*rcx]    ;Jump to chosen function         
   155                              <1> .memoryMap:
   156 00002412 66B80A0E            <1>     mov ax,0E0Ah
   157 00002416 CD30                <1>     int 30h
   158 00002418 66B80D0E            <1>     mov ax, 0E0Dh
   159 0000241C CD30                <1>     int 30h
   160 0000241E E8DDDBFFFF          <1>     call e820print  ;Print memory map
   161 00002423 E997FFFFFF          <1>     jmp .z11
   162                              <1> .singleStepsEP:
   163 00002428 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
   164 00002430 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   165 00002438 48896008            <1>     mov qword [rax + 08h], rsp
   166 0000243C E8860B0000          <1>     call .storeMainRegisters
   167 00002441 488B0424            <1>     mov rax, qword [rsp]    ;Get next instruction address
   168 00002445 48890425[F4010000]  <1>     mov qword [mcpUserRip], rax
   169 0000244D E875050000          <1>     call .dumpReg    ;Show register state
   170 00002452 E802020000          <1>     call .dumpDebugRegs
   171 00002457 FB                  <1>     sti ;Restore interrupts
   172 00002458 E962FFFFFF          <1>     jmp .z11
   173                              <1> .debugEpHardware:
   174 0000245D 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
   175 00002465 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   176 0000246D 48896008            <1>     mov qword [rax + 08h], rsp
   177 00002471 E8510B0000          <1>     call .storeMainRegisters
   178 00002476 FB                  <1>     sti ;Restore interrupts
   179 00002477 B020                <1>     mov al, EOI
   180 00002479 E620                <1>     out pic1command, al
   181 0000247B EB1A                <1>     jmp short .dep1
   182                              <1> .debugEp:    
   183                              <1> ;Return here after a single step or int 3. 
   184                              <1> ;Support Int 3h thru manual encoding only, not via the debugger
   185 0000247D 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
   186 00002485 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   187 0000248D 48896008            <1>     mov qword [rax + 08h], rsp
   188 00002491 E8310B0000          <1>     call .storeMainRegisters
   189 00002496 FB                  <1>     sti ;Restore interrupts
   190                              <1> .dep1:
   191 00002497 488B0424            <1>     mov rax, qword [rsp]    ;Get next instruction address
   192 0000249B 48890425[F4010000]  <1>     mov qword [mcpUserRip], rax
   193 000024A3 E81F050000          <1>     call .dumpReg    ;Show register state
   194 000024A8 E8AC010000          <1>     call .dumpDebugRegs
   195 000024AD E90DFFFFFF          <1>     jmp .z11
   196                              <1> .bad_command:
   197 000024B2 48B804130000000000- <1>     mov rax, 1304h
   197 000024BB 00                  <1>
   198 000024BC 30FF                <1>     xor bh, bh
   199 000024BE 48BD-               <1>     mov rbp, .bc1
   199 000024C0 [CF24000000000000]  <1>
   200 000024C8 CD30                <1>     int 30h
   201 000024CA E9F0FEFFFF          <1>     jmp MCP_int.z11
   202 000024CF 0A0D205E204572726F- <1> .bc1: db 0Ah,0Dh," ^ Error",0
   202 000024D8 7200                <1>
   203                              <1> ;><><><><><><><-Internal Commands Begin Here-><><><><><><><
   204                              <1> .connect:
   205 000024DA 50                  <1>     push rax
   206 000024DB 55                  <1>     push rbp
   207 000024DC B801C50000          <1>     mov eax, 0C501h ;Connect Debugger
   208 000024E1 CD35                <1>     int 35h
   209 000024E3 B804130000          <1>     mov eax, 1304h
   210 000024E8 48BD-               <1>     mov rbp, .connectString
   210 000024EA [F724000000000000]  <1>
   211 000024F2 CD30                <1>     int 30h
   212 000024F4 5D                  <1>     pop rbp
   213 000024F5 58                  <1>     pop rax
   214 000024F6 C3                  <1>     ret
   215 000024F7 0A0D53595344454255- <1> .connectString db 0Ah,0Dh,"SYSDEBUG Connected",0
   215 00002500 4720436F6E6E656374- <1>
   215 00002509 656400              <1>
   216                              <1> .disconnect:
   217 0000250C 50                  <1>     push rax
   218 0000250D 55                  <1>     push rbp
   219 0000250E B802C50000          <1>     mov eax, 0C502h ;Disconnect Debugger
   220 00002513 CD35                <1>     int 35h
   221 00002515 B804130000          <1>     mov eax, 1304h
   222 0000251A 48BD-               <1>     mov rbp, .disconnectString
   222 0000251C [2925000000000000]  <1>
   223 00002524 CD30                <1>     int 30h
   224 00002526 5D                  <1>     pop rbp
   225 00002527 58                  <1>     pop rax
   226 00002528 C3                  <1>     ret
   227 00002529 0A0D53595344454255- <1> .disconnectString db 0Ah,0Dh,"SYSDEBUG Disconnected",0
   227 00002532 4720446973636F6E6E- <1>
   227 0000253B 656374656400        <1>
   228                              <1> .version:
   229 00002541 66B80413            <1>     mov ax, 1304h
   230 00002545 30FF                <1>     xor bh, bh
   231 00002547 48BD-               <1>     mov rbp, .vstring
   231 00002549 [6925000000000000]  <1>
   232 00002551 CD30                <1>     int 30h
   233 00002553 48BE-               <1>     mov rsi, signature + 1    ;Point to BIOS signature string (skip the v char)
   233 00002555 [9957000000000000]  <1>
   234                              <1> .v1:
   235 0000255D AC                  <1>     lodsb
   236 0000255E 3C20                <1>     cmp al, 20h            ;Check space
   237 00002560 7406                <1>     je .v2
   238 00002562 B40E                <1>     mov ah, 0Eh
   239                              <1>     ;xor bh, bh
   240 00002564 CD30                <1>     int 30h
   241 00002566 EBF5                <1>     jmp short .v1
   242                              <1> .v2:
   243 00002568 C3                  <1>     ret
   244 00002569 0A0D5343502F42494F- <1> .vstring:    db 0Ah, 0Dh,"SCP/BIOS SYSDEBUG Version ",0
   244 00002572 532053595344454255- <1>
   244 0000257B 472056657273696F6E- <1>
   244 00002584 2000                <1>
   245                              <1> .debugRegs:
   246 00002586 E8CE000000          <1>     call .dumpDebugRegs
   247 0000258B 66B80413            <1>     mov ax, 1304h
   248 0000258F 48BD-               <1>     mov rbp, .crlf    ;Newline
   248 00002591 [AA31000000000000]  <1>
   249 00002599 CD30                <1>     int 30h
   250                              <1> 
   251 0000259B 66B82E0E            <1>     mov ax, 0E2Eh    ;Print dot byte
   252 0000259F CD30                <1>     int 30h
   253                              <1> 
   254 000025A1 66B80101            <1>     mov ax, 0101h    ;Process one byte
   255 000025A5 E82E0B0000          <1>     call .keyb
   256 000025AA 4885ED              <1>     test rbp, rbp
   257 000025AD 0F840CFEFFFF        <1>     jz .z11    ;If enter pressed, return to command line
   258 000025B3 E8C00A0000          <1>     call .arg
   259 000025B8 3C01                <1>     cmp al, 1
   260 000025BA 0F85DA070000        <1>     jne .dmbadexit
   261                              <1> 
   262 000025C0 488B7D00            <1>     mov rdi, qword [rbp]
   263 000025C4 4881FF04000000      <1>     cmp rdi, 4
   264 000025CB 7213                <1>     jb .xr11    ;Cant edit dr4, or 5. dr6 is read only
   265 000025CD 4881FF07000000      <1>     cmp rdi, 7  ;Can only edit 7
   266 000025D4 0F85D8FEFFFF        <1>     jne .bad_command
   267 000025DA 48FFCF              <1>     dec rdi     ;Is the fifth entry in the table
   268 000025DD 48FFCF              <1>     dec rdi
   269                              <1> .xr11:
   270 000025E0 48BD-               <1>     mov rbp, .crlf
   270 000025E2 [AA31000000000000]  <1>
   271 000025EA 66B80413            <1>     mov ax, 1304h
   272 000025EE 30FF                <1>     xor bh, bh
   273 000025F0 CD30                <1>     int 30h
   274                              <1> 
   275 000025F2 57                  <1>     push rdi    ;Save rdi
   276 000025F3 48C1E702            <1>     shl rdi, 2    ;Multiply by 4
   277 000025F7 66B90400            <1>     mov cx, 4    ;4 chars to print
   278                              <1> .xr1:   ;Print register name
   279 000025FB 8A87[0B270000]      <1>     mov al, byte [.dregtbl + rdi]
   280 00002601 B40E                <1>     mov ah, 0Eh
   281 00002603 CD30                <1>     int 30h
   282 00002605 66FFC7              <1>     inc di
   283 00002608 66FFC9              <1>     dec cx
   284 0000260B 75EE                <1>     jnz .xr1
   285                              <1> ;Get the qword into the keybuffer
   286 0000260D 5F                  <1>     pop rdi
   287 0000260E 66B80104            <1>     mov ax, 0401h    ;Process one qword
   288 00002612 E8C10A0000          <1>     call .keyb
   289 00002617 4885ED              <1>     test rbp, rbp
   290 0000261A 0F84C6010000        <1>     jz .xcnoexit
   291 00002620 E8530A0000          <1>     call .arg
   292 00002625 3C01                <1>     cmp al, 1
   293 00002627 0F856D070000        <1>     jne .dmbadexit
   294                              <1> 
   295 0000262D 488B4500            <1>     mov rax, qword [rbp]    ;rax has the replacement value
   296 00002631 4885FF              <1>     test rdi, rdi
   297 00002634 7504                <1>     jnz .xr2
   298 00002636 0F23C0              <1>     mov dr0, rax
   299 00002639 C3                  <1>     ret
   300                              <1> .xr2:
   301 0000263A 48FFCF              <1>     dec rdi
   302 0000263D 7504                <1>     jnz .xr3
   303 0000263F 0F23C8              <1>     mov dr1, rax
   304 00002642 C3                  <1>     ret
   305                              <1> .xr3:
   306 00002643 48FFCF              <1>     dec rdi
   307 00002646 7504                <1>     jnz .xr4
   308 00002648 0F23D0              <1>     mov dr2, rax
   309 0000264B C3                  <1>     ret
   310                              <1> .xr4:
   311 0000264C 48FFCF              <1>     dec rdi
   312 0000264F 7504                <1>     jnz .xr5
   313 00002651 0F23D8              <1>     mov dr3, rax
   314 00002654 C3                  <1>     ret
   315                              <1> .xr5:
   316 00002655 0F23F8              <1>     mov dr7, rax
   317 00002658 C3                  <1>     ret
   318                              <1> 
   319                              <1> .dumpDebugRegs:
   320 00002659 48BD-               <1>     mov rbp, .crlf
   320 0000265B [AA31000000000000]  <1>
   321 00002663 66B80413            <1>     mov ax, 1304h
   322 00002667 30FF                <1>     xor bh, bh
   323 00002669 CD30                <1>     int 30h
   324 0000266B 4831ED              <1>     xor rbp, rbp
   325 0000266E 4831FF              <1>     xor rdi, rdi
   326                              <1> 
   327 00002671 0F21F8              <1>     mov rax, dr7
   328 00002674 50                  <1>     push rax
   329 00002675 0F21F0              <1>     mov rax, dr6
   330 00002678 50                  <1>     push rax
   331 00002679 0F21D8              <1>     mov rax, dr3
   332 0000267C 50                  <1>     push rax
   333 0000267D 0F21D0              <1>     mov rax, dr2
   334 00002680 50                  <1>     push rax
   335 00002681 0F21C8              <1>     mov rax, dr1
   336 00002684 50                  <1>     push rax
   337 00002685 0F21C0              <1>     mov rax, dr0
   338 00002688 50                  <1>     push rax
   339                              <1> 
   340                              <1> .ddr1:
   341 00002689 4831C9              <1>     xor rcx, rcx
   342 0000268C 4881FF03000000      <1>     cmp rdi, 3      ;3 registers per row
   343 00002693 7450                <1>     je .dregcrlf
   344                              <1> .ddr11:
   345 00002695 8A840D[0B270000]    <1>     mov al, byte [.dregtbl + rbp + rcx]
   346 0000269C B40E                <1>     mov ah, 0Eh
   347 0000269E CD30                <1>     int 30h
   348 000026A0 66FFC1              <1>     inc cx
   349 000026A3 6681F90400          <1>     cmp cx, 4
   350 000026A8 75EB                <1>     jnz .ddr11
   351                              <1> 
   352 000026AA 48B908000000000000- <1>     mov rcx, 8
   352 000026B3 00                  <1>
   353                              <1> .ddr2:
   354 000026B4 5B                  <1>     pop rbx    ;Get debug register
   355 000026B5 480FCB              <1>     bswap rbx
   356                              <1> .ddr21:
   357 000026B8 B404                <1>     mov ah, 04h
   358 000026BA 88D8                <1>     mov al, bl
   359 000026BC CD30                <1>     int 30h
   360 000026BE 48C1EB08            <1>     shr rbx, 8h
   361 000026C2 FEC9                <1>     dec cl
   362 000026C4 75F2                <1>     jnz .ddr21
   363 000026C6 48FFC7              <1>     inc rdi
   364                              <1> 
   365 000026C9 B403                <1>     mov ah, 3
   366 000026CB CD30                <1>     int 30h
   367 000026CD 80C203              <1>     add dl, 3
   368 000026D0 B402                <1>     mov ah, 2
   369 000026D2 CD30                <1>     int 30h
   370 000026D4 4881C504000000      <1>     add rbp, 4
   371 000026DB 4881FD18000000      <1>     cmp rbp, 24 ;number of chars in the below typed string
   372 000026E2 72A5                <1>     jb .ddr1
   373                              <1> 
   374 000026E4 C3                  <1>     ret
   375                              <1> .dregcrlf:
   376 000026E5 4831FF              <1>     xor rdi, rdi
   377 000026E8 55                  <1>     push rbp
   378 000026E9 50                  <1>     push rax
   379 000026EA 53                  <1>     push rbx
   380 000026EB 48BD-               <1>     mov rbp, .crlf
   380 000026ED [AA31000000000000]  <1>
   381 000026F5 48B804130000000000- <1>     mov rax, 1304h
   381 000026FE 00                  <1>
   382 000026FF 30FF                <1>     xor bh, bh
   383 00002701 CD30                <1>     int 30h
   384 00002703 5B                  <1>     pop rbx
   385 00002704 58                  <1>     pop rax
   386 00002705 5D                  <1>     pop rbp
   387 00002706 E98AFFFFFF          <1>     jmp .ddr11
   388 0000270B 4452303D4452313D44- <1> .dregtbl db "DR0=", "DR1=", "DR2=", "DR3=", "DR6=", "DR7="
   388 00002714 52323D4452333D4452- <1>
   388 0000271D 363D4452373D        <1>
   389                              <1> 
   390                              <1> .xchangeReg:
   391 00002723 E89F020000          <1>     call .dumpReg
   392 00002728 66B80413            <1>     mov ax, 1304h
   393 0000272C 48BD-               <1>     mov rbp, .crlf    ;Newline
   393 0000272E [AA31000000000000]  <1>
   394 00002736 CD30                <1>     int 30h
   395                              <1> 
   396 00002738 66B82E0E            <1>     mov ax, 0E2Eh    ;Print dot byte
   397 0000273C CD30                <1>     int 30h
   398                              <1> 
   399 0000273E 66B80101            <1>     mov ax, 0101h    ;Process one byte
   400 00002742 E891090000          <1>     call .keyb
   401 00002747 4885ED              <1>     test rbp, rbp
   402 0000274A 0F846FFCFFFF        <1>     jz .z11    ;If enter pressed, return to command line
   403 00002750 E823090000          <1>     call .arg
   404 00002755 3C01                <1>     cmp al, 1
   405 00002757 0F853D060000        <1>     jne .dmbadexit
   406                              <1> 
   407 0000275D 488B7D00            <1>     mov rdi, qword [rbp]    ;move this byte into rdi
   408 00002761 4881FF11000000      <1>     cmp rdi, 11h
   409 00002768 0F8744FDFFFF        <1>     ja .bad_command    ;If the user chooses a value greater than 11, exit!
   410                              <1> 
   411 0000276E 48BD-               <1>     mov rbp, .crlf
   411 00002770 [AA31000000000000]  <1>
   412 00002778 66B80413            <1>     mov ax, 1304h
   413 0000277C 30FF                <1>     xor bh, bh
   414 0000277E CD30                <1>     int 30h
   415                              <1> 
   416 00002780 4881FF11000000      <1>     cmp rdi, 11h
   417 00002787 7467                <1>     je .xcflags ;If the user typed 10, then xchange flags
   418                              <1> 
   419 00002789 57                  <1>     push rdi    ;Save rdi
   420 0000278A 48C1E702            <1>     shl rdi, 2    ;Multiply by 4
   421 0000278E 66B90400            <1>     mov cx, 4    ;4 chars to print
   422                              <1> .xcr1:
   423 00002792 8A87[E22B0000]      <1>     mov al, byte [.regtbl + rdi]
   424 00002798 B40E                <1>     mov ah, 0Eh
   425 0000279A CD30                <1>     int 30h
   426 0000279C 66FFC7              <1>     inc di
   427 0000279F 66FFC9              <1>     dec cx
   428 000027A2 75EE                <1>     jnz .xcr1
   429                              <1> 
   430 000027A4 5F                  <1>     pop rdi
   431 000027A5 66B80104            <1>     mov ax, 0401h    ;Process one qword
   432 000027A9 E82A090000          <1>     call .keyb
   433 000027AE 4885ED              <1>     test rbp, rbp
   434 000027B1 7433                <1>     jz .xcnoexit
   435 000027B3 E8C0080000          <1>     call .arg
   436 000027B8 3C01                <1>     cmp al, 1
   437 000027BA 0F85DA050000        <1>     jne .dmbadexit
   438                              <1> 
   439 000027C0 488B4500            <1>     mov rax, qword [rbp]
   440 000027C4 4881FF10000000      <1>     cmp rdi, 10h
   441 000027CB 741A                <1>     je .xcipchange
   442 000027CD 488B1C25[EC010000]  <1>     mov rbx, qword [mcpUserBase]
   443 000027D5 4881C380000000      <1>     add rbx, 80h
   444 000027DC 48C1E703            <1>     shl rdi, 3  ;Multiply by 8
   445 000027E0 4829FB              <1>     sub rbx, rdi
   446 000027E3 488903              <1>     mov qword [rbx], rax    ;Replace element with rax
   447                              <1> .xcnoexit:
   448 000027E6 C3                  <1>     ret
   449                              <1> .xcipchange:
   450 000027E7 48890425[F4010000]  <1>     mov qword [mcpUserRip], rax
   451 000027EF C3                  <1>     ret
   452                              <1> .xcflags:
   453 000027F0 48B907000000000000- <1>     mov rcx, 7
   453 000027F9 00                  <1>
   454 000027FA 4831FF              <1>     xor rdi, rdi
   455                              <1> .xcf1:
   456 000027FD 8A87[382C0000]      <1>     mov al, byte [.rflgs + rdi]
   457 00002803 B40E                <1>     mov ah, 0Eh
   458 00002805 CD30                <1>     int 30h
   459 00002807 66FFC7              <1>     inc di
   460 0000280A 66FFC9              <1>     dec cx
   461 0000280D 75EE                <1>     jnz .xcf1
   462                              <1> 
   463 0000280F 66B80104            <1>     mov ax, 0401h    ;Process one qword
   464 00002813 E8C0080000          <1>     call .keyb
   465 00002818 4885ED              <1>     test rbp, rbp
   466 0000281B 74C9                <1>     jz .xcnoexit
   467 0000281D E856080000          <1>     call .arg
   468 00002822 3C01                <1>     cmp al, 1
   469 00002824 0F8570050000        <1>     jne .dmbadexit
   470 0000282A 488B4500            <1>     mov rax, qword [rbp]
   471 0000282E 488B2C25[EC010000]  <1>     mov rbp, qword [mcpUserBase]
   472 00002836 48894500            <1>     mov qword [rbp], rax
   473 0000283A C3                  <1>     ret
   474                              <1> .inport:
   475 0000283B 66B80413            <1>     mov ax, 1304h
   476 0000283F 30FF                <1>     xor bh, bh
   477 00002841 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   477 00002843 [A831000000000000]  <1>
   478 0000284B CD30                <1>     int 30h
   479                              <1> 
   480 0000284D 66B80101            <1>     mov ax, 0101h    ;Get 1 byte
   481 00002851 E882080000          <1>     call .keyb
   482 00002856 4885ED              <1>     test rbp, rbp
   483 00002859 0F8453FCFFFF        <1>     jz .bad_command
   484 0000285F E814080000          <1>     call .arg
   485 00002864 3C01                <1>     cmp al, 1
   486 00002866 0F852E050000        <1>     jne .dmbadexit
   487 0000286C 488B5500            <1>     mov rdx, qword [rbp]    ;First arg, word io addr
   488 00002870 48BD-               <1>     mov rbp, .crlf
   488 00002872 [AA31000000000000]  <1>
   489 0000287A 48B804130000000000- <1>     mov rax, 1304h
   489 00002883 00                  <1>
   490 00002884 30FF                <1>     xor bh, bh
   491 00002886 CD30                <1>     int 30h
   492 00002888 EC                  <1>     in al, dx
   493 00002889 B404                <1>     mov ah, 04h
   494 0000288B CD30                <1>     int 30h
   495 0000288D C3                  <1>     ret
   496                              <1> 
   497                              <1> .outport:
   498 0000288E 66B80413            <1>     mov ax, 1304h
   499 00002892 48BB07000000000000- <1>     mov rbx, 7h
   499 0000289B 00                  <1>
   500 0000289C 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   500 0000289E [A831000000000000]  <1>
   501 000028A6 CD30                <1>     int 30h
   502 000028A8 66B80102            <1>     mov ax, 0201h    ;Get 1 word
   503 000028AC E827080000          <1>     call .keyb
   504 000028B1 4885ED              <1>     test rbp, rbp
   505 000028B4 0F84F8FBFFFF        <1>     jz .bad_command
   506 000028BA E8B9070000          <1>     call .arg
   507 000028BF 3C01                <1>     cmp al, 1
   508 000028C1 0F85D3040000        <1>     jne .dmbadexit
   509 000028C7 488B5500            <1>     mov rdx, qword [rbp]    ;First arg, word io addr
   510 000028CB B02E                <1>     mov al, "."
   511 000028CD E8A7080000          <1>     call .print
   512 000028D2 66B80101            <1>     mov ax, 0101h    ;Get 1 byte
   513 000028D6 E8FD070000          <1>     call .keyb
   514 000028DB 4885ED              <1>     test rbp, rbp
   515 000028DE 0F84CEFBFFFF        <1>     jz .bad_command
   516 000028E4 E88F070000          <1>     call .arg
   517 000028E9 3C01                <1>     cmp al, 1
   518 000028EB 0F85A9040000        <1>     jne .dmbadexit
   519 000028F1 488B4500            <1>     mov rax, qword [rbp]
   520 000028F5 EE                  <1>     out dx, al
   521 000028F6 C3                  <1>     ret
   522                              <1> 
   523                              <1> .hexCalc:
   524 000028F7 66B80413            <1>     mov ax, 1304h
   525 000028FB 30FF                <1>     xor bh, bh
   526 000028FD 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   526 000028FF [A831000000000000]  <1>
   527 00002907 CD30                <1>     int 30h
   528 00002909 66B80204            <1>     mov ax, 0402h    ;Get 2 qwords
   529 0000290D E8C6070000          <1>     call .keyb
   530 00002912 4885ED              <1>     test rbp, rbp
   531 00002915 0F8497FBFFFF        <1>     jz .bad_command
   532 0000291B E858070000          <1>     call .arg
   533                              <1> 
   534 00002920 3C02                <1>     cmp al, 2
   535 00002922 0F8572040000        <1>     jne .dmbadexit
   536                              <1> 
   537 00002928 4C8B4508            <1>     mov r8, qword [rbp + 8] ;First number 
   538 0000292C 4C8B4D00            <1>     mov r9, qword [rbp]        ;Second number
   539 00002930 4F8D1408            <1>     lea r10, qword [r8+r9]
   540                              <1> 
   541 00002934 48BD-               <1>     mov rbp, .crlf
   541 00002936 [AA31000000000000]  <1>
   542 0000293E 48B804130000000000- <1>     mov rax, 1304h
   542 00002947 00                  <1>
   543 00002948 30FF                <1>     xor bh, bh
   544 0000294A CD30                <1>     int 30h
   545                              <1> 
   546 0000294C 4C89C2              <1>     mov rdx, r8
   547 0000294F E856000000          <1>     call .hcprintquad
   548 00002954 B02B                <1>     mov al, "+"
   549 00002956 E81E080000          <1>     call .print
   550 0000295B 4C89CA              <1>     mov rdx, r9
   551 0000295E E847000000          <1>     call .hcprintquad
   552 00002963 B03D                <1>     mov al, "="
   553 00002965 E80F080000          <1>     call .print
   554 0000296A 4C89D2              <1>     mov rdx, r10
   555 0000296D E838000000          <1>     call .hcprintquad
   556                              <1> 
   557 00002972 48B804130000000000- <1>     mov rax, 1304h
   557 0000297B 00                  <1>
   558 0000297C 30FF                <1>     xor bh, bh
   559 0000297E CD30                <1>     int 30h
   560                              <1> 
   561 00002980 4C89C2              <1>     mov rdx, r8
   562 00002983 E822000000          <1>     call .hcprintquad
   563 00002988 B02D                <1>     mov al, "-"
   564 0000298A E8EA070000          <1>     call .print
   565 0000298F 4C89CA              <1>     mov rdx, r9
   566 00002992 E813000000          <1>     call .hcprintquad
   567 00002997 B03D                <1>     mov al, "="
   568 00002999 E8DB070000          <1>     call .print
   569 0000299E 4D29C8              <1>     sub r8, r9
   570 000029A1 4C89C2              <1>     mov rdx, r8
   571 000029A4 E801000000          <1>     call .hcprintquad
   572 000029A9 C3                  <1>     ret
   573                              <1> 
   574                              <1> .hcprintquad:
   575                              <1> ;Takes whats in rdx, and prints it
   576 000029AA 480FCA              <1>     bswap rdx
   577 000029AD 48B908000000000000- <1>     mov rcx, 8
   577 000029B6 00                  <1>
   578                              <1> .hcpq1:
   579 000029B7 88D0                <1>     mov al, dl
   580 000029B9 B404                <1>     mov ah, 04h
   581 000029BB CD30                <1>     int 30h
   582 000029BD 48C1EA08            <1>     shr rdx, 8
   583 000029C1 66FFC9              <1>     dec cx
   584 000029C4 75F1                <1>     jnz .hcpq1
   585 000029C6 C3                  <1>     ret
   586                              <1> 
   587                              <1> .dumpReg:
   588 000029C7 48BD-               <1>     mov rbp, .crlf
   588 000029C9 [AA31000000000000]  <1>
   589 000029D1 66B80413            <1>     mov ax, 1304h
   590 000029D5 30FF                <1>     xor bh, bh
   591 000029D7 CD30                <1>     int 30h
   592 000029D9 4831ED              <1>     xor rbp, rbp
   593 000029DC 4831FF              <1>     xor rdi, rdi
   594 000029DF 4831F6              <1>     xor rsi, rsi
   595 000029E2 488B3425[EC010000]  <1>     mov rsi, qword [mcpUserBase]
   596 000029EA 4881C680000000      <1>     add rsi, 80h
   597                              <1> .dreg1:
   598 000029F1 4831C9              <1>     xor rcx, rcx
   599 000029F4 4881FF03000000      <1>     cmp rdi, 3
   600 000029FB 0F84BB010000        <1>     je .regcrlf
   601                              <1> .dreg11:    ;Print register name
   602 00002A01 8A840D[E22B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   603 00002A08 B40E                <1>     mov ah, 0Eh
   604 00002A0A CD30                <1>     int 30h
   605 00002A0C 66FFC1              <1>     inc cx
   606 00002A0F 6681F90400          <1>     cmp cx, 4h
   607 00002A14 75EB                <1>     jnz .dreg11
   608                              <1> .dreg2:
   609 00002A16 48B908000000000000- <1>     mov rcx, 8h
   609 00002A1F 00                  <1>
   610                              <1> ;Now print register value
   611 00002A20 488B1E              <1>     mov rbx, qword [rsi]    ;Get qword from storage
   612 00002A23 81EE08000000        <1>     sub esi, 8
   613 00002A29 480FCB              <1>     bswap rbx    ;Change endianness
   614                              <1> .dreg21:
   615 00002A2C B404                <1>     mov ah, 04h
   616 00002A2E 88D8                <1>     mov al, bl
   617 00002A30 CD30                <1>     int 30h
   618 00002A32 48C1EB08            <1>     shr rbx, 8h    ;Shift down by a byte
   619 00002A36 FEC9                <1>     dec cl
   620 00002A38 75F2                <1>     jnz .dreg21
   621 00002A3A 48FFC7              <1>     inc rdi
   622                              <1> 
   623 00002A3D B403                <1>     mov ah, 3
   624 00002A3F CD30                <1>     int 30h
   625 00002A41 80C203              <1>     add dl, 3
   626 00002A44 B402                <1>     mov ah, 2
   627 00002A46 CD30                <1>     int 30h
   628 00002A48 4881C504000000      <1>     add rbp, 4
   629 00002A4F 4881FD40000000      <1>     cmp rbp, 40h
   630 00002A56 7299                <1>     jb .dreg1
   631                              <1> 
   632                              <1> ;Print RIP
   633                              <1> .drip0:
   634 00002A58 4831C9              <1>     xor rcx, rcx
   635                              <1> .drip1:
   636                              <1> ;Print name
   637 00002A5B 8A840D[E22B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   638 00002A62 B40E                <1>     mov ah, 0Eh
   639 00002A64 CD30                <1>     int 30h
   640 00002A66 66FFC1              <1>     inc cx
   641 00002A69 6681F90400          <1>     cmp cx, 4h
   642 00002A6E 75EB                <1>     jne .drip1
   643                              <1> 
   644 00002A70 48B908000000000000- <1>     mov rcx, 8
   644 00002A79 00                  <1>
   645 00002A7A 488B3425[F4010000]  <1>     mov rsi, qword [mcpUserRip]
   646 00002A82 480FCE              <1>     bswap rsi
   647                              <1> .drip2:
   648                              <1> ;Print value
   649 00002A85 B404                <1>     mov ah, 04h
   650 00002A87 4088F0              <1>     mov al, sil
   651 00002A8A CD30                <1>     int 30h
   652 00002A8C 48C1EE08            <1>     shr rsi, 8h    ;Shift down by a byte
   653 00002A90 FEC9                <1>     dec cl
   654 00002A92 75F1                <1>     jnz .drip2
   655 00002A94 4881C504000000      <1>     add rbp, 4    ;Offset into table
   656                              <1> 
   657 00002A9B 55                  <1>     push rbp
   658 00002A9C 48BD-               <1>     mov rbp, .ipstrg
   658 00002A9E [3F2C000000000000]  <1>
   659 00002AA6 66B80413            <1>     mov ax, 1304h
   660 00002AAA CD30                <1>     int 30h    
   661 00002AAC B107                <1>     mov cl, 7
   662 00002AAE 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   663 00002AB6 488B4008            <1>     mov rax, qword [rax + 08h]  ;Get the old stack pointer
   664 00002ABA 488B18              <1>     mov rbx, qword [rax]    ;Get the address of 8 bytes at that instruction
   665 00002ABD 488B1B              <1>     mov rbx, qword [rbx]    ;Get the bytes
   666 00002AC0 88D8                <1>     mov al, bl
   667 00002AC2 B404                <1>     mov ah, 04h
   668 00002AC4 CD30                <1>     int 30h
   669 00002AC6 48C1EB08            <1>     shr rbx, 8
   670 00002ACA B40E                <1>     mov ah, 0Eh   ;Add a space to indicate mod r/m + optionals
   671 00002ACC B02D                <1>     mov al, '-'
   672 00002ACE CD30                <1>     int 30h
   673                              <1> .ssep0:
   674 00002AD0 88D8                <1>     mov al, bl
   675 00002AD2 B404                <1>     mov ah, 04h
   676 00002AD4 CD30                <1>     int 30h
   677 00002AD6 48C1EB08            <1>     shr rbx, 8
   678 00002ADA FEC9                <1>     dec cl
   679 00002ADC 75F2                <1>     jnz .ssep0
   680                              <1> 
   681 00002ADE 48BD-               <1>     mov rbp, .crlf
   681 00002AE0 [AA31000000000000]  <1>
   682 00002AE8 48B804130000000000- <1>     mov rax, 1304h
   682 00002AF1 00                  <1>
   683 00002AF2 48BB07000000000000- <1>     mov rbx, 7h
   683 00002AFB 00                  <1>
   684 00002AFC CD30                <1>     int 30h
   685 00002AFE 5D                  <1>     pop rbp
   686                              <1> 
   687 00002AFF 668CC8              <1>     mov ax, cs
   688 00002B02 E87D000000          <1>     call .dsegregwrite
   689 00002B07 668CD8              <1>     mov ax, ds
   690 00002B0A E875000000          <1>     call .dsegregwrite
   691 00002B0F 668CC0              <1>     mov ax, es
   692 00002B12 E86D000000          <1>     call .dsegregwrite
   693 00002B17 668CD0              <1>     mov ax, ss
   694 00002B1A E865000000          <1>     call .dsegregwrite
   695 00002B1F 668CE0              <1>     mov ax, fs
   696 00002B22 E85D000000          <1>     call .dsegregwrite
   697 00002B27 668CE8              <1>     mov ax, gs
   698 00002B2A E855000000          <1>     call .dsegregwrite
   699                              <1> 
   700 00002B2F 55                  <1>     push rbp
   701 00002B30 48BD-               <1>     mov rbp, .crlf
   701 00002B32 [AA31000000000000]  <1>
   702 00002B3A 48B804130000000000- <1>     mov rax, 1304h
   702 00002B43 00                  <1>
   703 00002B44 30FF                <1>     xor bh, bh
   704 00002B46 CD30                <1>     int 30h
   705 00002B48 5D                  <1>     pop rbp
   706                              <1> .drflagwrite:
   707 00002B49 4831C9              <1>     xor rcx, rcx
   708                              <1> .drflg1:    ;Print register name
   709 00002B4C 8A840D[E22B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   710 00002B53 B40E                <1>     mov ah, 0Eh
   711 00002B55 CD30                <1>     int 30h
   712 00002B57 48FFC1              <1>     inc rcx
   713 00002B5A 4881F907000000      <1>     cmp rcx, 7
   714 00002B61 75E9                <1>     jnz .drflg1
   715                              <1> 
   716 00002B63 48FFC1              <1>     inc rcx
   717 00002B66 488B1425[EC010000]  <1>     mov rdx, qword [mcpUserBase]    ;Get flags into rdx
   718 00002B6E 488B12              <1>     mov rdx, qword [rdx]
   719 00002B71 480FCA              <1>     bswap rdx
   720                              <1> .drflg2:
   721 00002B74 B404                <1>     mov ah, 04h
   722 00002B76 88D0                <1>     mov al, dl
   723 00002B78 CD30                <1>     int 30h
   724 00002B7A 48C1EA08            <1>     shr rdx, 8
   725 00002B7E 48FFC9              <1>     dec rcx
   726 00002B81 75F1                <1>     jnz .drflg2
   727                              <1> 
   728                              <1> .dregexit:
   729 00002B83 C3                  <1>     ret
   730                              <1> .dsegregwrite:
   731 00002B84 4831C9              <1>     xor rcx, rcx
   732 00002B87 6689C2              <1>     mov dx, ax    ;save
   733                              <1> .dsegreg1:    ;Print register name
   734 00002B8A 8A840D[E22B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   735                              <1>     ;xor bh, bh
   736 00002B91 B40E                <1>     mov ah, 0Eh
   737 00002B93 CD30                <1>     int 30h
   738 00002B95 48FFC1              <1>     inc rcx
   739 00002B98 4881F903000000      <1>     cmp rcx, 3
   740 00002B9F 75E9                <1>     jnz .dsegreg1
   741                              <1> 
   742 00002BA1 88F0                <1>     mov al, dh
   743 00002BA3 B404                <1>     mov ah, 04h
   744 00002BA5 CD30                <1>     int 30h
   745 00002BA7 88D0                <1>     mov al, dl
   746 00002BA9 B404                <1>     mov ah, 04h
   747 00002BAB CD30                <1>     int 30h
   748                              <1> 
   749 00002BAD 4801CD              <1>     add rbp, rcx
   750 00002BB0 B403                <1>     mov ah, 3
   751 00002BB2 CD30                <1>     int 30h
   752 00002BB4 80C202              <1>     add dl, 2
   753 00002BB7 B402                <1>     mov ah, 2
   754 00002BB9 CD30                <1>     int 30h
   755 00002BBB C3                  <1>     ret
   756                              <1> 
   757                              <1> .regcrlf:
   758 00002BBC 4831FF              <1>     xor rdi, rdi
   759 00002BBF 55                  <1>     push rbp
   760 00002BC0 50                  <1>     push rax
   761 00002BC1 53                  <1>     push rbx
   762 00002BC2 48BD-               <1>     mov rbp, .crlf
   762 00002BC4 [AA31000000000000]  <1>
   763 00002BCC 48B804130000000000- <1>     mov rax, 1304h
   763 00002BD5 00                  <1>
   764 00002BD6 30FF                <1>     xor bh, bh
   765 00002BD8 CD30                <1>     int 30h
   766 00002BDA 5B                  <1>     pop rbx
   767 00002BDB 58                  <1>     pop rax
   768 00002BDC 5D                  <1>     pop rbp
   769 00002BDD E91FFEFFFF          <1>     jmp .dreg11
   770                              <1> 
   771 00002BE2 5241583D5242583D52- <1> .regtbl  db "RAX=", "RBX=", "RCX=", "RDX=", "RSI=", "RDI=", "R8 =",
   771 00002BEB 43583D5244583D5253- <1>
   771 00002BF4 493D5244493D523820- <1>
   771 00002BFD 3D                  <1>
   772 00002BFE 5239203D5231303D52- <1>          db "R9 =", "R10=", "R11=", "R12=", "R13=", "R14=", "R15=",
   772 00002C07 31313D5231323D5231- <1>
   772 00002C10 333D5231343D523135- <1>
   772 00002C19 3D                  <1>
   773 00002C1A 5242503D5253503D52- <1>          db "RBP=", "RSP=", "RIP=","CS=", "DS=", "ES=", "SS=", "FS=", 
   773 00002C23 49503D43533D44533D- <1>
   773 00002C2C 45533D53533D46533D  <1>
   774 00002C35 47533D              <1>          db "GS="
   775 00002C38 52464C4147533D      <1> .rflgs   db "RFLAGS="
   776 00002C3F 20205B5249505D3D00  <1> .ipstrg: db "  [RIP]=",0
   777                              <1> .dumpMemory:
   778 00002C48 50                  <1>     push rax
   779 00002C49 53                  <1>     push rbx
   780 00002C4A 51                  <1>     push rcx
   781 00002C4B 52                  <1>     push rdx
   782 00002C4C 57                  <1>     push rdi
   783 00002C4D 56                  <1>     push rsi
   784 00002C4E 55                  <1>     push rbp
   785 00002C4F 4150                <1>     push r8
   786 00002C51 4151                <1>     push r9
   787                              <1> 
   788 00002C53 66B80413            <1>     mov ax, 1304h
   789 00002C57 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   789 00002C59 [A831000000000000]  <1>
   790 00002C61 CD30                <1>     int 30h
   791 00002C63 66B80204            <1>     mov ax, 0402h    ;Get 2 dwords
   792 00002C67 E86C040000          <1>     call .keyb
   793 00002C6C 4885ED              <1>     test rbp, rbp
   794 00002C6F 0F8442010000        <1>     jz .dmnoargs
   795 00002C75 B002                <1>     mov al, 2    ;Number of user inputs to convert
   796 00002C77 E8FC030000          <1>     call .arg
   797 00002C7C FEC8                <1>     dec al
   798 00002C7E 0F843D010000        <1>     jz .dmnoargs1
   799 00002C84 FEC8                <1>     dec al    ;More than 2 args, error
   800 00002C86 0F850E010000        <1>     jnz .dmbadexit
   801 00002C8C 4C8B4508            <1>     mov r8, qword [rbp + 8]    ;First argument, #Base
   802 00002C90 4C8B4D00            <1>     mov r9, qword [rbp]    ;Second argument, #Number of bytes
   803                              <1> .dmmain00:
   804 00002C94 4D85C9              <1>     test r9, r9
   805 00002C97 0F84FD000000        <1>     jz .dmbadexit
   806 00002C9D 66B80413            <1>     mov ax, 1304h
   807 00002CA1 48BD-               <1>     mov rbp, .crlf
   807 00002CA3 [AA31000000000000]  <1>
   808 00002CAB CD30                <1>     int 30h
   809 00002CAD 4C89C2              <1>     mov rdx, r8
   810 00002CB0 E85C010000          <1>     call .dmcsaddrprint
   811 00002CB5 30FF                <1>     xor bh, bh
   812 00002CB7 B403                <1>     mov ah, 03h
   813 00002CB9 CD30                <1>     int 30h
   814 00002CBB B219                <1>     mov dl, 25
   815 00002CBD B402                <1>     mov ah, 02h
   816 00002CBF CD30                <1>     int 30h
   817 00002CC1 4C89C6              <1>     mov rsi, r8    ;point rsi at r8
   818 00002CC4 48F7C608000000      <1>     test rsi, 08h    ;If it starts between a qword and para
   819                              <1> 
   820 00002CCB 48F7C60F000000      <1>     test rsi, 0Fh
   821 00002CD2 7430                <1>     jz .dmmain0    ;If it starts on paragraph bndry, continue as normal
   822 00002CD4 56                  <1>     push rsi
   823 00002CD5 4881E60F000000      <1>     and rsi, 0Fh
   824 00002CDC 4881FE08000000      <1>     cmp rsi, 8
   825 00002CE3 720F                <1>     jb .dmmain01
   826 00002CE5 48B901000000000000- <1>     mov rcx, 1
   826 00002CEE 00                  <1>
   827 00002CEF E8F9000000          <1>     call .dmal1    ;Print one space
   828                              <1> .dmmain01:
   829 00002CF4 5E                  <1>     pop rsi
   830 00002CF5 48B801000000000000- <1>     mov rax, 1
   830 00002CFE 00                  <1>
   831 00002CFF E8D0000000          <1>     call .dmalign
   832                              <1> 
   833                              <1> .dmmain0:
   834 00002D04 4889F7              <1>     mov rdi, rsi    ;Save start point at rdi
   835 00002D07 4151                <1>     push r9
   836                              <1> .dmmain1:    ;This loop prints a line
   837 00002D09 AC                  <1>     lodsb
   838 00002D0A B404                <1>     mov ah, 4h
   839 00002D0C CD30                <1>     int 30h
   840 00002D0E 49FFC9              <1>     dec r9
   841 00002D11 7416                <1>     jz .dmmain2
   842 00002D13 48F7C608000000      <1>     test rsi, 08h    ;This is zero iff rsi has bit 4 set
   843 00002D1A 0F85D9000000        <1>     jnz .dmhyphen1
   844 00002D20 48F7C60F000000      <1>     test rsi, 0Fh    ;This is zero iff lower nybble is zero
   845 00002D27 75E0                <1>     jnz .dmmain1
   846                              <1> .dmmain2:
   847                              <1> ;Now the numbers have been printed, get the ascii row too
   848                              <1> ;First check if numbers have stopped short of 16
   849 00002D29 4D85C9              <1>     test r9, r9
   850 00002D2C 7500                <1>     jnz .dmmain21    ;end of row
   851                              <1> 
   852                              <1> .dmmain21:
   853 00002D2E 4159                <1>     pop r9
   854 00002D30 30FF                <1>     xor bh, bh
   855 00002D32 B403                <1>     mov ah, 03h
   856 00002D34 CD30                <1>     int 30h
   857 00002D36 B23E                <1>     mov dl, 62
   858 00002D38 B402                <1>     mov ah, 02h
   859 00002D3A CD30                <1>     int 30h
   860 00002D3C 4889FE              <1>     mov rsi, rdi    ;Reload value
   861 00002D3F 48F7C60F000000      <1>     test rsi, 0Fh
   862 00002D46 7408                <1>     jz .dmmain3    ;If it starts on paragraph bndry, continue as normal
   863 00002D48 4831C0              <1>     xor rax, rax    ;no shift
   864 00002D4B E884000000          <1>     call .dmalign
   865                              <1> 
   866                              <1> .dmmain3:
   867 00002D50 AC                  <1>     lodsb
   868 00002D51 49FFC9              <1>     dec r9
   869 00002D54 3C30                <1>     cmp al, 30h
   870 00002D56 660F420425-         <1>     cmovb ax, word [.dmdot]    ;bring the dot to ax
   870 00002D5B [382E0000]          <1>
   871 00002D5F B40E                <1>     mov ah, 0Eh
   872 00002D61 CD30                <1>     int 30h
   873 00002D63 4D85C9              <1>     test r9, r9
   874 00002D66 7443                <1>     jz .dmexit
   875 00002D68 48F7C60F000000      <1>     test rsi, 0Fh    ;Check if lower nybble is 0
   876 00002D6F 75DF                <1>     jnz .dmmain3
   877                              <1> 
   878 00002D71 48BD-               <1>     mov rbp, .crlf
   878 00002D73 [AA31000000000000]  <1>
   879 00002D7B 66B80413            <1>     mov ax, 1304h
   880 00002D7F CD30                <1>     int 30h
   881                              <1> 
   882 00002D81 4889F2              <1>     mov rdx, rsi
   883 00002D84 E888000000          <1>     call .dmcsaddrprint
   884                              <1> 
   885 00002D89 B403                <1>     mov ah, 03h
   886 00002D8B 30FF                <1>     xor bh, bh
   887 00002D8D CD30                <1>     int 30h
   888 00002D8F B219                <1>     mov dl, 25
   889 00002D91 B402                <1>     mov ah, 02h
   890 00002D93 CD30                <1>     int 30h
   891 00002D95 E96AFFFFFF          <1>     jmp .dmmain0
   892                              <1> 
   893                              <1> .dmbadexit:
   894 00002D9A 48BD-               <1>     mov rbp, .dmbadargs
   894 00002D9C [3A2E000000000000]  <1>
   895 00002DA4 66B80413            <1>     mov ax, 1304h
   896 00002DA8 CD30                <1>     int 30h
   897 00002DAA C3                  <1>     ret;Reload program, error!
   898                              <1> .dmexit:
   899 00002DAB 4159                <1>     pop r9
   900 00002DAD 4158                <1>     pop r8
   901 00002DAF 5D                  <1>     pop rbp
   902 00002DB0 5E                  <1>     pop rsi
   903 00002DB1 5F                  <1>     pop rdi
   904 00002DB2 5A                  <1>     pop rdx
   905 00002DB3 59                  <1>     pop rcx
   906 00002DB4 5B                  <1>     pop rbx
   907 00002DB5 58                  <1>     pop rax
   908 00002DB6 C3                  <1>     ret
   909                              <1> .dmnoargs:
   910 00002DB7 4C8B0425[F4010000]  <1>     mov r8, qword [mcpUserRip]
   911                              <1>     ;add r8, 180h    ;Add 180 bytes, to bypass internal work areas
   912 00002DBF EB04                <1>     jmp short .dmnoargscommon
   913                              <1> .dmnoargs1:
   914 00002DC1 4C8B4500            <1>     mov r8, qword [rbp]
   915                              <1> .dmnoargscommon:
   916 00002DC5 49B980000000000000- <1>     mov r9, 80h
   916 00002DCE 00                  <1>
   917 00002DCF E9C0FEFFFF          <1>     jmp .dmmain00
   918                              <1> 
   919                              <1> .dmalign:    ;Print blank chars for offset
   920                              <1> ;Works out from rsi
   921                              <1> ;rax contains value for shl
   922 00002DD4 56                  <1>     push rsi
   923 00002DD5 4889F1              <1>     mov rcx, rsi
   924 00002DD8 4881E1F0FFFFFF      <1>     and rcx, 0FFFFFFFFFFFFFFF0h    ;Round down
   925 00002DDF 4829CE              <1>     sub rsi, rcx
   926 00002DE2 4887CE              <1>     xchg rcx, rsi
   927 00002DE5 5E                  <1>     pop rsi
   928 00002DE6 4891                <1>     xchg rcx, rax
   929 00002DE8 48D3E0              <1>     shl rax, cl
   930 00002DEB 4891                <1>     xchg rcx, rax
   931                              <1> .dmal1:
   932 00002DED 66B8200E            <1>     mov ax, 0E20h
   933 00002DF1 CD30                <1>     int 30h
   934 00002DF3 48FFC9              <1>     dec rcx
   935 00002DF6 75F5                <1>     jnz .dmal1
   936 00002DF8 C3                  <1>     ret
   937                              <1> 
   938                              <1> .dmhyphen1:
   939 00002DF9 48F7C607000000      <1>     test rsi, 07h    ;If the rest of the bits are set, go away
   940 00002E00 0F8503FFFFFF        <1>     jnz .dmmain1
   941 00002E06 66B82D0E            <1>     mov ax, 0E2Dh    ;2dh="-"
   942 00002E0A CD30                <1>     int 30h
   943 00002E0C E9F8FEFFFF          <1>     jmp .dmmain1
   944                              <1> .dmcsaddrprint:
   945 00002E11 668CC8              <1>     mov ax, cs    ;Get current code segment into ax
   946 00002E14 88E0                <1>     mov al, ah
   947 00002E16 B404                <1>     mov ah, 04h    ;print upper byte
   948 00002E18 CD30                <1>     int 30h
   949 00002E1A 668CC8              <1>     mov ax, cs
   950 00002E1D B404                <1>     mov ah, 04h
   951 00002E1F CD30                <1>     int 30h        ;print lower byte
   952 00002E21 66B83A0E            <1>     mov ax, 0E3Ah
   953                              <1> 
   954 00002E25 B108                <1>     mov cl, 8
   955 00002E27 CD30                <1>     int 30h
   956                              <1> 
   957                              <1> .dmrollprint:
   958                              <1> ;Takes whats in rdx, rols left by one byte, prints al
   959                              <1> ;repeats, cl times.
   960 00002E29 48C1C208            <1>     rol rdx, 8
   961 00002E2D 88D0                <1>     mov al, dl
   962 00002E2F B404                <1>     mov ah, 04h
   963 00002E31 CD30                <1>     int 30h
   964 00002E33 FEC9                <1>     dec cl
   965 00002E35 75F2                <1>     jnz .dmrollprint
   966 00002E37 C3                  <1>     ret
   967 00002E38 2E00                <1> .dmdot:    db    ".",0
   968 00002E3A 0A0D53796E74617820- <1> .dmbadargs:    db 0Ah, 0Dh,"Syntax error",0
   968 00002E43 6572726F7200        <1>
   969                              <1> 
   970                              <1> .editMemory:
   971 00002E49 66B80413            <1>     mov ax, 1304h
   972 00002E4D 30FF                <1>     xor bh, bh
   973 00002E4F 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   973 00002E51 [A831000000000000]  <1>
   974 00002E59 CD30                <1>     int 30h
   975                              <1> 
   976 00002E5B 66B80104            <1>     mov ax, 0401h    ;Get up to one qword
   977 00002E5F E874020000          <1>     call .keyb
   978 00002E64 4885ED              <1>     test rbp, rbp        ;No chars entered?
   979 00002E67 0F8445F6FFFF        <1>     jz .bad_command
   980 00002E6D E806020000          <1>     call .arg
   981 00002E72 488B7D00            <1>     mov rdi, qword [rbp]    ;First arg, Dword Address 
   982                              <1> 
   983 00002E76 48BD-               <1>     mov rbp, .crlf
   983 00002E78 [AA31000000000000]  <1>
   984 00002E80 30FF                <1>     xor bh, bh
   985 00002E82 48B804130000000000- <1>     mov rax, 1304h
   985 00002E8B 00                  <1>
   986 00002E8C CD30                <1>     int 30h
   987                              <1>     
   988 00002E8E 4889FE              <1>     mov rsi, rdi
   989 00002E91 AC                  <1>     lodsb    ;Get byte into al
   990 00002E92 B404                <1>     mov ah, 04
   991 00002E94 CD30                <1>     int 30h
   992 00002E96 B02E                <1>     mov al, "."
   993 00002E98 E8DC020000          <1>     call .print
   994 00002E9D 66B80101            <1>     mov ax, 0101h    ;Get 1 byte
   995 00002EA1 E832020000          <1>     call .keyb
   996 00002EA6 4885ED              <1>     test rbp, rbp        ;No chars entered?
   997 00002EA9 0F84EBFEFFFF        <1>     jz .dmbadexit
   998 00002EAF E8C4010000          <1>     call .arg
   999 00002EB4 4889EE              <1>     mov rsi, rbp    ;Point rsi to the stack
  1000 00002EB7 A4                  <1>     movsb            ;Move byte from rsi to rdi
  1001                              <1> 
  1002 00002EB8 C3                  <1>     ret
  1003                              <1> 
  1004                              <1> .jumpProc:
  1005 00002EB9 66B80413            <1>     mov ax, 1304h
  1006 00002EBD 30FF                <1>     xor bh, bh
  1007 00002EBF 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
  1007 00002EC1 [A831000000000000]  <1>
  1008 00002EC9 CD30                <1>     int 30h
  1009 00002ECB 66B80104            <1>     mov ax, 0401h    ;Get 1 dword (forbit going too high eh?)
  1010 00002ECF E804020000          <1>     call .keyb
  1011 00002ED4 4885ED              <1>     test rbp, rbp        ;No chars entered?
  1012 00002ED7 743B                <1>     jz .proceedDefault
  1013 00002ED9 E89A010000          <1>     call .arg
  1014 00002EDE FEC8                <1>     dec al
  1015 00002EE0 0F85B4FEFFFF        <1>     jnz .dmbadexit
  1016 00002EE6 488B6D00            <1>     mov rbp, qword [rbp]    ;First argument, Address of procedure
  1017 00002EEA 48892C25[F4010000]  <1>     mov qword [mcpUserRip], rbp   ;Move first argument into new Rip  
  1018 00002EF2 E81B010000          <1>     call .loadMainRegisters
  1019 00002EF7 488B6008            <1>     mov rsp, qword [rax + 08h]
  1020 00002EFB 488B0425[04020000]  <1>     mov rax, qword [mcpUserRaxStore]
  1021 00002F03 48CF                <1>     iretq
  1022                              <1> .singleStep:
  1023                              <1> ;When s is pressed, the program proceeds by a single step.
  1024                              <1> ;Sets trap flag on
  1025 00002F05 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
  1026 00002F0D 48810800010000      <1>     or qword [rax + 00h], 100h  ;Set trap flag on
  1027                              <1> .proceedDefault:
  1028 00002F14 E8F9000000          <1>     call .loadMainRegisters
  1029 00002F19 488B6008            <1>     mov rsp, qword [rax + 08h]
  1030 00002F1D 488B0425[04020000]  <1>     mov rax, qword [mcpUserRaxStore]
  1031 00002F25 48CF                <1>     iretq
  1032                              <1> 
  1033                              <1> .storageRead:
  1034 00002F27 50                  <1>     push rax
  1035 00002F28 B800820000          <1>     mov eax, 8200h ;LBA Read function
  1036 00002F2D EB06                <1>     jmp short .storageCommon
  1037                              <1> .storageWrite:
  1038 00002F2F 50                  <1>     push rax
  1039 00002F30 B800830000          <1>     mov eax, 8300h ;LBA Write function
  1040                              <1> .storageCommon:
  1041                              <1> ;l/w [Address Buffer] [Drive] [Sector] [Count]
  1042 00002F35 53                  <1>     push rbx
  1043 00002F36 51                  <1>     push rcx
  1044 00002F37 52                  <1>     push rdx
  1045 00002F38 56                  <1>     push rsi
  1046 00002F39 57                  <1>     push rdi
  1047 00002F3A 55                  <1>     push rbp
  1048                              <1> 
  1049 00002F3B 89C6                <1>     mov esi, eax        ;Save LBA r/w function number in esi
  1050 00002F3D 66B80413            <1>     mov ax, 1304h
  1051 00002F41 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
  1051 00002F43 [A831000000000000]  <1>
  1052 00002F4B CD30                <1>     int 30h
  1053                              <1> 
  1054 00002F4D 66B80404            <1>     mov ax, 0404h    ;Get 4 qwords
  1055 00002F51 E882010000          <1>     call .keyb
  1056 00002F56 4885ED              <1>     test rbp, rbp
  1057 00002F59 7452                <1>     jz .storageError
  1058 00002F5B B004                <1>     mov al, 4    ;Number of user inputs to convert
  1059 00002F5D E816010000          <1>     call .arg
  1060 00002F62 3C04                <1>     cmp al, 4   ;If not 4 arguments, fail
  1061 00002F64 7547                <1>     jne .storageError
  1062 00002F66 BF05000000          <1>     mov edi, 5
  1063                              <1> .sc0:
  1064 00002F6B 89F0                <1>     mov eax, esi                ;Get back LBA r/w function number into eax
  1065 00002F6D 488B5D18            <1>     mov rbx, qword [rbp + 24]   ;First argument, Address buffer
  1066 00002F71 488B5510            <1>     mov rdx, qword [rbp + 16]   ;dl ONLY, Second argument
  1067 00002F75 4881E2FF000000      <1>     and rdx, 0FFh
  1068 00002F7C 488B4D08            <1>     mov rcx, qword [rbp + 08]   ;LBA starting sector, third argument
  1069 00002F80 488B7500            <1>     mov rsi, qword [rbp]        ;Sector count into rsi
  1070 00002F84 4881E6FF000000      <1>     and rsi, 0FFh               ;Sector count can be at most 255
  1071 00002F8B 09F0                <1>     or eax, esi                 ;Add the sector count to eax
  1072 00002F8D 89C6                <1>     mov esi, eax                ;Copy the function number into esi for failures
  1073 00002F8F 81E600FF0000        <1>     and esi, 0FF00h             ;Save only byte two of esi, the function number
  1074 00002F95 CD33                <1>     int 33h
  1075 00002F97 7308                <1>     jnc .storageExit
  1076                              <1> 
  1077 00002F99 31C0                <1>     xor eax, eax
  1078 00002F9B CD33                <1>     int 33h
  1079 00002F9D FFCF                <1>     dec edi
  1080 00002F9F 75CA                <1>     jnz .sc0
  1081                              <1> .storageExit:
  1082 00002FA1 5D                  <1>     pop rbp
  1083 00002FA2 5F                  <1>     pop rdi
  1084 00002FA3 5E                  <1>     pop rsi
  1085 00002FA4 5A                  <1>     pop rdx
  1086 00002FA5 59                  <1>     pop rcx
  1087 00002FA6 5B                  <1>     pop rbx
  1088 00002FA7 58                  <1>     pop rax   
  1089 00002FA8 E912F4FFFF          <1>     jmp MCP_int.z11
  1090                              <1> .storageError: 
  1091 00002FAD 5D                  <1>     pop rbp
  1092 00002FAE 5F                  <1>     pop rdi
  1093 00002FAF 5E                  <1>     pop rsi
  1094 00002FB0 5A                  <1>     pop rdx
  1095 00002FB1 59                  <1>     pop rcx
  1096 00002FB2 5B                  <1>     pop rbx
  1097 00002FB3 58                  <1>     pop rax
  1098 00002FB4 E9F9F4FFFF          <1>     jmp .bad_command
  1099                              <1> .restartMcp:
  1100 00002FB9 CD40                <1>     int 40h     ;To allow returning to DOS
  1101                              <1> .clearscreen:
  1102 00002FBB B307                <1>     mov bl, 07h
  1103 00002FBD E835D1FFFF          <1>     call cls
  1104 00002FC2 E9F8F3FFFF          <1>     jmp MCP_int.z11
  1105                              <1> .storeMainRegisters:
  1106 00002FC7 9C                  <1>     pushfq
  1107 00002FC8 8F00                <1>     pop qword [rax + 00h]      ;Flags
  1108                              <1>     ;mov qword [rax + 08h], rsp
  1109 00002FCA 48896810            <1>     mov qword [rax + 10h], rbp
  1110 00002FCE 4C897818            <1>     mov qword [rax + 18h], r15
  1111 00002FD2 4C897020            <1>     mov qword [rax + 20h], r14
  1112 00002FD6 4C896828            <1>     mov qword [rax + 28h], r13
  1113 00002FDA 4C896030            <1>     mov qword [rax + 30h], r12
  1114 00002FDE 4C895838            <1>     mov qword [rax + 38h], r11
  1115 00002FE2 4C895040            <1>     mov qword [rax + 40h], r10
  1116 00002FE6 4C894848            <1>     mov qword [rax + 48h], r9
  1117 00002FEA 4C894050            <1>     mov qword [rax + 50h], r8
  1118 00002FEE 48897858            <1>     mov qword [rax + 58h], rdi
  1119 00002FF2 48897060            <1>     mov qword [rax + 60h], rsi
  1120 00002FF6 48895068            <1>     mov qword [rax + 68h], rdx
  1121 00002FFA 48894870            <1>     mov qword [rax + 70h], rcx
  1122 00002FFE 48895878            <1>     mov qword [rax + 78h], rbx
  1123 00003002 488B1C25[04020000]  <1>     mov rbx, qword [mcpUserRaxStore]
  1124 0000300A 48899880000000      <1>     mov qword [rax + 80h], rbx  ;Store rax
  1125 00003011 C3                  <1>     ret
  1126                              <1> .loadMainRegisters:
  1127 00003012 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
  1128 0000301A 488B5008            <1>     mov rdx, qword [rax + 08h]  ;Get old stack pointer into rdx
  1129 0000301E 488B1C25[F4010000]  <1>     mov rbx, qword [mcpUserRip]
  1130 00003026 48891A              <1>     mov qword [rdx], rbx    ;Move the userRip into rdx
  1131 00003029 488B18              <1>     mov rbx, qword [rax + 00h]
  1132 0000302C 48895A10            <1>     mov qword [rdx + 10h], rbx  ;Move new flags into position on stack
  1133 00003030 488B9880000000      <1>     mov rbx, qword [rax + 80h]  ;Get rax
  1134 00003037 48891C25[04020000]  <1>     mov qword [mcpUserRaxStore], rbx
  1135 0000303F 488B5878            <1>     mov rbx, qword [rax + 78h]
  1136 00003043 488B4870            <1>     mov rcx, qword [rax + 70h]
  1137 00003047 488B5068            <1>     mov rdx, qword [rax + 68h]
  1138 0000304B 488B7060            <1>     mov rsi, qword [rax + 60h]
  1139 0000304F 488B7858            <1>     mov rdi, qword [rax + 58h]
  1140 00003053 4C8B4050            <1>     mov r8,  qword [rax + 50h]
  1141 00003057 4C8B4848            <1>     mov r9,  qword [rax + 48h]
  1142 0000305B 4C8B5040            <1>     mov r10, qword [rax + 40h]
  1143 0000305F 4C8B5838            <1>     mov r11, qword [rax + 38h]
  1144 00003063 4C8B6030            <1>     mov r12, qword [rax + 30h]
  1145 00003067 4C8B6828            <1>     mov r13, qword [rax + 28h]
  1146 0000306B 4C8B7020            <1>     mov r14, qword [rax + 20h]
  1147 0000306F 4C8B7818            <1>     mov r15, qword [rax + 18h]
  1148 00003073 488B6810            <1>     mov rbp, qword [rax + 10h]
  1149 00003077 C3                  <1>     ret
  1150                              <1> ;ARG    PROC    NEAR
  1151                              <1> .arg:
  1152                              <1> ;Number of arguments expected in buffer in al (could early terminate due to 
  1153                              <1> ; enter)
  1154                              <1> ;Converted qwords stored on stack with al indicating how many processed
  1155                              <1> ;rbp returns the base of the stack of stored arguments
  1156                              <1> ;rdx is our scratch register
  1157 00003078 53                  <1>     push rbx
  1158 00003079 51                  <1>     push rcx
  1159 0000307A 52                  <1>     push rdx
  1160 0000307B 56                  <1>     push rsi
  1161 0000307C 4889E5              <1>     mov rbp, rsp    ;Preserve stack pointer
  1162 0000307F 488B3425[FC010000]  <1>     mov rsi, qword [mcpUserkeybf]
  1163 00003087 30C9                <1>     xor cl, cl        ;Keep track of how many arguments processed
  1164                              <1> .a01:
  1165 00003089 4831D2              <1>     xor rdx, rdx    ;Clean rdx
  1166                              <1> .a1:
  1167 0000308C AC                  <1>     lodsb        ;Get the first byte into al
  1168 0000308D 3C11                <1>     cmp al, 11h    ;Offset 11h is the space key
  1169 0000308F 740E                <1>     jz .a2
  1170 00003091 3C12                <1>     cmp al, 12h    ;Offset 12h is the enter key
  1171 00003093 740F                <1>     jz .aexit        ;Anyway, enter is exit!
  1172 00003095 48C1E204            <1>     shl rdx, 4    ;Go to next sig fig
  1173 00003099 08C2                <1>     or dl, al    ;Put this byte into dl
  1174 0000309B 7013                <1>     jo .error
  1175 0000309D EBED                <1>     jmp short .a1
  1176                              <1> .a2:
  1177 0000309F 52                  <1>     push rdx    ;Store argument on stack
  1178 000030A0 FEC1                <1>     inc cl        ;One more argument processed
  1179 000030A2 EBE5                <1>     jmp short .a01
  1180                              <1> .aexit:
  1181 000030A4 480FB6C1            <1>     movzx rax, cl    ;Return #of args processed
  1182 000030A8 4887E5              <1>     xchg rsp, rbp    ;rbp points to bottom of argument stack 
  1183 000030AB 5E                  <1>     pop rsi
  1184 000030AC 5A                  <1>     pop rdx
  1185 000030AD 59                  <1>     pop rcx
  1186 000030AE 5B                  <1>     pop rbx
  1187 000030AF C3                  <1>     ret
  1188                              <1> .error:
  1189 000030B0 48BD-               <1>     mov rbp, .emsg
  1189 000030B2 [C730000000000000]  <1>
  1190 000030BA 30FF                <1>     xor bh, bh
  1191 000030BC 66B80413            <1>     mov ax, 1304h
  1192 000030C0 CD30                <1>     int 30h
  1193 000030C2 5E                  <1>     pop rsi
  1194 000030C3 5A                  <1>     pop rdx
  1195 000030C4 59                  <1>     pop rcx
  1196 000030C5 5B                  <1>     pop rbx
  1197 000030C6 C3                  <1>     ret
  1198 000030C7 0A0D417267756D656E- <1> .emsg:    db 0Ah, 0Dh,"Argument error",0
  1198 000030D0 74206572726F7200    <1>
  1199                              <1> ;ARG    ENDP
  1200                              <1> 
  1201                              <1> ;KEYB     PROC     NEAR
  1202                              <1> .keyb:
  1203                              <1> ;Number of arguments to accept is passed in al, in units of ah
  1204                              <1> ;ah=4 => Qwords, ah=3 => dwords... ah=2 => word, ah=1 => bytes
  1205                              <1> ;Arguments are stored in buffer, after USB area, of size 2*al qwords
  1206                              <1> ;All arguments CAN be up to qword in size, though not all subprogs,
  1207                              <1> ;    may use the full qword.
  1208                              <1> ;ch returns number of chars not processed
  1209 000030D8 50                  <1>     push rax
  1210 000030D9 53                  <1>     push rbx
  1211                              <1>     ;push rcx
  1212 000030DA 57                  <1>     push rdi
  1213 000030DB 52                  <1>     push rdx
  1214                              <1> 
  1215 000030DC 4831C9              <1>     xor rcx, rcx
  1216 000030DF 88C1                <1>     mov cl, al
  1217 000030E1 51                  <1>     push rcx
  1218 000030E2 88E1                <1>     mov cl, ah
  1219 000030E4 D2E0                <1>     shl al, cl  ;Multiply by 16 to get the number of bytes needed w/o spaces
  1220 000030E6 59                  <1>     pop rcx
  1221 000030E7 00C8                <1>     add al, cl  ;Add space for spaces
  1222 000030E9 FEC8                <1>     dec al      ;We reserve one space for a "non-user accessible" EOL at the end
  1223                              <1> 
  1224 000030EB 488B3C25[FC010000]  <1>     mov rdi, qword [mcpUserkeybf]    ;Data area in command tail
  1225 000030F3 50                  <1>     push rax
  1226 000030F4 48B810000000000000- <1>     mov rax, 10h
  1226 000030FD 00                  <1>
  1227 000030FE 57                  <1>     push rdi
  1228 000030FF F348AB              <1>     rep stosq    ;Clear buffer space for al qwords (max 8)
  1229 00003102 5F                  <1>     pop rdi
  1230 00003103 58                  <1>     pop rax
  1231                              <1> 
  1232 00003104 88C5                <1>     mov ch, al    ;Rememebr 1 Qword is 16 ASCII chars
  1233 00003106 88C2                <1>     mov dl, al    ;Let dl save this number
  1234 00003108 4831ED              <1>     xor rbp, rbp    ;Cheap cop out char counter
  1235                              <1> 
  1236                              <1> .k1:
  1237 0000310B 6631C0              <1>     xor ax, ax
  1238 0000310E CD36                <1>     int 36h
  1239 00003110 3C71                <1>     cmp al, "q"    ;Quit option
  1240 00003112 0F84A7F2FFFF        <1>     je .z11
  1241 00003118 3C08                <1>     cmp al, 08h    ;Backspace
  1242 0000311A 7447                <1>     je .kb2
  1243 0000311C 3C0D                <1>     cmp al, 0Dh    ;Enter key pressed, we done
  1244 0000311E 7438                <1>     je .kend
  1245                              <1> 
  1246 00003120 84ED                <1>     test ch, ch    ;Have we filled a 16 char buffer?
  1247 00003122 74E7                <1>     jz .k1        ;Yes, await control key
  1248                              <1> 
  1249 00003124 4889FB              <1>     mov rbx, rdi    ;Save current offset into bbuffer
  1250 00003127 51                  <1>     push rcx
  1251 00003128 48BF-               <1>     mov rdi, .ascii
  1251 0000312A [7E31000000000000]  <1>
  1252 00003132 48B913000000000000- <1>     mov rcx, .asciil
  1252 0000313B 00                  <1>
  1253 0000313C F2AE                <1>     repne scasb        ;Find the offset of the char in al in the table
  1254 0000313E 59                  <1>     pop rcx            ;Doesnt affect flags
  1255 0000313F 4887FB              <1>     xchg rdi, rbx    ;Return value back to rdi 
  1256 00003142 75C7                <1>     jne .k1            ;Not a key from our buffer, loop again
  1257 00003144 48FFC5              <1>     inc rbp
  1258 00003147 E82D000000          <1>     call .print        ;Print typed char
  1259                              <1> 
  1260 0000314C 488D83(81CEFFFF)    <1>     lea rax, qword [rbx - .ascii -1]    ;Work out difference
  1261                              <1> 
  1262 00003153 AA                  <1>     stosb            ;Store the value in storage buffer, inc rdi
  1263 00003154 FECD                <1>     dec ch            ;Decrement the number of typable chars
  1264 00003156 EBB3                <1>     jmp short .k1    ;Get next char
  1265                              <1> .kend:
  1266 00003158 66B81112            <1>     mov ax, 1211h    ;Store a space and EOF at the end (little endian!)
  1267 0000315C 66AB                <1>     stosw
  1268                              <1> 
  1269 0000315E 5A                  <1>     pop rdx
  1270 0000315F 5F                  <1>     pop rdi
  1271                              <1>     ;pop rcx    ;Return in cl the number of processed chars
  1272 00003160 5B                  <1>     pop rbx
  1273 00003161 58                  <1>     pop rax
  1274                              <1> .kb1:        
  1275 00003162 C3                  <1>     ret
  1276                              <1> .kb2:
  1277                              <1> ;When a backspace is entered, DONT MOVE THIS PROC!
  1278 00003163 68[0B310000]        <1>     push .k1
  1279 00003168 38D5                <1>     cmp ch, dl    ;If bbuf is empty, ignore backspace 
  1280 0000316A 74F6                <1>     jz .kb1
  1281 0000316C 48FFCF              <1>     dec rdi        ;Decrement pointer and print the bspace char
  1282 0000316F FEC5                <1>     inc ch        ;Increment the number of typable chars
  1283 00003171 4885ED              <1>     test rbp, rbp
  1284 00003174 7403                <1>     jz .print    ;Dont decrement if rbp is zero
  1285 00003176 48FFCD              <1>     dec rbp
  1286                              <1> ;KEYB    ENDP
  1287                              <1> .print:    ;Print char in al
  1288 00003179 B40E                <1>     mov ah, 0Eh
  1289                              <1>     ;xor bh, bh
  1290 0000317B CD30                <1>     int 30h
  1291 0000317D C3                  <1>     ret
  1292 0000317E 303132333435363738- <1> .ascii       db    "0123456789abcdef", 08h, 20h, 0Dh ;b/space, enter
  1292 00003187 396162636465660820- <1>
  1292 00003190 0D                  <1>
  1293                              <1> .asciil       equ    $ - .ascii
  1294 00003191 64657367706C777163- <1> .lst       db    'desgplwqcrbhiovamkx';dump,edit,go,single step,read,write,quit,
  1294 0000319A 726268696F76616D6B- <1>
  1294 000031A3 78                  <1>
  1295                              <1> ;clearscreen,registers,deBug regs,hex,in,out,version,Single Step alt, memory map
  1296                              <1> ; (k)connect, dixonnect
  1297                              <1> .lstl    equ    $ - .lst
  1298 000031A4 0A0D2D00            <1> .prompt       db    0Ah, 0Dh, "-", 0    ;3Eh = >
  1299 000031A8 2000                <1> .prompt2    db 20h,0
  1300 000031AA 0A0D00              <1> .crlf       db    0Ah, 0Dh, 0
  1301                              <1> ;------------------------End of Interrupt------------------------
   101                                  %include "./Source/Resident/Services/Int39h.asm"
   102                              <1> ;-------------------Restart Interrupt Int 39h--------------------
   103                              <1> ;This interrupt allows the user to soft reboot
   104                              <1> ;----------------------------------------------------------------
   105                              <1> bootstrapInt:
   106                              <1> ;Bootstrap loader, loads user programmed sector into memory, first from
   107                              <1> ; device 00h and then from device 80h. If device 00h doesnt exist OR the 
   108                              <1> ; loadsector doesn't begin with the SCP/BIOS boot signature then the 
   109                              <1> ; same sector is read from of device 80h. If this also fails due to device 80h
   110                              <1> ; not existing or the sector not being bootable, the boot loader will return
   111                              <1> ; to the caller with the carry flag set.
   112                              <1> 
   113 000031AD 50                  <1>     push rax
   114 000031AE 53                  <1>     push rbx
   115 000031AF 51                  <1>     push rcx
   116 000031B0 52                  <1>     push rdx
   117 000031B1 56                  <1>     push rsi
   118                              <1> 
   119 000031B2 B9000100C0          <1>     mov ecx, 0C0000100h    ;Select fs register to load base addr
   120 000031B7 488B0425[CD010000]  <1>     mov rax, qword [userBase]    ;Load address to fs
   121 000031BF 31D2                <1>     xor edx, edx        ;Zero upper bytes
   122 000031C1 0F30                <1>     wrmsr                ;Write msr to load fs base
   123                              <1> 
   124 000031C3 BE0A000000          <1>     mov esi, 10
   125                              <1> ;Now load one sector of second prog from device 00h or 80h
   126 000031C8 803C25[4B020000]00  <1>     cmp byte [numMSD], 0    ;If we have no removable devices, skip checking rem dev
   127 000031D0 7447                <1>     jz .e3
   128 000031D2 6631D2              <1>     xor dx, dx  ;This also clears carry flag so no checking ah
   129                              <1> .e0:
   130 000031D5 48BB007C0000000000- <1>     mov rbx, 7c00h
   130 000031DE 00                  <1>
   131 000031DF 488B0C25[BF010000]  <1>     mov rcx, qword [nextFilePtr]
   132 000031E7 668B0425[C7010000]  <1>     mov ax, word [numSectors]   ;Max 42 sectors, upper byte is always 0
   133 000031EF B482                <1>     mov ah, 82h ;LBA Sector Read, dl has device number
   134 000031F1 CD33                <1>     int 33h     ;Read one sector, device number is preserved
   135 000031F3 730A                <1>     jnc .e1
   136                              <1> 
   137 000031F5 FFCE                <1>     dec esi
   138 000031F7 7412                <1>     jz .e2  ;Try again for fixed disk or if on fixed disk, exit
   139                              <1> 
   140 000031F9 30E4                <1>     xor ah, ah  ;Reset the device in dl
   141 000031FB CD33                <1>     int 33h
   142 000031FD EBD6                <1>     jmp short .e0
   143                              <1> .e1:
   144 000031FF 66813C25007C000055- <1>     cmp word [7c00h], 0AA55h ;The Boot signature
   144 00003208 AA                  <1>
   145 00003209 7418                <1>     je .leaveBIOS
   146                              <1> ;If we dont goto leaveBIOS, then we try again with device number 80h if it exists
   147                              <1> ;If already at device 80h, fail.
   148                              <1> .e2:
   149 0000320B 80FA80              <1>     cmp dl, 80h
   150 0000320E 742A                <1>     je .efail
   151 00003210 381425[AA010000]    <1>     cmp byte [fdiskNum], dl ;Recall, dl is zero here
   152 00003217 7421                <1>     je .efail   ;Don't waste time if there are no fixed disks
   153                              <1> .e3:
   154 00003219 B280                <1>     mov dl, 80h ;Try first fixed disk now
   155 0000321B BE0A000000          <1>     mov esi, 10 ;Reload repeat count
   156 00003220 F8                  <1>     clc
   157 00003221 EBB2                <1>     jmp short .e0
   158                              <1> .leaveBIOS:
   159                              <1> ;State when system transferred:
   160                              <1> ; RSP = DFF8h, 1FFh qword stack from DFFFh to 7C00H + 42*200h sectors = D000h
   161                              <1> ; FS MSR = userbase pointer, can be used for segment override.
   162                              <1> ; DX = Int 33h boot device number
   163                              <1> ; RBX = LBA of first Logical Block after SCP/BIOS
   164                              <1> ; BDA and BIOS ready to go
   165 00003223 48BCF8DF0000000000- <1>     mov rsp, 0DFF8h ;Move Stack pointer to default init stack position
   165 0000322C 00                  <1>
   166 0000322D 488B1C25[BF010000]  <1>     mov rbx, qword [nextFilePtr]     ;First sector on device after SCP/BIOS
   167 00003235 E9(027C0000)        <1>     jmp 7C02h       ;New sector entry point
   168                              <1> .efail:
   169 0000323A 5E                  <1>     pop rsi
   170 0000323B 5A                  <1>     pop rdx
   171 0000323C 59                  <1>     pop rcx
   172 0000323D 5B                  <1>     pop rbx
   173 0000323E 58                  <1>     pop rax
   174 0000323F 804C241001          <1>     or byte [rsp + 2*8h], 1 ;Set carry flag
   175 00003244 48CF                <1>     iretq
   176                              <1> ;------------------------End of Interrupt------------------------
   102                                  %include "./Source/Resident/Services/Int3Ah.asm"
   103                              <1> ;-----------------System Timer Interrupt Int 3Ah-----------------
   104                              <1> ;System Timer functions:
   105                              <1> ; ah=0 -> Get tick count
   106                              <1> ; ah=1 -> Set tick count
   107                              <1> ; ah=2 -> Read RTC time
   108                              <1> ; ah=3 -> Set RTC time
   109                              <1> ; ah=4 -> Read RTC date
   110                              <1> ; ah=5 -> Set RTC date
   111                              <1> ; ah=6 -> Set RTC alarm
   112                              <1> ; ah=7 -> Reset RTC alarm
   113                              <1> ; ah=80h -> Get PIT divisor
   114                              <1> ; ah=81h -> Set PIT divisor
   115                              <1> ;----------------------------------------------------------------
   116                              <1> timerInt:
   117 00003246 80FC80              <1>     cmp ah, 80h
   118 00003249 737B                <1>     jae .tiext
   119 0000324B 84E4                <1>     test ah, ah
   120 0000324D 7444                <1>     jz .gett
   121 0000324F 80FC01              <1>     cmp ah, 1
   122 00003252 745E                <1>     jz .sett
   123 00003254 80FC02              <1>     cmp ah, 2
   124 00003257 0F8497000000        <1>     jz .readRTCtime
   125 0000325D 80FC03              <1>     cmp ah, 3
   126 00003260 0F84D8000000        <1>     jz .setRTCtime
   127 00003266 80FC04              <1>     cmp ah, 4
   128 00003269 0F8431010000        <1>     jz .readRTCdate
   129 0000326F 80FC05              <1>     cmp ah, 5
   130 00003272 0F845C010000        <1>     jz .setRTCdate
   131 00003278 80FC06              <1>     cmp ah, 6
   132 0000327B 0F84B4010000        <1>     jz .setRTCalarm
   133 00003281 80FC07              <1>     cmp ah, 7
   134 00003284 0F84F6010000        <1>     jz .resetRTCalarm
   135                              <1> .bad:
   136 0000328A 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   137 0000328F B480                <1>     mov ah, 80h
   138                              <1> .exit:
   139 00003291 48CF                <1>     iretq
   140                              <1> .gett:
   141                              <1> ;Returns:
   142                              <1> ; al=Rolled over flag (0=not rolled)
   143                              <1> ; cx=Hi count
   144                              <1> ; dx=Lo count
   145 00003293 8B0425[37010000]    <1>     mov eax, dword [pit_ticks]
   146 0000329A 6689C2              <1>     mov dx, ax    ;Lo count
   147 0000329D C1E810              <1>     shr eax, 10h    ;Bring high word down
   148 000032A0 30ED                <1>     xor ch, ch
   149 000032A2 88C1                <1>     mov cl, al
   150 000032A4 88E0                <1>     mov al, ah
   151 000032A6 0FB6C0              <1>     movzx eax, al    ;Zero upper bytes
   152 000032A9 882425[3A010000]    <1>     mov byte [pit_ticks + 3], ah    ;Move 0 into day OF counter
   153 000032B0 48CF                <1>     iretq
   154                              <1> .sett:
   155                              <1> ;Called with:
   156                              <1> ; cx=Hi count (bzw. cl)
   157                              <1> ; dx=Lo count
   158                              <1> ;Returns: Nothing
   159 000032B2 66891425[37010000]  <1>     mov word [pit_ticks], dx
   160 000032BA 30ED                <1>     xor ch, ch    ;Reset the OF counter
   161 000032BC 66890C25[39010000]  <1>     mov word [pit_ticks + 2], cx
   162 000032C4 48CF                <1>     iretq
   163                              <1> 
   164                              <1> .tiext:    ;Extended Timer functions
   165 000032C6 80EC80              <1>     sub ah, 80h
   166 000032C9 7406                <1>     jz .getpitdiv
   167 000032CB FECC                <1>     dec ah
   168 000032CD 740C                <1>     jz .setpitdiv
   169 000032CF EBB9                <1>     jmp short .bad
   170                              <1> .getpitdiv:
   171                              <1> ;Returns:
   172                              <1> ; ax=PIT divisor
   173 000032D1 668B0425[35010000]  <1>     mov ax, word [pit_divisor]
   174 000032D9 48CF                <1>     iretq
   175                              <1> .setpitdiv:
   176                              <1> ;Called with:
   177                              <1> ; dx=divsor
   178                              <1> ;Returns: Nothing
   179 000032DB 66891425[35010000]  <1>     mov word [pit_divisor], dx
   180 000032E3 50                  <1>     push rax
   181 000032E4 B036                <1>     mov al, 36h ;Bitmap for frequency write to channel 0 of PIT
   182 000032E6 E643                <1>     out PITcommand, al
   183 000032E8 6689D0              <1>     mov ax, dx
   184 000032EB E640                <1>     out PIT0, al    ;Send low byte of new divisor
   185 000032ED 88E0                <1>     mov al, ah
   186 000032EF E640                <1>     out PIT0, al    ;Send high byte of new divisor
   187 000032F1 58                  <1>     pop rax
   188 000032F2 48CF                <1>     iretq
   189                              <1> 
   190                              <1> .readRTCtime:
   191                              <1> ; dh = Seconds
   192                              <1> ; cl = Minutes
   193                              <1> ; ch = Hours
   194                              <1> ; dl = Daylight Savings   
   195 000032F4 50                  <1>     push rax
   196 000032F5 51                  <1>     push rcx
   197 000032F6 31C9                <1>     xor ecx, ecx    ;Long counter
   198                              <1> .rrt0:
   199 000032F8 FFC9                <1>     dec ecx
   200 000032FA 743C                <1>     jz .rrtbad
   201 000032FC B08A                <1>     mov al, 8Ah ;Disable NMI and and read bit 7. When 0, read
   202 000032FE E89A010000          <1>     call .readRTC
   203 00003303 A880                <1>     test al, 80h    ;Check bit 7 is zero
   204 00003305 75F1                <1>     jnz .rrt0   ;If zero, fall and read RTC registers
   205                              <1> 
   206 00003307 59                  <1>     pop rcx         ;Pop upper word of ecx back
   207 00003308 B080                <1>     mov al, 80h     ;Get seconds
   208 0000330A E88E010000          <1>     call .readRTC
   209 0000330F 88C6                <1>     mov dh, al      ;Pack seconds in dh
   210 00003311 B082                <1>     mov al, 82h     ;Get minutes
   211 00003313 E885010000          <1>     call .readRTC
   212 00003318 88C1                <1>     mov cl, al      ;Pack minutes in cl
   213 0000331A B084                <1>     mov al, 84h     ;Get Hours
   214 0000331C E87C010000          <1>     call .readRTC
   215 00003321 88C5                <1>     mov ch, al      ;Pack Hours in ch
   216 00003323 B08B                <1>     mov al, 8Bh     ;Get Status B for Daylight Savings
   217 00003325 E873010000          <1>     call .readRTC
   218 0000332A 2401                <1>     and al, 1       ;Isolate bit 0
   219 0000332C 88C2                <1>     mov dl, al      ;Pack Daylight Savings bit in dl
   220 0000332E B00D                <1>     mov al, 0Dh     ;Enable NMI
   221 00003330 E868010000          <1>     call .readRTC
   222 00003335 58                  <1>     pop rax
   223 00003336 48CF                <1>     iretq
   224                              <1> .rrtbad:
   225 00003338 59                  <1>     pop rcx
   226 00003339 58                  <1>     pop rax
   227 0000333A F9                  <1>     stc
   228 0000333B C20800              <1>     ret 8   ;Set carry and return
   229                              <1> 
   230                              <1> .setRTCtime:
   231                              <1> ; dh = Seconds
   232                              <1> ; cl = Minutes
   233                              <1> ; ch = Hours
   234                              <1> ; dl = Daylight Savings 
   235 0000333E 50                  <1>     push rax
   236 0000333F 51                  <1>     push rcx
   237 00003340 31C9                <1>     xor ecx, ecx
   238                              <1> .srt0:
   239 00003342 FFC9                <1>     dec ecx
   240 00003344 74F2                <1>     jz .rrtbad
   241 00003346 B08A                <1>     mov al, 8Ah ;Disable NMI and and read bit 7. When 0, write
   242 00003348 E850010000          <1>     call .readRTC
   243 0000334D A880                <1>     test al, 80h    ;Check bit 7 is zero
   244 0000334F 75F1                <1>     jnz .srt0   ;If zero, fall and write RTC registers
   245                              <1> 
   246 00003351 59                  <1>     pop rcx
   247 00003352 B08B                <1>     mov al, 8Bh
   248 00003354 E844010000          <1>     call .readRTC
   249 00003359 80E201              <1>     and dl, 1   ;Ensure we only have the low bit of dl
   250 0000335C 08D0                <1>     or al, dl   ;Set the daylight savings bit of Status B
   251 0000335E 0C80                <1>     or al, 80h  ;Stop RTC updates
   252 00003360 88C4                <1>     mov ah, al
   253 00003362 B08B                <1>     mov al, 8Bh ;Reset Status B Register, and daylight savings
   254 00003364 E83D010000          <1>     call .writeRTC
   255                              <1> 
   256 00003369 88F4                <1>     mov ah, dh  ;Pack seconds
   257 0000336B B080                <1>     mov al, 80h
   258 0000336D E834010000          <1>     call .writeRTC
   259 00003372 88CC                <1>     mov ah, cl  ;Pack minutes
   260 00003374 B082                <1>     mov al, 82h
   261 00003376 E82B010000          <1>     call .writeRTC
   262 0000337B 88EC                <1>     mov ah, ch  ;Pack hours
   263 0000337D B084                <1>     mov al, 84h
   264 0000337F E822010000          <1>     call .writeRTC
   265                              <1> 
   266 00003384 B08B                <1>     mov al, 8Bh
   267 00003386 E812010000          <1>     call .readRTC
   268 0000338B 247F                <1>     and al, 7Fh ;Clear the top bit
   269 0000338D 88C4                <1>     mov ah, al  ;Pack byte to send in ah
   270 0000338F B08B                <1>     mov al, 8Bh
   271 00003391 E810010000          <1>     call .writeRTC  ;Restart RTC
   272                              <1> 
   273 00003396 B00D                <1>     mov al, 0Dh   ;Enable NMI
   274 00003398 E800010000          <1>     call .readRTC
   275                              <1> 
   276 0000339D 58                  <1>     pop rax
   277 0000339E 48CF                <1>     iretq
   278                              <1>     
   279                              <1> .readRTCdate:
   280                              <1> ; ch = Reserved, Century (19/20/21...), fixed 20h for now
   281                              <1> ; cl = Year
   282                              <1> ; dh = Month
   283                              <1> ; dl = Day
   284 000033A0 50                  <1>     push rax
   285 000033A1 51                  <1>     push rcx
   286 000033A2 31C9                <1>     xor ecx, ecx
   287                              <1> .rrd0:
   288 000033A4 FFC9                <1>     dec ecx
   289 000033A6 7490                <1>     jz .rrtbad
   290 000033A8 B08A                <1>     mov al, 8Ah     ;Disable NMI and and read bit 7. When 0, write
   291 000033AA E8EE000000          <1>     call .readRTC
   292 000033AF A880                <1>     test al, 80h    ;Check bit 7 is zero
   293 000033B1 75F1                <1>     jnz .rrd0       ;If zero, fall and read RTC registers
   294                              <1> 
   295 000033B3 59                  <1>     pop rcx
   296 000033B4 B087                <1>     mov al, 87h     ;Get Day of the Month
   297 000033B6 E8E2000000          <1>     call .readRTC
   298 000033BB 88C2                <1>     mov dl, al      ;Pack Day of the Month
   299 000033BD B088                <1>     mov al, 88h     ;Get Month of the Year
   300 000033BF E8D9000000          <1>     call .readRTC
   301 000033C4 88C6                <1>     mov dh, al      ;Pack Month of the Year
   302 000033C6 B089                <1>     mov al, 89h     ;Get bottom two digits of year
   303 000033C8 E8D0000000          <1>     call .readRTC
   304 000033CD 88C1                <1>     mov cl, al      ;Pack Year
   305 000033CF B514                <1>     mov ch, 20      ;BCD value for 20
   306                              <1> 
   307 000033D1 58                  <1>     pop rax
   308 000033D2 48CF                <1>     iretq
   309                              <1> 
   310                              <1> .setRTCdate:
   311                              <1> ; ch = Reserved, Century (19/20/21...), fixed 20h for now
   312                              <1> ; cl = Year
   313                              <1> ; dh = Month
   314                              <1> ; dl = Day
   315 000033D4 50                  <1>     push rax
   316 000033D5 51                  <1>     push rcx
   317 000033D6 31C9                <1>     xor ecx, ecx
   318                              <1> .srd0:
   319 000033D8 FFC9                <1>     dec ecx
   320 000033DA 0F8458FFFFFF        <1>     jz .rrtbad
   321 000033E0 B08A                <1>     mov al, 8Ah     ;Disable NMI and and read bit 7. When 0, write
   322 000033E2 E8B6000000          <1>     call .readRTC
   323 000033E7 A880                <1>     test al, 80h    ;Check bit 7 is zero
   324 000033E9 75ED                <1>     jnz .srd0       ;If zero, fall and write RTC registers
   325                              <1> 
   326 000033EB 59                  <1>     pop rcx
   327 000033EC B08B                <1>     mov al, 8Bh
   328 000033EE E8AA000000          <1>     call .readRTC
   329 000033F3 0C80                <1>     or al, 80h      ;Stop RTC updates
   330 000033F5 88C4                <1>     mov ah, al
   331 000033F7 B08B                <1>     mov al, 8Bh
   332 000033F9 E8A8000000          <1>     call .writeRTC
   333 000033FE 88D4                <1>     mov ah, dl      ;Pack Day of the Month
   334 00003400 B087                <1>     mov al, 87h
   335 00003402 E89F000000          <1>     call .writeRTC
   336 00003407 88F4                <1>     mov ah, dh      ;Pack Month of the Year
   337 00003409 B088                <1>     mov al, 88h
   338 0000340B E896000000          <1>     call .writeRTC
   339 00003410 88CC                <1>     mov ah, cl      ;Pack Year
   340 00003412 B089                <1>     mov al, 89h
   341 00003414 E88D000000          <1>     call .writeRTC
   342                              <1> 
   343 00003419 B08B                <1>     mov al, 8Bh
   344 0000341B E87D000000          <1>     call .readRTC
   345 00003420 247F                <1>     and al, 7Fh ;Clear the top bit
   346 00003422 88C4                <1>     mov ah, al  ;Pack byte to send in ah
   347 00003424 B08B                <1>     mov al, 8Bh
   348 00003426 E87B000000          <1>     call .writeRTC  ;Restart RTC
   349                              <1> 
   350 0000342B B00D                <1>     mov al, 0Dh   ;Enable NMI
   351 0000342D E86B000000          <1>     call .readRTC
   352                              <1> 
   353 00003432 58                  <1>     pop rax
   354 00003433 48CF                <1>     iretq
   355                              <1> 
   356                              <1> .setRTCalarm:
   357                              <1> ; dh = Seconds for alarm
   358                              <1> ; cl = Minutes for alarm
   359                              <1> ; ch = Hours for alarm
   360 00003435 50                  <1>     push rax
   361 00003436 B08B                <1>     mov al, 8BH ;Get status B
   362 00003438 E860000000          <1>     call .readRTC
   363 0000343D A820                <1>     test al, 20h
   364 0000343F 7537                <1>     jnz .srabad ;If The alarm bit is already set, exit CF=CY
   365                              <1> 
   366 00003441 88F4                <1>     mov ah, dh      ;Pack Seconds for alarm
   367 00003443 B081                <1>     mov al, 81h     
   368 00003445 E85C000000          <1>     call .writeRTC
   369 0000344A 88CC                <1>     mov ah, cl      ;Pack Minutes for alarm
   370 0000344C B083                <1>     mov al, 83h
   371 0000344E E853000000          <1>     call .writeRTC
   372 00003453 88EC                <1>     mov ah, ch      ;Pack Hours for alarm
   373 00003455 B085                <1>     mov al, 85h
   374 00003457 E84A000000          <1>     call .writeRTC
   375                              <1> 
   376 0000345C B08B                <1>     mov al, 8Bh     ;Get Status B
   377 0000345E E83A000000          <1>     call .readRTC
   378 00003463 0C20                <1>     or al, 20h      ;Set Bit 5 - Alarm Interrupt Enable
   379 00003465 88C4                <1>     mov ah, al      ;Pack new Status B
   380 00003467 B08B                <1>     mov al, 8Bh
   381 00003469 E838000000          <1>     call .writeRTC 
   382                              <1> 
   383 0000346E B00D                <1>     mov al, 0Dh     ;Enable NMI
   384 00003470 E828000000          <1>     call .readRTC
   385                              <1> 
   386 00003475 58                  <1>     pop rax
   387 00003476 48CF                <1>     iretq
   388                              <1> .srabad:
   389 00003478 58                  <1>     pop rax
   390 00003479 804C241001          <1>     or byte [rsp + 2*8], 1 ;Set Carry Flag
   391 0000347E 48CF                <1>     iretq  
   392                              <1> .resetRTCalarm:
   393 00003480 50                  <1>     push rax
   394 00003481 B08B                <1>     mov al, 8Bh     ;Get Status B
   395 00003483 E815000000          <1>     call .readRTC
   396 00003488 24DF                <1>     and al, 0DFh    ;Clear Alarm Interrupt Enable
   397 0000348A 88C4                <1>     mov ah, al
   398 0000348C B08B                <1>     mov al, 8Bh
   399 0000348E E813000000          <1>     call .writeRTC
   400                              <1> 
   401 00003493 B00D                <1>     mov al, 0Dh     ;Enable NMI
   402 00003495 E803000000          <1>     call .readRTC 
   403 0000349A 58                  <1>     pop rax
   404 0000349B 48CF                <1>     iretq
   405                              <1> 
   406                              <1> .readRTC:
   407                              <1> ;Reads an RTC port, interrupts disabled throughout
   408                              <1> ;Input: al = I/O port to read
   409                              <1> ;Output: al = I/O data
   410 0000349D FA                  <1>     cli
   411 0000349E E670                <1>     out cmos_base, al
   412 000034A0 E680                <1>     out waitp, al
   413 000034A2 E471                <1>     in al, cmos_data
   414 000034A4 FB                  <1>     sti
   415 000034A5 C3                  <1>     ret
   416                              <1> .writeRTC:
   417                              <1> ;Writes to an RTC port, interrupts disabled throughout 
   418                              <1> ;Input: al = I/O port to read, ah = Data byte to send
   419 000034A6 FA                  <1>     cli
   420 000034A7 E670                <1>     out cmos_base, al
   421 000034A9 E680                <1>     out waitp, al
   422 000034AB 88E0                <1>     mov al, ah
   423 000034AD E671                <1>     out cmos_data, al
   424 000034AF FB                  <1>     sti
   425 000034B0 C3                  <1>     ret
   426                              <1> ;------------------------End of Interrupt------------------------
   103                                  %include "./Source/Resident/Services/Int3Bh.asm"
   104                              <1> ;-----------------CTRL+BREAK Interrupt Int 3Bh-------------------
   105                              <1> ;CTRL+Break will call this!
   106                              <1> ;----------------------------------------------------------------
   107                              <1> ctrlbreak_io:
   108 000034B1 48CF                <1>     iretq
   109                              <1> ;------------------------End of Interrupt-------------------------
   104                                  %include "./Source/Resident/Services/Int3Dh.asm"
   105                              <1> ;------------Screen Mode Parameters Interrupt Int 3Dh-------------
   106                              <1> ;This Interrupt returns in r8 the pointer to screen mode 
   107                              <1> ; parameters. It replaces the nice pointers in the IVT of yore.
   108                              <1> ;Returns in r8 to not conflict with ported apps
   109                              <1> ;----------------------------------------------------------------
   110                              <1> scr_params_io:
   111 000034B3 49B8-               <1>     mov r8, scr_mode_params
   111 000034B5 [6001000000000000]  <1>
   112 000034BD 48CF                <1>     iretq
   113                              <1> ;------------------------End of Interrupt------------------------
   105                                  %include "./Source/Resident/Services/Int3Eh.asm"
   106                              <1> ;-----------------Disk Params Interrupt Int 3Eh------------------
   107                              <1> disk_params_io:
   108 000034BF 4C8B0425[AF010000]  <1>     mov r8, qword [diskDptPtr]    
   109 000034C7 4C8B0C25[B7010000]  <1>     mov r9, qword [fdiskDptPtr]
   110 000034CF 48CF                <1>     iretq
   111                              <1> ;------------------------End of Interrupt------------------------
   106                                  %include "./Source/Resident/Services/Int3Fh.asm"
   107                              <1> ;------------------CGA font Interrupt Int 3Fh--------------------
   108                              <1> ;This Interrupt returns in r8 the pointer to the CGA font.
   109                              <1> ;It replaces the nice pointers in the IVT of yore.
   110                              <1> ;Returns in r8 to not conflict with ported apps
   111                              <1> ;----------------------------------------------------------------
   112                              <1> cga_ret_io: ;Get first pointer in list
   113 000034D1 4C0FB70425-         <1>     movzx r8, word [scr_vga_ptrs]
   113 000034D6 [68010000]          <1>
   114 000034DA 49C1E004            <1>     shl r8, 4
   115 000034DE 6644030425-         <1>     add r8w, word [scr_vga_ptrs + 2]
   115 000034E3 [6A010000]          <1>
   116 000034E7 48CF                <1>     iretq
   117                              <1> ;------------------------End of Interrupt------------------------
   107                                  ;========================RESIDENT DRIVERS=====================
   108                                  %include "./Source/Resident/Hardware/ATA/ataDrv.asm"
   109                              <1> ;ATA driver!
   110                              <1> ATA:
   111                              <1> .identifyDevice:
   112                              <1> ;Drive to be identified should be selected already
   113                              <1> ;dx should contain the base register
   114                              <1> ;rdi points to the buffer
   115                              <1> ;Carry set if failed.
   116                              <1> 
   117 000034E9 50                  <1>     push rax
   118 000034EA 53                  <1>     push rbx
   119                              <1> 
   120 000034EB 30C0                <1>     xor al, al
   121 000034ED 81C202000000        <1>     add edx, 2            ;dx at base + 2
   122 000034F3 EE                  <1>     out dx, al
   123 000034F4 FFC2                <1>     inc edx               ;dx at base + 3
   124 000034F6 EE                  <1>     out dx, al
   125 000034F7 FFC2                <1>     inc edx               ;dx at base + 4
   126 000034F9 EE                  <1>     out dx, al
   127 000034FA FFC2                <1>     inc edx               ;dx at base + 5
   128 000034FC EE                  <1>     out dx, al
   129 000034FD 81C202000000        <1>     add edx, 2           ;dx at base + 7
   130 00003503 B0EC                <1>     mov al, 0ECh         ;ECh = Identify drive command
   131 00003505 EE                  <1>     out dx, al
   132                              <1> 
   133 00003506 EB00                <1>     jmp short $ + 2      ;IO cycle kill
   134 00003508 B30A                <1>     mov bl, 10           ;10 retries ok
   135                              <1> .l2:
   136 0000350A EC                  <1>     in al, dx            ;get status byte
   137 0000350B A808                <1>     test al, 00001000b   ;Check DRQ, to be set for data ready
   138 0000350D 7511                <1>     jnz .l3 ;If set we good to go
   139                              <1>     ;Else timeout, wait for 1 ms before reading again
   140 0000350F FECB                <1>     dec bl
   141 00003511 741E                <1>     jz .exitfail
   142 00003513 51                  <1>     push rcx
   143 00003514 B901000000          <1>     mov ecx, 1
   144 00003519 B486                <1>     mov ah, 86h
   145 0000351B CD35                <1>     int 35h
   146 0000351D 59                  <1>     pop rcx
   147 0000351E EBEA                <1>     jmp short .l2
   148                              <1> .l3:
   149 00003520 81EA07000000        <1>     sub edx, 7            ;dx at base + 0
   150 00003526 B900010000          <1>     mov ecx, 100h         ;100h words to be copied
   151 0000352B F3666D              <1>     rep insw
   152 0000352E F8                  <1>     clc
   153 0000352F EB01                <1>     jmp short .exit
   154                              <1> 
   155                              <1> .exitfail:
   156 00003531 F9                  <1>     stc
   157                              <1> .exit:
   158 00003532 5B                  <1>     pop rbx
   159 00003533 58                  <1>     pop rax
   160 00003534 C3                  <1>     ret
   161                              <1> .selectDriveFromTable:
   162                              <1> ;Selects the drive pointed to by the table entry in rbp
   163                              <1> ;Input: rbp = Pointer to drive table entry
   164                              <1> ;Output: CF=NC -> All ok, can proceed with writing data
   165                              <1> ;        CF=CY -> drive not set
   166 00003535 52                  <1>     push rdx
   167 00003536 50                  <1>     push rax
   168 00003537 8A4515              <1>     mov al, byte [rbp + fdiskEntry.msBit]
   169 0000353A 668B5513            <1>     mov dx, word [rbp + fdiskEntry.ioBase]
   170 0000353E E803000000          <1>     call .selectDrive
   171 00003543 58                  <1>     pop rax
   172 00003544 5A                  <1>     pop rdx
   173 00003545 C3                  <1>     ret
   174                              <1> .selectDrive:
   175                              <1> ;Selects either master or slave drive
   176                              <1> ;Sets/clears bit 7 of ataXCmdByte 
   177                              <1> ;Bit 7 ataX Clear => Master
   178                              <1> ;Input: dx = ataXbase, 
   179                              <1> ;       ah = al = A0h/B0h (or E0h/F0h for LBA) for master/slave
   180                              <1> ;
   181                              <1> ;Return: If CF=NC, al = the status of the selected drive after selection
   182                              <1> ;        If CF=CY drive not set
   183                              <1> ;ah is preserved
   184                              <1> ;First check if this is the presently active device
   185 00003546 53                  <1>     push rbx
   186 00003547 51                  <1>     push rcx
   187                              <1>     ;First find if ata0CmdByte or ata1CmdByte
   188 00003548 8D0C25[AB010000]    <1>     lea ecx, ata0CmdByte
   189 0000354F 8D1C25[AD010000]    <1>     lea ebx, ata1CmdByte
   190 00003556 81FAF0010000        <1>     cmp edx, ata0_base
   191 0000355C 0F45CB              <1>     cmovne ecx, ebx    ;Move ata1CmdByte to ecx
   192                              <1>     ;Now isolate master/slave bit
   193 0000355F 88C3                <1>     mov bl, al  ;Save master/slave byte in bl
   194 00003561 C0EB04              <1>     shr bl, 4   ;Bring nybble low
   195 00003564 80E301              <1>     and bl, 1   ;Save only bottom bit, if set it is slave
   196 00003567 8A39                <1>     mov bh, byte [rcx]  ;Now get ataXCmdByte
   197 00003569 80E701              <1>     and bh, 1   ;Only care for the bottom bit
   198                              <1>     ;bh has in memory bit, bl has device bit
   199 0000356C 38DF                <1>     cmp bh, bl
   200 0000356E 743A                <1>     je .skipSelection   ;If bh and bl are equal, the drive we want is selected
   201                              <1>     ;Now set master/slave on host
   202 00003570 B70B                <1>     mov bh, 11     ;Up to 10 tries to set a device
   203                              <1> .sd0:      
   204 00003572 FECF                <1>     dec bh
   205 00003574 7437                <1>     jz .driveNotSelected
   206 00003576 88E0                <1>     mov al, ah     ;Return A0h/B0h to al from ah
   207 00003578 88C3                <1>     mov bl, al     ;Save shifted-up drive select bit in bl
   208 0000357A 81C206000000        <1>     add edx, 6     ;dx at base + 6, drive select register
   209 00003580 EE                  <1>     out dx, al     ;Select here
   210 00003581 81EA06000000        <1>     sub edx, 6     ;dx back at base + 0
   211                              <1>     ;Now wait 400ns for value to settle
   212 00003587 E824000000          <1>     call .driveSelectWait
   213 0000358C 81C207000000        <1>     add edx, 7     ;Go to Status Register
   214 00003592 EC                  <1>     in al, dx      ;Get status
   215 00003593 81EA07000000        <1>     sub edx, 7     ;Go back to ataXbase
   216 00003599 A888                <1>     test al, 88h   ;Test if either BSY and DRQ bits set.
   217 0000359B 75D5                <1>     jnz .sd0       ;If either is set, drive setting failed, try set again!
   218                              <1>     ;Here set the bit in ataXCmdByte to confirm drive as selected
   219                              <1>     ;ecx still has the value of the ataXCmdbyte
   220 0000359D 8021FE              <1>     and byte [rcx], 0FEh    ;Clear the bottom bit
   221 000035A0 88E3                <1>     mov bl, ah              ;Bring A0h/B0h to bl
   222 000035A2 C0EB04              <1>     shr bl, 4               ;Shift it down to bl[0]
   223 000035A5 80E301              <1>     and bl, 1   ;Save only bottom bit, if set it is slave
   224 000035A8 0819                <1>     or byte [rcx], bl       ;Set the bit if bl[0] is set
   225                              <1> .skipSelection:
   226 000035AA 59                  <1>     pop rcx
   227 000035AB 5B                  <1>     pop rbx
   228 000035AC C3                  <1>     ret
   229                              <1> .driveNotSelected:
   230 000035AD F9                  <1>     stc
   231 000035AE EBFA                <1>     jmp short .skipSelection
   232                              <1> 
   233                              <1> .driveSelectWait:
   234                              <1> ; Called with dx = ataXbase
   235                              <1> ; Reads the alternate status register 14 times
   236                              <1> ; Returns the alternate status after a 15th read
   237 000035B0 51                  <1>     push rcx
   238 000035B1 81C206020000        <1>     add edx, 206h   ;Move to alt base
   239 000035B7 B90E000000          <1>     mov ecx, 14     ;14 iterations for 420ns wait
   240                              <1> .dsw0:
   241 000035BC EC                  <1>     in al, dx
   242 000035BD E2FD                <1>     loop .dsw0
   243 000035BF 81EAFF010000        <1>     sub edx, 1FFh   ;Return to ataXbase + 7
   244 000035C5 EC                  <1>     in al, dx       ;Get status and clear pending Interrupt
   245 000035C6 81EA07000000        <1>     sub edx, 7      ;Return to ataXbase
   246 000035CC 59                  <1>     pop rcx
   247 000035CD C3                  <1>     ret
   248                              <1> 
   249                              <1> .wait400ns:
   250                              <1> ;Called with dx pointing to a port to read 14 times
   251 000035CE 51                  <1>     push rcx
   252 000035CF B90E000000          <1>     mov ecx, 14     ;14 iterations for 420ns wait
   253                              <1> .wns:
   254 000035D4 EC                  <1>     in al, dx
   255 000035D5 E2FD                <1>     loop .wns
   256 000035D7 59                  <1>     pop rcx
   257 000035D8 C3                  <1>     ret
   258                              <1> 
   259                              <1> .getTablePointer:
   260                              <1> ;Given a drive number in dl, put the table pointer in rbp
   261                              <1> ;If entry not valid OR greater than 4, fail with CF=CY
   262 000035D9 52                  <1>     push rdx
   263 000035DA 80E27F              <1>     and dl, 7Fh ;Clear top bit
   264 000035DD 80FA03              <1>     cmp dl, 3   ;Only 4 fixed disks allowed!
   265 000035E0 7720                <1>     ja .gtpBad
   266 000035E2 488D2C25[7B030000]  <1>     lea rbp, fdiskTable ;Point to the fdisktable
   267                              <1> .gtpSearch:
   268 000035EA 84D2                <1>     test dl, dl
   269 000035EC 740B                <1>     jz .gtpVerifyOk
   270 000035EE FECA                <1>     dec dl
   271 000035F0 4881C516000000      <1>     add rbp, fdiskEntry_size    ;Goto next entry
   272 000035F7 EBF1                <1>     jmp short .gtpSearch
   273                              <1> .gtpVerifyOk:
   274 000035F9 807D0001            <1>     cmp byte [rbp + fdiskEntry.signature], 1    ;Configured bit must be set
   275 000035FD 7403                <1>     jz .gtpBad 
   276 000035FF 5A                  <1>     pop rdx
   277 00003600 F8                  <1>     clc
   278 00003601 C3                  <1>     ret
   279                              <1> .gtpBad:
   280 00003602 F9                  <1>     stc 
   281 00003603 5A                  <1>     pop rdx
   282 00003604 C3                  <1>     ret
   283                              <1> ;==============================:
   284                              <1> ;    ATA primitive functions
   285                              <1> ;==============================:
   286                              <1> .resetChannel:
   287                              <1>     ;Resets a selected ATA channel
   288                              <1>     ;Input: rbp = Fixed Disk Table entry pointer for chosen device
   289                              <1>     ;Output: CF=CY -> Channel did not reset.
   290                              <1>     ;        CF=NC -> Channel reset
   291                              <1>     ;If the channel doesnt reset, the caller will establish an error code
   292                              <1>     ;
   293 00003605 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   294 00003609 81C206020000        <1>     add edx, 206h   ;Go to alternate base
   295 0000360F B004                <1>     mov al, 4h      ;Set the SoftwareReSeT (SRST) bit
   296 00003611 EE                  <1>     out dx, al      ;Set the bit
   297 00003612 B90A000000          <1>     mov ecx, 10     ;Wait 10 milliseconds
   298 00003617 B486                <1>     mov ah, 86h
   299 00003619 CD35                <1>     int 35h
   300 0000361B 30C0                <1>     xor al, al
   301 0000361D EE                  <1>     out dx, al      ;Clear the SRST bit
   302 0000361E B90A000000          <1>     mov ecx, 10     ;Wait 10 milliseconds
   303 00003623 B486                <1>     mov ah, 86h
   304 00003625 CD35                <1>     int 35h
   305 00003627 EC                  <1>     in al, dx       ;Get one more read
   306 00003628 81EA06020000        <1>     sub edx, 206h   ;Return to base
   307 0000362E 24C0                <1> 	and al, 0xc0    ;Get only BSY and DRDY
   308 00003630 3C40                <1> 	cmp al, 0x40	;Check that BSY is clear and that DRDY is set
   309 00003632 751F                <1>     jne .rcBad
   310                              <1>     ;Here clear the master/slave bit in ataXCmdByte
   311 00003634 488D1C25[AB010000]  <1>     lea rbx, ata0CmdByte
   312 0000363C 488D0C25[AD010000]  <1>     lea rcx, ata1CmdByte
   313 00003644 66817D13F001        <1>     cmp word [rbp + fdiskEntry.ioBase], ata0_base
   314 0000364A 480F45D9            <1>     cmovne rbx, rcx
   315 0000364E 8023FE              <1>     and byte [rbx], 0FEh    ;Clear low bit
   316                              <1> 
   317 00003651 F8                  <1>     clc             ;Clear carry
   318 00003652 C3                  <1>     ret
   319                              <1> .rcBad:
   320 00003653 F9                  <1>     stc             ;Set carry
   321 00003654 C3                  <1>     ret
   322                              <1> ;Common functions:
   323                              <1> ;Jumped to with: 
   324                              <1> ; al = Primary function number
   325                              <1> ; cl = Sector count
   326                              <1> ; dx = Command register for drive
   327                              <1> .read:
   328 00003655 EE                  <1>     out dx, al  ;Output the command byte!
   329 00003656 88C8                <1>     mov al, cl  ;Return sector count into al
   330                              <1> 
   331                              <1>     ;Now we wait for the DRQ bit in the status register to set
   332 00003658 4889DF              <1>     mov rdi, rbx    ;Move the read buffer pointer to rdi
   333 0000365B 88C3                <1>     mov bl, al      ;Save sector count in bl
   334                              <1> .rWait:
   335 0000365D B9FFFFFFFF          <1>     mov ecx, -1  ;Data should be ready within ~67 miliseconds
   336 00003662 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   337 00003666 81C207000000        <1>     add edx, 7  ;Dummy read on status register
   338                              <1> .rWaitLoop:
   339 0000366C FFC9                <1>     dec ecx
   340 0000366E 7440                <1>     jz .rTimeout
   341 00003670 EC                  <1>     in al, dx
   342 00003671 A880                <1>     test al, 80h     ;Is BSY set?
   343 00003673 75F7                <1>     jnz .rWaitLoop   ;If so, keep looping
   344 00003675 A821                <1>     test al, 21h     ;Are error bits set?  
   345 00003677 753F                <1>     jnz .errorExit   ;If not, must be ok to go
   346 00003679 A808                <1>     test al, 8h      ;Check DRQ, data ready bit is set
   347 0000367B 74EF                <1>     jz .rWaitLoop
   348                              <1> ;Now we can read the data
   349 0000367D 81EA07000000        <1>     sub edx, 7   ;Point to base=data register
   350 00003683 B900010000          <1>     mov ecx, 256    ;Number of words in a sector
   351                              <1> .r0:
   352 00003688 666D                <1>     insw    ;Read that many words!
   353 0000368A EB00                <1>     jmp short $ + 2
   354 0000368C E2FA                <1>     loop .r0    ;Read the sector, one word at a time
   355 0000368E FECB                <1>     dec bl      ;Reduce the number of sectors read by 1
   356 00003690 75CB                <1>     jnz .rWait
   357                              <1>     ;Here check status register to ensure error isnt set
   358 00003692 81C207000000        <1>     add edx, 7
   359 00003698 B9FFFFFFFF          <1>     mov ecx, -1
   360                              <1> .readExitloop:
   361 0000369D FFC9                <1>     dec ecx
   362 0000369F 7417                <1>     jz .errorExit
   363 000036A1 EC                  <1>     in al, dx
   364 000036A2 A880                <1>     test al, 80h        ;Check if BSY bit still set (i.e not ready yet)
   365 000036A4 75F7                <1>     jnz .readExitloop   ;If BSY still set keep looping
   366 000036A6 A861                <1>     test al, 61h        ;Check if DSDY bit or Error bits are set
   367 000036A8 74F3                <1>     jz .readExitloop    ;If DSDY not set, wait
   368 000036AA A821                <1>     test al, 21h    ;Check status bits 0 and 5 (error and drive fault)
   369 000036AC 750A                <1>     jnz .errorExit
   370                              <1> .rExit:
   371 000036AE F8                  <1>     clc
   372 000036AF C3                  <1>     ret
   373                              <1> .rTimeout:
   374 000036B0 C60425[A9010000]80  <1>     mov byte [msdStatus], 80h   ;Timeout occured
   375                              <1> .errorExit:
   376 000036B8 F9                  <1>     stc
   377 000036B9 C3                  <1>     ret
   378                              <1> 
   379                              <1> .write:
   380 000036BA EE                  <1>     out dx, al  ;Output the command byte!
   381 000036BB 88C8                <1>     mov al, cl  ;Return sector count into al
   382                              <1> 
   383                              <1>     ;Now we wait for the DRQ bit in the status register to set
   384 000036BD 4889DE              <1>     mov rsi, rbx    ;Move the write buffer pointer to rsi
   385 000036C0 88C3                <1>     mov bl, al      ;Save sector count in bl
   386                              <1> .writeWait:
   387 000036C2 B9FFFFFFFF          <1>     mov ecx, -1  ;Data should be ready within ~67 miliseconds
   388 000036C7 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   389 000036CB 81C207000000        <1>     add edx, 7  ;Dummy read on Alt status register
   390                              <1> .writeWaitLoop:
   391 000036D1 FFC9                <1>     dec ecx
   392 000036D3 74DB                <1>     jz .rTimeout
   393 000036D5 EC                  <1>     in al, dx
   394 000036D6 A880                <1>     test al, 80h     ;Is BSY set?
   395 000036D8 75F7                <1>     jnz .writeWaitLoop   ;If so, keep looping
   396 000036DA A821                <1>     test al, 21h     ;Are error bits set?  
   397 000036DC 75DA                <1>     jnz .errorExit   ;If not, must be ok to go
   398 000036DE A808                <1>     test al, 8h      ;Check DRQ, data ready bit is set
   399 000036E0 74EF                <1>     jz .writeWaitLoop
   400                              <1> ;Now we can write the data
   401 000036E2 81EA07000000        <1>     sub edx, 7   ;Point to base=data register
   402 000036E8 B900010000          <1>     mov ecx, 256    ;Number of words in a sector
   403                              <1> .w1:
   404 000036ED 666F                <1>     outsw    ;Write that many words!
   405 000036EF EB00                <1>     jmp short $ + 2
   406 000036F1 E2FA                <1>     loop .w1 ;Write one sector, one word at a time
   407 000036F3 FECB                <1>     dec bl
   408 000036F5 75CB                <1>     jnz .writeWait  ;Keep going up by a sector
   409                              <1>     ;Here wait for device to stop being busy. 
   410                              <1>     ;If it doesnt after ~4 seconds, declare an error
   411                              <1> .formatEP:  ;Where the format routine enters the write routine
   412 000036F7 B9FFFFFFFF          <1>     mov ecx, -1 ;About 4 seconds
   413 000036FC 81C207000000        <1>     add edx, 7  ;Goto status register
   414                              <1> .wBSYcheck:
   415 00003702 FFC9                <1>     dec ecx
   416 00003704 74B2                <1>     jz .errorExit   ;If after 4 seconds the device is still BSY, consider it failing
   417 00003706 EC                  <1>     in al, dx   ;Read status reg
   418 00003707 A880                <1>     test al, 80h    ;Check BSY
   419 00003709 75F7                <1>     jnz .wBSYcheck   ;If it is no longer BSY, check error status
   420 0000370B A861                <1>     test al, 61h        ;Check if DSDY bit or Error bits are set
   421 0000370D 74F3                <1>     jz .wBSYcheck    ;If not set, do not send next command
   422                              <1> ;NOW FLUSH THE DISK BUFFERS TO DISK
   423                              <1>     ;Here check status register to ensure error isnt set
   424 0000370F A821                <1>     test al, 21h    ;Test bits 0 and 5 (error and drive fault)
   425 00003711 75A5                <1>     jnz .errorExit
   426                              <1>     ;Now we must flush cache on the device
   427 00003713 B0E7                <1>     mov al, 0E7h    ;FLUSH CACHE COMMAND
   428 00003715 EE                  <1>     out dx, al
   429                              <1>     ;This command can take 30 seconds to complete so we check status 
   430                              <1>     ; every ms to see if BSY is clear yet.
   431 00003716 BB30750000          <1>     mov ebx, 30000   ;30,000 miliseconds in 30 seconds
   432                              <1> .wFlushCheck:
   433 0000371B FFCB                <1>     dec ebx
   434 0000371D 7499                <1>     jz .errorExit
   435 0000371F B901000000          <1>     mov ecx, 1
   436 00003724 B486                <1>     mov ah, 86h
   437 00003726 CD35                <1>     int 35h
   438 00003728 EC                  <1>     in al, dx   ;Read the status byte
   439 00003729 A880                <1>     test al, 80h    ;Are we still busy?
   440 0000372B 75EE                <1>     jnz .wFlushCheck ;IF yes, loop again
   441 0000372D A861                <1>     test al, 61h    ;Check if DSDY bit or Error bits are set
   442 0000372F 74EA                <1>     jz .wFlushCheck  ;Whilst it is not set, keep looping
   443 00003731 A821                <1>     test al, 21h    ;Test bits 0 and 5 (error and drive fault)
   444 00003733 7583                <1>     jnz .errorExit   ;If either are set, return fail
   445 00003735 F8                  <1>     clc
   446 00003736 C3                  <1>     ret
   447                              <1> 
   448                              <1> .verify:
   449 00003737 EE                  <1>     out dx, al  ;Output the command byte!
   450                              <1>     ;Now we wait for BSY to go low and DRDY to go high
   451 00003738 66B9FFFF            <1>     mov cx, -1  ;Data should be ready within ~67 miliseconds
   452 0000373C 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   453 00003740 81C207000000        <1>     add edx, 7  ;Goto status register
   454                              <1> .vLoop:
   455 00003746 66FFC9              <1>     dec cx
   456 00003749 0F8469FFFFFF        <1>     jz .errorExit
   457 0000374F EC                  <1>     in al, dx   ;Get status
   458 00003750 A880                <1>     test al, 80h    ;BSY bit set
   459 00003752 75F2                <1>     jnz .vLoop
   460                              <1>     ;Once it clears come here
   461 00003754 A861                <1>     test al, 61h    ;Check if DSDY bit or Error bits are set
   462 00003756 74EE                <1>     jz .vLoop    ;Whilst it is not set, keep looping
   463 00003758 A821                <1>     test al, 21h    ;Test bits 0 and 5 (error and drive fault)
   464 0000375A 0F8558FFFFFF        <1>     jnz .errorExit   ;If either are set, return fail
   465 00003760 F8                  <1>     clc
   466 00003761 C3                  <1>     ret
   467                              <1> 
   468                              <1> .format:
   469                              <1>     ;A write which writes a byte to disk (0E5h for classical reasons)
   470 00003762 EE                  <1>     out dx, al  ;Output the command byte!
   471 00003763 88C8                <1>     mov al, cl  ;Return sector count into al
   472                              <1> 
   473                              <1>     ;Now we wait for the DRQ bit in the status register to set
   474 00003765 88C3                <1>     mov bl, al     ;Save sector count in bl to use as counter
   475                              <1> .formatWait:
   476 00003767 B9FFFFFFFF          <1>     mov ecx, -1  ;Data should be ready within ~67 miliseconds
   477 0000376C 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   478 00003770 81C207000000        <1>     add edx, 7  ;Dummy read on Alt status register
   479                              <1> .formatWaitLoop:
   480 00003776 FFC9                <1>     dec ecx
   481 00003778 0F8432FFFFFF        <1>     jz .rTimeout
   482 0000377E EC                  <1>     in al, dx
   483 0000377F A880                <1>     test al, 80h     ;Is BSY set?
   484 00003781 75F3                <1>     jnz .formatWaitLoop   ;If so, keep looping
   485 00003783 A821                <1>     test al, 21h     ;Are error bits set?  
   486 00003785 0F852DFFFFFF        <1>     jnz .errorExit   ;If not, must be ok to go
   487 0000378B A808                <1>     test al, 8h      ;Check DRQ, data ready bit is set
   488 0000378D 74E7                <1>     jz .formatWaitLoop
   489                              <1> ;Now we can write the format data
   490 0000378F 81EA07000000        <1>     sub edx, 7
   491 00003795 B900010000          <1>     mov ecx, 256    ;Number of words in a sector
   492 0000379A B8E5E50000          <1>     mov eax, 0E5E5h ;Format Signature Word
   493                              <1> .f1:
   494 0000379F 66EF                <1>     out dx, ax  ;Write E5h to the disk!!
   495 000037A1 EB00                <1>     jmp short $ + 2
   496 000037A3 E2FA                <1>     loop .f1 ;Write one sector, one word at a time
   497 000037A5 FECB                <1>     dec bl
   498 000037A7 75BE                <1>     jnz .formatWait  ;Keep going up by a sector
   499 000037A9 E949FFFFFF          <1>     jmp .formatEP   ;Goto the format entry point
   500                              <1> 
   501                              <1> ;CHS functions
   502                              <1> .readCHS:
   503                              <1> ;Called with rdi as a free register to use
   504                              <1> ;All other registers have parameters as in Int 33h function ah=02h
   505 000037AE E87B000000          <1>     call .setupCHS
   506 000037B3 0F82FFFEFFFF        <1>     jc .errorExit
   507                              <1>     ;Send command
   508 000037B9 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   509 000037BD 81C207000000        <1>     add edx, 7  ;Goto command register
   510 000037C3 88C1                <1>     mov cl, al  ;Save sector count in cl
   511 000037C5 B020                <1>     mov al, 20h ;ATA READ COMMAND!
   512 000037C7 E989FEFFFF          <1>     jmp .read
   513                              <1> 
   514                              <1> .writeCHS:
   515                              <1> ;Called with rsi as a free register to use
   516                              <1> ;All other registers have parameters as in Int 33h function ah=02h
   517 000037CC E85D000000          <1>     call .setupCHS
   518 000037D1 0F82E1FEFFFF        <1>     jc .errorExit
   519                              <1>     ;Send command
   520 000037D7 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   521 000037DB 81C207000000        <1>     add edx, 7  ;Goto command register
   522 000037E1 88C1                <1>     mov cl, al  ;Save sector count in cl
   523 000037E3 B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   524 000037E5 E9D0FEFFFF          <1>     jmp .write
   525                              <1> 
   526                              <1> .verifyCHS:
   527 000037EA E83F000000          <1>     call .setupCHS
   528 000037EF 0F82C3FEFFFF        <1>     jc .errorExit
   529                              <1>     ;Send command
   530 000037F5 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   531 000037F9 81C207000000        <1>     add edx, 7  ;Goto command register
   532 000037FF B040                <1>     mov al, 40h ;ATA VERIFY COMMAND!
   533 00003801 E931FFFFFF          <1>     jmp .verify
   534                              <1> 
   535                              <1> .formatCHS:
   536                              <1> ;Ignore al (number of sectors) and cl[5:0] (Starting sector number)
   537 00003806 668B4505            <1>     mov ax, word [rbp + fdiskEntry.wSecTrc] ;Get sectors in a track to clear
   538                              <1>     ;Sectors per track is always less than 256 so byte is ok!
   539 0000380A 80E1C0              <1>     and cl, 0C0h    ;Clear bottom 6 bits. 
   540 0000380D 80C901              <1>     or cl, 1        ;All tracks start at sector 1
   541 00003810 E819000000          <1>     call .setupCHS
   542 00003815 0F829DFEFFFF        <1>     jc .errorExit
   543 0000381B 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   544 0000381F 81C207000000        <1>     add edx, 7  ;Goto command register
   545 00003825 88C1                <1>     mov cl, al  ;Save sector count in cl
   546 00003827 B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   547 00003829 E934FFFFFF          <1>     jmp .format
   548                              <1> 
   549                              <1> .setupCHS:
   550                              <1>     ;First sets the chosen device, then sets all the registers
   551                              <1>     ; except for the command and then returns
   552 0000382E E802FDFFFF          <1>     call .selectDriveFromTable
   553 00003833 722F                <1>     jc .sCHSFailed
   554                              <1>     ;Now the drive has been selected, we can write to it
   555 00003835 50                  <1>     push rax    ;Only sector count needs to be preserved
   556 00003836 52                  <1>     push rdx    ;Temporarily save drive head bits to use later
   557 00003837 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   558 0000383B 81C202000000        <1>     add edx, 2  ;Goto base + 2, Sector count
   559 00003841 EE                  <1>     out dx, al
   560 00003842 FFC2                <1>     inc edx     ;Goto base + 3, Starting sector number
   561 00003844 88C8                <1>     mov al, cl  ;Bits [5:0] have starting sector number
   562 00003846 243F                <1>     and al, 3Fh ;Clear upper two bits
   563 00003848 EE                  <1>     out dx, al
   564 00003849 FFC2                <1>     inc edx     ;Goto base + 4, Cylinder low bits
   565 0000384B 88E8                <1>     mov al, ch  ;Get the low 8 bits of the cylinder number
   566 0000384D EE                  <1>     out dx, al
   567 0000384E FFC2                <1>     inc edx     ;Goto base + 5, Cylinder high bits
   568 00003850 88C8                <1>     mov al, cl  ;Bits [7:6] have top two bits of cylinder number
   569 00003852 C0E806              <1>     shr al, 6   ;Shift them down to clear bottom 6 bits
   570 00003855 EE                  <1>     out dx, al  
   571 00003856 FFC2                <1>     inc edx     ;Goto base + 6, Drive/Head controller register
   572 00003858 58                  <1>     pop rax     ;Get back the drive head number from dh into ah
   573 00003859 88E0                <1>     mov al, ah  
   574 0000385B 240F                <1>     and al, 0Fh ;Save only bottom nybble
   575 0000385D 0A4515              <1>     or al, byte [rbp + fdiskEntry.msBit]    ;Add the MS bits to al
   576 00003860 EE                  <1>     out dx, al
   577 00003861 58                  <1>     pop rax
   578 00003862 F8                  <1>     clc
   579 00003863 C3                  <1>     ret
   580                              <1> .sCHSFailed:
   581 00003864 C60425[A9010000]20  <1>     mov byte [msdStatus], 20h   ;General controller failure
   582 0000386C C3                  <1>     ret ;Carry flag propagated
   583                              <1> 
   584                              <1> ;LBA functions
   585                              <1> .readLBA:
   586 0000386D E873000000          <1>     call .setupLBA
   587 00003872 0F8240FEFFFF        <1>     jc .errorExit
   588                              <1>     ;Send command
   589 00003878 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   590 0000387C 81C207000000        <1>     add edx, 7  ;Goto command register
   591 00003882 88C1                <1>     mov cl, al  ;Save sector count in cl
   592 00003884 B020                <1>     mov al, 20h ;ATA READ COMMAND!
   593 00003886 E9CAFDFFFF          <1>     jmp .read
   594                              <1> 
   595                              <1> .writeLBA:
   596 0000388B E855000000          <1>     call .setupLBA
   597 00003890 0F8222FEFFFF        <1>     jc .errorExit
   598                              <1>     ;Send command
   599 00003896 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   600 0000389A 81C207000000        <1>     add edx, 7  ;Goto command register
   601 000038A0 88C1                <1>     mov cl, al  ;Save sector count in cl
   602 000038A2 B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   603 000038A4 E911FEFFFF          <1>     jmp .write
   604                              <1> 
   605                              <1> .verifyLBA:
   606 000038A9 E837000000          <1>     call .setupLBA
   607 000038AE 0F8204FEFFFF        <1>     jc .errorExit
   608                              <1>     ;Send command
   609 000038B4 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   610 000038B8 81C207000000        <1>     add edx, 7  ;Goto command register
   611 000038BE 88C1                <1>     mov cl, al  ;Save sector count in cl
   612 000038C0 B040                <1>     mov al, 40h ;ATA VERIFY COMMAND!
   613 000038C2 E970FEFFFF          <1>     jmp .verify
   614                              <1> 
   615                              <1> .formatLBA:
   616 000038C7 E819000000          <1>     call .setupLBA
   617 000038CC 0F82E6FDFFFF        <1>     jc .errorExit
   618                              <1>     ;Send command
   619 000038D2 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   620 000038D6 81C207000000        <1>     add edx, 7  ;Goto command register
   621 000038DC 88C1                <1>     mov cl, al  ;Save sector count in cl
   622 000038DE B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   623 000038E0 E97DFEFFFF          <1>     jmp .format
   624                              <1> 
   625                              <1> .setupLBA:
   626                              <1>     ;First sets the chosen device, then sets all the registers
   627                              <1>     ; except for the command and then returns
   628 000038E5 E84BFCFFFF          <1>     call .selectDriveFromTable
   629 000038EA 7233                <1>     jc .sLBAFailed
   630 000038EC 50                  <1>     push rax        ;Save sector count on stack
   631 000038ED 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   632 000038F1 81C202000000        <1>     add edx, 2      ;Goto base + 2, Sector count
   633 000038F7 EE                  <1>     out dx, al      ;Output sector number
   634 000038F8 FFC2                <1>     inc edx         ;Goto base + 3, LBA low
   635 000038FA 88C8                <1>     mov al, cl      ;Get LBA low address
   636 000038FC C1E908              <1>     shr ecx, 8      ;Get second byte low
   637 000038FF EE                  <1>     out dx, al      
   638                              <1> 
   639 00003900 FFC2                <1>     inc edx         ;Goto base + 4, LBA mid
   640 00003902 88C8                <1>     mov al, cl      ;Get LBA second byte
   641 00003904 C1E908              <1>     shr ecx, 8      ;Get third byte low
   642 00003907 EE                  <1>     out dx, al
   643                              <1> 
   644 00003908 FFC2                <1>     inc edx         ;Goto base + 5, LBA high
   645 0000390A 88C8                <1>     mov al, cl      ;Get LBA third byte
   646 0000390C C1E908              <1>     shr ecx, 8      ;Get final nybble into cl
   647 0000390F EE                  <1>     out dx, al
   648                              <1> 
   649 00003910 FFC2                <1>     inc edx         ;Goto base + 6, LBA upper bits and drive select
   650 00003912 88C8                <1>     mov al, cl      ;Get final nybble into al
   651 00003914 240F                <1>     and al, 0Fh     ;Clear extra bits
   652 00003916 0A4515              <1>     or al, byte [rbp + fdiskEntry.msBit]    ;Add the master/slave bit and fixed bits
   653 00003919 0C40                <1>     or al, 40h      ;Set LBA bit
   654 0000391B EE                  <1>     out dx, al
   655 0000391C 58                  <1>     pop rax  ;Return sector count into al
   656 0000391D F8                  <1>     clc
   657 0000391E C3                  <1>     ret
   658                              <1> .sLBAFailed:
   659 0000391F C60425[A9010000]20  <1>     mov byte [msdStatus], 20h   ;General controller failure
   660 00003927 C3                  <1>     ret ;Carry flag propagated
   661                              <1> 
   662                              <1> ;LBA48 functions
   663                              <1> .readLBA48:
   664 00003928 E873000000          <1>     call .setupLBA48
   665 0000392D 0F8285FDFFFF        <1>     jc .errorExit
   666                              <1>     ;Send command
   667 00003933 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   668 00003937 81C207000000        <1>     add edx, 7  ;Goto command register
   669 0000393D 88C1                <1>     mov cl, al  ;Save sector count in cl
   670 0000393F B024                <1>     mov al, 24h ;ATA READ EXT COMMAND!
   671 00003941 E90FFDFFFF          <1>     jmp .read
   672                              <1> 
   673                              <1> .writeLBA48:
   674 00003946 E855000000          <1>     call .setupLBA48
   675 0000394B 0F8267FDFFFF        <1>     jc .errorExit
   676                              <1>     ;Send command
   677 00003951 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   678 00003955 81C207000000        <1>     add edx, 7  ;Goto command register
   679 0000395B 88C1                <1>     mov cl, al  ;Save sector count in cl
   680 0000395D B034                <1>     mov al, 34h ;ATA WRITE EXT COMMAND!
   681 0000395F E956FDFFFF          <1>     jmp .write
   682                              <1> 
   683                              <1> .verifyLBA48:
   684 00003964 E837000000          <1>     call .setupLBA48
   685 00003969 0F8249FDFFFF        <1>     jc .errorExit
   686                              <1>     ;Send command
   687 0000396F 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   688 00003973 81C207000000        <1>     add edx, 7  ;Goto command register
   689 00003979 88C1                <1>     mov cl, al  ;Save sector count in cl
   690 0000397B B042                <1>     mov al, 42h ;ATA VERIFY EXT COMMAND!
   691 0000397D E9B5FDFFFF          <1>     jmp .verify
   692                              <1> 
   693                              <1> .formatLBA48:
   694 00003982 E819000000          <1>     call .setupLBA48
   695 00003987 0F822BFDFFFF        <1>     jc .errorExit
   696                              <1>     ;Send command
   697 0000398D 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   698 00003991 81C207000000        <1>     add edx, 7  ;Goto command register
   699 00003997 88C1                <1>     mov cl, al  ;Save sector count in cl
   700 00003999 B034                <1>     mov al, 34h ;ATA WRITE EXT COMMAND!
   701 0000399B E9C2FDFFFF          <1>     jmp .format
   702                              <1> 
   703                              <1> .setupLBA48:
   704                              <1> ;First sets the chosen device, then sets all the registers
   705                              <1>     ; except for the command and then returns
   706 000039A0 E890FBFFFF          <1>     call .selectDriveFromTable
   707 000039A5 0F8274FFFFFF        <1>     jc .sLBAFailed
   708 000039AB 50                  <1>     push rax        ;Save sector count on stack
   709 000039AC 0FB75513            <1>     movzx edx, word [rbp + fdiskEntry.ioBase]
   710 000039B0 81C202000000        <1>     add edx, 2      ;Goto base + 2, Sector count
   711 000039B6 48C1C918            <1>     ror rcx, 24     ;Move the upper three bytes low
   712 000039BA 30C0                <1>     xor al, al      ;High byte of sector count is always 0
   713 000039BC EE                  <1>     out dx, al
   714                              <1> 
   715 000039BD FFC2                <1>     inc edx         ;Goto base + 3, Write LBA byte 4
   716 000039BF 88C8                <1>     mov al, cl      ;Get LBA byte 4 into al
   717 000039C1 EE                  <1>     out dx, al
   718 000039C2 48C1E908            <1>     shr rcx, 8      ;Shift bytes down by 1
   719                              <1> 
   720 000039C6 FFC2                <1>     inc edx         ;Goto base + 4, Write LBA byte 5
   721 000039C8 88C8                <1>     mov al, cl      ;Get LBA byte 5 into al
   722 000039CA EE                  <1>     out dx, al
   723 000039CB 48C1E908            <1>     shr rcx, 8      ;Shift bytes down by 1
   724                              <1> 
   725 000039CF FFC2                <1>     inc edx         ;Goto base + 5, Write LBA byte 6
   726 000039D1 88C8                <1>     mov al, cl      ;Get LBA byte 6 into al
   727 000039D3 EE                  <1>     out dx, al
   728                              <1> 
   729 000039D4 48C1E918            <1>     shr rcx, 24     ;Shift down by an extra two to eliminate two dummy bytes
   730                              <1> ;cl now has LBA byte 1 again
   731 000039D8 81EA03000000        <1>     sub edx, 3      ;Goto base + 2, Write low byte of sector count
   732 000039DE 58                  <1>     pop rax         ;Get back sector count from stack
   733 000039DF 50                  <1>     push rax        ;Push it back onto the stack
   734 000039E0 EE                  <1>     out dx, al
   735                              <1> 
   736 000039E1 FFC2                <1>     inc edx         ;Goto base + 3, Write LBA byte 1
   737 000039E3 88C8                <1>     mov al, cl      ;Get LBA byte 1 into al
   738 000039E5 EE                  <1>     out dx, al
   739 000039E6 48C1E908            <1>     shr rcx, 8      ;Shift bytes down by 1
   740                              <1> 
   741 000039EA FFC2                <1>     inc edx         ;Goto base + 4, Write LBA byte 2
   742 000039EC 88C8                <1>     mov al, cl      ;Get LBA byte 2 into al
   743 000039EE EE                  <1>     out dx, al
   744 000039EF 48C1E908            <1>     shr rcx, 8
   745                              <1> 
   746 000039F3 FFC2                <1>     inc edx         ;Goto base + 5, Write LBA byte 3
   747 000039F5 88C8                <1>     mov al, cl      ;Get LBA byte 3 into al
   748 000039F7 EE                  <1>     out dx, al
   749                              <1> 
   750 000039F8 FFC2                <1>     inc edx         ;Goto base + 6, write drive select
   751 000039FA 8A4515              <1>     mov al, byte [rbp + fdiskEntry.msBit]    ;Add the master/slave bit and fixed bits
   752 000039FD 0C40                <1>     or al, 40h      ;Set LBA bit
   753 000039FF EE                  <1>     out dx, al
   754                              <1> 
   755 00003A00 58                  <1>     pop rax  ;Return sector count into al
   756 00003A01 F8                  <1>     clc
   757 00003A02 C3                  <1>     ret
   109                                  %include "./Source/Resident/Hardware/USB/EHCI/ehciDriv.asm"
   110                              <1> ;--------------------USB Driver and data area--------------------
   111                              <1> ;Note, this needs to be updated.
   112                              <1> ;All SCSI, MSD and HUB related functions are grouped in this file
   113                              <1> ;SCSI functions need to be moved into their own folder
   114                              <1> USB:
   115                              <1> ;------------------------EHCI functions--------------------------
   116                              <1> ;eActiveCtrlr must be set with the offset of the controller
   117                              <1> ; IFF the controller is about to enter a state in which it could
   118                              <1> ; fire an interrupt. These functions must safeguard against it by
   119                              <1> ; checking that this byte is -1 first and then setting the byte
   120                              <1> ; with the selected controller index, ending by resetting this 
   121                              <1> ; byte to -1 (even on fail). 
   122                              <1> ;
   123                              <1> ;Certain functions may be called to act upon the CURRENT ACTIVE
   124                              <1> ; controller, these functions dont need these safeguards, though
   125                              <1> ; they may need to ensure that there is a valid controller number 
   126                              <1> ; in the eActiveCtrlr byte.
   127                              <1> ;----------------------------------------------------------------
   128                              <1> .ehciCriticalErrorWrapper:
   129                              <1> ;Currently just jumps to the installed address.
   130                              <1> ;Conditional error calls MUST call this wrapper to allow for
   131                              <1> ; host operating systems to install their own USB error handlers
   132                              <1> ; and have the system continue working.
   133 00003A03 FF2425[36020000]    <1>     jmp qword [eHCErrorHandler]
   134                              <1> .ehciCriticalErrorHandler:
   135                              <1> ;Currently just halts the system
   136 00003A0A BB07000000          <1>     mov ebx, 07h
   137 00003A0F E8E3C6FFFF          <1>     call cls
   138 00003A14 48BD-               <1>     mov rbp, .ecehmsg
   138 00003A16 [313A000000000000]  <1>
   139 00003A1E 66B80413            <1>     mov ax, 1304h
   140 00003A22 CD30                <1>     int 30h
   141 00003A24 B0FF                <1>     mov al, 0FFh
   142 00003A26 E621                <1>     out pic1data, al
   143 00003A28 E6A1                <1>     out pic2data, al
   144 00003A2A FA                  <1>     cli
   145 00003A2B F4                  <1>     hlt
   146 00003A2C E9F9FFFFFF          <1>     jmp $ - 2
   147 00003A31 454843492043686563- <1> .ecehmsg db "EHCI Check 1", 0
   147 00003A3A 6B203100            <1>
   148                              <1> .setupEHCIcontroller:
   149                              <1> ;Resets, initialises variables to default
   150                              <1> ;Input: al = Controller to setup (0 based)
   151                              <1> ;Output: CF=CY - Controller failed to reset
   152                              <1> ;        CF=NC - No problems
   153                              <1> ; al = Controller that was reset
   154 00003A3E 51                  <1>     push rcx
   155 00003A3F 53                  <1>     push rbx
   156 00003A40 55                  <1>     push rbp
   157 00003A41 E80F010000          <1>     call .ehciResetCtrlr    ;Reset the controller
   158 00003A46 7215                <1>     jc .secexit
   159 00003A48 6631DB              <1>     xor bx, bx ;No schedule, no interrupts
   160 00003A4B 31C9                <1>     xor ecx, ecx
   161 00003A4D 48BD-               <1>     mov rbp, ehciAschedule
   161 00003A4F [0000000000000000]  <1>
   162 00003A57 E8EB010000          <1>     call .ehciInitCtrlrRegs    ;Initialise controller registers
   163 00003A5C F8                  <1>     clc
   164                              <1> .secexit:
   165 00003A5D 5D                  <1>     pop rbp
   166 00003A5E 5B                  <1>     pop rbx
   167 00003A5F 59                  <1>     pop rcx
   168 00003A60 C3                  <1>     ret
   169                              <1> 
   170                              <1> .ehciResetControllerPort:
   171                              <1> ;A function that enacts an EHCI reset on a port.
   172                              <1> ;Works ONLY on the current active controller.
   173                              <1> ;Input:
   174                              <1> ; al = Port number [0,N-1] (Checked against ctrlr struc params entry)
   175                              <1> ;Returns:
   176                              <1> ; CF set if failed, clear if success
   177                              <1> ; ax=Error code, 0h=No active controller
   178                              <1> ;             1h=Invalid port number
   179                              <1> ;             2h=No device on port
   180                              <1> ;             3h=Port not enabled (Low speed device)
   181                              <1> ;             4h=Device not entering reset
   182                              <1> ;             5h=Device not clearing reset
   183                              <1> ;             6h=Port not enabled (Full speed device)
   184                              <1> ; rax destroyed
   185 00003A61 53                  <1>     push rbx
   186 00003A62 51                  <1>     push rcx
   187 00003A63 52                  <1>     push rdx
   188 00003A64 55                  <1>     push rbp
   189                              <1> 
   190 00003A65 6631ED              <1>     xor bp, bp
   191 00003A68 0FB6D0              <1>     movzx edx, al    ;Save port number into dl (edx)
   192 00003A6B 0FB61C25[47020000]  <1>     movzx ebx, byte [eActiveCtrlr]
   193 00003A73 80FBFF              <1>     cmp bl, -1
   194 00003A76 0F84D3000000        <1>     je .ercperr    ;Error, No active controller (ec=0)
   195 00003A7C 66FFC5              <1>     inc bp        ;Inc error counter
   196 00003A7F 8B1CDD[19020000]    <1>     mov ebx, dword [eControllerList + 4 + 8*rbx]    ;get mmiobase into ebx
   197 00003A86 678B4304            <1>     mov eax, dword [ebx+ehcistrucparams]    ;Get # of ports in al
   198 00003A8A 247F                <1>     and al, 7Fh    ;al contains port number, clear upper bit
   199 00003A8C FEC8                <1>     dec al        ;Zero based port number
   200 00003A8E 0FB6C0              <1>     movzx eax, al
   201 00003A91 38C2                <1>     cmp dl, al    ;dl contains called port number
   202 00003A93 0F87B6000000        <1>     ja .ercperr    ;Error, invalid port number (ec=1)
   203 00003A99 66FFC5              <1>     inc bp        ;Inc error counter
   204                              <1> 
   205                              <1> 
   206 00003A9C 670FB603            <1>     movzx eax, byte [ebx]    ;Byte access for caplength!
   207 00003AA0 01C3                <1>     add ebx, eax    ;eax now points to opregs    
   208 00003AA2 66B90A00            <1>     mov cx, 10
   209                              <1> .erclp0:    ;Remember ebx=opregs, edx=port number    
   210 00003AA6 67814C934400100000  <1>     or dword [ebx+4*edx+ehciportsc], 1000h ;Set power bit
   211                              <1> 
   212 00003AAF 51                  <1>     push rcx
   213 00003AB0 B90A000000          <1>     mov ecx, 10
   214 00003AB5 B486                <1>     mov ah, 86h
   215 00003AB7 CD35                <1>     int 35h        ;Wait for 10 ms
   216 00003AB9 59                  <1>     pop rcx
   217                              <1> 
   218                              <1> .erclp1:
   219 00003ABA 66FFC9              <1>     dec cx
   220 00003ABD 0F848C000000        <1>     jz .ercperr ;Error, No device on port (ec=2)
   221 00003AC3 67F744934401000000  <1>     test dword [ebx+4*edx+ehciportsc], 1h    ;Test device on port
   222 00003ACC 74D8                <1>     jz .erclp0
   223 00003ACE 66FFC5              <1>     inc bp        ;Inc error counter
   224                              <1> 
   225 00003AD1 678B449344          <1>     mov eax, dword [ebx+4*edx+ehciportsc]
   226 00003AD6 6625000C            <1>     and ax, 0C00h
   227 00003ADA 662D0004            <1>     sub ax, 400h
   228 00003ADE 66FFC8              <1>     dec ax
   229 00003AE1 746C                <1>     jz .ercperr    ;Error, Low speed device (ec=3)
   230 00003AE3 66FFC5              <1>     inc bp        ;Inc error counter
   231                              <1> 
   232 00003AE6 66B90A00            <1>     mov cx, 10
   233                              <1> .erclp2:
   234 00003AEA 66FFC9              <1>     dec cx
   235 00003AED 7460                <1>     jz .ercperr ;Error, Device not entering reset (ec=4)
   236 00003AEF 67814C934400010000  <1>     or dword [ebx+4*edx+ehciportsc], 100h    ;Set bit 8, port reset bit
   237                              <1>     
   238 00003AF8 51                  <1>     push rcx
   239 00003AF9 B90A000000          <1>     mov ecx, 10
   240 00003AFE B486                <1>     mov ah, 86h
   241 00003B00 CD35                <1>     int 35h        ;Wait for 10 ms
   242 00003B02 59                  <1>     pop rcx
   243                              <1> 
   244 00003B03 67F744934400010000  <1>     test dword [ebx+4*edx+ehciportsc], 100h    ;Check if entered reset
   245 00003B0C 74DC                <1>     jz .erclp2
   246                              <1> 
   247 00003B0E 66FFC5              <1>     inc bp        ;Inc error counter
   248 00003B11 66B90A00            <1>     mov cx, 10
   249 00003B15 6781649344FFFEFFFF  <1>     and dword [ebx+4*edx+ehciportsc], 0FFFFFEFFh    ;Clear reset bit
   250                              <1> .erclp3:
   251 00003B1E FFC9                <1>     dec ecx
   252 00003B20 742D                <1>     jz .ercperr ;Error, Device not leaving reset (ec=5)
   253                              <1> 
   254 00003B22 51                  <1>     push rcx
   255 00003B23 B90A000000          <1>     mov ecx, 10
   256 00003B28 B486                <1>     mov ah, 86h
   257 00003B2A CD35                <1>     int 35h        ;Wait for 10 ms
   258 00003B2C 59                  <1>     pop rcx
   259                              <1> 
   260 00003B2D 67F744934400010000  <1>     test dword [ebx+4*edx+ehciportsc], 100h
   261 00003B36 75E6                <1>     jnz .erclp3
   262 00003B38 66FFC5              <1>     inc bp        ;Inc error counter
   263                              <1> 
   264 00003B3B 67F744934404000000  <1>     test dword [ebx+4*edx+ehciportsc], 4h    ;Bit 2 is the port enabled bit
   265 00003B44 7409                <1>     jz .ercperr    ;Error, Full speed device (ec=6)
   266                              <1> ;We get here IFF device on port is high speed
   267                              <1>     
   268                              <1> ;High Speed Device successfully reset. Now print message or whatever
   269 00003B46 4831C0              <1>     xor rax, rax
   270 00003B49 F8                  <1>     clc
   271                              <1> .ercpexit:
   272 00003B4A 5D                  <1>     pop rbp
   273 00003B4B 5A                  <1>     pop rdx
   274 00003B4C 59                  <1>     pop rcx
   275 00003B4D 5B                  <1>     pop rbx
   276 00003B4E C3                  <1>     ret
   277                              <1> .ercperr:
   278 00003B4F 6689E8              <1>     mov ax, bp    ;Get error code in ax
   279 00003B52 F9                  <1>     stc
   280 00003B53 EBF5                <1>     jmp short .ercpexit
   281                              <1> 
   282                              <1> .ehciResetCtrlr:
   283                              <1> ;A function that resets a controller. 
   284                              <1> ;No other controllers may be running during a ctrlr reset
   285                              <1> ;Input:
   286                              <1> ; al = Offset into the ehci controller table
   287                              <1> ;Returns:
   288                              <1> ; CF=CY if failed, CF=NC if reset
   289                              <1> ;All registers preserved
   290 00003B55 50                  <1>     push rax
   291 00003B56 51                  <1>     push rcx
   292                              <1>     ;cmp byte [eActiveCtrlr], -1
   293                              <1>     ;jne .erc2    ;A controller already active, exit fail (ec=0)
   294                              <1>     ;mov byte [eActiveCtrlr], al    ;For added security (may be removed later)
   295 00003B57 E800180000          <1>     call .ehciGetOpBase
   296 00003B5C 67C7400800000000    <1>     mov dword [eax + ehciintr], 0h    ;No interrupts
   297 00003B64 67C740043F000000    <1>     mov dword [eax + ehcists], 3Fh    ;Clear any outstanding interrupts
   298                              <1>     ;Set the reset bit, check to see if run bit has cleared first!
   299 00003B6C 31C9                <1>     xor ecx, ecx
   300                              <1> .erc0:
   301 00003B6E 678120FEFFFFFF      <1>     and dword [eax + ehcicmd], 0FFFFFFFEh    ;Force stop the controller
   302 00003B75 FFC9                <1>     dec ecx
   303 00003B77 743D                <1>     jz .erc2    ;Controller not resetting, exit fail  (ec=1)
   304                              <1> 
   305 00003B79 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;Test if bit 12 has been set
   306 00003B81 74EB                <1>     jz .erc0
   307 00003B83 67810802000000      <1>     or dword [eax + ehcicmd], 02h ;Set bit 1, reset HC
   308                              <1>     ;Spin and wait to give device time to respond and reset.
   309 00003B8A 6631C9              <1>     xor cx, cx
   310                              <1> .erc1:
   311 00003B8D 66FFC9              <1>     dec cx        ;Wait for reset to happen
   312 00003B90 7424                <1>     jz .erc2    ;Not resetting, exit fail (ec=2)
   313                              <1> 
   314 00003B92 50                  <1>     push rax
   315 00003B93 51                  <1>     push rcx
   316 00003B94 B486                <1>     mov ah, 86h
   317 00003B96 B905000000          <1>     mov ecx, 5    ;5ms wait
   318 00003B9B CD35                <1>     int 35h
   319 00003B9D 59                  <1>     pop rcx
   320 00003B9E 58                  <1>     pop rax
   321                              <1> 
   322 00003B9F 67F70002000000      <1>     test dword [eax + ehcicmd], 2h    ;Whilst this bit is set, keep looping
   323 00003BA6 75E5                <1>     jnz .erc1
   324 00003BA8 31C0                <1>     xor eax, eax
   325 00003BAA F8                  <1>     clc
   326                              <1> .ercexit:
   327 00003BAB C60425[47020000]FF  <1>     mov byte [eActiveCtrlr], -1    ;No controllers active
   328 00003BB3 59                  <1>     pop rcx
   329 00003BB4 58                  <1>     pop rax
   330 00003BB5 C3                  <1>     ret
   331                              <1> .erc2:
   332 00003BB6 F9                  <1>     stc
   333 00003BB7 EBF2                <1>     jmp short .ercexit
   334                              <1> 
   335                              <1> .ehciRunCtrlr:
   336                              <1> ;A function that runs a controller to process set schedules
   337                              <1> ;Input:
   338                              <1> ;   al = Offset into the controller table
   339                              <1> ;Returns:
   340                              <1> ; CF = CY if failed, CF = NC if success
   341 00003BB9 50                  <1>     push rax
   342 00003BBA 51                  <1>     push rcx
   343 00003BBB E89C170000          <1>     call .ehciGetOpBase
   344 00003BC0 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;bit 12 must be set to write 1 in cmd
   345 00003BC8 741E                <1>     jz .esc2
   346 00003BCA 67810801000000      <1>     or dword [eax + ehcicmd], 1h ;Set bit 0 to run
   347 00003BD1 31C9                <1>     xor ecx, ecx
   348                              <1> .esc0:
   349 00003BD3 66FFC9              <1>     dec cx
   350 00003BD6 7410                <1>     jz .esc2
   351 00003BD8 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;bit 12 must be clear
   352 00003BE0 75F1                <1>     jnz .esc0
   353 00003BE2 31C0                <1>     xor eax, eax
   354 00003BE4 F8                  <1>     clc
   355                              <1> .esc1:
   356 00003BE5 59                  <1>     pop rcx
   357 00003BE6 58                  <1>     pop rax
   358 00003BE7 C3                  <1>     ret
   359                              <1> .esc2:    ;Bad exit
   360 00003BE8 F9                  <1>     stc
   361 00003BE9 EBFA                <1>     jmp short .esc1
   362                              <1> 
   363                              <1> .ehciStopCtrlr:
   364                              <1> ;A function that stops current active controller from running
   365                              <1> ;Input:
   366                              <1> ; al=Controller to stop processing
   367                              <1> ;Returns:
   368                              <1> ; CF set if failed to stop, clear if success
   369 00003BEB 50                  <1>     push rax
   370 00003BEC 51                  <1>     push rcx
   371 00003BED 480FB60425-         <1>     movzx rax, byte [eActiveCtrlr]
   371 00003BF2 [47020000]          <1>
   372 00003BF6 E861170000          <1>     call .ehciGetOpBase
   373 00003BFB 678120FEFFFFFF      <1>     and dword [eax + ehcicmd], 0FFFFFFFEh    ;Stop controller
   374 00003C02 31C9                <1>     xor ecx, ecx
   375                              <1> .estc0:
   376 00003C04 66FFC9              <1>     dec cx
   377 00003C07 740E                <1>     jz .estc1
   378 00003C09 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;test hchalted until set
   379 00003C11 74F1                <1>     jz .estc0
   380 00003C13 F8                  <1>     clc
   381                              <1> .estcexit:
   382 00003C14 59                  <1>     pop rcx
   383 00003C15 58                  <1>     pop rax
   384 00003C16 C3                  <1>     ret
   385                              <1> .estc1:
   386 00003C17 F9                  <1>     stc
   387 00003C18 EBFA                <1>     jmp short .estcexit
   388                              <1> .ehciAdjustAsyncSchedCtrlr:
   389                              <1> ;This function checks the currently online controller and compares it to
   390                              <1> ; the value provided in al. 
   391                              <1> ;If they are equal, do nothing.
   392                              <1> ;If not, turn off controller, update active ctrlr byte and indicate a new bus 
   393                              <1> ; was activated.
   394                              <1> ;If no controller active, update active ctrlr byte and indicate which bus 
   395                              <1> ; has been activated.
   396                              <1> ;
   397                              <1> ; Input: al = Controller to activate, preserved.
   398                              <1> ; Output: CF=CY: Error, turn off all controllers
   399                              <1> ;         CF=NC: All ok, proceed
   400 00003C1A 3A0425[47020000]    <1>     cmp al, byte [eActiveCtrlr]
   401 00003C21 7420                <1>     je .eacOkExit
   402 00003C23 803C25[47020000]FF  <1>     cmp byte [eActiveCtrlr], -1
   403 00003C2B 7407                <1>     je .eacStart
   404 00003C2D E8D8020000          <1>     call .ehciStopAsyncSchedule ;Stop currently transacting controller
   405 00003C32 7211                <1>     jc .eacBad
   406                              <1> .eacStart:
   407 00003C34 880425[47020000]    <1>     mov byte [eActiveCtrlr], al ;Set new active controller
   408 00003C3B C60425[46020000]01  <1>     mov byte [eNewBus], 1   ;Set flag that a new bus has been selected
   409                              <1> .eacOkExit:
   410 00003C43 F8                  <1>     clc
   411 00003C44 C3                  <1>     ret
   412                              <1> .eacBad:
   413 00003C45 F9                  <1>     stc
   414 00003C46 C3                  <1>     ret
   415                              <1> .ehciInitCtrlrRegs:
   416                              <1> ;A function that initialises a given controllers registers as needed.
   417                              <1> ;Controller is left ready to process data start schedules
   418                              <1> ;MUST NOT BE CALLED ON A RUNNING CONTROLLER
   419                              <1> ;Input:
   420                              <1> ; al = Offset into the ehci controller table
   421                              <1> ; bl = ehciintr mask
   422                              <1> ; bh = Schedule mask, bits [7:2] reserved
   423                              <1> ;        00b = No schedule, 01b=Periodic, 10b=Async, 11b=Both
   424                              <1> ; ecx = Frame Index
   425                              <1> ; rbp = Schedule address
   426                              <1> ;Returns:
   427                              <1> ; Nothing
   428 00003C47 50                  <1>     push rax
   429 00003C48 53                  <1>     push rbx
   430 00003C49 51                  <1>     push rcx
   431 00003C4A 53                  <1>     push rbx
   432 00003C4B E80C170000          <1>     call .ehciGetOpBase    ;Get opbase 
   433 00003C50 0FB7DB              <1>     movzx ebx, bx
   434 00003C53 67C7400800000000    <1>     mov dword [eax + ehciintr], 0
   435 00003C5B 6789480C            <1>     mov dword [eax + ehcifrindex], ecx
   436 00003C5F 67896818            <1>     mov dword [eax + ehciasyncaddr], ebp
   437 00003C63 48C1CD20            <1>     ror rbp, 20h    ;Get upper dword low
   438 00003C67 67896810            <1>     mov dword [eax + ehcictrlseg], ebp
   439 00003C6B 5B                  <1>     pop rbx    ;Get back bh
   440 00003C6C 30DB                <1>     xor bl, bl    ;Zero lo byte
   441 00003C6E 66C1EB04            <1>     shr bx, 4    ;Shift to hi nybble of lo byte
   442 00003C72 678120CF000000      <1>     and dword [eax + ehcicmd], 0CFh    ;Clear schedule enable bits
   443 00003C79 670B18              <1>     or ebx, dword [eax + ehcicmd]    ;Add ehcicmd to schedule mask
   444 00003C7C 81E3F3FF00FF        <1>     and ebx, 0FF00FFF3h    ;Clear the Int Threshold and Frame List bits
   445 00003C82 81CB00000800        <1>     or ebx, 000080000h ;Set 8 microframes (1 ms) per interrupt
   446 00003C88 678918              <1>     mov dword [eax + ehcicmd], ebx    ;Write back
   447 00003C8B 67C7404001000000    <1>     mov dword [eax + ehciconfigflag], 1h    ;Route all ports to EHCI ctrlr
   448 00003C93 59                  <1>     pop rcx
   449 00003C94 5B                  <1>     pop rbx
   450 00003C95 58                  <1>     pop rax
   451 00003C96 C3                  <1>     ret
   452                              <1> .ehciCtrlrGetNumberOfPorts:
   453                              <1> ;Gets the number of ports on a Host Controller.
   454                              <1> ;Ports are zero addressed so ports numbers are 0 to NUMBER_OF_PORTS - 1
   455                              <1> ;Input:  al = Offset into the controller table
   456                              <1> ;Output: rax = Number of ports on controller.
   457                              <1> ;Warning, input NOT bounds checked.
   458 00003C97 0FB6C0              <1>     movzx eax, al
   459 00003C9A 8B04C5[19020000]    <1>     mov eax, dword [eControllerList + 4 + 8*rax]
   460 00003CA1 678B4004            <1>     mov eax, dword [eax + ehcistrucparams]
   461 00003CA5 257F000000          <1>     and eax, 7Fh    ;Clear upper bits
   462 00003CAA C3                  <1>     ret
   463                              <1> .ehciGetNewQHeadAddr:
   464                              <1> ;Picks which QHead position to put the new Qhead into
   465                              <1> ;Input: Nothing
   466                              <1> ;Output: rdi = Position in RAM for QHead
   467                              <1> ;        r8  = Link to next QHead
   468                              <1> ;           r8 NEEDS to be or'ed with 2 when used as a QHead pointer
   469 00003CAB 49B8-               <1>     mov r8, ehciQHead1
   469 00003CAD [8000000000000000]  <1>
   470 00003CB5 48BF-               <1>     mov rdi, ehciQHead0
   470 00003CB7 [0000000000000000]  <1>
   471 00003CBF 483B3C25[3E020000]  <1>     cmp rdi, qword [eCurrAsyncHead]   ;Compare head to start of buffer
   472 00003CC7 7503                <1>     jne .egnqaexit
   473 00003CC9 4987F8              <1>     xchg rdi, r8
   474                              <1> .egnqaexit:
   475 00003CCC C3                  <1>     ret
   476                              <1> 
   477                              <1> .ehciToggleTransactingQHead:
   478                              <1> ;Toggles the transacting Qhead position
   479                              <1> ;This is called AFTER the old Qhead has been delinked from the AsynchSchedule
   480 00003CCD 48813C25[3E020000]- <1>     cmp qword [eCurrAsyncHead], ehciQHead0
   480 00003CD5 [00000000]          <1>
   481 00003CD9 750D                <1>     jne .ettqh0
   482 00003CDB 48C70425[3E020000]- <1>     mov qword [eCurrAsyncHead], ehciQHead1
   482 00003CE3 [80000000]          <1>
   483 00003CE7 C3                  <1>     ret
   484                              <1> .ettqh0:
   485 00003CE8 48C70425[3E020000]- <1>     mov qword [eCurrAsyncHead], ehciQHead0
   485 00003CF0 [00000000]          <1>
   486 00003CF4 C3                  <1>     ret
   487                              <1> 
   488                              <1> .ehciDelinkOldQHead:
   489                              <1> ;Delinks the old Qhead from the list async list
   490 00003CF5 57                  <1>     push rdi
   491 00003CF6 4150                <1>     push r8
   492 00003CF8 E8AEFFFFFF          <1>     call .ehciGetNewQHeadAddr
   493 00003CFD 4989F8              <1>     mov r8, rdi
   494 00003D00 4981C802000000      <1>     or r8, 2
   495 00003D07 448907              <1>     mov dword [rdi], r8d    ;Point the new qhead to itself
   496 00003D0A 814F0400800000      <1>     or dword [rdi + 4], 8000h   ;Toggle H-bit in the current transacting QHead
   497 00003D11 4158                <1>     pop r8
   498 00003D13 5F                  <1>     pop rdi
   499 00003D14 C3                  <1>     ret
   500                              <1> 
   501                              <1> .ehciLinkNewQHead:
   502                              <1> ;Links the inserted qhead into the async list
   503 00003D15 57                  <1>     push rdi
   504 00003D16 4150                <1>     push r8
   505 00003D18 E88EFFFFFF          <1>     call .ehciGetNewQHeadAddr   ;Get bus addresses
   506 00003D1D 803C25[46020000]01  <1>     cmp byte [eNewBus], 1
   507 00003D25 740F                <1>     je .elnqadjusted   ;If equal, exit
   508 00003D27 4881CF02000000      <1>     or rdi, 2
   509 00003D2E 418938              <1>     mov dword [r8], edi
   510                              <1> .elnqhexit:
   511 00003D31 F8                  <1>     clc
   512 00003D32 4158                <1>     pop r8
   513 00003D34 5F                  <1>     pop rdi
   514 00003D35 C3                  <1>     ret
   515                              <1> ;Only here if a new bus was Adjusted
   516                              <1> .elnqadjusted:
   517                              <1> ;The first qhead in a new queue must always point to itself and be
   518                              <1> ; the head of the reclaim list.
   519                              <1> ;The same address is provided to the function which writes the qhead
   520                              <1> ; and in the above function call into rdi, thus allowing us to point
   521                              <1> ; the new qhead to itself and set the H-bit on, in ALL instances 
   522 00003D36 4989F8              <1>     mov r8, rdi
   523 00003D39 4981C802000000      <1>     or r8, 2
   524 00003D40 448907              <1>     mov dword [rdi], r8d    ;Point the QHead to itself
   525 00003D43 814F0400800000      <1>     or dword [rdi + 4], 8000h   ;Set H bit on
   526 00003D4A 50                  <1>     push rax
   527 00003D4B 8A0425[47020000]    <1>     mov al, byte [eActiveCtrlr]
   528 00003D52 E805160000          <1>     call .ehciGetOpBase
   529 00003D57 67897818            <1>     mov dword [eax + ehciasyncaddr], edi ;Set the address in the ctrlr register
   530 00003D5B 58                  <1>     pop rax
   531 00003D5C E87D010000          <1>     call .ehciStartAsyncSchedule    ;Start schedule
   532 00003D61 7209                <1>     jc .elnqhbad
   533 00003D63 FE0C25[46020000]    <1>     dec byte [eNewBus]  ;Reset back to zero if successfully onlined
   534 00003D6A EBC5                <1>     jmp short .elnqhexit
   535                              <1> .elnqhbad:  ;If Async fails to start, exit
   536 00003D6C 4158                <1>     pop r8
   537 00003D6E 5F                  <1>     pop rdi
   538 00003D6F F9                  <1>     stc
   539 00003D70 C3                  <1>     ret
   540                              <1> 
   541                              <1> .ehciSetNoData:
   542                              <1> ;A function that does a set request with no data phase to the device
   543                              <1> ;at address al.
   544                              <1> ;Input:
   545                              <1> ; al = Address number (7 bit value)
   546                              <1> ; rbx = Setup packet
   547                              <1> ; cx = Max Packet Length 
   548                              <1> ;Returns:
   549                              <1> ; CF = NC if no Host error, CF = CY if Host error
   550                              <1> ; Caller MUST check the schedule to ensure that the transfer was successful,
   551                              <1> ; and without transaction errors as these dont constitute Host system errors.
   552                              <1> ;
   553                              <1> ; All registers except for CF preserved
   554 00003D71 57                  <1>     push rdi
   555 00003D72 4150                <1>     push r8
   556 00003D74 4151                <1>     push r9
   557 00003D76 4152                <1>     push r10
   558 00003D78 4153                <1>     push r11
   559 00003D7A 51                  <1>     push rcx
   560 00003D7B 52                  <1>     push rdx
   561 00003D7C FC                  <1>     cld    ;Set right direction for string ops
   562                              <1>     
   563                              <1>     ;Write setup packet
   564 00003D7D 48891C25[80030000]  <1>     mov qword [ehciDataOut], rbx
   565 00003D85 E821FFFFFF          <1>     call .ehciGetNewQHeadAddr
   566 00003D8A 4981C802000000      <1>     or r8, 2    ;Process qH TDs
   567 00003D91 41B900600080        <1>     mov r9d, 80006000h  ;Bit 15 not set here!!!!! Important
   568 00003D97 0FB7C9              <1>     movzx ecx, cx
   569 00003D9A C1E110              <1>     shl ecx, 8*2
   570 00003D9D 4109C9              <1>     or r9d, ecx
   571 00003DA0 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
   572 00003DA2 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
   573 00003DA5 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
   574 00003DAB 49BB-               <1>     mov r11, ehciTDSpace  ;First TD is the head of the buffer
   574 00003DAD [0001000000000000]  <1>
   575                              <1> 
   576 00003DB5 E827080000          <1>     call .ehciWriteQHead
   577                              <1> 
   578 00003DBA 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
   579 00003DBD 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]    ;Point to next TD
   580 00003DC1 49B901000000000000- <1>     mov r9, 1
   580 00003DCA 00                  <1>
   581 00003DCB 41BA800E0800        <1>     mov r10d, 00080E80h ;Active TD, SETUP EP, Error ctr = 3, 8 byte transfer
   582 00003DD1 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
   582 00003DD3 [8003000000000000]  <1>
   583                              <1> 
   584 00003DDB E826080000          <1>     call .ehciWriteQHeadTD
   585                              <1> 
   586 00003DE0 4881C740000000      <1>     add rdi, ehciSizeOfTD     ;Go to next TD space
   587 00003DE7 49B801000000000000- <1>     mov r8, 1
   587 00003DF0 00                  <1>
   588 00003DF1 4D89C1              <1>     mov r9, r8
   589 00003DF4 41BA808D0080        <1>     mov r10d, 80008D80h        ;Status stage opposite direction of last transfer
   590 00003DFA 49BB-               <1>     mov r11, msdCSW         ;Nothing should be returned but use this point
   590 00003DFC [C005000000000000]  <1>
   591                              <1> 
   592 00003E04 E8FD070000          <1>     call .ehciWriteQHeadTD
   593 00003E09 B103                <1>     mov cl, 011b   ;Lock out internal buffer
   594 00003E0B E9BD000000          <1>     jmp .egddproceed
   595                              <1> 
   596                              <1> .ehciGetRequest:
   597                              <1> ;A function which does a standard get request from a device at
   598                              <1> ;address al.
   599                              <1> ;Input:
   600                              <1> ; al = Address number (7 bit value)
   601                              <1> ; rbx = Setup packet
   602                              <1> ; ecx = Max Packet Length 
   603                              <1> ;Returns:
   604                              <1> ; CF = NC if no Host error, CF = CY if Host error
   605                              <1> ; Caller MUST check the schedule to ensure that the transfer was successful,
   606                              <1> ; and without transaction errors as these dont constitute Host system errors.
   607                              <1> ;
   608                              <1> ; All registers except for CF preserved
   609 00003E10 57                  <1>     push rdi
   610 00003E11 4150                <1>     push r8
   611 00003E13 4151                <1>     push r9
   612 00003E15 4152                <1>     push r10
   613 00003E17 4153                <1>     push r11
   614 00003E19 51                  <1>     push rcx
   615 00003E1A 52                  <1>     push rdx
   616 00003E1B FC                  <1>     cld    ;Ensure right direction
   617                              <1> 
   618                              <1>     ;Write setup packet
   619 00003E1C 48891C25[80030000]  <1>     mov qword [ehciDataOut], rbx
   620 00003E24 E882FEFFFF          <1>     call .ehciGetNewQHeadAddr
   621 00003E29 4981C802000000      <1>     or r8, 2    ;Process qH TDs
   622 00003E30 41B900600080        <1>     mov r9d, 80006000h  ;Bit 15 not set here!!!!! Important
   623 00003E36 0FB7C9              <1>     movzx ecx, cx
   624 00003E39 C1E110              <1>     shl ecx, 8*2
   625 00003E3C 4109C9              <1>     or r9d, ecx
   626 00003E3F 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
   627 00003E41 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
   628 00003E44 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
   629 00003E4A 49BB-               <1>     mov r11, ehciTDSpace  ;First TD is the head of the buffer
   629 00003E4C [0001000000000000]  <1>
   630                              <1>     
   631 00003E54 E888070000          <1>     call .ehciWriteQHead
   632                              <1> 
   633 00003E59 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
   634 00003E5C 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]    ;Point to next TD
   635 00003E60 49B901000000000000- <1>     mov r9, 1
   635 00003E69 00                  <1>
   636 00003E6A 41BA800E0800        <1>     mov r10d, 00080E80h ;Active TD, SETUP EP, Error ctr = 3, 8 byte transfer
   637 00003E70 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
   637 00003E72 [8003000000000000]  <1>
   638                              <1> 
   639 00003E7A E887070000          <1>     call .ehciWriteQHeadTD
   640                              <1> 
   641 00003E7F 4881C740000000      <1>     add rdi, ehciSizeOfTD    ;Go to next TD space
   642 00003E86 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]
   643 00003E8A 4D89C1              <1>     mov r9, r8    ;Alt pointer also points to next TD since this is expected!
   644 00003E8D 41BA800D4080        <1>     mov r10d, 80400D80h ;Active TD, IN EP, Error ctr = 3, max 64 byte transfer
   645 00003E93 49BB-               <1>     mov r11, ehciDataIn
   645 00003E95 [C003000000000000]  <1>
   646                              <1> 
   647 00003E9D E864070000          <1>     call .ehciWriteQHeadTD
   648                              <1> 
   649 00003EA2 4881C740000000      <1>     add rdi, ehciSizeOfTD     ;Go to next TD space
   650 00003EA9 49B801000000000000- <1>     mov r8, 1
   650 00003EB2 00                  <1>
   651 00003EB3 4D89C1              <1>     mov r9, r8
   652 00003EB6 41BA808C0080        <1>     mov r10d, 80008C80h
   653 00003EBC 49BB-               <1>     mov r11, msdCSW
   653 00003EBE [C005000000000000]  <1>
   654                              <1> 
   655 00003EC6 E83B070000          <1>     call .ehciWriteQHeadTD
   656                              <1> 
   657 00003ECB B103                <1>     mov cl, 11b    ;Lock out internal buffer, ignore one interrupt
   658                              <1> ;Now set controller to process the schedule
   659                              <1> .egddproceed:
   660 00003ECD E867000000          <1>     call .ehciProcessCommand
   661                              <1> ;The carry status of the previous function will propagate
   662                              <1> .egddexit:
   663 00003ED2 5A                  <1>     pop rdx
   664 00003ED3 59                  <1>     pop rcx
   665 00003ED4 415B                <1>     pop r11
   666 00003ED6 415A                <1>     pop r10
   667 00003ED8 4159                <1>     pop r9
   668 00003EDA 4158                <1>     pop r8
   669 00003EDC 5F                  <1>     pop rdi
   670 00003EDD C3                  <1>     ret
   671                              <1> 
   672                              <1> .ehciStartAsyncSchedule:
   673 00003EDE 50                  <1>     push rax
   674 00003EDF 51                  <1>     push rcx
   675                              <1> 
   676 00003EE0 8A0425[47020000]    <1>     mov al, byte [eActiveCtrlr]    ;Deals with current active controller
   677 00003EE7 E870140000          <1>     call .ehciGetOpBase            ;Return opregs ADDRESS in eax
   678 00003EEC 67810820000000      <1>     or dword [eax + ehcicmd], 20h    ;Process asyncschedule
   679 00003EF3 31C9                <1>     xor ecx, ecx
   680                              <1> .esas0:
   681 00003EF5 FFC9                <1>     dec ecx
   682 00003EF7 740E                <1>     jz .esasfail
   683 00003EF9 67F7400400800000    <1>     test dword [eax + ehcists], 08000h ;Asyncschedule bit should be on
   684 00003F01 74F2                <1>     jz .esas0
   685                              <1> 
   686 00003F03 F8                  <1>     clc
   687                              <1> .esasok:
   688 00003F04 59                  <1>     pop rcx
   689 00003F05 58                  <1>     pop rax
   690 00003F06 C3                  <1>     ret
   691                              <1> .esasfail:
   692 00003F07 F9                  <1>     stc
   693 00003F08 EBFA                <1>     jmp short .esasok
   694                              <1> 
   695                              <1> .ehciStopAsyncSchedule:
   696                              <1> ;This function stops the processing of the current active Async Schedule
   697                              <1> ;Output: CF=CY: Failed to stop Async Schedule CF=NC: Stopped Async Schedule
   698 00003F0A 50                  <1>     push rax
   699 00003F0B 51                  <1>     push rcx
   700 00003F0C 8A0425[47020000]    <1>     mov al, byte [eActiveCtrlr]    ;Deals with current active controller
   701 00003F13 E844140000          <1>     call .ehciGetOpBase            ;Return opregs ADDRESS in eax
   702 00003F18 6631C9              <1>     xor cx, cx
   703 00003F1B 678120DFFFFFFF      <1>     and dword [eax + ehcicmd], 0FFFFFFDFh ;Stop processing async
   704                              <1> .espc0:
   705 00003F22 66FFC9              <1>     dec cx
   706 00003F25 740E                <1>     jz .espcfail
   707 00003F27 67F7400400800000    <1>     test dword [eax + ehcists], 08000h
   708 00003F2F 75F1                <1>     jnz .espc0
   709                              <1> 
   710 00003F31 F8                  <1>     clc
   711 00003F32 59                  <1>     pop rcx
   712 00003F33 58                  <1>     pop rax
   713 00003F34 C3                  <1>     ret
   714                              <1> .espcfail:
   715 00003F35 F9                  <1>     stc
   716 00003F36 59                  <1>     pop rcx
   717 00003F37 58                  <1>     pop rax
   718 00003F38 C3                  <1>     ret
   719                              <1> 
   720                              <1> .ehciProcessCommand:
   721                              <1> ; Allows EHCI async schedule to process commands.
   722                              <1> ; Preserves all registers except CF
   723                              <1> ; Returns: CF=CY if error detected 
   724                              <1> ;          CF=NC if no error detected
   725                              <1> ;
   726                              <1> ; If returned with CF=CY, caller must read the msdStatus byte
   727 00003F39 50                  <1>     push rax
   728 00003F3A 53                  <1>     push rbx
   729 00003F3B 51                  <1>     push rcx
   730 00003F3C 57                  <1>     push rdi
   731                              <1> 
   732 00003F3D 880C25[49020000]    <1>     mov byte [eAsyncMutex], cl  ;Set mutex
   733 00003F44 8A0425[47020000]    <1>     mov al, byte [eActiveCtrlr]    ;Deals with current active controller
   734 00003F4B E80C140000          <1>     call .ehciGetOpBase            ;Return opregs ADDRESS in eax
   735 00003F50 4889C3              <1>     mov rbx, rax
   736 00003F53 66BF8813            <1>     mov di, 5000
   737 00003F57 E8B9FDFFFF          <1>     call .ehciLinkNewQHead
   738 00003F5C 0F82A1000000        <1>     jc .epcfailedstart
   739                              <1> .epc1:
   740 00003F62 67F7430413000000    <1>     test dword [ebx + ehcists], 13h
   741 00003F6A 7516                <1>     jnz .epc2     ;If bits we care about are set, call IRQ proceedure
   742 00003F6C F390                <1>     pause       
   743 00003F6E 66FFCF              <1>     dec di
   744 00003F71 0F849F000000        <1>     jz .epcfailtimeout
   745 00003F77 B486                <1>     mov ah, 86h
   746 00003F79 B901000000          <1>     mov ecx, 1    ;Max 5s in 1ms chunks
   747 00003F7E CD35                <1>     int 35h
   748 00003F80 EBE0                <1>     jmp short .epc1
   749                              <1> .epc2:
   750 00003F82 89D8                <1>     mov eax, ebx    ;Get opreg base into eax before we proceed into IRQ handler
   751 00003F84 E8F1CBFFFF          <1>     call ehci_IRQ.nonIRQep ;Manually call IRQ
   752 00003F89 F60425[48020000]10  <1>     test byte [eActiveInt], 10h ;HC error bit
   753 00003F91 7578                <1>     jnz .epcHostError   ;HC error detected
   754 00003F93 F60425[49020000]00  <1>     test byte [eAsyncMutex], 0
   755 00003F9B 75C5                <1>     jnz .epc1    ;If the mutex isnt cleared, go back to sts check
   756 00003F9D E853FDFFFF          <1>     call .ehciDelinkOldQHead   ;Perform delink
   757 00003FA2 E826FDFFFF          <1>     call .ehciToggleTransactingQHead    ;Toggle the active Qheads
   758                              <1> ;Now set doorbell
   759 00003FA7 67810B40000000      <1>     or dword [ebx + ehcicmd], 40h   ;Ring Doorbell
   760 00003FAE 66BF8813            <1>     mov di, 5000
   761                              <1> .epc3:
   762 00003FB2 67F7430420000000    <1>     test dword [ebx + ehcists], 20h ;Test for doorbell set high
   763 00003FBA 7512                <1>     jnz .epc4
   764 00003FBC F390                <1>     pause
   765 00003FBE 66FFCF              <1>     dec di
   766 00003FC1 7440                <1>     jz .epcfaildelinked
   767 00003FC3 B486                <1>     mov ah, 86h
   768 00003FC5 B901000000          <1>     mov ecx, 1    ;Max 5s in 1ms chunks
   769 00003FCA CD35                <1>     int 35h
   770 00003FCC EBE4                <1>     jmp short .epc3
   771                              <1> .epc4:
   772                              <1> ;Clear once more to clear the doorbell bit
   773 00003FCE 678B4B04            <1>     mov ecx, dword [ebx + ehcists]  
   774 00003FD2 67094B04            <1>     or dword  [ebx + ehcists], ecx    ;WC high bits
   775                              <1> ;Check if it was a stall
   776 00003FD6 F60425[48020000]02  <1>     test byte [eActiveInt], 2h  ;Check USBError bit
   777 00003FDE 7509                <1>     jnz .epcexit
   778 00003FE0 C60425[A9010000]00  <1>     mov byte [msdStatus], 00h   ;No error... yet
   779 00003FE8 F8                  <1>     clc
   780                              <1> .epcexit:
   781 00003FE9 5F                  <1>     pop rdi
   782 00003FEA 59                  <1>     pop rcx
   783 00003FEB 5B                  <1>     pop rbx
   784 00003FEC 58                  <1>     pop rax
   785 00003FED C3                  <1>     ret 
   786                              <1> .epcStall:
   787 00003FEE C60425[A9010000]21  <1>     mov byte [msdStatus], 21h   ;General Controller Failure - Stall
   788 00003FF6 F9                  <1>     stc
   789 00003FF7 EBF0                <1>     jmp short .epcexit
   790                              <1> .epcfail:
   791 00003FF9 E8F7FCFFFF          <1>     call .ehciDelinkOldQHead   ;Perform delink
   792 00003FFE E8CAFCFFFF          <1>     call .ehciToggleTransactingQHead    ;Toggle the active Qheads
   793                              <1> .epcfailedstart: ;No need to delink as that data structure is considered garbage
   794                              <1> .epcfaildelinked:
   795 00004003 678B4B04            <1>     mov ecx, dword [ebx + ehcists]
   796 00004007 67094B04            <1>     or dword  [ebx + ehcists], ecx    ;WC selected bits
   797                              <1> .epcHostError:  ;Host error detected in interrupt register
   798 0000400B C60425[A9010000]20  <1>     mov byte [msdStatus], 20h   ;General Controller Error
   799 00004013 F9                  <1>     stc
   800 00004014 EBD3                <1>     jmp short .epcexit
   801                              <1> .epcfailtimeout:
   802                              <1> ;Called in the event that the schedule fails to process the QHead.
   803                              <1> ;Emergency stops the currently transacting schedule
   804 00004016 E8DAFCFFFF          <1>     call .ehciDelinkOldQHead   ;Perform delink
   805 0000401B E8ADFCFFFF          <1>     call .ehciToggleTransactingQHead    ;Toggle the active Qheads
   806 00004020 678B4B04            <1>     mov ecx, dword [ebx + ehcists]
   807 00004024 67094B04            <1>     or dword  [ebx + ehcists], ecx    ;WC selected bits
   808 00004028 C60425[A9010000]80  <1>     mov byte [msdStatus], 80h   ;Timeout Error
   809 00004030 F9                  <1>     stc
   810 00004031 EBB6                <1>     jmp short .epcexit  ;Delink
   811                              <1> 
   812                              <1> .ehciEnumerateRootPort:
   813                              <1> ;This function discovers whether a device is of a valid type
   814                              <1> ;or not.
   815                              <1> ;Input: dl=port number - 1 (0 based), dh = bus [0-3]
   816                              <1> ;       r10b = Host hub address (if the device is on a hub, 0 else)
   817                              <1> ;Output:     CF=CY if error, CF=NC if bus transaction occured 
   818                              <1> ;           ZF=ZR if passed enum: ah = bus number, al = Address number
   819                              <1> ;            ZF=NZ if the device failed enumeration: ax=error code
   820                              <1> ;                ah = Enum stage, al = Sub function stage
   821 00004033 53                  <1>     push rbx
   822 00004034 51                  <1>     push rcx
   823 00004035 52                  <1>     push rdx
   824 00004036 55                  <1>     push rbp
   825 00004037 4150                <1>     push r8
   826 00004039 4151                <1>     push r9
   827 0000403B 4152                <1>     push r10
   828 0000403D 4153                <1>     push r11
   829                              <1> 
   830                              <1> .eebinit:
   831 0000403F 6631ED              <1>     xor bp, bp    ;Use as error counter    (Stage 0)
   832 00004042 88D0                <1>     mov al, dl
   833 00004044 E818FAFFFF          <1>     call .ehciResetControllerPort    ;Reset port
   834 00004049 0F828C010000        <1>     jc .ehciedbadnotimeout
   835                              <1> ;Power on debounce!
   836 0000404F B9C8000000          <1>     mov ecx, debounceperiod    ;debounce period
   837 00004054 B486                <1>     mov ah, 86h
   838 00004056 CD35                <1>     int 35h
   839                              <1> 
   840 00004058 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 1)
   841                              <1> .eeb0:
   842 0000405B 48BB80060001000008- <1>     mov rbx, 00008000001000680h    ;Pass get minimal device descriptor
   842 00004064 00                  <1>
   843 00004065 48891C25[80030000]  <1>     mov qword [ehciDataOut], rbx
   844 0000406D 66B94000            <1>     mov cx, 40h    ;Pass default endpoint size
   845 00004071 30C0                <1>     xor al, al
   846 00004073 E898FDFFFF          <1>     call .ehciGetRequest
   847 00004078 0F8245010000        <1>     jc .ehciedexit  ;Fast exit with carry set
   848                              <1> .eeb1:
   849 0000407E 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 2)
   850 00004081 30C0                <1>     xor al, al    ;Increment Error subcounter    (Substage 0)
   851 00004083 48BB-               <1>     mov rbx, ehciDataIn
   851 00004085 [C003000000000000]  <1>
   852 0000408D 807B0101            <1>     cmp byte [rbx + 1], 01h    ;Verify this is a valid dev descriptor
   853 00004091 0F8539010000        <1>     jne .ehciedbad
   854 00004097 FEC0                <1>     inc al    ;Increment Error subcounter    (Substage 1)
   855 00004099 66817B020002        <1>     cmp word [rbx + 2], 0200h    ;Verify this is a USB 2.0 device or above
   856 0000409F 0F822B010000        <1>     jb .ehciedbad
   857 000040A5 FEC0                <1>     inc al    ;Increment Error subcounter    (Substage 2)
   858 000040A7 807B0400            <1>     cmp byte [rbx + 4], 0    ;Check interfaces
   859 000040AB 7410                <1>     je .eeb2
   860 000040AD 807B0408            <1>     cmp byte [rbx + 4], 08h    ;MSD?
   861 000040B1 740A                <1>     je .eeb2
   862 000040B3 807B0409            <1>     cmp byte [rbx + 4], 09h    ;Hub?
   863 000040B7 0F8513010000        <1>     jne .ehciedbad
   864                              <1> .eeb2:
   865 000040BD 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 3)
   866 000040C0 440FB64307          <1>     movzx r8d, byte [rbx + 7]    ;Byte 7 is MaxPacketSize0, save in r8b
   867 000040C5 88D0                <1>     mov al, dl
   868                              <1> 
   869 000040C7 E895F9FFFF          <1>     call .ehciResetControllerPort    ;Reset port again
   870 000040CC 0F82FE000000        <1>     jc .ehciedbad
   871 000040D2 49BB0A000000000000- <1>     mov r11, 10
   871 000040DB 00                  <1>
   872                              <1> .ehciEnumCommonEp:
   873 000040DC 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 4)
   874 000040DF 88F0                <1>     mov al, dh    ;Put bus number into al
   875                              <1> 
   876 000040E1 E825030000          <1>     call .ehciGiveValidAddress    ;Get a valid address for device
   877 000040E6 3C80                <1>     cmp al, 80h    
   878 000040E8 0F83E2000000        <1>     jae .ehciedbad    ;Invalid address
   879                              <1> 
   880 000040EE 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 5)
   881 000040F1 4188C1              <1>     mov r9b, al        ;Save the new device address number in r9b
   882                              <1> .eeb3:
   883 000040F4 BB00050000          <1>     mov ebx, 0500h    ;Set address function
   884 000040F9 410FB6C9            <1>     movzx ecx, r9b    ;move new address into ecx
   885 000040FD C1E110              <1>     shl ecx, 8*2
   886 00004100 09CB                <1>     or ebx, ecx    ;Add address number to ebx
   887 00004102 664489C1            <1>     mov cx, r8w    ;Move endpoint size into cx
   888 00004106 30C0                <1>     xor al, al    ;Device still talks on address 0, ax not preserved
   889 00004108 E864FCFFFF          <1>     call .ehciSetNoData    ;Set address
   890 0000410D 0F82B0000000        <1>     jc .ehciedexit  ;Fast exit with carry set
   891                              <1> .eeb4:
   892 00004113 B486                <1>     mov ah, 86h
   893 00004115 4C89D9              <1>     mov rcx, r11
   894 00004118 CD35                <1>     int 35h
   895                              <1> 
   896 0000411A 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 6)
   897                              <1> .eeb5:
   898 0000411D 48BB80060001000012- <1>     mov rbx, 00012000001000680h    ;Now get full device descriptor
   898 00004126 00                  <1>
   899 00004127 4488C8              <1>     mov al, r9b    ;Get address
   900 0000412A 664489C1            <1>     mov cx, r8w
   901 0000412E E8DDFCFFFF          <1>     call .ehciGetRequest    ;Get full device descriptor and discard
   902 00004133 0F828A000000        <1>     jc .ehciedexit  ;Fast exit with carry set
   903 00004139 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 7/0Bh)
   904                              <1> .eeb6:
   905 0000413C 48BB80060002000000- <1>     mov rbx, 00000000002000680h ;Get config descriptor
   905 00004145 00                  <1>
   906 00004146 4489C1              <1>     mov ecx, r8d    ;Adjust the packet data with bMaxPacketSize0
   907 00004149 48C1E130            <1>     shl rcx, 8*6    ;cx contains bMaxPacketSize0
   908 0000414D 4809CB              <1>     or rbx, rcx
   909 00004150 4488C8              <1>     mov al, r9b    ;Get address
   910 00004153 664489C1            <1>     mov cx, r8w    ;Move endpoint size into cx
   911 00004157 E8B4FCFFFF          <1>     call .ehciGetRequest
   912 0000415C 7265                <1>     jc .ehciedexit  ;Fast exit with carry set
   913                              <1> .eeb7:
   914 0000415E 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 8/0Ch)
   915                              <1> ;Find a valid interface in this config
   916 00004161 E8CB020000          <1>     call .ehciFindValidInterface
   917 00004166 7268                <1>     jc .ehciedbad    ;Dont set config, exit bad
   918                              <1> ;If success, ah has device type (0=msd, 1=hub), al = Interface to use
   919                              <1> ;rbx points to interface descriptor
   920 00004168 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 9/0Dh)
   921 0000416B E889000000          <1>     call .ehciAddDeviceToTables
   922 00004170 725E                <1>     jc .ehciedbad    ;Failed to be added to internal tables
   923 00004172 FE0425[35020000]    <1>     inc byte [usbDevices]   ;Device added successfully, inc byte
   924                              <1> ;Set configuration 1 (wie OG Windows, consider upgrading soon)
   925 00004179 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 0Ah/0Ch)
   926                              <1> .eeb8:
   927 0000417C 48BB00090100000000- <1>     mov rbx, 00000000000010900h    ;Set configuration 1 (function 09h)
   927 00004185 00                  <1>
   928 00004186 4488C8              <1>     mov al, r9b    ;Get address
   929 00004189 664489C1            <1>     mov cx, r8w    ;Move endpoint size into cx
   930 0000418D E8DFFBFFFF          <1>     call .ehciSetNoData
   931 00004192 722F                <1>     jc .ehciedexit  ;Fast exit with carry set
   932                              <1> .eeb9:
   933 00004194 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 0Bh/0Dh)
   934                              <1> .eeb10:
   935 00004197 48BB80080000000001- <1>     mov rbx, 0001000000000880h  ;Get device config (sanity check)
   935 000041A0 00                  <1>
   936 000041A1 410FB7C8            <1>     movzx ecx, r8w              ;bMaxPacketSize0
   937 000041A5 4488C8              <1>     mov al, r9b                 ;Get device address
   938 000041A8 E863FCFFFF          <1>     call .ehciGetRequest
   939 000041AD 7214                <1>     jc .ehciedexit  ;Fast exit with carry set
   940                              <1> .eeb11:
   941 000041AF 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 0Ch/0Eh)
   942 000041B2 803C25[C0030000]01  <1>     cmp byte [ehciDataIn], 01
   943 000041BA 7531                <1>     jne .ehcibadremtables
   944                              <1> ;Device is now configured and ready to go to set/reset
   945 000041BC 88F4                <1>     mov ah, dh  ;Move bus number
   946 000041BE 4488C8              <1>     mov al, r9b ;Move address number
   947 000041C1 31D2                <1>     xor edx, edx  ;This will always set the zero flag
   948                              <1> .ehciedexit:
   949 000041C3 415B                <1>     pop r11
   950 000041C5 415A                <1>     pop r10
   951 000041C7 4159                <1>     pop r9
   952 000041C9 4158                <1>     pop r8
   953 000041CB 5D                  <1>     pop rbp
   954 000041CC 5A                  <1>     pop rdx
   955 000041CD 59                  <1>     pop rcx
   956 000041CE 5B                  <1>     pop rbx
   957 000041CF C3                  <1>     ret
   958                              <1> .ehciedbad:
   959                              <1> .ehciedbadnoport:
   960 000041D0 50                  <1>     push rax
   961 000041D1 B486                <1>     mov ah, 86h
   962 000041D3 B9F4010000          <1>     mov ecx, 500    ;500 ms wait between failed attempts
   963 000041D8 CD35                <1>     int 35h
   964 000041DA 58                  <1>     pop rax
   965                              <1> .ehciedbadnotimeout:
   966 000041DB 88C4                <1>     mov ah, al    ;Save subproc error code
   967 000041DD 30C0                <1>     xor al, al    ;Zero byte
   968 000041DF 6609E8              <1>     or ax, bp    ;Add proc error stage code into al
   969 000041E2 86E0                <1>     xchg ah, al
   970 000041E4 6631ED              <1>     xor bp, bp
   971 000041E7 66FFC5              <1>     inc bp      ;This will always clear the Zero flag
   972 000041EA F8                  <1>     clc         ;This will force clear the Carry flag
   973 000041EB EBD6                <1>     jmp short .ehciedexit
   974                              <1> .ehcibadremtables:
   975 000041ED 4488C8              <1>     mov al, r9b ;Get address low
   976 000041F0 88F4                <1>     mov ah, dh  
   977 000041F2 E87F010000          <1>     call .ehciRemoveDevFromTables
   978 000041F7 EBE2                <1>     jmp short .ehciedbadnotimeout
   979                              <1> 
   980                              <1> .ehciAddDeviceToTables:
   981                              <1> ;This function adds a valid device to the internal tables.
   982                              <1> ;Interrupts are off for this to avoid dead entries
   983                              <1> ;Input: ah = device type (0=msd, 1=hub)
   984                              <1> ;       al = Interface Value to use (USB bInterfaceNumber)
   985                              <1> ;       rbx = Ptr to valid Interface descriptor
   986                              <1> ;       r8b = MaxPacketSize0
   987                              <1> ;       r9b = Device Address
   988                              <1> ;       dh = Bus number
   989                              <1> ;       dl = Physical Port number - 1
   990                              <1> ;       r10b = Host hub address
   991 000041F9 4153                <1>     push r11
   992 000041FB 55                  <1>     push rbp    ;Error counter
   993 000041FC 57                  <1>     push rdi
   994 000041FD 53                  <1>     push rbx
   995 000041FE 52                  <1>     push rdx
   996 000041FF 9C                  <1>     pushfq
   997 00004200 FEC2                <1>     inc dl      ;Add one to the Physical port number (kludge for root hub enum)
   998 00004202 6631ED              <1>     xor bp, bp  ;Zero error counter (Stage 0)
   999 00004205 B90A000000          <1>     mov ecx, usbMaxDevices
  1000 0000420A 380C25[35020000]    <1>     cmp byte [usbDevices], cl   ;Max number of devices, check
  1001 00004211 0F8458010000        <1>     je .eadttbad        ;If max, fail
  1002 00004217 66FFC5              <1>     inc bp      ;Increment error counter (Stage 1)
  1003 0000421A 48BF-               <1>     mov rdi, usbDevTbl
  1003 0000421C [4C02000000000000]  <1>
  1004 00004224 B10A                <1>     mov cl, usbDevTblE  ;Within the length of the table
  1005                              <1> ;Write Common table first
  1006                              <1> .eadtt0:
  1007 00004226 800F00              <1>     or byte [rdi], 0   ;Check if there exists a free entry
  1008 00004229 7411                <1>     jz .eadtt1
  1009 0000422B 4881C703000000      <1>     add rdi, usbDevTblEntrySize ;Go to next entry
  1010 00004232 FEC9                <1>     dec cl
  1011 00004234 0F8435010000        <1>     jz .eadttbad
  1012 0000423A EBEA                <1>     jmp short .eadtt0
  1013                              <1> .eadtt1:
  1014 0000423C 66FFC5              <1>     inc bp      ;Increment error counter (Stage 2)
  1015 0000423F 80C408              <1>     add ah, 08h ;hub is 09h
  1016                              <1> ;Add device here, rdi points to entry
  1017 00004242 44880F              <1>     mov byte [rdi], r9b
  1018 00004245 887701              <1>     mov byte [rdi + 1], dh
  1019 00004248 886702              <1>     mov byte [rdi + 2], ah
  1020                              <1> ;Entry written
  1021 0000424B 66FFC5              <1>     inc bp      ;Increment error counter (Stage 3)
  1022                              <1> ;Individual Device table writing
  1023 0000424E 80FC08              <1>     cmp ah, 08h
  1024 00004251 740E                <1>     je .eadttmsd
  1025 00004253 80FC09              <1>     cmp ah, 09h
  1026 00004256 0F84C9000000        <1>     je .eadtthub
  1027 0000425C E90E010000          <1>     jmp .eadttbad
  1028                              <1> .eadttmsd:
  1029 00004261 48BF-               <1>     mov rdi, msdDevTbl
  1029 00004263 [BA02000000000000]  <1>
  1030 0000426B B10A                <1>     mov cl, msdDevTblE  ;Max entries possible
  1031 0000426D 66FFC5              <1>     inc bp      ;Increment error counter (Stage 4)
  1032                              <1> .eadttmsd0:
  1033 00004270 800F00              <1>     or byte [rdi], 0
  1034 00004273 7411                <1>     jz .eadttmsd1
  1035 00004275 4881C710000000      <1>     add rdi, msdDevTblEntrySize
  1036 0000427C FEC9                <1>     dec cl
  1037 0000427E 0F84EB000000        <1>     jz .eadttbad
  1038 00004284 EBEA                <1>     jmp short .eadttmsd0
  1039                              <1> .eadttmsd1:
  1040                              <1> ;rdi points to correct offset into table
  1041                              <1> ;rbx points to interface
  1042 00004286 8A4B04              <1>     mov cl, byte [rbx + 4]   ;Get number of endpoints to check
  1043 00004289 88CD                <1>     mov ch, cl
  1044 0000428B 66FFC5              <1>     inc bp      ;Increment error counter (Stage 5)
  1045 0000428E 4989DB              <1>     mov r11, rbx    ;Save Interface Pointer in r11
  1046 00004291 4881C309000000      <1>     add rbx, 9  ;Go to first IF
  1047                              <1> .eadttmsd11:
  1048 00004298 50                  <1>     push rax
  1049 00004299 668B4302            <1>     mov ax, word [rbx + 2]
  1050 0000429D 66C1E804            <1>     shr ax, 4   ;Remove low 4 bits
  1051 000042A1 663D2800            <1>     cmp ax, 28h     ;Bulk/In bits
  1052 000042A5 58                  <1>     pop rax         ;Doesnt ruin flags
  1053 000042A6 7411                <1>     je .eadttmsd2   ;Not zero only if valid
  1054 000042A8 4881C307000000      <1>     add rbx, 7   ;Go to next endpoint
  1055 000042AF FEC9                <1>     dec cl
  1056 000042B1 0F84B8000000        <1>     jz .eadttbad
  1057 000042B7 EBDF                <1>     jmp short .eadttmsd11
  1058                              <1> .eadttmsd2:
  1059 000042B9 44880F              <1>     mov byte [rdi], r9b      ;Device Address
  1060 000042BC 887701              <1>     mov byte [rdi + 1], dh   ;Root hub/bus
  1061 000042BF 44885702            <1>     mov byte [rdi + 2], r10b ;Address of parent device if not root
  1062 000042C3 885703              <1>     mov byte [rdi + 3], dl   ;Port number we are inserted in
  1063 000042C6 884704              <1>     mov byte [rdi + 4], al   ;Save Interface number
  1064 000042C9 418A4306            <1>     mov al, byte [r11 + 6]   ;bInterfaceSubclass is +6
  1065 000042CD 884705              <1>     mov byte [rdi + 5], al
  1066 000042D0 418A4307            <1>     mov al, byte [r11 + 7]   ;Protocol
  1067 000042D4 884706              <1>     mov byte [rdi + 6], al
  1068 000042D7 44884707            <1>     mov byte [rdi + 7], r8b  ;MaxPacketSize0
  1069                              <1> ;Valid In EP found, write table entries
  1070 000042DB 8A4302              <1>     mov al, byte [rbx + 2]  ;Get address
  1071 000042DE 884708              <1>     mov byte [rdi + 8], al
  1072 000042E1 668B4304            <1>     mov ax, word [rbx + 4]  ;Get maxPacketSizeIn
  1073 000042E5 66894709            <1>     mov word [rdi + 9], ax
  1074                              <1> 
  1075 000042E9 498D5B09            <1>     lea rbx, qword [r11 + 9]   ;Return rbx to first IF
  1076 000042ED 66FFC5              <1>     inc bp      ;Increment error counter (Stage 6)
  1077                              <1> .eadttmsd21:
  1078 000042F0 668B4302            <1>     mov ax, word [rbx + 2]  ;Bulk/Out bits
  1079 000042F4 66C1E804            <1>     shr ax, 4
  1080 000042F8 663D2000            <1>     cmp ax, 20h
  1081 000042FC 740D                <1>     je .eadttmsd3   ;Not zero only if valid
  1082 000042FE 4881C307000000      <1>     add rbx, 7   ;Go to next endpoint
  1083 00004305 FECD                <1>     dec ch
  1084 00004307 7466                <1>     jz .eadttbad
  1085 00004309 EBE5                <1>     jmp short .eadttmsd21
  1086                              <1> .eadttmsd3:
  1087 0000430B 8A4302              <1>     mov al, byte [rbx + 2]  ;Get address
  1088 0000430E 88470B              <1>     mov byte [rdi + 11], al
  1089 00004311 668B4304            <1>     mov ax, word [rbx + 4]  ;Get maxPacketSizeIn
  1090 00004315 6689470C            <1>     mov word [rdi + 12], ax
  1091 00004319 6631C0              <1>     xor ax, ax  ;Zero ax
  1092 0000431C 6689470E            <1>     mov word [rdi + 14], ax ;Make dt bits for I/O EPs zero
  1093                              <1> ;Table entry written for MSD device
  1094 00004320 E93F000000          <1>     jmp .eadttpass
  1095                              <1> .eadtthub:
  1096 00004325 48BF-               <1>     mov rdi, hubDevTbl
  1096 00004327 [6A02000000000000]  <1>
  1097 0000432F B10A                <1>     mov cl,  hubDevTblE ;Max entries possible
  1098 00004331 66BD0700            <1>     mov bp, 7      ;Increment error counter (Stage 7)
  1099                              <1> .eadtthub0:
  1100 00004335 800F00              <1>     or byte [rdi], 0
  1101 00004338 740D                <1>     jz .eadtthub1
  1102 0000433A 4881C708000000      <1>     add rdi, hubDevTblEntrySize
  1103 00004341 FEC9                <1>     dec cl
  1104 00004343 742A                <1>     jz .eadttbad
  1105 00004345 EBEE                <1>     jmp short .eadtthub0
  1106                              <1> .eadtthub1:
  1107                              <1> ;Valid table space found
  1108 00004347 44880F              <1>     mov byte [rdi], r9b      ;Device Address
  1109 0000434A 887701              <1>     mov byte [rdi + 1], dh   ;Root hub/bus
  1110 0000434D 44885702            <1>     mov byte [rdi + 2], r10b ;Address of parent device if not root
  1111 00004351 885703              <1>     mov byte [rdi + 3], dl   ;Port number we are inserted in
  1112 00004354 44884704            <1>     mov byte [rdi + 4], r8b  ;MaxPacketSize0
  1113 00004358 66B800FF            <1>     mov ax, 0FF00h  ;Res byte is 0FFh, Num ports (byte 6) is 0
  1114 0000435C 66894705            <1>     mov word [rdi + 5], ax   ;Number of ports and PowerOn2PowerGood
  1115 00004360 C64707FF            <1>     mov byte [rdi + 7], 0FFh    ;EP address, currently reserved
  1116                              <1> .eadttpass:
  1117 00004364 9D                  <1>     popfq   ;If IF was clear, it will be set clear by popf
  1118 00004365 6631C0              <1>     xor ax, ax  ;Clear ax and clc
  1119                              <1> .eadttexit:
  1120 00004368 5A                  <1>     pop rdx
  1121 00004369 5B                  <1>     pop rbx
  1122 0000436A 5F                  <1>     pop rdi
  1123 0000436B 5D                  <1>     pop rbp
  1124 0000436C 415B                <1>     pop r11
  1125 0000436E C3                  <1>     ret
  1126                              <1> .eadttbad:
  1127 0000436F 9D                  <1>     popfq   ;If IF was clear, it will be set clear by popf
  1128 00004370 F9                  <1>     stc
  1129 00004371 6689E8              <1>     mov ax, bp
  1130 00004374 EBF2                <1>     jmp short .eadttexit
  1131                              <1> .ehciRemoveDevFromTables:
  1132                              <1> ;This function removes a function from internal tables
  1133                              <1> ;Input: al = Address number, ah = Bus number
  1134                              <1> ;Output: Internal tables zeroed out, ax destroyed, Carry clear
  1135                              <1> ;    If invalid argument, Carry set
  1136 00004376 57                  <1>     push rdi
  1137 00004377 51                  <1>     push rcx
  1138 00004378 53                  <1>     push rbx
  1139 00004379 48BF-               <1>     mov rdi, usbDevTbl
  1139 0000437B [4C02000000000000]  <1>
  1140 00004383 B10A                <1>     mov cl, usbDevTblE    ;10 entries possible
  1141                              <1> .erdft0:
  1142 00004385 66AF                <1>     scasw
  1143 00004387 7409                <1>     je .erdft1    ;Device signature found
  1144 00004389 48FFC7              <1>     inc rdi
  1145 0000438C FEC9                <1>     dec cl
  1146 0000438E 7478                <1>     jz .erdftbad
  1147 00004390 EBF3                <1>     jmp short .erdft0
  1148                              <1> .erdft1:
  1149 00004392 4881EF02000000      <1>     sub rdi, 2  ;scasw pointers to the next word past the comparison
  1150 00004399 8A6702              <1>     mov ah, byte [rdi + 2]    ;Save class code in ah
  1151 0000439C 80FC08              <1>     cmp ah, 08h ;USB MSD Class device
  1152 0000439F 7507                <1>     jne .erdft11    ;Skip the dec if it is a hub class device
  1153 000043A1 FE0C25[4B020000]    <1>     dec byte [numMSD]   ;Device is being removed from tables, decrement count
  1154                              <1> .erdft11:
  1155                              <1> ;Clear usbDevTbl entry for usb device
  1156 000043A8 50                  <1>     push rax
  1157 000043A9 B903000000          <1>     mov ecx, usbDevTblEntrySize    ;Table entry size
  1158 000043AE 30C0                <1>     xor al, al
  1159 000043B0 F3AA                <1>     rep stosb    ;Store zeros for entry
  1160 000043B2 58                  <1>     pop rax
  1161                              <1> 
  1162 000043B3 48BB-               <1>     mov rbx, hubDevTbl
  1162 000043B5 [6A02000000000000]  <1>
  1163 000043BD 48B9-               <1>     mov rcx, msdDevTbl
  1163 000043BF [BA02000000000000]  <1>
  1164 000043C7 80FC09              <1>     cmp ah, 09h
  1165 000043CA 480F44CB            <1>     cmove rcx, rbx ;If 09h (Hub), change table pointed to by rcx
  1166 000043CE 4889CF              <1>     mov rdi, rcx    ;Point rdi to appropriate table
  1167 000043D1 BB08000000          <1>     mov ebx, hubDevTblEntrySize    ;Size of hub table entry
  1168 000043D6 B910000000          <1>     mov ecx, msdDevTblEntrySize    ;Size of msd table entry
  1169 000043DB 80FC09              <1>     cmp ah, 09h
  1170 000043DE 0F44CB              <1>     cmove ecx, ebx    ;If hub, move size into cx
  1171                              <1> ;cx has entry size, rdi points to appropriate table
  1172 000043E1 4889FB              <1>     mov rbx, rdi
  1173 000043E4 31FF                <1>     xor edi, edi
  1174 000043E6 29CF                <1>     sub edi, ecx
  1175 000043E8 B411                <1>     mov ah, 11h
  1176                              <1> .erdft2:
  1177 000043EA FECC                <1>     dec ah
  1178 000043EC 741A                <1>     jz .erdftbad    ;Somehow, address not found
  1179 000043EE 01CF                <1>     add edi, ecx
  1180 000043F0 3A043B              <1>     cmp al, byte [rbx + rdi]
  1181 000043F3 75F5                <1>     jne .erdft2
  1182 000043F5 4801DF              <1>     add rdi, rbx    ;point rdi to table entry
  1183 000043F8 30C0                <1>     xor al, al
  1184 000043FA F3AA                <1>     rep stosb    ;ecx contains table entry size in bytes
  1185 000043FC FE0C25[35020000]    <1>     dec byte [usbDevices]   ;Decrement total usb devices
  1186 00004403 F8                  <1>     clc
  1187                              <1> .erdftexit:
  1188 00004404 5B                  <1>     pop rbx
  1189 00004405 59                  <1>     pop rcx
  1190 00004406 5F                  <1>     pop rdi
  1191 00004407 C3                  <1>     ret
  1192                              <1> .erdftbad:
  1193 00004408 F9                  <1>     stc
  1194 00004409 EBF9                <1>     jmp short .erdftexit 
  1195                              <1> .ehciGiveValidAddress:
  1196                              <1> ;This function will return a valid value to use as an address
  1197                              <1> ;for a new device.
  1198                              <1> ;Input: al = Controller number [0-3]
  1199                              <1> ;Output: al = Address, or 80h => No valid available address
  1200 0000440B 57                  <1>     push rdi
  1201 0000440C 51                  <1>     push rcx
  1202 0000440D 88C4                <1>     mov ah, al    ;Move bus number high
  1203 0000440F B000                <1>     mov al, 0 ;Address 0, start at addr 1
  1204                              <1> .egva0:
  1205 00004411 FEC0                <1>     inc al
  1206 00004413 3C80                <1>     cmp al, 80h
  1207 00004415 7317                <1>     jae .egvaexit
  1208 00004417 48BF-               <1>     mov rdi, usbDevTbl
  1208 00004419 [4C02000000000000]  <1>
  1209 00004421 B10A                <1>     mov cl, usbDevTblE    ;10 entries possible
  1210                              <1> .egva1:
  1211 00004423 66AF                <1>     scasw
  1212 00004425 74EA                <1>     je .egva0
  1213 00004427 48FFC7              <1>     inc rdi    ;Pass third byte in table entry
  1214 0000442A FEC9                <1>     dec cl
  1215 0000442C 75F5                <1>     jnz .egva1    ;Check every entry for any addresses being used
  1216                              <1> .egvaexit:
  1217 0000442E 59                  <1>     pop rcx
  1218 0000442F 5F                  <1>     pop rdi
  1219 00004430 C3                  <1>     ret 
  1220                              <1> .ehciFindValidInterface:
  1221                              <1> ;A proc to check a valid interface descriptor is present. 
  1222                              <1> ;Input: Nothing [Assumes Get Config was called in standard buffer]
  1223                              <1> ;Output: Carry set if invalid. Carry clear if valid.
  1224                              <1> ;    On success: ah = device type (0 is msd, 1 is hub)
  1225                              <1> ;                al = interface number to set
  1226                              <1> ;               rbx = Pointer to Interface Descriptor
  1227                              <1> ;   On fail: al contains error code, registers rbx, cx, dx destroyed
  1228 00004431 56                  <1>     push rsi
  1229 00004432 57                  <1>     push rdi
  1230 00004433 51                  <1>     push rcx
  1231 00004434 52                  <1>     push rdx
  1232                              <1> 
  1233 00004435 48BE-               <1>     mov rsi, ehciDataIn    ;Shift to buffer
  1233 00004437 [C003000000000000]  <1>
  1234 0000443F 30D2                <1>     xor dl, dl    ;Error code counter
  1235 00004441 807E0102            <1>     cmp byte [rsi + 1], 02h    ;Check if valid config descriptor
  1236 00004445 753F                <1>     jne .ecvifail
  1237 00004447 FEC2                <1>     inc dl
  1238                              <1> ;cl counts ep's per interface, ch counts possible interfaces
  1239 00004449 8A6E05              <1>     mov ch, byte [rsi + 5]        ;Get number of interfaces
  1240                              <1> .ecvi0:
  1241 0000444C 84ED                <1>     test ch, ch
  1242 0000444E 7436                <1>     jz .ecvifail    ;Zero interfaces is invalid for us
  1243 00004450 FEC2                <1>     inc dl
  1244                              <1> 
  1245 00004452 4889F3              <1>     mov rbx, rsi    ;Save this descriptor in rbx
  1246 00004455 480FB633            <1>     movzx rsi, byte [rbx]    ;get the size of the config to skip
  1247 00004459 4801DE              <1>     add rsi, rbx    ;point rsi to head of first interface descriptor
  1248 0000445C 807E0104            <1>     cmp byte [rsi + 1], 04h    ;Check if valid interface descriptor
  1249 00004460 7524                <1>     jne .ecvifail
  1250 00004462 FEC2                <1>     inc dl
  1251 00004464 8A4E04              <1>     mov cl, byte [rsi + 4]
  1252                              <1> ;Cmp IF has valid class/prototcol
  1253 00004467 4831C0              <1>     xor rax, rax    ;Device signature, 0 is msd, 1 is hub
  1254 0000446A E859000000          <1>     call .ehciCheckMsdIf
  1255 0000446F 7309                <1>     jnc    .ecviif    ;Not clear => valid interface
  1256 00004471 FEC4                <1>     inc ah    ;Device signature, 0 is msd, 1 is hub
  1257 00004473 E831000000          <1>     call .ehciCheckHubIf
  1258 00004478 7213                <1>     jc    .ecvibadif    ;Clear => bad interface
  1259                              <1> .ecviif:    ;Valid interface found
  1260 0000447A 8A4602              <1>     mov al, byte [rsi + 2]    ;Get interface number into al
  1261 0000447D 4889F3              <1>     mov rbx, rsi    ;Save pointer in rbx for return
  1262 00004480 F8                  <1>     clc ;Clear carry
  1263                              <1> .ecviexit:
  1264 00004481 5A                  <1>     pop rdx
  1265 00004482 59                  <1>     pop rcx
  1266 00004483 5F                  <1>     pop rdi
  1267 00004484 5E                  <1>     pop rsi
  1268 00004485 C3                  <1>     ret
  1269                              <1> .ecvifail:
  1270 00004486 31DB                <1>     xor ebx, ebx    ;Zero rbx for bad returns
  1271 00004488 F9                  <1>     stc
  1272 00004489 88D0                <1>     mov al, dl    ;Move error code
  1273 0000448B EBF4                <1>     jmp short .ecviexit
  1274                              <1> .ecvibadif:    ;Bad interface, goto next interface
  1275 0000448D 84C9                <1>     test cl, cl
  1276 0000448F 740B                <1>     jz .ecvibadif1
  1277 00004491 FEC9                <1>     dec cl
  1278 00004493 4881C607000000      <1>     add rsi, 7
  1279 0000449A EBF1                <1>     jmp short .ecvibadif
  1280                              <1> .ecvibadif1:
  1281 0000449C 4881C609000000      <1>     add rsi, 9
  1282 000044A3 FECD                <1>     dec ch
  1283 000044A5 B201                <1>     mov dl, 1
  1284 000044A7 EBA3                <1>     jmp short .ecvi0
  1285                              <1> .ehciCheckHubIf:
  1286                              <1> ;Input: rsi points to interface descriptor
  1287                              <1> ;Output: All registers preserved, carry set if NOT valid hub
  1288 000044A9 56                  <1>     push rsi
  1289 000044AA 807E0509            <1>     cmp byte [rsi + 5], 09h
  1290 000044AE 7515                <1>     jne .ecdhfail
  1291 000044B0 807E0600            <1>     cmp byte [rsi + 6], 0
  1292 000044B4 750F                <1>     jne .ecdhfail
  1293 000044B6 807E0702            <1>     cmp byte [rsi + 7], 2
  1294 000044BA 7709                <1>     ja .ecdhfail
  1295 000044BC 807E0401            <1>     cmp byte [rsi + 4], 1    ;One endpoint to rule them all
  1296 000044C0 7503                <1>     jne .ecdhfail
  1297 000044C2 F8                  <1>     clc 
  1298                              <1> .ecdhexit:
  1299 000044C3 5E                  <1>     pop rsi
  1300 000044C4 C3                  <1>     ret
  1301                              <1> .ecdhfail:
  1302 000044C5 F9                  <1>     stc
  1303 000044C6 EBFB                <1>     jmp short .ecdhexit
  1304                              <1> .ehciCheckMsdIf:
  1305                              <1> ;Input: rsi points to interface descriptor
  1306                              <1> ;Output: Carry set if fail, ax destroyed
  1307                              <1> ;    rsi points to good descriptor if all ok
  1308                              <1> ;Note we only accept 09/00/50 and 09/06/50
  1309 000044C8 56                  <1>     push rsi
  1310 000044C9 53                  <1>     push rbx
  1311 000044CA 51                  <1>     push rcx
  1312 000044CB 807E0508            <1>     cmp byte [rsi + 5], 08h    ;MSD class
  1313 000044CF 7517                <1>     jne .ecdmfail
  1314                              <1> ;Subclass check
  1315 000044D1 807E0606            <1>     cmp byte [rsi + 6], 06h    ;SCSI actual
  1316 000044D5 7406                <1>     je .ecdmprot
  1317 000044D7 807E0600            <1>     cmp byte [rsi + 6], 00h    ;SCSI defacto
  1318 000044DB 750B                <1>     jne .ecdmfail
  1319                              <1> .ecdmprot:
  1320 000044DD 807E0750            <1>     cmp byte [rsi + 7], 50h    ;BBB
  1321 000044E1 7505                <1>     jne .ecdmfail
  1322                              <1> .ecdmprotUAF:   ;Dummy label to find where to add this later
  1323                              <1> .ecdmpass:
  1324 000044E3 F8                  <1>     clc
  1325                              <1> .ecdmexit:
  1326 000044E4 59                  <1>     pop rcx
  1327 000044E5 5B                  <1>     pop rbx
  1328 000044E6 5E                  <1>     pop rsi
  1329 000044E7 C3                  <1>     ret
  1330                              <1> .ecdmfail:
  1331 000044E8 F9                  <1>     stc
  1332 000044E9 EBF9                <1>     jmp short .ecdmexit
  1333                              <1> .ehciGetDevicePtr:
  1334                              <1> ;Gets address/bus pair and returns in rax a pointer to the data
  1335                              <1> ;structure of the device, in the data table.
  1336                              <1> ;Input: ah = bus number, al = Address number
  1337                              <1> ;Output: ax = Preserved, rsi = Pointer to table structure, bl = USB Class Code
  1338 000044EB 51                  <1>     push rcx
  1339 000044EC 52                  <1>     push rdx
  1340 000044ED 55                  <1>     push rbp
  1341 000044EE B90A000000          <1>     mov ecx, usbMaxDevices
  1342 000044F3 48BE-               <1>     mov rsi, usbDevTbl
  1342 000044F5 [4C02000000000000]  <1>
  1343                              <1> .egdp0:
  1344 000044FD 663B06              <1>     cmp ax, word [rsi]
  1345 00004500 740E                <1>     je .egdp1   ;Device found
  1346 00004502 4881C603000000      <1>     add rsi, usbDevTblEntrySize
  1347 00004509 66FFC9              <1>     dec cx
  1348 0000450C 7447                <1>     jz .egdpfail    ;Got to the end with no dev found, exit
  1349 0000450E EBED                <1>     jmp short .egdp0
  1350                              <1> .egdp1:
  1351 00004510 48BD-               <1>     mov rbp, hubDevTbl
  1351 00004512 [6A02000000000000]  <1>
  1352 0000451A B908000000          <1>     mov ecx, hubDevTblEntrySize
  1353 0000451F 0FB65E02            <1>     movzx ebx, byte [rsi + 2]  ;Return bl for device type
  1354 00004523 80FB09              <1>     cmp bl, 09h ;Are we hub?
  1355 00004526 48BE-               <1>     mov rsi, msdDevTbl  ;Set to msd
  1355 00004528 [BA02000000000000]  <1>
  1356 00004530 BA10000000          <1>     mov edx, msdDevTblEntrySize
  1357 00004535 480F44F5            <1>     cmove rsi, rbp  ;If hub, reload rsi pointer to hub table
  1358 00004539 0F44D1              <1>     cmove edx, ecx    ;If hub, reload dx with hub table size
  1359 0000453C B90A000000          <1>     mov ecx, usbMaxDevices
  1360                              <1> .egdp2:
  1361 00004541 663B06              <1>     cmp ax, word [rsi]
  1362 00004544 740A                <1>     je .egdp3
  1363 00004546 4801D6              <1>     add rsi, rdx    ;rdx contains size of entry for either table
  1364 00004549 66FFC9              <1>     dec cx
  1365 0000454C 7407                <1>     jz .egdpfail
  1366 0000454E EBF1                <1>     jmp short .egdp2
  1367                              <1> .egdp3:
  1368 00004550 F8                  <1>     clc
  1369                              <1> .egdpexit:
  1370 00004551 5D                  <1>     pop rbp
  1371 00004552 5A                  <1>     pop rdx
  1372 00004553 59                  <1>     pop rcx
  1373 00004554 C3                  <1>     ret
  1374                              <1> .egdpfail:
  1375 00004555 6631DB              <1>     xor bx, bx
  1376 00004558 F9                  <1>     stc
  1377 00004559 EBF6                <1>     jmp short .egdpexit
  1378                              <1> 
  1379                              <1> .ehciProbeQhead:
  1380                              <1> ;A proc that returns a Queue Heads' status byte in bl.
  1381                              <1> ;Input:
  1382                              <1> ;   rbx = Address of QHead to probe
  1383                              <1> ;Output: 
  1384                              <1> ;   bl = Status byte, if 0, successful transfer!
  1385 0000455B 8A5B18              <1>     mov bl, byte [rbx + 18h]  ;08h is offset in qTD
  1386 0000455E C3                  <1>     ret
  1387                              <1> .ehciStandardErrorHandler:
  1388                              <1> ;Attempts to verify if something went wrong in previous transaction.
  1389                              <1> ;May only be called if eActiveInt has bit USBSTS bit set
  1390                              <1> ;Input:  al = Device Address
  1391                              <1> ;        cx = Default Endpoint Size
  1392                              <1> ;Output: CF=CY: Host error, Reset host system
  1393                              <1> ;        CF=NC: Proceed with below
  1394                              <1> ;        al = 0 => Benign error, Make request again/Verify data.
  1395                              <1> ;        al = 1 => Stall, Transaction error or Handshake error, corrected.
  1396                              <1> ;        al = 80h => Fatal error, EPClear errored out, but no clear reason why
  1397                              <1> ;        al > 80h => Bits 6-0 give the status byte for the error on EP Clear.
  1398                              <1> ;                  Bit 7 is the fatal error bit. 
  1399                              <1> ;                  If set, recommend device is port reset.
  1400                              <1> ;All other registers preserved
  1401 0000455F 53                  <1>     push rbx
  1402 00004560 4150                <1>     push r8
  1403 00004562 4151                <1>     push r9
  1404                              <1> 
  1405 00004564 4989C0              <1>     mov r8, rax
  1406 00004567 4989C9              <1>     mov r9, rcx
  1407 0000456A 30C0                <1>     xor al, al                  ;Set error counter and clear CF
  1408 0000456C F60425[48020000]02  <1>     test byte [eActiveInt], 2   ;Error Interrupt
  1409 00004574 744B                <1>     jz .esehexit                ;No error found, should not have been called
  1410 00004576 488B1C25[3E020000]  <1>     mov rbx, qword [eCurrAsyncHead] ;Get the current transacting QHead address
  1411 0000457E E8D8FFFFFF          <1>     call .ehciProbeQhead    ;Ret in bl status byte
  1412 00004583 80E378              <1>     and bl, 01111000b       ;Check if it is something we should clear EP for
  1413 00004586 7439                <1>     jz .esehexit            ;If it is not, benign error. al = 0
  1414                              <1> 
  1415 00004588 488B1C25[3E020000]  <1>     mov rbx, qword [eCurrAsyncHead] ;Get current AsyncHead again
  1416 00004590 4488C0              <1>     mov al, r8b        ;Device Address
  1417 00004593 664489C9            <1>     mov cx, r9w        ;EP size
  1418 00004597 8A5B05              <1>     mov bl, byte [rbx + 05h]  ;Get Endpoint to reset
  1419 0000459A 80E30F              <1>     and bl, 0Fh ;Lo nybble only
  1420 0000459D E828000000          <1>     call .ehciClearEpStallHalt
  1421 000045A2 721D                <1>     jc .esehexit        ;HC error!
  1422 000045A4 B001                <1>     mov al, 1           ;Stall cleared
  1423 000045A6 F60425[48020000]02  <1>     test byte [eActiveInt], 2   ;Check if interrupt returned an error
  1424 000045AE 7411                <1>     jz .esehexit                ;No error found, return al=1, stall cleared
  1425 000045B0 B080                <1>     mov al, 80h                 ;Fatal error indication
  1426 000045B2 488B1C25[3E020000]  <1>     mov rbx, qword [eCurrAsyncHead] ;Get the current transacting QHead address
  1427 000045BA E89CFFFFFF          <1>     call .ehciProbeQhead   
  1428 000045BF 08D8                <1>     or al, bl          ;Add error bits to al for Fatal error indication.
  1429                              <1> .esehexit:
  1430 000045C1 4C89C9              <1>     mov rcx, r9
  1431 000045C4 4159                <1>     pop r9
  1432 000045C6 4158                <1>     pop r8
  1433 000045C8 5B                  <1>     pop rbx
  1434 000045C9 C3                  <1>     ret
  1435                              <1> 
  1436                              <1> .ehciClearEpStallHalt:
  1437                              <1> ;Clears a halt or stall on an endpoint.
  1438                              <1> ;Input: bl=Endpoint (0 for control)
  1439                              <1> ;       al=Device Address
  1440                              <1> ;       cx=Ctrl Endpoint Size
  1441                              <1> ;Output:
  1442                              <1> ;   CF=CY: Host error, Reset host system
  1443                              <1> ;   CF=NC: Transaction succeeded, check interrupt error bit for confirmation
  1444 000045CA 53                  <1>     push rbx
  1445 000045CB 480FB6DB            <1>     movzx rbx, bl
  1446 000045CF 48C1E320            <1>     shl rbx, 2*10h  ;Shift wIndex by two words
  1447 000045D3 4881CB02010000      <1>     or rbx, 0102h   ;01=bRequest(CLEAR_FEATURE) 02h=bmRequestType (Endpoint)
  1448 000045DA E892F7FFFF          <1>     call .ehciSetNoData
  1449 000045DF 5B                  <1>     pop rbx ;Get original bx
  1450 000045E0 C3                  <1>     ret
  1451                              <1> 
  1452                              <1> .ehciWriteQHead:
  1453                              <1> ;Writes a Queue head at rdi, and clears the space for the transfer descriptor
  1454                              <1> ;rdi points at the head of the qhead on return
  1455                              <1> ;All non argument registers preserved
  1456                              <1> ;r8d=Horizontal Ptr + Typ + T
  1457                              <1> ;r9d=Endpoint Characteristics
  1458                              <1> ;r10d=Endpoint Capabilities
  1459                              <1> ;r11d=Next qTD Pointer
  1460 000045E1 50                  <1>     push rax
  1461 000045E2 51                  <1>     push rcx
  1462 000045E3 57                  <1>     push rdi
  1463 000045E4 31C0                <1>     xor eax, eax
  1464 000045E6 4489C0              <1>     mov eax, r8d
  1465 000045E9 AB                  <1>     stosd
  1466 000045EA 4489C8              <1>     mov eax, r9d
  1467 000045ED AB                  <1>     stosd
  1468 000045EE 4489D0              <1>     mov eax, r10d
  1469 000045F1 AB                  <1>     stosd
  1470 000045F2 31C0                <1>     xor eax, eax
  1471 000045F4 AB                  <1>     stosd            ;Enter 0 for the current qTD pointer entry
  1472 000045F5 4489D8              <1>     mov eax, r11d
  1473 000045F8 AB                  <1>     stosd
  1474 000045F9 B90A000000          <1>     mov ecx, 10
  1475 000045FE 31C0                <1>     xor eax, eax
  1476 00004600 F3AB                <1>     rep stosd
  1477 00004602 5F                  <1>     pop rdi
  1478 00004603 59                  <1>     pop rcx
  1479 00004604 58                  <1>     pop rax
  1480 00004605 C3                  <1>     ret
  1481                              <1> .ehciWriteQHeadTD:
  1482                              <1> ;Writes a transfer descriptor at the location pointed at by rdi
  1483                              <1> ;rdi points at the head of the qheadTD on return
  1484                              <1> ;All registers except passed arguments, preserved
  1485                              <1> ;rdi=location for current linked list element
  1486                              <1> ;r8d=Next qTD ptr
  1487                              <1> ;r9d=Alternate Next qTD ptr
  1488                              <1> ;r10d=Transfer Descriptor Token
  1489                              <1> ;r11=Buffer Ptr 0 + Current Offset
  1490 00004606 50                  <1>     push rax
  1491 00004607 57                  <1>     push rdi
  1492 00004608 4489C0              <1>     mov eax, r8d
  1493 0000460B AB                  <1>     stosd
  1494 0000460C 4489C8              <1>     mov eax, r9d
  1495 0000460F AB                  <1>     stosd
  1496 00004610 4489D0              <1>     mov eax, r10d
  1497 00004613 AB                  <1>     stosd
  1498 00004614 4489D8              <1>     mov eax, r11d
  1499 00004617 AB                  <1>     stosd
  1500 00004618 2500F0FFFF          <1>     and eax, 0FFFFF000h
  1501 0000461D 0500100000          <1>     add eax, 1000h
  1502 00004622 AB                  <1>     stosd
  1503 00004623 0500100000          <1>     add eax, 1000h
  1504 00004628 AB                  <1>     stosd
  1505 00004629 0500100000          <1>     add eax, 1000h
  1506 0000462E AB                  <1>     stosd
  1507 0000462F 0500100000          <1>     add eax, 1000h
  1508 00004634 AB                  <1>     stosd
  1509                              <1> 
  1510 00004635 4C89D8              <1>     mov rax, r11
  1511 00004638 48C1C820            <1>     ror rax, 20h
  1512 0000463C AB                  <1>     stosd
  1513 0000463D 48C1C820            <1>     ror rax, 20h
  1514 00004641 482500F0FFFF        <1>     and rax, 0FFFFFFFFFFFFF000h
  1515 00004647 480500100000        <1>     add rax, 1000h
  1516 0000464D 48C1C820            <1>     ror rax, 20h
  1517 00004651 AB                  <1>     stosd
  1518 00004652 48C1C820            <1>     ror rax, 20h
  1519 00004656 480500100000        <1>     add rax, 1000h
  1520 0000465C 48C1C820            <1>     ror rax, 20h
  1521 00004660 AB                  <1>     stosd  
  1522 00004661 48C1C820            <1>     ror rax, 20h
  1523 00004665 480500100000        <1>     add rax, 1000h
  1524 0000466B 48C1C820            <1>     ror rax, 20h
  1525 0000466F AB                  <1>     stosd
  1526 00004670 48C1C820            <1>     ror rax, 20h
  1527 00004674 480500100000        <1>     add rax, 1000h
  1528 0000467A 48C1C820            <1>     ror rax, 20h
  1529 0000467E AB                  <1>     stosd
  1530 0000467F 5F                  <1>     pop rdi
  1531 00004680 58                  <1>     pop rax
  1532 00004681 C3                  <1>     ret
  1533                              <1> 
  1534                              <1> 
  1535                              <1> .ehciDevSetupHub:
  1536                              <1> ;Device specific setup. Takes rsi as a ptr to the 
  1537                              <1> ; specific device parameter block.
  1538 00004682 53                  <1>     push rbx
  1539 00004683 51                  <1>     push rcx
  1540 00004684 56                  <1>     push rsi
  1541 00004685 55                  <1>     push rbp
  1542 00004686 6631ED              <1>     xor bp, bp    ;Error Stage 0
  1543                              <1> .edshub:
  1544 00004689 E839030000          <1>     call .ehciHubClassDescriptor
  1545 0000468E 0F82DA000000        <1>     jc .edsfail
  1546 00004694 66FFC5              <1>     inc bp  ;Error Stage 1
  1547 00004697 8A4E05              <1>     mov cl, byte [rsi + 5] ;Get number of ports here
  1548 0000469A B201                <1>     mov dl, 1   ;Start port number to begin enum on (hub ports start at 1)
  1549                              <1> .edshub1:
  1550 0000469C 49BC03000000000000- <1>     mov r12, 3
  1550 000046A5 00                  <1>
  1551                              <1> .edshub11:
  1552 000046A6 E8CB000000          <1>     call .ehciEnumerateHubPort    ;dl for port to scan/enumerate
  1553 000046AB 7413                <1>     jz .edshub13    ;If ZF=ZR, valid device found!
  1554 000046AD 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h  ;General Controller Failure
  1555 000046B5 0F8448F3FFFF        <1>     je USB.ehciCriticalErrorWrapper
  1556 000046BB 49FFCC              <1>     dec r12
  1557 000046BE 75E6                <1>     jnz .edshub11   ;Still not zero but failed, try again.
  1558                              <1> .edshub13:
  1559 000046C0 FEC2                <1>     inc dl  ;Start with port 1
  1560 000046C2 38D1                <1>     cmp cl, dl
  1561 000046C4 73D6                <1>     jae .edshub1
  1562                              <1> .edshub2:
  1563                              <1> ;Need to write bHostHub for any detected devices here
  1564 000046C6 F8                  <1>     clc    ;Common success exit
  1565 000046C7 5D                  <1>     pop rbp
  1566 000046C8 5E                  <1>     pop rsi
  1567 000046C9 59                  <1>     pop rcx
  1568 000046CA 5B                  <1>     pop rbx
  1569 000046CB C3                  <1>     ret
  1570                              <1> 
  1571                              <1> .ehciDeviceSetupMsd:
  1572                              <1> ; Input:  rsi = MSD Device Parameter Block
  1573                              <1> ; Output: CF=CY if catastrophic host error.
  1574                              <1> ;         CF=NC then ax = Return code
  1575                              <1> ;         ax = 0 if successful setup
  1576                              <1> ;         ax = 1 if device did not reset the first time
  1577                              <1> ;         ax = 2 if device did not return a valid LUN
  1578                              <1> ;         ax = 3 if device did not reset the second time
  1579                              <1> ;         Device must me removed from tables and port reset if ax != 0
  1580 000046CC 51                  <1>     push rcx
  1581 000046CD 55                  <1>     push rbp
  1582 000046CE 4150                <1>     push r8
  1583 000046D0 6631ED              <1>     xor bp, bp    ;Error Stage 0
  1584                              <1> .edsmsd:
  1585 000046D3 49B810000000000000- <1>     mov r8, 10h ;Loop counter setup
  1585 000046DC 00                  <1>
  1586                              <1> .edsm1:
  1587 000046DD E8BD030000          <1>     call .ehciMsdDeviceReset
  1588 000046E2 0F8281000000        <1>     jc .edsexit
  1589                              <1> ;Check eActiveInterrupt for confirmation if we need to handle error
  1590 000046E8 F60425[48020000]02  <1>     test byte [eActiveInt], 2   ;If this is set, handle error
  1591 000046F0 7416                <1>     jz .edsms2
  1592 000046F2 668B4E07            <1>     mov cx, word [rsi + 7]    ;Pass endpoint size
  1593 000046F6 8A06                <1>     mov al, byte [rsi]  ;Device address
  1594 000046F8 E862FEFFFF          <1>     call .ehciStandardErrorHandler
  1595 000046FD A880                <1>     test al, 80h 
  1596 000046FF 756D                <1>     jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  1597 00004701 49FFC8              <1>     dec r8                ;Dec loop counter
  1598 00004704 7468                <1>     jz .edsfail           ;Fatal error if after 16 goes nothing was resolved
  1599 00004706 EBD5                <1>     jmp short .edsm1
  1600                              <1> .edsms2:
  1601 00004708 66FFC5              <1>     inc bp  ;Error Stage 1
  1602                              <1> .edsms3:
  1603 0000470B E8B9030000          <1>     call .ehciMsdGetMaxLun  ;If stall, clear endpoint and proceed. No loop
  1604 00004710 7257                <1>     jc .edsexit
  1605 00004712 F60425[48020000]02  <1>     test byte [eActiveInt], 2   ;If this is set, handle error
  1606 0000471A 740F                <1>     jz .edsms4
  1607                              <1> 
  1608 0000471C 668B4E07            <1>     mov cx, word [rsi + 7]    ;Pass endpoint size
  1609 00004720 8A06                <1>     mov al, byte [rsi]  ;Device address
  1610 00004722 E838FEFFFF          <1>     call .ehciStandardErrorHandler
  1611 00004727 A880                <1>     test al, 80h 
  1612 00004729 7543                <1>     jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  1613                              <1> .edsms4:
  1614 0000472B 66FFC5              <1>     inc bp  ;Error Stage 2
  1615 0000472E 49B810000000000000- <1>     mov r8, 10h ;Loop counter setup
  1615 00004737 00                  <1>
  1616                              <1> .edsms5:
  1617 00004738 E862030000          <1>     call .ehciMsdDeviceReset  ;Reset once again to clear issues
  1618 0000473D 722A                <1>     jc .edsexit
  1619 0000473F F60425[48020000]02  <1>     test byte [eActiveInt], 2   ;If this is set, handle error
  1620 00004747 7416                <1>     jz .edsms6
  1621                              <1> 
  1622 00004749 668B4E07            <1>     mov cx, word [rsi + 7]    ;Pass endpoint size
  1623 0000474D 8A06                <1>     mov al, byte [rsi]  ;Device address
  1624 0000474F E80BFEFFFF          <1>     call .ehciStandardErrorHandler
  1625 00004754 A880                <1>     test al, 80h 
  1626 00004756 7516                <1>     jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  1627 00004758 49FFC8              <1>     dec r8                 ;Dec loop counter
  1628 0000475B 7411                <1>     jz .edsfail           ;Fatal error if after 16 goes nothing was resolved
  1629 0000475D EBD9                <1>     jmp short .edsms5
  1630                              <1> .edsms6:
  1631 0000475F FE0425[4B020000]    <1>     inc byte [numMSD] 
  1632 00004766 6631C0              <1>     xor ax, ax  ;Note that xor also clears CF
  1633                              <1> .edsexit:
  1634 00004769 4158                <1>     pop r8
  1635 0000476B 5D                  <1>     pop rbp
  1636 0000476C 59                  <1>     pop rcx
  1637 0000476D C3                  <1>     ret
  1638                              <1> .edsfail:
  1639                              <1> ;If a fail occurs, then the entry needs to be removed from the data tables
  1640 0000476E 6689E8              <1>     mov ax, bp
  1641 00004771 E9F3FFFFFF          <1>     jmp .edsexit
  1642                              <1> 
  1643                              <1> .ehciEnumerateHubPort:
  1644                              <1> ;Enumerates devices on an external Hub.
  1645                              <1> ;Use rsi to get device properties
  1646                              <1> ;Input: rsi = ptr to hub device block
  1647                              <1> ;       dl = Port number to reset
  1648                              <1> ;Output: None, CF
  1649                              <1> 
  1650 00004776 53                  <1>     push rbx
  1651 00004777 51                  <1>     push rcx
  1652 00004778 52                  <1>     push rdx
  1653 00004779 55                  <1>     push rbp
  1654 0000477A 4150                <1>     push r8
  1655 0000477C 4151                <1>     push r9
  1656 0000477E 4152                <1>     push r10
  1657 00004780 4153                <1>     push r11
  1658                              <1> 
  1659 00004782 0FB6D2              <1>     movzx edx, dl
  1660 00004785 48C1E220            <1>     shl rdx, 4*8    ;Shift port number to right bits
  1661                              <1> .eehdeinit:
  1662 00004789 6631ED              <1>     xor bp, bp  ;Error counter
  1663 0000478C 4C0FB70E            <1>     movzx r9, word [rsi]        ;Save hub bus/addr in r9w
  1664 00004790 4C0FB64604          <1>     movzx r8, byte [rsi + 4]    ;Get MaxPacketSize0
  1665                              <1> 
  1666                              <1> .eehde0:
  1667 00004795 48BB23030800000000- <1>     mov rbx, 0000000000080323h  ;Set port power feature
  1667 0000479E 00                  <1>
  1668 0000479F 4809D3              <1>     or rbx, rdx ;Add port number into descriptor
  1669 000047A2 664489C1            <1>     mov cx, r8w
  1670 000047A6 4488C8              <1>     mov al, r9b
  1671 000047A9 E8C3F5FFFF          <1>     call .ehciSetNoData   ;Turn on power to port on device in addr al
  1672 000047AE 0F829F010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1673                              <1> .eehde1:
  1674                              <1> ;Power on debounce!
  1675 000047B4 B486                <1>     mov ah, 86h
  1676 000047B6 0FB64E06            <1>     movzx ecx, byte [rsi + 6]   ;poweron2powergood
  1677 000047BA D1E1                <1>     shl ecx, 1
  1678 000047BC CD35                <1>     int 35h
  1679                              <1> 
  1680 000047BE 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 1)
  1681                              <1> .eehde2:
  1682 000047C1 48BB23011000000000- <1>     mov rbx, 0000000000100123h  ;Clear port set connection bit
  1682 000047CA 00                  <1>
  1683 000047CB 4809D3              <1>     or rbx, rdx ;Add port number into descriptor
  1684 000047CE 4488C1              <1>     mov cl, r8b
  1685 000047D1 4488C8              <1>     mov al, r9b
  1686 000047D4 E898F5FFFF          <1>     call .ehciSetNoData
  1687 000047D9 0F8274010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1688                              <1> .eehde3:
  1689                              <1> 
  1690 000047DF 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 2)
  1691                              <1> .eehde31:
  1692 000047E2 48BBA3000000000004- <1>     mov rbx, 00040000000000A3h ;Get port status
  1692 000047EB 00                  <1>
  1693 000047EC 4809D3              <1>     or rbx, rdx
  1694 000047EF 4488C1              <1>     mov cl, r8b
  1695 000047F2 4488C8              <1>     mov al, r9b
  1696 000047F5 E816F6FFFF          <1>     call .ehciGetRequest
  1697 000047FA 0F8253010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1698                              <1> .eehde4:
  1699 00004800 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 3)
  1700                              <1> 
  1701 00004803 8A0C25[C0030000]    <1>     mov cl, byte [ehciDataIn]   ;Get the first byte in into cx
  1702 0000480A F6C101              <1>     test cl, 1  ;Check device in port
  1703 0000480D 0F8436010000        <1>     jz .eehdebadnotimeout
  1704                              <1> 
  1705                              <1> .eehde41:   ;EP for first port reset state
  1706 00004813 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 4)
  1707 00004816 E83D010000          <1>     call .eehdereset    ;First port reset
  1708 0000481B 0F8232010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1709                              <1> 
  1710 00004821 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 5)
  1711                              <1> 
  1712 00004824 49BB10000000000000- <1>     mov r11, 10h
  1712 0000482D 00                  <1>
  1713                              <1> .eehde5:
  1714 0000482E 48BBA3000000000004- <1>     mov rbx, 00040000000000A3h ;Get port status again
  1714 00004837 00                  <1>
  1715 00004838 4809D3              <1>     or rbx, rdx
  1716 0000483B 4488C1              <1>     mov cl, r8b
  1717 0000483E 4488C8              <1>     mov al, r9b
  1718 00004841 E8CAF5FFFF          <1>     call .ehciGetRequest
  1719 00004846 0F8207010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1720                              <1> .eehde6:
  1721 0000484C 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 6)
  1722                              <1> ;Now check for high speed
  1723                              <1> 
  1724 0000484F 668B0C25[C0030000]  <1>     mov cx, word [ehciDataIn]
  1725 00004857 6681E1FF07          <1>     and cx, 7FFh    ;Zero upper bits
  1726 0000485C 66C1E909            <1>     shr cx, 9   ;Bring bits [10:9] low
  1727 00004860 6681F90200          <1>     cmp cx, 2   ;2 is High Speed device
  1728 00004865 0F85DE000000        <1>     jne .eehdebadnotimeout
  1729 0000486B 48C70425[C0030000]- <1>     mov qword [ehciDataIn], 0
  1729 00004873 00000000            <1>
  1730                              <1> 
  1731 00004877 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 7)
  1732                              <1> 
  1733 0000487A 57                  <1>     push rdi
  1734 0000487B 48BF-               <1>     mov rdi, ehciDataIn
  1734 0000487D [C003000000000000]  <1>
  1735 00004885 B908000000          <1>     mov ecx, 8
  1736 0000488A 31C0                <1>     xor eax, eax
  1737 0000488C F348AB              <1>     rep stosq
  1738 0000488F 5F                  <1>     pop rdi
  1739                              <1> .eehde7:
  1740 00004890 48BB23011200000000- <1>     mov rbx, 0000000000120123h  ;Clear port suspend
  1740 00004899 00                  <1>
  1741 0000489A 4809D3              <1>     or rbx, rdx ;Add port number into descriptor
  1742 0000489D 4488C1              <1>     mov cl, r8b
  1743 000048A0 4488C8              <1>     mov al, r9b
  1744 000048A3 E8C9F4FFFF          <1>     call .ehciSetNoData
  1745 000048A8 0F82A5000000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1746                              <1> 
  1747                              <1> .eehde10:
  1748 000048AE 48BB80060001000008- <1>     mov rbx, 00008000001000680h    ;Pass get minimal device descriptor
  1748 000048B7 00                  <1>
  1749 000048B8 66B94000            <1>     mov cx, 40h    ;Pass default endpoint size
  1750 000048BC 30C0                <1>     xor al, al
  1751 000048BE E84DF5FFFF          <1>     call .ehciGetRequest
  1752 000048C3 0F828A000000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1753                              <1> .eehde101:
  1754 000048C9 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 8)
  1755                              <1> 
  1756 000048CC 803C25[C1030000]01  <1>     cmp byte [ehciDataIn + 1], 01h    ;Verify this is a valid dev descriptor
  1757 000048D4 756E                <1>     jne .eehdebad       ;ehciDataIn contains error signature
  1758                              <1> 
  1759                              <1> ;Sanity check the returned descriptor here
  1760                              <1> .eehde11:
  1761 000048D6 66813C25[C2030000]- <1>     cmp word [ehciDataIn + 2], 0200h    ;Verify this is a USB 2.0+ device or
  1761 000048DE 0002                <1>
  1762 000048E0 7262                <1>     jb .eehdebad
  1763 000048E2 803C25[C4030000]00  <1>     cmp byte [ehciDataIn + 4], 0    ;Check interfaces
  1764 000048EA 7414                <1>     je .eehde12
  1765 000048EC 803C25[C4030000]08  <1>     cmp byte [ehciDataIn + 4], 08h    ;MSD?
  1766 000048F4 740A                <1>     je .eehde12
  1767 000048F6 803C25[C4030000]09  <1>     cmp byte [ehciDataIn + 4], 09h    ;Hub?
  1768 000048FE 7544                <1>     jne .eehdebad
  1769                              <1> 
  1770                              <1> .eehde12:    ;Valid device detected
  1771 00004900 440FB60425-         <1>     movzx r8d, byte [ehciDataIn + 7]   ;Save attached device max ep size
  1771 00004905 [C7030000]          <1>
  1772                              <1> .eehde13: 
  1773 00004909 E84A000000          <1>     call .eehdereset    ;Do second reset
  1774 0000490E 7243                <1>     jc .eehdecritical  ;Fast exit with carry set
  1775                              <1> ;Clear the data in buffer
  1776 00004910 57                  <1>     push rdi
  1777 00004911 48BF-               <1>     mov rdi, ehciDataIn
  1777 00004913 [C003000000000000]  <1>
  1778 0000491B B908000000          <1>     mov ecx, 8
  1779 00004920 31C0                <1>     xor eax, eax
  1780 00004922 F348AB              <1>     rep stosq
  1781 00004925 5F                  <1>     pop rdi
  1782                              <1> 
  1783                              <1> ;Device on port now ready to have an address set to it, and be enumerated
  1784 00004926 48C1EA20            <1>     shr rdx, 4*8    ;Shift port number back down to dl
  1785 0000492A 668B06              <1>     mov ax, word [rsi]  ;Get hub bus/addr pair
  1786 0000492D 88E6                <1>     mov dh, ah          ;Move the bus number into dh
  1787 0000492F 440FB6D0            <1>     movzx r10d, al      ;Move hub address into r10b
  1788                              <1> ;Ensure dl=port number - 1, dh=Root hub (Bus) number, r10b=Host hub number
  1789                              <1> ;       r8b=Max Control EP endpoint size
  1790 00004933 49BB64000000000000- <1>     mov r11, 100    ;Address settle time
  1790 0000493C 00                  <1>
  1791 0000493D FECA                <1>     dec dl
  1792 0000493F E998F7FFFF          <1>     jmp .ehciEnumCommonEp
  1793                              <1> 
  1794                              <1> .eehdebad:
  1795                              <1> .eehdebadnoport:    ;EP if done without disabling port
  1796 00004944 E987F8FFFF          <1>     jmp .ehciedbadnoport
  1797                              <1> .eehdebadnotimeout:
  1798 00004949 E98DF8FFFF          <1>     jmp .ehciedbadnotimeout
  1799                              <1> .eehdebadremtables:
  1800 0000494E E99AF8FFFF          <1>     jmp .ehcibadremtables
  1801                              <1> .eehdecritical:
  1802 00004953 E96BF8FFFF          <1>     jmp .ehciedexit  ;Fast exit with carry set
  1803                              <1> .eehdereset:
  1804                              <1> ;rsi must point to valid Hub device block
  1805 00004958 48BB23030400000000- <1>     mov rbx, 0000000000040323h  ;Reset port 
  1805 00004961 00                  <1>
  1806 00004962 4809D3              <1>     or rbx, rdx ;Add device address
  1807 00004965 4488C1              <1>     mov cl, r8b
  1808 00004968 4488C8              <1>     mov al, r9b
  1809 0000496B E801F4FFFF          <1>     call .ehciSetNoData
  1810 00004970 7254                <1>     jc .eehcritexit
  1811                              <1> 
  1812 00004972 49BB88130000000000- <1>     mov r11, 5000 ;Just keep trying
  1812 0000497B 00                  <1>
  1813                              <1> .eehder1:
  1814 0000497C B486                <1>     mov ah, 86h
  1815 0000497E B914000000          <1>     mov ecx, 20     ;20 ms is max according to USB 2.0 standard
  1816 00004983 CD35                <1>     int 35h
  1817                              <1> 
  1818 00004985 48BBA3000000000004- <1>     mov rbx, 00040000000000A3h ;Get port status
  1818 0000498E 00                  <1>
  1819 0000498F 4809D3              <1>     or rbx, rdx
  1820 00004992 4488C1              <1>     mov cl, r8b
  1821 00004995 4488C8              <1>     mov al, r9b
  1822 00004998 E873F4FFFF          <1>     call .ehciGetRequest
  1823 0000499D 8A0C25[C0030000]    <1>     mov cl, byte [ehciDataIn]   ;Get low byte of in data
  1824 000049A4 F6C110              <1>     test cl, 10h    ;If bit not set, reset over, proceed
  1825 000049A7 7405                <1>     jz .eehder2
  1826 000049A9 49FFCB              <1>     dec r11
  1827 000049AC 75CE                <1>     jnz .eehder1
  1828                              <1> .eehder2:
  1829 000049AE 48BB23011400000000- <1>     mov rbx, 0000000000140123h ;Clear port reset bit
  1829 000049B7 00                  <1>
  1830 000049B8 4809D3              <1>     or rbx, rdx
  1831 000049BB 4488C1              <1>     mov cl, r8b
  1832 000049BE 4488C8              <1>     mov al, r9b
  1833 000049C1 E8ABF3FFFF          <1>     call .ehciSetNoData
  1834                              <1> .eehcritexit:
  1835 000049C6 C3                  <1>     ret
  1836                              <1> 
  1837                              <1> .ehciHubClassDescriptor:
  1838                              <1> ;Gets the Hub class descriptor
  1839                              <1> ;Get Hub descriptor for device pointed to by rsi
  1840                              <1> ;If invalid data, returns error
  1841                              <1> ;Input: rsi = Ptr to hub data block
  1842                              <1> ;Output:
  1843                              <1> ;   Carry Clear if success
  1844                              <1> ;   Carry Set if fail, al contains error code
  1845 000049C7 53                  <1>     push rbx
  1846 000049C8 51                  <1>     push rcx
  1847 000049C9 55                  <1>     push rbp
  1848 000049CA 66BD0300            <1>     mov bp, 3
  1849                              <1> 
  1850 000049CE 48BBA0060029000007- <1>     mov rbx, 00070000290006A0h  ;Get Hub descriptor (only first 7 bytes)
  1850 000049D7 00                  <1>
  1851 000049D8 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
  1852 000049DC 8A06                <1>     mov al, byte [rsi]      ;Get device address
  1853 000049DE E82DF4FFFF          <1>     call .ehciGetRequest
  1854 000049E3 7226                <1>     jc .ehcdfail    ;Errors 0-2 live here
  1855                              <1> 
  1856 000049E5 66FFC5              <1>     inc bp
  1857 000049E8 803C25[C1030000]29  <1>     cmp byte [ehciDataIn + 1], 29h  ;Is this a valid hub descriptor
  1858 000049F0 7519                <1>     jne .ehcdfail
  1859                              <1> 
  1860 000049F2 8A0C25[C2030000]    <1>     mov cl, byte [ehciDataIn + 2]   ;Get number of downstream ports
  1861 000049F9 884E05              <1>     mov byte [rsi + 5], cl  ;Store in variable, marking device as configured
  1862                              <1> 
  1863 000049FC 8A0C25[C5030000]    <1>     mov cl, byte [ehciDataIn + 5]   ;Get PowerOn2PowerGood
  1864 00004A03 884E06              <1>     mov byte [rsi + 6], cl  ;Store in variable
  1865 00004A06 F8                  <1>     clc
  1866                              <1> .ehcdexit:
  1867 00004A07 5D                  <1>     pop rbp
  1868 00004A08 59                  <1>     pop rcx
  1869 00004A09 5B                  <1>     pop rbx
  1870 00004A0A C3                  <1>     ret
  1871                              <1> .ehcdfail:
  1872 00004A0B 4088E8              <1>     mov al, bpl
  1873 00004A0E F9                  <1>     stc
  1874 00004A0F EBF6                <1>     jmp short .ehcdexit
  1875                              <1> ;                        ---------MSD functions---------
  1876                              <1> .ehciMsdInitialise:
  1877                              <1> ;Initialises an MSD device.
  1878                              <1> ;Input: rsi = Valid MSD device block
  1879                              <1> ;Output: CF=CY: Init did not complete
  1880                              <1> ;        al = 0 => Device initialised
  1881                              <1> ;        al = 1 => Host/Schedule error
  1882                              <1> ;        al = 2 => Device failed to initialise
  1883                              <1> ;        CF=NC: Init complete, rsi points to complete USB MSD device block
  1884 00004A11 51                  <1>     push rcx
  1885 00004A12 8A4601              <1>     mov al, byte [rsi + 1]  ;Get the bus number into al
  1886 00004A15 E800F2FFFF          <1>     call .ehciAdjustAsyncSchedCtrlr
  1887 00004A1A B001                <1>     mov al, 1
  1888 00004A1C 7249                <1>     jc .ehciMsdInitFail
  1889 00004A1E E8A9FCFFFF          <1>     call .ehciDeviceSetupMsd
  1890 00004A23 B002                <1>     mov al, 2
  1891 00004A25 7240                <1>     jc .ehciMsdInitFail
  1892 00004A27 E8EB040000          <1>     call .ehciMsdBOTInquiry
  1893 00004A2C 7239                <1>     jc .ehciMsdInitFail
  1894 00004A2E B905000000          <1>     mov ecx, 5
  1895                              <1> .emi0:
  1896 00004A33 E82C050000          <1>     call .ehciMsdBOTReadFormatCapacities
  1897 00004A38 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;Host error
  1898 00004A40 7439                <1>     je .ehciMsdInitialisePfail  ;Protocol fail
  1899 00004A42 E88C010000          <1>     call .ehciMsdBOTCheckTransaction
  1900 00004A47 6685C0              <1>     test ax, ax
  1901 00004A4A 7538                <1>     jnz .emipf0
  1902 00004A4C E8F6060000          <1>     call .ehciMsdBOTModeSense6
  1903 00004A51 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;Host error
  1904 00004A59 7420                <1>     je .ehciMsdInitialisePfail  ;Protocol fail
  1905 00004A5B E873010000          <1>     call .ehciMsdBOTCheckTransaction
  1906 00004A60 6685C0              <1>     test ax, ax     ;Also clears CF if zero
  1907 00004A63 751F                <1>     jnz .emipf0
  1908                              <1> .ehciMsdInitExit:
  1909 00004A65 59                  <1>     pop rcx
  1910 00004A66 C3                  <1>     ret
  1911                              <1> .ehciMsdInitFail:
  1912 00004A67 668B06              <1>     mov ax, word [rsi]
  1913 00004A6A E807F9FFFF          <1>     call .ehciRemoveDevFromTables
  1914 00004A6F FE0C25[4B020000]    <1>     dec byte [numMSD]   ;Device was removed from tables, decrement
  1915 00004A76 F9                  <1>     stc
  1916 00004A77 B002                <1>     mov al, 2
  1917 00004A79 EBEA                <1>     jmp short .ehciMsdInitExit
  1918                              <1> .ehciMsdInitialisePfail:
  1919 00004A7B E873000000          <1>     call .ehciMsdBOTResetRecovery
  1920 00004A80 FFC9                <1>     dec ecx
  1921 00004A82 74E3                <1>     jz .ehciMsdInitFail
  1922                              <1> .emipf0:
  1923 00004A84 E836060000          <1>     call .ehciMsdBOTRequestSense
  1924 00004A89 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h
  1925 00004A91 74E8                <1>     je .ehciMsdInitialisePfail
  1926 00004A93 E83B010000          <1>     call .ehciMsdBOTCheckTransaction
  1927 00004A98 6685C0              <1>     test ax, ax
  1928 00004A9B 7496                <1>     jz .emi0
  1929 00004A9D EBDC                <1>     jmp short .ehciMsdInitialisePfail
  1930                              <1> 
  1931                              <1> .ehciMsdDeviceReset:
  1932                              <1> ;Reset an MSD device on current active EHCI bus
  1933                              <1> ;Input: rsi = Pointer to table data structure
  1934                              <1> ;Output:
  1935                              <1> ;   CF=CY: Host error, Reset host system
  1936                              <1> ;   CF=NC: Transaction succeeded, check reset occurred successfully 
  1937                              <1> ;          (If eActiveIntr AND 2 != 0, then error in transfer)
  1938 00004A9F 51                  <1>     push rcx
  1939 00004AA0 52                  <1>     push rdx
  1940 00004AA1 53                  <1>     push rbx
  1941 00004AA2 50                  <1>     push rax
  1942                              <1> 
  1943 00004AA3 0FB64E07            <1>     movzx ecx, byte [rsi + 7]  ;Get bMaxPacketSize0
  1944 00004AA7 480FB65604          <1>     movzx rdx, byte [rsi + 4]  ;Get Interface Number
  1945 00004AAC 48C1E228            <1>     shl rdx, 5*8 ;Send to 5th byte
  1946 00004AB0 48BB21FF0000000000- <1>     mov rbx, 0FF21h            ;MSD Reset
  1946 00004AB9 00                  <1>
  1947 00004ABA 4809D3              <1>     or rbx, rdx                ;And those bytes
  1948 00004ABD 8A06                <1>     mov al, byte [rsi]
  1949 00004ABF E8ADF2FFFF          <1>     call .ehciSetNoData
  1950                              <1> 
  1951 00004AC4 58                  <1>     pop rax
  1952 00004AC5 5B                  <1>     pop rbx
  1953 00004AC6 5A                  <1>     pop rdx
  1954 00004AC7 59                  <1>     pop rcx
  1955 00004AC8 C3                  <1>     ret
  1956                              <1> 
  1957                              <1> .ehciMsdGetMaxLun:
  1958                              <1> ;Get max LUN of an MSD device on current active EHCI bus
  1959                              <1> ;Input: rsi = Pointer to table data structure
  1960                              <1> ;       al = Address
  1961                              <1> ;Output:
  1962                              <1> ;   CF=CY: Host error, Reset host system
  1963                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  1964                              <1> ;   Max Lun saved at DataIn Buffer (first byte)
  1965                              <1> ;   Check this was transferred, by checking total data transferred value
  1966 00004AC9 51                  <1>     push rcx
  1967 00004ACA 52                  <1>     push rdx
  1968 00004ACB 53                  <1>     push rbx
  1969 00004ACC 50                  <1>     push rax
  1970                              <1> 
  1971 00004ACD 0FB64E07            <1>     movzx ecx, byte [rsi + 7]  ;Get bMaxPacketSize0
  1972 00004AD1 480FB65604          <1>     movzx rdx, byte [rsi + 4]  ;Get Interface Number
  1973 00004AD6 48C1E228            <1>     shl rdx, 5*8 ;Send to 5th byte
  1974 00004ADA 48BBA1FE0000000001- <1>     mov rbx, 000100000000FEA1h            ;MSD Get Max LUN
  1974 00004AE3 00                  <1>
  1975 00004AE4 4809D3              <1>     or rbx, rdx                ;And those bytes
  1976 00004AE7 8A06                <1>     mov al, byte [rsi]
  1977 00004AE9 E822F3FFFF          <1>     call .ehciGetRequest
  1978                              <1> 
  1979 00004AEE 58                  <1>     pop rax
  1980 00004AEF 5B                  <1>     pop rbx
  1981 00004AF0 5A                  <1>     pop rdx
  1982 00004AF1 59                  <1>     pop rcx
  1983 00004AF2 C3                  <1>     ret
  1984                              <1> 
  1985                              <1> .ehciMsdBOTResetRecovery:
  1986                              <1> ;----------------------------------------------------------------
  1987                              <1> ;Calls the reset recovery procedure on a device ptd to by rsi   :
  1988                              <1> ;Input:  rsi = Pointer to MSD device parameter block            :
  1989                              <1> ;Output: CF=CY if something went wrong. Else CF=NC              :
  1990                              <1> ;----------------------------------------------------------------
  1991                              <1> ;Calls an MSDBBB reset then calls StandardErrorHandler AFTER    : 
  1992                              <1> ; writing the Qhead for each Bulk EP.                           :
  1993                              <1> ;----------------------------------------------------------------
  1994 00004AF3 50                  <1>     push rax
  1995 00004AF4 53                  <1>     push rbx
  1996 00004AF5 51                  <1>     push rcx
  1997 00004AF6 66C7460E0000        <1>     mov word [rsi + 14], 00h    ;Reset clear both endpoint dt bits 
  1998                              <1> 
  1999 00004AFC E89EFFFFFF          <1>     call .ehciMsdDeviceReset    ;Call the device reset
  2000 00004B01 721E                <1>     jc .embrrexit
  2001                              <1> ;Now clear stall on IN EP
  2002 00004B03 8A06                <1>     mov al, byte [rsi]          ;Get the address
  2003 00004B05 8A5E08              <1>     mov bl, byte [rsi + 8]      ;Get the 4 byte EP address
  2004 00004B08 0FB64E07            <1>     movzx ecx, byte [rsi + 7]   ;Get the Max packet size for the ctrl EP
  2005 00004B0C E8B9FAFFFF          <1>     call .ehciClearEpStallHalt
  2006 00004B11 720E                <1>     jc .embrrexit
  2007                              <1> ;Now clear stall on OUT EP
  2008 00004B13 8A06                <1>     mov al, byte [rsi]          ;Get the address
  2009 00004B15 8A5E0B              <1>     mov bl, byte [rsi + 11]     ;Get the 4 byte EP address
  2010 00004B18 0FB64E07            <1>     movzx ecx, byte [rsi + 7]   ;Get the Max packet size for the ctrl EP
  2011 00004B1C E8A9FAFFFF          <1>     call .ehciClearEpStallHalt
  2012                              <1> .embrrexit:
  2013 00004B21 59                  <1>     pop rcx
  2014 00004B22 5B                  <1>     pop rbx
  2015 00004B23 58                  <1>     pop rax
  2016 00004B24 C3                  <1>     ret
  2017                              <1> .ehciMsdBOTCheckValidCSW:
  2018                              <1> ; This function checks that the recieved CSW was valid.
  2019                              <1> ; If this function returns a non-zero value in al, 
  2020                              <1> ; a reset recovery of the device is required
  2021                              <1> ; Output: al = 0 : valid CSW
  2022                              <1> ;         If CSW not valid, al contains a bitfield describing what failed
  2023                              <1> ;         al = 1h   : CSW is not 13 bytes in length
  2024                              <1> ;         al = 2h   : dCSWSignature is not equal to 053425355h
  2025                              <1> ;         al = 4h   : dCSWTag does not match the dCBWTag
  2026                              <1> ;         al = 0F8h : Reserved
  2027                              <1> ;   rax destroyed
  2028 00004B25 53                  <1>     push rbx
  2029 00004B26 51                  <1>     push rcx
  2030 00004B27 31C0                <1>     xor eax, eax
  2031 00004B29 66B90100            <1>     mov cx, 1
  2032 00004B2D 668B1C25[8A010000]  <1>     mov bx, word [ehciTDSpace + 2*ehciSizeOfTD + 0Ah]   
  2033                              <1> ;Get total bytes to transfer from third QHeadTD to see if 13h bytes were 
  2034                              <1> ; transferred
  2035 00004B35 6681E3FF7F          <1>     and bx, 7FFFh   ;Clear upper bit
  2036 00004B3A 660F45C1            <1>     cmovnz ax, cx   ;If the result for the and is not zero, <>13 bytes were sent
  2037                              <1> 
  2038 00004B3E 66D1E1              <1>     shl cx, 1     
  2039 00004B41 6609C1              <1>     or cx, ax
  2040 00004B44 813C25[C0050000]55- <1>     cmp dword [msdCSW], CSWSig
  2040 00004B4C 534253              <1>
  2041 00004B4F 660F45C1            <1>     cmovne ax, cx
  2042                              <1> 
  2043 00004B53 66B90400            <1>     mov cx, 4h
  2044 00004B57 6609C1              <1>     or cx, ax
  2045 00004B5A 0FB61C25[4A020000]  <1>     movzx ebx, byte [cbwTag]
  2046 00004B62 FECB                <1>     dec bl
  2047 00004B64 3A1C25[C4050000]    <1>     cmp bl, byte [msdCSW + 4h]
  2048 00004B6B 660F45C1            <1>     cmovne ax, cx
  2049                              <1> 
  2050 00004B6F 59                  <1>     pop rcx
  2051 00004B70 5B                  <1>     pop rbx
  2052 00004B71 C3                  <1>     ret
  2053                              <1> 
  2054                              <1> .ehciMsdBOTCheckMeaningfulCSW:
  2055                              <1> ; This function checks if the CSW was meaningful.
  2056                              <1> ; If this function returns a non-zero value in al, it is up to the
  2057                              <1> ; caller to decide what action to take. The possible set of actions that
  2058                              <1> ; can be taken is outlined in Section 6.7 of the USB MSC BOT Revision 1.0 
  2059                              <1> ; specification.
  2060                              <1> ; Output :  al = 0h  : Invalid
  2061                              <1> ;           al = 1h  : bCSWStatus = 0
  2062                              <1> ;           al = 2h  : bCSWStatus = 1
  2063                              <1> ;           al = 4h  : bCSWStatus = 2
  2064                              <1> ;           al = 8h  : bCSWStatus > 2
  2065                              <1> ;           al = 10h : dCSWDataResidue = 0
  2066                              <1> ;           al = 20h : dCSWDataResidue < dCBWDataTransferLength
  2067                              <1> ;           al = 40h : dCSWDataResidue > dCBWDataTransferLength
  2068                              <1> ;           al = 80h : Reserved
  2069                              <1> ;   rax destroyed
  2070 00004B72 53                  <1>     push rbx
  2071 00004B73 51                  <1>     push rcx
  2072                              <1> 
  2073 00004B74 31C0                <1>     xor eax, eax  ;In the event that things go completely wrong
  2074 00004B76 66BB0800            <1>     mov bx, 8h
  2075 00004B7A 8A0C25[CC050000]    <1>     mov cl, byte [msdCSW + 0Ch]
  2076                              <1> 
  2077 00004B81 80F902              <1>     cmp cl, 2
  2078 00004B84 660F47C3            <1>     cmova ax, bx
  2079 00004B88 7718                <1>     ja .embcmcResidueCheck
  2080                              <1> 
  2081 00004B8A 66D1EB              <1>     shr bx, 1       ;Shift it down to 4
  2082 00004B8D 660F44C3            <1>     cmove ax, bx    ;If bCSWStatus = 2, move it in
  2083 00004B91 740F                <1>     je .embcmcResidueCheck
  2084                              <1> 
  2085 00004B93 66D1EB              <1>     shr bx, 1       ;Shift down to 2
  2086 00004B96 80F901              <1>     cmp cl, 1
  2087 00004B99 660F44C3            <1>     cmove ax, bx    ;If bCSWStatus = 1, move bx into ax
  2088 00004B9D 7403                <1>     je .embcmcResidueCheck
  2089                              <1> 
  2090 00004B9F 66FFC0              <1>     inc ax          ;Otherwise bCSWStatus = 0
  2091                              <1> .embcmcResidueCheck:
  2092 00004BA2 8B0C25[C8050000]    <1>     mov ecx, dword [msdCSW + 8] ;Get dCSWDataResidue
  2093                              <1> 
  2094 00004BA9 66BB1000            <1>     mov bx, 10h
  2095 00004BAD 6609C3              <1>     or bx, ax   
  2096 00004BB0 85C9                <1>     test ecx, ecx
  2097 00004BB2 660F44C3            <1>     cmovz ax, bx    ;If its zero, move bx with added bit from ax into ax
  2098 00004BB6 7418                <1>     jz .embcmcExit
  2099                              <1> 
  2100 00004BB8 66BB2000            <1>     mov bx, 20h
  2101 00004BBC 6609C3              <1>     or bx, ax 
  2102 00004BBF 3B0C25[88030000]    <1>     cmp ecx, dword [ehciDataOut + 8];ehciDataOut + 8 = dCBWDataTransferLength
  2103 00004BC6 660F42C3            <1>     cmovb ax, bx
  2104 00004BCA 7204                <1>     jb .embcmcExit
  2105                              <1> 
  2106 00004BCC 660D4000            <1>     or ax, 40h  ;Else, it must be above, fail
  2107                              <1> .embcmcExit:
  2108 00004BD0 59                  <1>     pop rcx
  2109 00004BD1 5B                  <1>     pop rbx
  2110 00004BD2 C3                  <1>     ret
  2111                              <1> 
  2112                              <1> .ehciMsdBOTCheckTransaction:
  2113                              <1> ;Check successful return data here
  2114                              <1> ;Output: ax = 0                                 : CSW Valid and Meaningful
  2115                              <1> ;        ah = 1, al = CSW Validity bitfield     : CSW NOT valid
  2116                              <1> ;        ah = 2, al = CSW Meaningful bitfield   : CSW NOT meaningful
  2117                              <1> ;   rax destroyed
  2118 00004BD3 30E4                <1>     xor ah, ah
  2119 00004BD5 E84BFFFFFF          <1>     call .ehciMsdBOTCheckValidCSW
  2120 00004BDA 84C0                <1>     test al, al
  2121 00004BDC 7407                <1>     jz .embhiehcswmeaningful
  2122 00004BDE B401                <1>     mov ah, 1       ; CSW Not Valid signature
  2123 00004BE0 E90B000000          <1>     jmp .embhiehexit
  2124                              <1> .embhiehcswmeaningful:
  2125 00004BE5 E888FFFFFF          <1>     call .ehciMsdBOTCheckMeaningfulCSW
  2126 00004BEA 244C                <1>     and al, 4Ch     ;Check bad bits first and bCSWStatus=02 40h|08h|04h
  2127 00004BEC 7402                <1>     jz .embhiehexit
  2128 00004BEE B402                <1>     mov ah, 2       ; CSW Not Meaningful signature
  2129                              <1> .embhiehexit:
  2130 00004BF0 C3                  <1>     ret
  2131                              <1> .ehciMsdBOTOO64I:   ;For devices with 64 byte max packet size
  2132                              <1> .ehciMsdBOTOI64I:   ;For devices with 64 byte max packet size
  2133 00004BF1 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh   ;Undefined error
  2134 00004BF9 C3                  <1>     ret
  2135                              <1> .ehciMsdBOTOOI:     ;Out Out In transfer
  2136                              <1> ;Input - rsi = MSD device parameter block
  2137                              <1> ;        rbx = Input buffer for Data In
  2138                              <1> ;        ecx = Number of milliseconds to wait between Out and In packets
  2139                              <1> ;        r8  = Number of bytes to be transferred (for the DATA phase)
  2140                              <1> ;        r10 = LUN Value
  2141                              <1> ;        r11 = Length of CBW command block
  2142 00004BFA 57                  <1>     push rdi
  2143 00004BFB 4150                <1>     push r8
  2144 00004BFD 4151                <1>     push r9
  2145 00004BFF 4152                <1>     push r10
  2146 00004C01 4153                <1>     push r11
  2147 00004C03 4154                <1>     push r12
  2148 00004C05 51                  <1>     push rcx
  2149 00004C06 FC                  <1>     cld
  2150                              <1> 
  2151 00004C07 4D89C4              <1>     mov r12, r8     ;Save number of bytes to transfer to MSD device
  2152 00004C0A 51                  <1>     push rcx
  2153                              <1> ;Write QHead for CBW
  2154 00004C0B 49BB-               <1>     mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  2154 00004C0D [0001000000000000]  <1>
  2155 00004C15 E840020000          <1>     call .ehciMsdWriteOutQHead
  2156                              <1> ;Write TD for CBW send
  2157 00004C1A 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2158 00004C1D 49B801000000000000- <1>     mov r8, 1
  2158 00004C26 00                  <1>
  2159 00004C27 4D89C1              <1>     mov r9, r8
  2160 00004C2A 440FB6560F          <1>     movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  2161 00004C2F 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2162 00004C33 41D1CA              <1>     ror r10d, 1 ;Roll dt bit to upper bit of dword
  2163 00004C36 4181CA808C1F00      <1>     or r10d, 001F8C80h 
  2164                              <1> ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  2165 00004C3D 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
  2165 00004C3F [8003000000000000]  <1>
  2166 00004C47 E8BAF9FFFF          <1>     call .ehciWriteQHeadTD
  2167                              <1> 
  2168 00004C4C B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2169 00004C4E E8E6F2FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2170 00004C53 59                  <1>     pop rcx    ;Wait ecx ms for "motors to spin up"
  2171 00004C54 0F824B010000        <1>     jc .emboexit    ;If catastrophic Host system error, exit!
  2172                              <1> 
  2173 00004C5A 50                  <1>     push rax
  2174 00004C5B B486                <1>     mov ah, 86h
  2175 00004C5D CD35                <1>     int 35h
  2176 00004C5F 58                  <1>     pop rax
  2177                              <1> ;Write Qhead to Send data
  2178 00004C60 49BB80000000000000- <1>     mov r11, ehciSizeOfTD + ehciSizeOfTD
  2178 00004C69 00                  <1>
  2179 00004C6A E8EB010000          <1>     call .ehciMsdWriteOutQHead
  2180                              <1> ;Write TD for data send
  2181 00004C6F 4C89DF              <1>     mov rdi, r11
  2182 00004C72 49B801000000000000- <1>     mov r8, 1
  2182 00004C7B 00                  <1>
  2183 00004C7C 4D89C1              <1>     mov r9, r8
  2184 00004C7F 4D89E2              <1>     mov r10, r12     ;Get back number of bytes to transfer
  2185 00004C82 49C1E210            <1>     shl r10, 8*2    ;Shift into 3rd byte
  2186 00004C86 4181CA808C0000      <1>     or r10d, 00008C80h ;Add control bits: Active TD, OUT EP, Error ctr = 3
  2187 00004C8D 0FB64E0F            <1>     movzx ecx, byte [rsi + 15]  ;Get Out EP dt bit in r9d
  2188 00004C91 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2189 00004C95 D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2190 00004C97 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2191 00004C9A 4989DB              <1>     mov r11, rbx    ;Get the address of Data buffer
  2192 00004C9D E864F9FFFF          <1>     call .ehciWriteQHeadTD
  2193                              <1> 
  2194 00004CA2 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2195 00004CA4 E890F2FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2196 00004CA9 0F82F6000000        <1>     jc .emboexit    ;If catastrophic Host system error, exit!
  2197                              <1> ;Write Qhead for CSW
  2198 00004CAF 49BB-               <1>     mov r11, ehciTDSpace + 2*ehciSizeOfTD ;Third TD
  2198 00004CB1 [8001000000000000]  <1>
  2199 00004CB9 E8DB010000          <1>     call .ehciMsdWriteInQHead
  2200 00004CBE 4C89DF              <1>     mov rdi, r11
  2201 00004CC1 E9A9000000          <1>     jmp .emboiicommonep
  2202                              <1> .ehciMsdBOTOII: ;Out In In transfer
  2203                              <1> ;Input - rsi = MSD device parameter block
  2204                              <1> ;        rbx = Input buffer for Data In
  2205                              <1> ;        ecx = Number of milliseconds to wait between Out and In packets
  2206                              <1> ;        r8  = Number of bytes to be transferred (for the DATA phase)
  2207                              <1> ;        r10 = LUN Value
  2208                              <1> ;        r11 = Length of CBW command block
  2209                              <1> 
  2210 00004CC6 57                  <1>     push rdi
  2211 00004CC7 4150                <1>     push r8
  2212 00004CC9 4151                <1>     push r9
  2213 00004CCB 4152                <1>     push r10
  2214 00004CCD 4153                <1>     push r11
  2215 00004CCF 4154                <1>     push r12
  2216 00004CD1 51                  <1>     push rcx
  2217 00004CD2 FC                  <1>     cld
  2218                              <1> 
  2219 00004CD3 4D89C4              <1>     mov r12, r8 ;Save the number of bytes to be transferred
  2220 00004CD6 51                  <1>     push rcx
  2221                              <1> 
  2222                              <1> ;Write the OUT Queue Head
  2223 00004CD7 49BB-               <1>     mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  2223 00004CD9 [0001000000000000]  <1>
  2224 00004CE1 E874010000          <1>     call .ehciMsdWriteOutQHead
  2225                              <1> 
  2226 00004CE6 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2227 00004CE9 49B801000000000000- <1>     mov r8, 1
  2227 00004CF2 00                  <1>
  2228 00004CF3 4D89C1              <1>     mov r9, r8
  2229 00004CF6 440FB6560F          <1>     movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  2230 00004CFB 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2231 00004CFF 41D1CA              <1>     ror r10d, 1 ;Roll dt bit to upper bit of dword
  2232 00004D02 4181CA808C1F00      <1>     or r10d, 001F8C80h 
  2233                              <1> ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  2234 00004D09 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
  2234 00004D0B [8003000000000000]  <1>
  2235 00004D13 E8EEF8FFFF          <1>     call .ehciWriteQHeadTD
  2236                              <1> 
  2237 00004D18 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2238 00004D1A E81AF2FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2239 00004D1F 59                  <1>     pop rcx    ;Wait ecx ms for "motors to spin up"
  2240 00004D20 0F827F000000        <1>     jc .emboexit    ;If catastrophic Host system error, exit!
  2241                              <1>          
  2242 00004D26 50                  <1>     push rax
  2243 00004D27 B486                <1>     mov ah, 86h
  2244 00004D29 CD35                <1>     int 35h
  2245 00004D2B 58                  <1>     pop rax
  2246                              <1> ;Write the IN Queue Head
  2247 00004D2C 49BB-               <1>     mov r11, ehciTDSpace + ehciSizeOfTD ;Move to position 2 to preserve OUT TD
  2247 00004D2E [4001000000000000]  <1>
  2248 00004D36 E85E010000          <1>     call .ehciMsdWriteInQHead
  2249                              <1> 
  2250 00004D3B 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2251 00004D3E 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]  ;Point to next TD
  2252 00004D42 4D89C1              <1>     mov r9, r8
  2253 00004D45 4D89E2              <1>     mov r10, r12     ;Get back number of bytes to transfer from the stack
  2254 00004D48 49C1E210            <1>     shl r10, 8*2    ;Shift into 3rd byte
  2255 00004D4C 4181CA800D0000      <1>     or r10d, 00000D80h ;Add control bits: Active TD, IN EP, Error ctr = 3
  2256 00004D53 0FB64E0E            <1>     movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  2257 00004D57 80760E01            <1>     xor byte [rsi + 14], 1  ;Toggle bit
  2258 00004D5B D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2259 00004D5D 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2260 00004D60 4989DB              <1>     mov r11, rbx ; Data out buffer, default ehciDataIn
  2261 00004D63 E89EF8FFFF          <1>     call .ehciWriteQHeadTD
  2262                              <1> 
  2263 00004D68 4881C740000000      <1>     add rdi, ehciSizeOfTD     ;Go to next TD space
  2264                              <1> .emboiicommonep:
  2265 00004D6F 49B801000000000000- <1>     mov r8, 1
  2265 00004D78 00                  <1>
  2266 00004D79 4D89C1              <1>     mov r9, r8
  2267 00004D7C 41BA808D0D00        <1>     mov r10d, 000D8D80h     ;Active TD, IN EP, Error ctr = 3, 0Dh = 13 byte CSW
  2268 00004D82 0FB64E0E            <1>     movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  2269 00004D86 80760E01            <1>     xor byte [rsi + 14], 1  ;Toggle bit
  2270 00004D8A D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2271 00004D8C 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2272 00004D8F 49BB-               <1>     mov r11, msdCSW
  2272 00004D91 [C005000000000000]  <1>
  2273                              <1> 
  2274 00004D99 E868F8FFFF          <1>     call .ehciWriteQHeadTD
  2275                              <1> 
  2276 00004D9E B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2277 00004DA0 E894F1FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2278                              <1> .emboexit:
  2279 00004DA5 59                  <1>     pop rcx
  2280 00004DA6 415C                <1>     pop r12
  2281 00004DA8 415B                <1>     pop r11
  2282 00004DAA 415A                <1>     pop r10
  2283 00004DAC 4159                <1>     pop r9
  2284 00004DAE 4158                <1>     pop r8
  2285 00004DB0 5F                  <1>     pop rdi
  2286 00004DB1 C3                  <1>     ret
  2287                              <1> .ehciMsdBOTOI: ;Out In transfer
  2288                              <1> ;Input - rsi = MSD device parameter block
  2289                              <1> ;        rbx = Input buffer for Data In
  2290                              <1> ;        ecx = Number of milliseconds to wait between Out and In packets
  2291                              <1> ;        r8  = Number of bytes to be transferred (for the DATA phase)
  2292                              <1> ;        r10 = LUN Value
  2293                              <1> ;        r11 = Length of CBW command block
  2294                              <1> 
  2295 00004DB2 57                  <1>     push rdi
  2296 00004DB3 4150                <1>     push r8
  2297 00004DB5 4151                <1>     push r9
  2298 00004DB7 4152                <1>     push r10
  2299 00004DB9 4153                <1>     push r11
  2300 00004DBB 51                  <1>     push rcx
  2301 00004DBC FC                  <1>     cld
  2302                              <1> 
  2303                              <1> 
  2304                              <1> ;Write the OUT Queue Head
  2305 00004DBD 49BB-               <1>     mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  2305 00004DBF [0001000000000000]  <1>
  2306 00004DC7 E88E000000          <1>     call .ehciMsdWriteOutQHead
  2307                              <1> 
  2308 00004DCC 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2309 00004DCF 49B801000000000000- <1>     mov r8, 1
  2309 00004DD8 00                  <1>
  2310 00004DD9 4D89C1              <1>     mov r9, r8
  2311 00004DDC 440FB6560F          <1>     movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  2312 00004DE1 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2313 00004DE5 41D1CA              <1>     ror r10d, 1 ;Roll dt bit to upper bit of dword
  2314 00004DE8 4181CA808C1F00      <1>     or r10d, 001F8C80h 
  2315                              <1> ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  2316 00004DEF 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
  2316 00004DF1 [8003000000000000]  <1>
  2317 00004DF9 E808F8FFFF          <1>     call .ehciWriteQHeadTD
  2318                              <1> 
  2319 00004DFE B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2320 00004E00 E834F1FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2321 00004E05 7248                <1>     jc .emboiexit    ;If catastrophic Host system error, exit!
  2322                              <1>          
  2323                              <1> ;Write the IN Queue Head
  2324 00004E07 49BB-               <1>     mov r11, ehciTDSpace + ehciSizeOfTD ;Move to position 2 to preserve OUT TD
  2324 00004E09 [4001000000000000]  <1>
  2325 00004E11 E883000000          <1>     call .ehciMsdWriteInQHead
  2326                              <1> 
  2327 00004E16 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2328 00004E19 49B801000000000000- <1>     mov r8, 1
  2328 00004E22 00                  <1>
  2329 00004E23 4D89C1              <1>     mov r9, r8
  2330 00004E26 41BA808D0D00        <1>     mov r10d, 000D8D80h     ;Active TD, IN EP, Error ctr = 3, 0Dh = 13 byte CSW
  2331 00004E2C 0FB64E0E            <1>     movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  2332 00004E30 80760E01            <1>     xor byte [rsi + 14], 1  ;Toggle bit
  2333 00004E34 D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2334 00004E36 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2335 00004E39 49BB-               <1>     mov r11, msdCSW
  2335 00004E3B [C005000000000000]  <1>
  2336                              <1> 
  2337 00004E43 E8BEF7FFFF          <1>     call .ehciWriteQHeadTD
  2338                              <1> 
  2339 00004E48 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2340 00004E4A E8EAF0FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2341                              <1> .emboiexit:
  2342 00004E4F 59                  <1>     pop rcx
  2343 00004E50 415B                <1>     pop r11
  2344 00004E52 415A                <1>     pop r10
  2345 00004E54 4159                <1>     pop r9
  2346 00004E56 4158                <1>     pop r8
  2347 00004E58 5F                  <1>     pop rdi
  2348 00004E59 C3                  <1>     ret
  2349                              <1> .ehciMsdWriteOutQHead:
  2350                              <1> ;Input: rsi = Valid MSD device
  2351                              <1> ;       r11 = Ptr to First QHTD
  2352 00004E5A E84CEEFFFF          <1>     call .ehciGetNewQHeadAddr
  2353 00004E5F 4181C802000000      <1>     or r8d, 2    ;Process QHs
  2354 00004E66 41B900600000        <1>     mov r9d, 00006000h  ;Default mask, no nak counter
  2355 00004E6C 0FB74E0C            <1>     movzx ecx, word [rsi + 12]  ;wMaxPacketSizeOut
  2356 00004E70 C1E110              <1>     shl ecx, 8*2
  2357 00004E73 4109C9              <1>     or r9d, ecx
  2358 00004E76 0FB64E0B            <1>     movzx ecx, byte [rsi + 11]  ;EP address
  2359 00004E7A 81E10F000000        <1>     and ecx, 0Fh
  2360 00004E80 C1E108              <1>     shl ecx, 8  ;Shift to second byte 
  2361 00004E83 4109C9              <1>     or r9d, ecx ;Add bits
  2362 00004E86 8A06                <1>     mov al, byte [rsi]  ;Get device address
  2363 00004E88 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
  2364 00004E8A 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
  2365 00004E8D 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
  2366 00004E93 E849F7FFFF          <1>     call .ehciWriteQHead
  2367 00004E98 C3                  <1>     ret
  2368                              <1> .ehciMsdWriteInQHead:
  2369                              <1> ;Input: rsi = Valid MSD device
  2370                              <1> ;       r11 = Ptr to First QHTD
  2371 00004E99 E80DEEFFFF          <1>     call .ehciGetNewQHeadAddr
  2372 00004E9E 4981C802000000      <1>     or r8, 2
  2373 00004EA5 41B900600000        <1>     mov r9d, 00006000h  ;Default mask
  2374 00004EAB 0FB74E09            <1>     movzx ecx, word [rsi + 9]  ;wMaxPacketSizeIn
  2375 00004EAF C1E110              <1>     shl ecx, 8*2
  2376 00004EB2 4109C9              <1>     or r9d, ecx
  2377 00004EB5 0FB64E08            <1>     movzx ecx, byte [rsi + 8]  ;EP address
  2378 00004EB9 81E10F000000        <1>     and ecx, 0Fh
  2379 00004EBF C1E108              <1>     shl ecx, 8  ;Shift to second byte 
  2380 00004EC2 4109C9              <1>     or r9d, ecx ;Add bits
  2381 00004EC5 8A06                <1>     mov al, byte [rsi]  ;Get device address
  2382 00004EC7 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
  2383 00004EC9 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
  2384 00004ECC 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
  2385 00004ED2 E80AF7FFFF          <1>     call .ehciWriteQHead
  2386 00004ED7 C3                  <1>     ret
  2387                              <1> .ehciMsdBOTRequest:
  2388                              <1> ;Input: ecx = Number of miliseconds to wait between Out and In requests
  2389                              <1> ;       rbx = Data in Buffer
  2390                              <1> ;       r8  = Number of bytes to be returned by command
  2391                              <1> ;       r11 = Length of SCSI command block
  2392                              <1> ;       r14 = Pointer to EHCI(USB) transaction function
  2393                              <1> ;       r15 = Pointer to SCSI command function
  2394                              <1> ;Output:
  2395                              <1> ;   CF=CY: Host error, Reset host system
  2396                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2397 00004ED8 50                  <1>     push rax
  2398 00004ED9 51                  <1>     push rcx
  2399 00004EDA 57                  <1>     push rdi
  2400 00004EDB 4151                <1>     push r9
  2401 00004EDD 4152                <1>     push r10
  2402                              <1> ;Clear the previous CSW
  2403 00004EDF 48BF-               <1>     mov rdi, msdCSW
  2403 00004EE1 [C005000000000000]  <1>
  2404 00004EE9 30C0                <1>     xor al, al
  2405 00004EEB B90D000000          <1>     mov ecx, 13
  2406 00004EF0 F3AA                <1>     rep stosb
  2407                              <1> ;Write the CBW
  2408 00004EF2 48BF-               <1>     mov rdi, ehciDataOut    ;Write the CBW at the data out point
  2408 00004EF4 [8003000000000000]  <1>
  2409                              <1> 
  2410 00004EFC 41B180              <1>     mov r9b, 80h            ;Recieve an IN packet
  2411 00004EFF 4D31D2              <1>     xor r10, r10            ;LUN 0
  2412 00004F02 E865030000          <1>     call .msdWriteCBW       ;Write the 15 byte CBW
  2413                              <1> ;Append the Command Block to the CBW
  2414 00004F07 30C0                <1>     xor al, al              ;LUN 0 device
  2415 00004F09 41FFD7              <1>     call r15                ;Write the valid CBW Command block
  2416                              <1> ;Enact transaction
  2417 00004F0C 41FFD6              <1>     call r14
  2418                              <1> 
  2419 00004F0F 415A                <1>     pop r10
  2420 00004F11 4159                <1>     pop r9
  2421 00004F13 5F                  <1>     pop rdi
  2422 00004F14 59                  <1>     pop rcx
  2423 00004F15 58                  <1>     pop rax
  2424 00004F16 C3                  <1>     ret
  2425                              <1> 
  2426                              <1> .ehciMsdBOTInquiry:
  2427                              <1> ;Input: 
  2428                              <1> ; rsi = Pointer to MSD table data structure that we want to Inqure
  2429                              <1> ;Output:
  2430                              <1> ;   CF=CY: Host error, Reset host system
  2431                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2432 00004F17 53                  <1>     push rbx
  2433 00004F18 51                  <1>     push rcx
  2434 00004F19 4150                <1>     push r8
  2435 00004F1B 4153                <1>     push r11
  2436 00004F1D 4156                <1>     push r14
  2437 00004F1F 4157                <1>     push r15
  2438 00004F21 48BB-               <1>     mov rbx, ehciDataIn
  2438 00004F23 [C003000000000000]  <1>
  2439 00004F2B B900000000          <1>     mov ecx, 0
  2440 00004F30 41B824000000        <1>     mov r8d, 024h           ;36 bytes to be returned
  2441 00004F36 49BB0C000000000000- <1>     mov r11, 0Ch            ;The command block is 12 bytes (As per Bootability)
  2441 00004F3F 00                  <1>
  2442 00004F40 49BF-               <1>     mov r15, .scsiInquiry
  2442 00004F42 [9D52000000000000]  <1>
  2443 00004F4A 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2443 00004F4C [C64C000000000000]  <1>
  2444 00004F54 E87FFFFFFF          <1>     call .ehciMsdBOTRequest
  2445 00004F59 415F                <1>     pop r15
  2446 00004F5B 415E                <1>     pop r14
  2447 00004F5D 415B                <1>     pop r11
  2448 00004F5F 4158                <1>     pop r8
  2449 00004F61 59                  <1>     pop rcx
  2450 00004F62 5B                  <1>     pop rbx
  2451 00004F63 C3                  <1>     ret
  2452                              <1> 
  2453                              <1> .ehciMsdBOTReadFormatCapacities:
  2454                              <1> ;Input: 
  2455                              <1> ; rsi = Pointer to MSD table data structure
  2456                              <1> ;Output:
  2457                              <1> ;   CF=CY: Host error, Reset host system
  2458                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2459 00004F64 53                  <1>     push rbx
  2460 00004F65 51                  <1>     push rcx
  2461 00004F66 4150                <1>     push r8
  2462 00004F68 4153                <1>     push r11
  2463 00004F6A 4156                <1>     push r14
  2464 00004F6C 4157                <1>     push r15
  2465 00004F6E 48BB-               <1>     mov rbx, ehciDataIn
  2465 00004F70 [C003000000000000]  <1>
  2466 00004F78 B900000000          <1>     mov ecx, 0
  2467 00004F7D 49B8FC000000000000- <1>     mov r8, 0FCh            ;Return 252 bytes
  2467 00004F86 00                  <1>
  2468 00004F87 49BB0A000000000000- <1>     mov r11, 0Ah            ;The command block is 10 bytes
  2468 00004F90 00                  <1>
  2469 00004F91 49BF-               <1>     mov r15, .scsiReadFormatCapacities
  2469 00004F93 [FC52000000000000]  <1>
  2470 00004F9B 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2470 00004F9D [C64C000000000000]  <1>
  2471 00004FA5 E82EFFFFFF          <1>     call .ehciMsdBOTRequest
  2472 00004FAA 415F                <1>     pop r15
  2473 00004FAC 415E                <1>     pop r14
  2474 00004FAE 415B                <1>     pop r11
  2475 00004FB0 4158                <1>     pop r8
  2476 00004FB2 59                  <1>     pop rcx
  2477 00004FB3 5B                  <1>     pop rbx
  2478 00004FB4 C3                  <1>     ret
  2479                              <1> 
  2480                              <1> .ehciMsdBOTReadCapacity10:
  2481                              <1> ;Input: 
  2482                              <1> ; rsi = Pointer to MSD table data structure that we want to Read Capcities
  2483                              <1> ;Output:
  2484                              <1> ;   CF=CY: Host error, Reset host system
  2485                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2486 00004FB5 53                  <1>     push rbx
  2487 00004FB6 51                  <1>     push rcx
  2488 00004FB7 4150                <1>     push r8
  2489 00004FB9 4153                <1>     push r11
  2490 00004FBB 4156                <1>     push r14
  2491 00004FBD 4157                <1>     push r15
  2492 00004FBF 48BB-               <1>     mov rbx, ehciDataIn
  2492 00004FC1 [C003000000000000]  <1>
  2493 00004FC9 B900000000          <1>     mov ecx, 0
  2494 00004FCE 49B808000000000000- <1>     mov r8, 8
  2494 00004FD7 00                  <1>
  2495 00004FD8 49BB0A000000000000- <1>     mov r11, 0Ah
  2495 00004FE1 00                  <1>
  2496 00004FE2 49BF-               <1>     mov r15, .scsiReadCap10
  2496 00004FE4 [0C53000000000000]  <1>
  2497 00004FEC 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2497 00004FEE [C64C000000000000]  <1>
  2498 00004FF6 E8DDFEFFFF          <1>     call .ehciMsdBOTRequest
  2499 00004FFB 415F                <1>     pop r15
  2500 00004FFD 415E                <1>     pop r14
  2501 00004FFF 415B                <1>     pop r11
  2502 00005001 4158                <1>     pop r8
  2503 00005003 59                  <1>     pop rcx
  2504 00005004 5B                  <1>     pop rbx
  2505 00005005 C3                  <1>     ret
  2506                              <1> .ehciMsdBOTFormatUnit:
  2507                              <1> ;Input: 
  2508                              <1> ; rsi = Pointer to MSD table data structure that we want to Format
  2509                              <1> ;Output:
  2510                              <1> ;   CF=CY: Host error, Reset host system
  2511                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2512 00005006 50                  <1>     push rax
  2513 00005007 4150                <1>     push r8
  2514 00005009 4153                <1>     push r11
  2515 0000500B 4156                <1>     push r14
  2516 0000500D 4157                <1>     push r15
  2517 0000500F 4D31C0              <1>     xor r8, r8  ;Request no data
  2518 00005012 49BB06000000000000- <1>     mov r11, 06h  ;Command length is 6 bytes
  2518 0000501B 00                  <1>
  2519 0000501C 49BE-               <1>     mov r14, .ehciMsdBOTOI
  2519 0000501E [B24D000000000000]  <1>
  2520 00005026 49BF-               <1>     mov r15, .scsiFormatUnit
  2520 00005028 [1653000000000000]  <1>
  2521 00005030 E8A3FEFFFF          <1>     call .ehciMsdBOTRequest
  2522 00005035 7236                <1>     jc .embfuerror
  2523 00005037 E897FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2524 0000503C 6685C0              <1>     test ax, ax
  2525 0000503F 752C                <1>     jnz .embfuerror
  2526                              <1> .embfu0:
  2527 00005041 E8CA000000          <1>     call .ehciMsdBOTTestReady
  2528 00005046 7225                <1>     jc .embfuerror
  2529 00005048 E886FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2530 0000504D 6685C0              <1>     test ax, ax
  2531 00005050 7411                <1>     jz .embfuexit
  2532 00005052 E868000000          <1>     call .ehciMsdBOTRequestSense
  2533 00005057 7214                <1>     jc .embfuerror
  2534 00005059 E875FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2535 0000505E 6685C0              <1>     test ax, ax
  2536 00005061 75DE                <1>     jnz .embfu0
  2537                              <1> .embfuexit:
  2538 00005063 415F                <1>     pop r15
  2539 00005065 415E                <1>     pop r14
  2540 00005067 415B                <1>     pop r11
  2541 00005069 4158                <1>     pop r8
  2542 0000506B 58                  <1>     pop rax
  2543 0000506C C3                  <1>     ret
  2544                              <1> .embfuerror:
  2545 0000506D F9                  <1>     stc
  2546 0000506E EBF3                <1>     jmp short .embfuexit
  2547                              <1> .ehciMsdBOTVerify:
  2548                              <1> ;Input: 
  2549                              <1> ; rsi = Pointer to MSD table data structure that we want to Verify Sectors
  2550                              <1> ; edx = Starting LBA to verify
  2551                              <1> ;Output:
  2552                              <1> ;   CF=CY: Host error, Reset host system
  2553                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2554 00005070 50                  <1>     push rax
  2555 00005071 4150                <1>     push r8
  2556 00005073 4153                <1>     push r11
  2557 00005075 4154                <1>     push r12
  2558 00005077 4156                <1>     push r14
  2559 00005079 4157                <1>     push r15
  2560 0000507B 4D31C0              <1>     xor r8, r8  ;Request no data
  2561 0000507E 49BB0A000000000000- <1>     mov r11, 0Ah  ;Command length is 10 bytes
  2561 00005087 00                  <1>
  2562 00005088 4189D4              <1>     mov r12d, edx
  2563 0000508B 49BE-               <1>     mov r14, .ehciMsdBOTOI
  2563 0000508D [B24D000000000000]  <1>
  2564 00005095 49BF-               <1>     mov r15, .scsiVerify
  2564 00005097 [2B53000000000000]  <1>
  2565 0000509F E834FEFFFF          <1>     call .ehciMsdBOTRequest
  2566 000050A4 7216                <1>     jc .embvbad
  2567 000050A6 E828FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2568 000050AB 6685C0              <1>     test ax, ax
  2569 000050AE 750C                <1>     jnz .embvbad
  2570                              <1> .embvexit:
  2571 000050B0 415F                <1>     pop r15
  2572 000050B2 415E                <1>     pop r14
  2573 000050B4 415C                <1>     pop r12
  2574 000050B6 415B                <1>     pop r11
  2575 000050B8 4158                <1>     pop r8
  2576 000050BA 59                  <1>     pop rcx
  2577 000050BB C3                  <1>     ret
  2578                              <1> .embvbad:
  2579 000050BC F9                  <1>     stc
  2580 000050BD EBF1                <1>     jmp short .embvexit
  2581                              <1> .ehciMsdBOTRequestSense:
  2582                              <1> ;Input: 
  2583                              <1> ; rsi = Pointer to device MSD table data structure
  2584                              <1> ;Output:
  2585                              <1> ;   CF=CY: Host error, Reset host system
  2586                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2587 000050BF 53                  <1>     push rbx
  2588 000050C0 51                  <1>     push rcx
  2589 000050C1 4150                <1>     push r8
  2590 000050C3 4153                <1>     push r11
  2591 000050C5 4156                <1>     push r14
  2592 000050C7 4157                <1>     push r15
  2593 000050C9 48BB-               <1>     mov rbx, ehciDataIn
  2593 000050CB [C003000000000000]  <1>
  2594 000050D3 B900000000          <1>     mov ecx, 0
  2595 000050D8 49B812000000000000- <1>     mov r8, 12h         ;Request 18 bytes
  2595 000050E1 00                  <1>
  2596 000050E2 49BB06000000000000- <1>     mov r11, 6          ;Command length is 6
  2596 000050EB 00                  <1>
  2597 000050EC 49BF-               <1>     mov r15, .scsiRequestSense
  2597 000050EE [DF52000000000000]  <1>
  2598 000050F6 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2598 000050F8 [C64C000000000000]  <1>
  2599 00005100 E8D3FDFFFF          <1>     call .ehciMsdBOTRequest
  2600 00005105 415F                <1>     pop r15
  2601 00005107 415E                <1>     pop r14
  2602 00005109 415B                <1>     pop r11
  2603 0000510B 4158                <1>     pop r8
  2604 0000510D 59                  <1>     pop rcx
  2605 0000510E 5B                  <1>     pop rbx
  2606 0000510F C3                  <1>     ret
  2607                              <1> 
  2608                              <1> .ehciMsdBOTTestReady:
  2609                              <1> ;Input: 
  2610                              <1> ; rsi = Pointer to MSD table data structure that we want to Test Ready
  2611                              <1> ;Output:
  2612                              <1> ;   CF=CY: Host error, Reset host system
  2613                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2614 00005110 4150                <1>     push r8
  2615 00005112 4153                <1>     push r11
  2616 00005114 4156                <1>     push r14
  2617 00005116 4157                <1>     push r15
  2618 00005118 4D31C0              <1>     xor r8, r8  ;Request no data
  2619 0000511B 49BB06000000000000- <1>     mov r11, 6  ;Command length is 6
  2619 00005124 00                  <1>
  2620 00005125 49BE-               <1>     mov r14, .ehciMsdBOTOI
  2620 00005127 [B24D000000000000]  <1>
  2621 0000512F 49BF-               <1>     mov r15, .scsiTestUnitReady
  2621 00005131 [F252000000000000]  <1>
  2622 00005139 E89AFDFFFF          <1>     call .ehciMsdBOTRequest
  2623 0000513E 415F                <1>     pop r15
  2624 00005140 415E                <1>     pop r14
  2625 00005142 415B                <1>     pop r11
  2626 00005144 4158                <1>     pop r8
  2627 00005146 C3                  <1>     ret
  2628                              <1> .ehciMsdBOTModeSense6:
  2629                              <1> ;Input: 
  2630                              <1> ; rsi = Pointer to MSD table data structure that we want to Test Ready
  2631                              <1> ;Output:
  2632                              <1> ;   CF=CY: Host error, Reset host system
  2633                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2634 00005147 53                  <1>     push rbx
  2635 00005148 51                  <1>     push rcx
  2636 00005149 4150                <1>     push r8
  2637 0000514B 4153                <1>     push r11
  2638 0000514D 4156                <1>     push r14
  2639 0000514F 4157                <1>     push r15
  2640 00005151 48BB-               <1>     mov rbx, ehciDataIn
  2640 00005153 [C003000000000000]  <1>
  2641 0000515B B900000000          <1>     mov ecx, 0
  2642 00005160 49B8C0000000000000- <1>     mov r8, 0C0h        ;Request 192 bytes
  2642 00005169 00                  <1>
  2643 0000516A 49BB06000000000000- <1>     mov r11, 6          ;Command length is 6
  2643 00005173 00                  <1>
  2644 00005174 49BF-               <1>     mov r15, .scsiModeSense6
  2644 00005176 [4C53000000000000]  <1>
  2645 0000517E 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2645 00005180 [C64C000000000000]  <1>
  2646 00005188 E84BFDFFFF          <1>     call .ehciMsdBOTRequest
  2647 0000518D 415F                <1>     pop r15
  2648 0000518F 415E                <1>     pop r14
  2649 00005191 415B                <1>     pop r11
  2650 00005193 4158                <1>     pop r8
  2651 00005195 59                  <1>     pop rcx
  2652 00005196 5B                  <1>     pop rbx
  2653 00005197 C3                  <1>     ret
  2654                              <1> 
  2655                              <1> ;.ehciMsdBOTOutSector64:
  2656                              <1> .ehciMsdBOTOutSector512:
  2657                              <1> ;Input: 
  2658                              <1> ; rsi = Pointer to MSD table data structure that we want to read
  2659                              <1> ; rbx = Address of the buffer to read the segment from
  2660                              <1> ; edx = Starting LBA to read to
  2661                              <1> ;Output:
  2662                              <1> ;   CF=CY: Host error, Reset host system
  2663                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2664 00005198 4151                <1>     push r9
  2665 0000519A 4156                <1>     push r14
  2666 0000519C 4157                <1>     push r15
  2667 0000519E 50                  <1>     push rax
  2668 0000519F 4D31C9              <1>     xor r9, r9 ;Send an OUT packet
  2669 000051A2 49BE-               <1>     mov r14, .ehciMsdBOTOOI
  2669 000051A4 [FA4B000000000000]  <1>
  2670 000051AC 49BF-               <1>     mov r15, .scsiWrite10
  2670 000051AE [B852000000000000]  <1>
  2671 000051B6 E860000000          <1>     call .ehciMsdBOTSector512
  2672 000051BB 7223                <1>     jc .emboseerror
  2673 000051BD E811FAFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2674 000051C2 6685C0              <1>     test ax, ax
  2675 000051C5 7519                <1>     jnz .emboseerror
  2676 000051C7 E844FFFFFF          <1>     call .ehciMsdBOTTestReady   ;Seems to flush data onto disk
  2677 000051CC 7212                <1>     jc .emboseerror
  2678 000051CE E800FAFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2679 000051D3 6685C0              <1>     test ax, ax
  2680 000051D6 7508                <1>     jnz .emboseerror
  2681                              <1> .embosexit:
  2682 000051D8 58                  <1>     pop rax
  2683 000051D9 415F                <1>     pop r15
  2684 000051DB 415E                <1>     pop r14
  2685 000051DD 4159                <1>     pop r9
  2686 000051DF C3                  <1>     ret
  2687                              <1> .emboseerror:
  2688 000051E0 F9                  <1>     stc
  2689 000051E1 EBF5                <1>     jmp short .embosexit
  2690                              <1> ;.ehciMsdBOTInSector64:
  2691                              <1> .ehciMsdBOTInSector512:
  2692                              <1> ;Input: 
  2693                              <1> ; rsi = Pointer to MSD table data structure that we want to read
  2694                              <1> ; rbx = Address of the buffer to read the segment into
  2695                              <1> ; edx = Starting LBA to read from
  2696                              <1> ;Output:
  2697                              <1> ;   CF=CY: Host error, Reset host system
  2698                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2699 000051E3 4151                <1>     push r9
  2700 000051E5 4156                <1>     push r14
  2701 000051E7 4157                <1>     push r15
  2702 000051E9 50                  <1>     push rax
  2703 000051EA 49B980000000000000- <1>     mov r9, 80h ;Recieve an IN packet
  2703 000051F3 00                  <1>
  2704 000051F4 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2704 000051F6 [C64C000000000000]  <1>
  2705 000051FE 49BF-               <1>     mov r15, .scsiRead10
  2705 00005200 [BC52000000000000]  <1>
  2706 00005208 E80E000000          <1>     call .ehciMsdBOTSector512
  2707 0000520D 72D1                <1>     jc .emboseerror
  2708 0000520F E8BFF9FFFF          <1>     call .ehciMsdBOTCheckTransaction
  2709 00005214 6685C0              <1>     test ax, ax
  2710 00005217 75C7                <1>     jnz .emboseerror
  2711 00005219 EBBD                <1>     jmp short .embosexit
  2712                              <1> .ehciMsdBOTSector512:
  2713                              <1> ;Input: 
  2714                              <1> ; rsi = Pointer to MSD table data structure that we want to read
  2715                              <1> ; rbx = Address of the buffer to read the segment into
  2716                              <1> ; edx = Starting LBA to read to/from
  2717                              <1> ; r9  = CBW flag (IN or OUT transaction)
  2718                              <1> ; r15 = SCSI function
  2719                              <1> ;Output:
  2720                              <1> ;   CF=CY: Host error, Reset host system
  2721                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2722 0000521B 57                  <1>     push rdi
  2723 0000521C 4150                <1>     push r8
  2724 0000521E 4152                <1>     push r10
  2725 00005220 4153                <1>     push r11
  2726                              <1> 
  2727 00005222 48BF-               <1>     mov rdi, ehciDataOut    ;Write the CBW at the data out point
  2727 00005224 [8003000000000000]  <1>
  2728 0000522C 41B800020000        <1>     mov r8d, 200h           ;512 bytes to be transferred
  2729 00005232 4D31D2              <1>     xor r10, r10            ;LUN 0
  2730 00005235 49BB0C000000000000- <1>     mov r11, 0Ch            ;The command block is 10 bytes long
  2730 0000523E 00                  <1>
  2731 0000523F E828000000          <1>     call .msdWriteCBW     ;Write the CBW
  2732                              <1> 
  2733 00005244 50                  <1>     push rax                ;Temp push ax
  2734 00005245 4150                <1>     push r8                 ;Temp save # of bytes for transfer
  2735 00005247 30C0                <1>     xor al, al              ;LUN 0 device
  2736 00005249 4189D0              <1>     mov r8d, edx            ;Starting LBA to read from
  2737 0000524C 49B901000000000000- <1>     mov r9, 1               ;Number of LBAs to read
  2737 00005255 00                  <1>
  2738 00005256 41FFD7              <1>     call r15                ;Write the valid CBW Command block
  2739 00005259 4158                <1>     pop r8
  2740 0000525B 58                  <1>     pop rax
  2741                              <1> 
  2742 0000525C B90A000000          <1>     mov ecx, 10              ;Wait for data preparation, 10ms
  2743 00005261 41FFD6              <1>     call r14
  2744                              <1> 
  2745 00005264 415B                <1>     pop r11
  2746 00005266 415A                <1>     pop r10
  2747 00005268 4158                <1>     pop r8
  2748 0000526A 5F                  <1>     pop rdi
  2749 0000526B C3                  <1>     ret
  2750                              <1> .msdWriteCBW:
  2751                              <1> ;Writes a Command Block Wrapper at the location pointed to by rdi
  2752                              <1> ; without a functional command block. Must be appended by user.
  2753                              <1> ; Input:  rdi=Pointer to CBW buffer
  2754                              <1> ;         r8d=Command Block Wrapper Data Transfer Length
  2755                              <1> ;         r9b=Command Block Wrapper Flags
  2756                              <1> ;         r10b=Command Block Wrapper LUN nybble
  2757                              <1> ;         r11b=Command Block Wrapper Command Block Length
  2758                              <1> ; Output: rdi = Pointer to CBW's (SCSI) Command Descriptor Block buffer
  2759 0000526C 50                  <1>     push rax
  2760 0000526D B855534243          <1>     mov eax, CBWSig
  2761 00005272 AB                  <1>     stosd
  2762 00005273 0FB60425[4A020000]  <1>     movzx eax, byte [cbwTag]
  2763 0000527B FE0425[4A020000]    <1>     inc byte [cbwTag]
  2764 00005282 AB                  <1>     stosd
  2765 00005283 4489C0              <1>     mov eax, r8d
  2766 00005286 AB                  <1>     stosd
  2767 00005287 4488C8              <1>     mov al, r9b
  2768 0000528A AA                  <1>     stosb
  2769 0000528B 4488D0              <1>     mov al, r10b
  2770 0000528E AA                  <1>     stosb
  2771 0000528F 4488D8              <1>     mov al, r11b
  2772 00005292 AA                  <1>     stosb
  2773 00005293 31C0                <1>     xor eax, eax
  2774 00005295 57                  <1>     push rdi
  2775 00005296 48AB                <1>     stosq   ;16 bytes in csw command block
  2776 00005298 48AB                <1>     stosq   ;Clear memory
  2777 0000529A 5F                  <1>     pop rdi
  2778 0000529B 58                  <1>     pop rax
  2779 0000529C C3                  <1>     ret
  2780                              <1> 
  2781                              <1> ;                        --------SCSI functions---------
  2782                              <1> 
  2783                              <1> .scsiInquiry:
  2784                              <1> ;Writes an inquiry scsi command block to the location pointed to by rdi
  2785                              <1> ;al contains the LUN of the device we are accessing. (lower 3 bits considered)
  2786                              <1> ;al not preserved
  2787 0000529D B412                <1>     mov ah, 12h        ;Move inquiry command value high
  2788 0000529F C0E005              <1>     shl al, 5        ;Shift left by five to align LUN properly
  2789 000052A2 86E0                <1>     xchg ah, al        ;swap ah and al
  2790 000052A4 66AB                <1>     stosw            ;Store command and shifted LUN together
  2791 000052A6 4831C0              <1>     xor rax, rax
  2792 000052A9 66AB                <1>     stosw            ;Store two zeros (reserved fields)
  2793 000052AB 48B824000000000000- <1>     mov rax, 24h    ;Allocation length (36 bytes)
  2793 000052B4 00                  <1>
  2794 000052B5 48AB                <1>     stosq
  2795 000052B7 C3                  <1>     ret
  2796                              <1> ;NOTE! Using read/write 10 means can't read beyond the first 4 Gb of Medium.
  2797                              <1> .scsiWrite10:
  2798                              <1> ;Writes a scsi write 10 transfer command to the location pointed at by rdi
  2799                              <1> ;al contains the LUN of the device we are accessing
  2800                              <1> ;r8d contains the LBA start address
  2801                              <1> ;r9w contains the Verification Length
  2802 000052B8 B42A                <1>     mov ah, 2Ah        ;Operation code for command
  2803 000052BA EB02                <1>     jmp short .scsirw
  2804                              <1> .scsiRead10:
  2805                              <1> ;Writes a scsi Read 10 command to the location pointed to by rdi
  2806                              <1> ;al contains the LUN of the device we are accessing.
  2807                              <1> ;r8d contains the LBA to read from
  2808                              <1> ;r9w contains the number of contiguous blocks to read (should be 1 for us)
  2809 000052BC B428                <1>     mov ah, 28h        ;Move read(10) command value high
  2810                              <1> .scsirw:
  2811 000052BE C0E005              <1>     shl al, 5        ;Shift left by five to align LUN properly
  2812 000052C1 86E0                <1>     xchg ah, al        ;swap ah and al
  2813 000052C3 66AB                <1>     stosw            ;Store command and shifted LUN together
  2814 000052C5 410FC8              <1>     bswap r8d        ;swap endianness of r8d
  2815 000052C8 4489C0              <1>     mov eax, r8d
  2816 000052CB AB                  <1>     stosd
  2817 000052CC 4831C0              <1>     xor rax, rax    ;Clear for a Reserved byte
  2818 000052CF AA                  <1>     stosb
  2819 000052D0 664489C8            <1>     mov ax, r9w        ;move into ax to use xchg on upper and lower bytes
  2820 000052D4 86C4                <1>     xchg al, ah        ;MSB first, yuck yuck yuck
  2821 000052D6 66AB                <1>     stosw
  2822 000052D8 C1E810              <1>     shr eax, 16        ;Bring zeros down onto lower word
  2823 000052DB 66AB                <1>     stosw            ;Store one reserved byte and two padding bytes
  2824 000052DD AA                  <1>     stosb            
  2825 000052DE C3                  <1>     ret
  2826                              <1> .scsiRequestSense:
  2827                              <1> ;Writes a scsi Request Sense command to the location pointer to by rdi
  2828                              <1> ;al contains the LUN of the device we are accessing.
  2829 000052DF B403                <1>     mov ah, 03h        ;Move reqsense command value high
  2830 000052E1 C0E005              <1>     shl al, 5        ;Shift left by five to align LUN properly
  2831 000052E4 86E0                <1>     xchg ah, al        ;swap ah and al
  2832 000052E6 66AB                <1>     stosw            ;Store command and shifted LUN together
  2833 000052E8 4831C0              <1>     xor rax, rax    
  2834 000052EB 66AB                <1>     stosw            ;Reserved word
  2835 000052ED B012                <1>     mov al, 12h    ;Move alloc length byte into al
  2836 000052EF 48AB                <1>     stosq
  2837 000052F1 C3                  <1>     ret
  2838                              <1> .scsiTestUnitReady:
  2839                              <1> ;Writes a scsi test unit ready command to the location pointed to by rdi
  2840                              <1> ;al contains the LUN of the device we are accessing.
  2841 000052F2 30E4                <1>     xor ah, ah        ;Operation code zero
  2842 000052F4 C0E005              <1>     shl al, 5
  2843 000052F7 86E0                <1>     xchg ah, al
  2844 000052F9 66AB                <1>     stosw            ;Store shifted LUN and command code
  2845 000052FB C3                  <1>     ret
  2846                              <1> .scsiReadFormatCapacities:
  2847                              <1> ;al contains the LUN of the device
  2848 000052FC 88C4                <1>     mov ah, al
  2849 000052FE B023                <1>     mov al, 23h        ;Operation code for command
  2850 00005300 66AB                <1>     stosw            ;Store shifted LUN and command code
  2851 00005302 4831C0              <1>     xor rax, rax
  2852 00005305 AB                  <1>     stosd          ;Reserved dword    
  2853 00005306 66AB                <1>     stosw           ;Reserved word
  2854 00005308 B0FC                <1>     mov al, 0FCh    ;Move alloc length byte into al
  2855 0000530A AA                  <1>     stosb
  2856 0000530B C3                  <1>     ret
  2857                              <1> .scsiReadCap10:
  2858                              <1> ;Writes a scsi read capacity command to the location pointed to by rdi
  2859                              <1> ;al contains the LUN of the device we are accessing
  2860 0000530C B425                <1>     mov ah, 25h        ;Operation code for command
  2861 0000530E C0E005              <1>     shl al, 5
  2862 00005311 86E0                <1>     xchg ah, al
  2863 00005313 66AB                <1>     stosw            ;Store shifted LUN and command code
  2864 00005315 C3                  <1>     ret
  2865                              <1> .scsiFormatUnit:
  2866                              <1> ;Writes a scsi format unit command to the location pointed to by rdi
  2867                              <1> ;al contains the LUN of the device we are accessing
  2868 00005316 B404                <1>     mov ah, 04h        ;Operation code for format command
  2869 00005318 C0E005              <1>     shl al, 5
  2870 0000531B 0C17                <1>     or al, 17h      ;Set bits [3:0] and 5, keep bit 4 clear
  2871 0000531D 86E0                <1>     xchg ah, al
  2872 0000531F 66AB                <1>     stosw
  2873 00005321 30C0                <1>     xor al, al
  2874 00005323 66AB                <1>     stosw            ;Vender specific, set to 0!!
  2875 00005325 4831C0              <1>     xor rax, rax
  2876 00005328 48AB                <1>     stosq            ;Store LSB byte and all the 0 padding
  2877 0000532A C3                  <1>     ret
  2878                              <1> .scsiVerify:
  2879                              <1> ;Writes a scsi verify transfer command to the location pointed at by rdi
  2880                              <1> ;al contains the LUN of the device we are accessing
  2881                              <1> ;r12d contains the LBA for the sector address
  2882                              <1> ;Verifies one sector
  2883 0000532B B42F                <1>     mov ah, 2Fh        ;Operation code for command
  2884 0000532D C0E005              <1>     shl al, 5        ;Hardcode bytecheck (byte [1]) to 0
  2885 00005330 86E0                <1>     xchg ah, al
  2886 00005332 66AB                <1>     stosw            ;Store shifted LUN and command code
  2887 00005334 410FCC              <1>     bswap r12d        ;swap endianness of r12d
  2888 00005337 4489E0              <1>     mov eax, r12d
  2889 0000533A AB                  <1>     stosd
  2890 0000533B 4831C0              <1>     xor rax, rax    ;Clear for a Reserved byte
  2891 0000533E AA                  <1>     stosb
  2892 0000533F 66B80001            <1>     mov ax, 0100h    ;Write the number 1 in Big endian
  2893 00005343 66AB                <1>     stosw
  2894 00005345 C1E810              <1>     shr eax, 16        ;Bring zeros down onto lower word
  2895 00005348 66AB                <1>     stosw            ;Store one reserved byte and two padding bytes
  2896 0000534A AA                  <1>     stosb        
  2897 0000534B C3                  <1>     ret
  2898                              <1> .scsiModeSense6:
  2899                              <1> ;al contains the LUN of the device we are accessing
  2900 0000534C B41A                <1>     mov ah, 1Ah     ;Operation code for Mode Sense 6
  2901 0000534E C0E005              <1>     shl al, 5       ;Move LUN
  2902 00005351 86E0                <1>     xchg ah, al
  2903 00005353 66AB                <1>     stosw
  2904 00005355 B83F00C000          <1>     mov eax, 0C0003Fh    
  2905                              <1>     ;Request all pages, reserve byte, 192 bytes and 0 end byte
  2906 0000535A AB                  <1>     stosd
  2907 0000535B C3                  <1>     ret
  2908                              <1> ;                    -------------------------------
  2909                              <1> .ehciGetOpBase:
  2910                              <1> ;Gets opbase from mmio base (aka adds caplength) into eax
  2911                              <1> ;Input:
  2912                              <1> ; al = offset into ehci table
  2913                              <1> ;Return:
  2914                              <1> ; eax = opbase (low 4Gb)
  2915 0000535C 53                  <1>     push rbx
  2916 0000535D 4831DB              <1>     xor rbx, rbx
  2917 00005360 480FB6C0            <1>     movzx rax, al
  2918 00005364 8B04C5[19020000]    <1>     mov eax, dword [eControllerList + 4 + 8*rax]    ;get mmiobase into eax
  2919 0000536B 85C0                <1>     test eax, eax             ;addrress of 0 means no controller
  2920 0000536D 7406                <1>     jz .egob1
  2921 0000536F 670FB618            <1>     movzx ebx, byte [eax]    ;get the offset to opbase into ebx
  2922 00005373 01D8                <1>     add eax, ebx            ;add this offset to mmiobase to get opbase
  2923                              <1> .egob1:
  2924 00005375 5B                  <1>     pop rbx
  2925 00005376 C3                  <1>     ret
   110                                  ;====================================CPU Interrupts=============================
   111                                  %include "./Source/Resident/Hardware/CPU/xception.asm"
   112                              <1> i0:
   113 00005377 4831C0              <1>     xor rax, rax
   114 0000537A E936010000          <1>     jmp cpu_2args
   115                              <1> i1:
   116 0000537F 48B801000000000000- <1>     mov rax, 1
   116 00005388 00                  <1>
   117 00005389 E927010000          <1>     jmp cpu_2args
   118                              <1> i2:
   119 0000538E 48B802000000000000- <1>     mov rax, 2
   119 00005397 00                  <1>
   120 00005398 E918010000          <1>     jmp cpu_2args
   121                              <1> i3:
   122 0000539D 48B803000000000000- <1>     mov rax, 3
   122 000053A6 00                  <1>
   123 000053A7 E909010000          <1>     jmp cpu_2args
   124                              <1> i4:
   125 000053AC 48B804000000000000- <1>     mov rax, 4
   125 000053B5 00                  <1>
   126 000053B6 E9FA000000          <1>     jmp cpu_2args
   127                              <1> i5:
   128 000053BB 48B805000000000000- <1>     mov rax, 5
   128 000053C4 00                  <1>
   129 000053C5 E9EB000000          <1>     jmp cpu_2args
   130                              <1> i6:
   131 000053CA 48B806000000000000- <1>     mov rax, 6
   131 000053D3 00                  <1>
   132 000053D4 E9DC000000          <1>     jmp cpu_2args
   133                              <1> i7:
   134 000053D9 48B807000000000000- <1>     mov rax, 7
   134 000053E2 00                  <1>
   135 000053E3 E9CD000000          <1>     jmp cpu_2args
   136                              <1> i8:
   137 000053E8 48B808000000000000- <1>     mov rax, 8
   137 000053F1 00                  <1>
   138 000053F2 E9B2000000          <1>     jmp cpu_3args
   139                              <1> i9:
   140 000053F7 48B809000000000000- <1>     mov rax, 9
   140 00005400 00                  <1>
   141 00005401 E9AF000000          <1>     jmp cpu_2args
   142                              <1> i10:
   143 00005406 48B80A000000000000- <1>     mov rax, 0Ah
   143 0000540F 00                  <1>
   144 00005410 E994000000          <1>     jmp cpu_3args
   145                              <1> i11:
   146 00005415 48B80B000000000000- <1>     mov rax, 0Bh
   146 0000541E 00                  <1>
   147 0000541F E985000000          <1>     jmp cpu_3args
   148                              <1> i12:
   149 00005424 48B80C000000000000- <1>     mov rax, 0Ch
   149 0000542D 00                  <1>
   150 0000542E E976000000          <1>     jmp cpu_3args
   151                              <1> i13:
   152 00005433 48B80D000000000000- <1>     mov rax, 0Dh
   152 0000543C 00                  <1>
   153 0000543D EB6A                <1>     jmp short cpu_3args
   154                              <1> i14:
   155 0000543F 48B80E000000000000- <1>     mov rax, 0Eh
   155 00005448 00                  <1>
   156 00005449 EB52                <1>     jmp short cpu_4args
   157                              <1> i15:
   158 0000544B 48B80F000000000000- <1>     mov rax, 0Fh
   158 00005454 00                  <1>
   159 00005455 EB5E                <1>     jmp short cpu_2args
   160                              <1> i16:
   161 00005457 48B810000000000000- <1>     mov rax, 10h
   161 00005460 00                  <1>
   162 00005461 EB52                <1>     jmp short cpu_2args
   163                              <1> i17:
   164 00005463 48B811000000000000- <1>     mov rax, 11h
   164 0000546C 00                  <1>
   165 0000546D EB3A                <1>     jmp short cpu_3args
   166                              <1> i18:
   167 0000546F 48B812000000000000- <1>     mov rax, 12h
   167 00005478 00                  <1>
   168 00005479 EB3A                <1>     jmp short cpu_2args
   169                              <1> i19:
   170 0000547B 48B813000000000000- <1>     mov rax, 13h
   170 00005484 00                  <1>
   171 00005485 EB2E                <1>     jmp short cpu_2args
   172                              <1> i20:
   173 00005487 48B814000000000000- <1>     mov rax, 14h
   173 00005490 00                  <1>
   174 00005491 EB22                <1>     jmp short cpu_2args
   175                              <1> i21:
   176 00005493 48B815000000000000- <1>     mov rax, 15h
   176 0000549C 00                  <1>
   177                              <1> cpu_4args:
   178 0000549D 48B903000000000000- <1>     mov rcx, 3
   178 000054A6 00                  <1>
   179 000054A7 EB16                <1>     jmp short cpu_exception
   180                              <1> cpu_3args:
   181 000054A9 48B902000000000000- <1>     mov rcx, 2
   181 000054B2 00                  <1>
   182 000054B3 EB0A                <1>     jmp short cpu_exception
   183                              <1> cpu_2args:
   184 000054B5 48B901000000000000- <1>     mov rcx, 1
   184 000054BE 00                  <1>
   185                              <1> cpu_exception:
   186 000054BF 50                  <1>     push rax
   187 000054C0 51                  <1>     push rcx
   188 000054C1 66BB1F00            <1>     mov bx, 001Fh    ;cls attribs
   189 000054C5 E82DACFFFF          <1>     call cls
   190                              <1> 
   191 000054CA 48B800020000000000- <1>     mov rax, 0200h
   191 000054D3 00                  <1>
   192 000054D4 4831DB              <1>     xor rbx, rbx
   193 000054D7 48BA22070000000000- <1>     mov rdx, 0722h    ;7 Rows down, 24 columns across
   193 000054E0 00                  <1>
   194 000054E1 48BD-               <1>     mov rbp, .fatalt0
   194 000054E3 [2C56000000000000]  <1>
   195 000054EB 66BB7100            <1>     mov bx, 0071h     ;blue grey attribs, page 0
   196 000054EF 66B80113            <1>     mov ax, 1301h     ;print zero 8 chars, with bh attrib
   197 000054F3 48B908000000000000- <1>     mov rcx, 8
   197 000054FC 00                  <1>
   198 000054FD CD30                <1>     int 30h
   199                              <1> 
   200 000054FF 48B800020000000000- <1>     mov rax, 0200h
   200 00005508 00                  <1>
   201 00005509 30FF                <1>     xor bh, bh
   202 0000550B 48BA040A0000000000- <1>     mov rdx, 0A04h    ;11 Rows down, 24 columns across
   202 00005514 00                  <1>
   203 00005515 CD30                <1>     int 30h
   204 00005517 48BD-               <1>     mov rbp, .fatal1
   204 00005519 [3456000000000000]  <1>
   205 00005521 30FF                <1>     xor bh, bh        ;blue grey attribs, page 0
   206 00005523 66B80413            <1>     mov ax, 1304h            ;print zero terminated string
   207 00005527 CD30                <1>     int 30h
   208                              <1> 
   209 00005529 59                  <1>     pop rcx
   210 0000552A 58                  <1>     pop rax                ;pop the exception number back into rax
   211 0000552B E8DF000000          <1>     call .printbyte
   212                              <1> 
   213 00005530 48B804130000000000- <1>     mov rax, 1304h
   213 00005539 00                  <1>
   214 0000553A 30FF                <1>     xor bh, bh
   215 0000553C 48BD-               <1>     mov rbp, .fatal2
   215 0000553E [7557000000000000]  <1>
   216 00005546 CD30                <1>     int 30h
   217                              <1> 
   218 00005548 80F901              <1>     cmp cl, 1
   219 0000554B 773A                <1>     ja .cpuextendederror    ;rax contains error code, or extra cr2 value
   220                              <1> .cpurollprint:
   221 0000554D 488B1424            <1>     mov rdx, qword [rsp]    ;Get address
   222                              <1> ;Takes whats in rdx, rols left by one byte, prints al
   223 00005551 B108                <1>     mov cl, 8    ;8 bytes
   224                              <1> .cpurollprint1:
   225 00005553 48C1C208            <1>     rol rdx, 8
   226 00005557 88D0                <1>     mov al, dl
   227 00005559 52                  <1>     push rdx
   228 0000555A E8B0000000          <1>     call .printbyte
   229 0000555F 5A                  <1>     pop rdx
   230 00005560 FEC9                <1>     dec cl
   231 00005562 75EF                <1>     jnz .cpurollprint1
   232                              <1> 
   233                              <1> .cpuexendloop:
   234 00005564 6631C0              <1>     xor ax, ax
   235 00005567 CD36                <1>     int 36h
   236 00005569 3C1B                <1>     cmp al, 1Bh    ;Check for escape pressed (unlikely?)
   237 0000556B 740F                <1>     je .cpu_exception_appret
   238 0000556D 3C0D                <1>     cmp al, 0Dh ;Check for enter pressed
   239 0000556F 75F3                <1>     jne .cpuexendloop
   240                              <1> 
   241 00005571 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   242 00005575 E87DABFFFF          <1>     call cls
   243 0000557A CD38                <1>     int 38h    ;Jump to debugger
   244                              <1> .cpu_exception_appret:
   245 0000557C 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   246 00005580 E872ABFFFF          <1>     call cls
   247 00005585 48CF                <1>     iretq ;Return to address on stack
   248                              <1> 
   249                              <1> .cpuextendederror:
   250 00005587 5A                  <1>     pop rdx
   251 00005588 48FFC9              <1>     dec rcx
   252 0000558B 51                  <1>     push rcx
   253 0000558C B102                <1>     mov cl, 2    ;CAN CHANGE TO 4 BYTES IN THE FUTURE
   254                              <1> .pr1:
   255 0000558E C1C208              <1>     rol edx, 8    ;Print just edx
   256 00005591 88D0                <1>     mov al, dl
   257 00005593 52                  <1>     push rdx
   258 00005594 E876000000          <1>     call .printbyte
   259 00005599 5A                  <1>     pop rdx
   260 0000559A FEC9                <1>     dec cl
   261 0000559C 75F0                <1>     jnz .pr1
   262                              <1> 
   263 0000559E 48B804130000000000- <1>     mov rax, 1304h
   263 000055A7 00                  <1>
   264 000055A8 48BB17000000000000- <1>     mov rbx, 17h
   264 000055B1 00                  <1>
   265 000055B2 48BD-               <1>     mov rbp, .fatal2
   265 000055B4 [7557000000000000]  <1>
   266 000055BC CD30                <1>     int 30h
   267 000055BE 59                  <1>     pop rcx    ;Bring the comparison value back into rcx
   268                              <1>     
   269 000055BF 48FFC9              <1>     dec rcx
   270 000055C2 7489                <1>     jz .cpurollprint
   271                              <1> 
   272 000055C4 B108                <1>     mov cl, 8
   273 000055C6 0F20D2              <1>     mov rdx, cr2    ;Get page fault address
   274                              <1> .pr2:
   275 000055C9 48C1C208            <1>     rol rdx, 8    ;Print rdx
   276 000055CD 88D0                <1>     mov al, dl
   277 000055CF 52                  <1>     push rdx
   278 000055D0 E83A000000          <1>     call .printbyte
   279 000055D5 5A                  <1>     pop rdx
   280 000055D6 FEC9                <1>     dec cl
   281 000055D8 75EF                <1>     jnz .pr2
   282                              <1> 
   283 000055DA 48B804130000000000- <1>     mov rax, 1304h
   283 000055E3 00                  <1>
   284 000055E4 48BB17000000000000- <1>     mov rbx, 17h
   284 000055ED 00                  <1>
   285 000055EE 48BD-               <1>     mov rbp, .fatal2
   285 000055F0 [7557000000000000]  <1>
   286 000055F8 CD30                <1>     int 30h
   287                              <1>     
   288 000055FA E94EFFFFFF          <1>     jmp .cpurollprint
   289                              <1> 
   290                              <1> 
   291                              <1> .char:    ;Print a single character
   292 000055FF 48BB-               <1>     mov rbx, .ascii
   292 00005601 [7957000000000000]  <1>
   293 00005609 D7                  <1>     xlatb    ;point al to entry in ascii table, using al as offset into table
   294                              <1>     ;xor bh, bh
   295 0000560A B40E                <1>     mov ah, 0Eh
   296 0000560C CD30                <1>     int 30h    ;print char
   297 0000560E C3                  <1>     ret
   298                              <1> .printbyte:
   299 0000560F 88C2                <1>     mov dl, al            ;save byte in dl
   300 00005611 6625F000            <1>     and ax, 00F0h        ;Hi nybble
   301 00005615 6681E20F00          <1>     and dx, 000Fh        ;Lo nybble
   302 0000561A 66C1E804            <1>     shr ax, 4            ;shift one hex place value pos right
   303 0000561E E8DCFFFFFF          <1>     call .char
   304 00005623 6689D0              <1>     mov ax, dx            ;mov lo nybble, to print
   305 00005626 E8D4FFFFFF          <1>     call .char
   306 0000562B C3                  <1>     ret    
   307 0000562C 5343502F42494F53    <1> .fatalt0:  db "SCP/BIOS"
   308 00005634 4120706F74656E7469- <1> .fatal1:   db "A potentially fatal error has occured. To continue: ",0Ah,0Ah,0Dh
   308 0000563D 616C6C792066617461- <1>
   308 00005646 6C206572726F722068- <1>
   308 0000564F 6173206F6363757265- <1>
   308 00005658 642E20546F20636F6E- <1>
   308 00005661 74696E75653A200A0A- <1>
   308 0000566A 0D                  <1>
   309 0000566B 202020205072657373- <1> db "    Press Enter to launch SYSDEBUG, or",0Ah,0Ah,0Dh 
   309 00005674 20456E74657220746F- <1>
   309 0000567D 206C61756E63682053- <1>
   309 00005686 595344454255472C20- <1>
   309 0000568F 6F720A0A0D          <1>
   310 00005694 202020205072657373- <1> db "    Press ESC to try and return to the application which caused the error," 
   310 0000569D 2045534320746F2074- <1>
   310 000056A6 727920616E64207265- <1>
   310 000056AF 7475726E20746F2074- <1>
   310 000056B8 6865206170706C6963- <1>
   310 000056C1 6174696F6E20776869- <1>
   310 000056CA 636820636175736564- <1>
   310 000056D3 20746865206572726F- <1>
   310 000056DC 722C                <1>
   311 000056DE 6F720A0A0D          <1> db "or", 0Ah, 0Ah,0Dh,
   312 000056E3 202020205072657373- <1> db "    Press CTRL+ALT+DEL to restart your system. If you do this,",0Ah,0Dh
   312 000056EC 204354524C2B414C54- <1>
   312 000056F5 2B44454C20746F2072- <1>
   312 000056FE 65737461727420796F- <1>
   312 00005707 75722073797374656D- <1>
   312 00005710 2E20496620796F7520- <1>
   312 00005719 646F20746869732C0A- <1>
   312 00005722 0D                  <1>
   313 00005723 20202020796F752077- <1> db "    you will lose any unsaved information in all open applications.",0Ah, 
   313 0000572C 696C6C206C6F736520- <1>
   313 00005735 616E7920756E736176- <1>
   313 0000573E 656420696E666F726D- <1>
   313 00005747 6174696F6E20696E20- <1>
   313 00005750 616C6C206F70656E20- <1>
   313 00005759 6170706C6963617469- <1>
   313 00005762 6F6E732E0A          <1>
   314 00005767 0A0D                <1> db 0Ah, 0Dh
   315 00005769 202020204572726F72- <1> db "    Error: ",0
   315 00005772 3A2000              <1>
   316 00005775 203A2000            <1> .fatal2:   db " : ",0
   317 00005779 303132333435363738- <1> .ascii:    db '0123456789ABCDEF'
   317 00005782 39414243444546      <1>
   112                                  ;==========================Dummy Interrupts======================
   113                                  %include "./Source/Resident/Hardware/dummyInt.asm"
   114                              <1> dummy_interrupt:
   115                              <1> .pic2:
   116 00005789 50                  <1>     push rax
   117 0000578A B020                <1>     mov al, EOI
   118 0000578C E6A0                <1>     out pic2command, al    ;EOI to pic2
   119 0000578E EB01                <1>     jmp short .p1
   120                              <1> .pic1:
   121 00005790 50                  <1>     push rax
   122                              <1> .p1:
   123 00005791 B020                <1>     mov al, EOI
   124 00005793 E620                <1>     out pic1command, al    ;EOI to pic2
   125 00005795 58                  <1>     pop rax
   126                              <1> dummy_return_64:
   127 00005796 48CF                <1>     iretq
   114                                  %include "./Source/Resident/Misc/version.asm"
   115                              <1> ;----------------------------------------------------------------
   116 00005798 76302E392053435042- <1> signature:    db "v0.9 SCPBIOS"    ;12 byte signature
   116 000057A1 494F53              <1>
   117 000057A4 436F70797269676874- <1> signature2:   db "Copyright (C) Yll Buzoku"
   117 000057AD 2028432920596C6C20- <1>
   117 000057B6 42757A6F6B75        <1>
   118 000057BC 30332F31322F323032- <1>               db "03/12/2021"
   118 000057C5 31                  <1>
   115                                  codeResidentEndPtr:
   116                                  residentLength  equ $-$$
