     1                                  [map all ./Source/scpbios.map]
     2                                  ;-----------------------------------SCPBIOS-----------------------------------
     3                                  %include "./Source/Include/equates.inc"
     1                              <1> ;------------------------------------Equates------------------------------------
     2                              <1> permissionflags equ 003h    ;Page table Permission flags
     3                              <1> codedescriptor     equ 0008h
     4                              <1> 
     5                              <1> BIOSStartAddr   equ 00110000h   ;Start just after HMA + 16 bytes
     6                              <1> BIOSInitAddr    equ 800h
     7                              <1> 
     8                              <1> e820Seg         equ 1000h
     9                              <1> e820SizeOff     equ 0000h    ;First word is # of entries
    10                              <1> e820BaseOff     equ e820SizeOff + 2
    11                              <1> e820SizeAddr    equ (e820Seg<<4) + e820SizeOff
    12                              <1> ;---------------------PIC Chip IO values---------------------
    13                              <1> pic1command     equ 020h        ;Command port
    14                              <1> pic2command     equ 0A0h        ;Command port
    15                              <1> pic1data        equ 021h        ;Data port
    16                              <1> pic2data        equ 0A1h        ;Data port
    17                              <1> ;------------------------------------------------------------
    18                              <1> ;-----------------PS/2 IO port commands----------------------
    19                              <1> ps2command      equ 64h            ;Command Port (write)
    20                              <1> ps2status       equ 64h            ;Status Port  (read)
    21                              <1> ps2data         equ 60h           ;Data Port     (read/write)
    22                              <1> ;------------------------------------------------------------
    23                              <1> ;--------------------Serial port equates---------------------
    24                              <1> com1_base       equ 03F8h
    25                              <1> com2_base       equ 02F8h
    26                              <1> com3_base       equ 03E8h
    27                              <1> com4_base       equ 02E8h
    28                              <1> ;------------------------------------------------------------
    29                              <1> ;---------------------PIT port equates-----------------------
    30                              <1> PITbase         equ 40h
    31                              <1> PIT0            equ PITbase
    32                              <1> PIT1            equ PITbase + 1
    33                              <1> PIT2            equ PITbase + 2
    34                              <1> PITcommand      equ PITbase + 3
    35                              <1> ;------------------------------------------------------------
    36                              <1> ;---------------------CMOS port equates----------------------
    37                              <1> cmos_base        equ 70h
    38                              <1> cmos_data        equ 71h
    39                              <1> ;------------------------------------------------------------
    40                              <1> ;--------------------Keyboard equates------------------------
    41                              <1> kb_flag_rshift   equ    01h    ;Right Shift is being held
    42                              <1> kb_flag_lshift   equ    02h    ;Left Shift is being held
    43                              <1> kb_flag_ctrl     equ    04h    ;Ctrl is being held
    44                              <1> kb_flag_alt      equ    08h    ;Alt is being held
    45                              <1> kb_flag_scrlset  equ    10h    ;Scroll lock is set
    46                              <1> kb_flag_numset   equ    20h    ;Num lock is set
    47                              <1> kb_flag_capsset  equ    40h    ;Caps lock is set
    48                              <1> kb_flag_insset   equ    80h    ;Insert mode is set
    49                              <1> 
    50                              <1> kb_flag2_e1      equ    01h    ;0E1h scancode procedure being processed
    51                              <1> kb_flag2_e0      equ    02h    ;0E0h scancode procedure being processed
    52                              <1> ;------------------------------------------------------------
    53                              <1> ;--------------------Screen equates--------------------------
    54                              <1> vga_index        equ    03D4h
    55                              <1> vga_data         equ    03D5h
    56                              <1> ;---------------- New Equates ----------------
    57                              <1> vga_aindex       equ    03B4h    ;Alt (MDA) IO Base
    58                              <1> vga_adata        equ    03B5h
    59                              <1> ;These equates are SEGMENTS, need to be SHL 4 to become addrs
    60                              <1> vga_bpage0       equ    0A0000h
    61                              <1> vga_bpage1       equ    0B0000h
    62                              <1> vga_bpage2       equ    0B8000h
    63                              <1> ;------------------------------------------------------------
    64                              <1> ;----------------------PCI equates---------------------------
    65                              <1> pci_index        equ    0CF8h
    66                              <1> pci_data         equ    0CFCh
    67                              <1> ;------------------------------------------------------------
    68                              <1> ;----------------------USB equates---------------------------
    69                              <1> usb_class        equ    0Ch    ;pci class
    70                              <1> usb_subclass     equ    03h    ;pci subclase
    71                              <1> uhci_interface   equ    00h    ;usb 1.0
    72                              <1> uhcimask         equ    10h
    73                              <1> ohci_interface   equ    10h    ;usb 1.0 alt
    74                              <1> ohcimask         equ    20h
    75                              <1> ehci_interface   equ    20h    ;usb 2.0
    76                              <1> ehcimask         equ    40h
    77                              <1> xhci_interface   equ    30h    ;usb 3.0
    78                              <1> xhcimask         equ    80h
    79                              <1> lousbtablesize   equ    0000E000h    ;Location of the table size, uword
    80                              <1> lousbtablebase   equ    lousbtablesize + 2 ;base of the table, tword entries
    81                              <1> debounceperiod   equ 200 ;double 200ms as per Windows, for inaccuracies
    82                              <1> ;                ------EHCI equates------
    83                              <1> ehcicaplength    equ    00h    ;Add this to base addr in table to find opparams
    84                              <1> ehciversion      equ    02h    ;Interface Version number
    85                              <1> ehcistrucparams  equ    04h    ;Structural Parameters
    86                              <1> ehcihccparams    equ    08h    ;Capability Parameters
    87                              <1> ehciportroute    equ    0Ch    ;Companion Port Route Description (v1 ignore)
    88                              <1> 
    89                              <1> ;Operational registers below
    90                              <1> 
    91                              <1> ehcicmd          equ    00h    ;USB command register
    92                              <1> ehcists          equ    04h    ;USB status register
    93                              <1> ehciintr         equ    08h    ;USB Interrupt Enable
    94                              <1> ehcifrindex      equ    0Ch    ;USB Frame Index
    95                              <1> ehcictrlseg      equ    10h    ;4Gb Segment Selector
    96                              <1> ehciperiodbase   equ    14h    ;Frame List Base Address
    97                              <1> ehciasyncaddr    equ    18h    ;Next Asynchronus List Address
    98                              <1> ehciconfigflag   equ    40h    ;Configured Flag Register
    99                              <1> ehciportsc       equ    44h    ;Read = 1 - # of ports, Write = port ctrl
   100                              <1> ;                ------------------------
   101                              <1> ;                -------MSD equates------
   102                              <1> setupReset       equ 0FFh
   103                              <1> setupGetMaxLUN   equ 0FEh
   104                              <1> ;                ------------------------
   105                              <1> ;                ------Bulk Storage equates------
   106                              <1> CBWSig           equ    043425355h
   107                              <1> CSWSig           equ    053425355h
   108                              <1> CBWFlagOut       equ    00h    ;Switch to send to device
   109                              <1> CBWFlagIn        equ    80h    ;Switch to recieve from
   110                              <1> bCSWPassed       equ    00h
   111                              <1> bCSWFailed       equ    01h
   112                              <1> bCSWPhase        equ    02h
   113                              <1> ;                ------------------------
   114                              <1> ;------------------USB Table equates------------------
   115                              <1> usbMaxDevices   equ 10
   116                              <1> usbDevTblSz     equ usbMaxDevices  ;Number of Entries in the usb device table!
   117                              <1> struc usbDevTblEntry
   118 00000000 ??                  <1>     .bAddr      db ?    ;Dev Addr
   119 00000001 ??                  <1>     .bBus       db ?    ;Root hub
   120 00000002 ??                  <1>     .bClassCde  db ?    ;A usbDevClass_* value
   121                              <1> endstruc
   122                              <1> ;USB device Class codes
   123                              <1> usbDevClass_MSD equ 8
   124                              <1> usbDevClass_Hub equ 9
   125                              <1> 
   126                              <1> ;------------------Hub Table equates------------------
   127                              <1> hubDevTblSz     equ 10  ;Number of Entries in the hub device table!
   128                              <1> struc hubDevTblEntry
   129 00000000 ??                  <1>     .bAddr      db ?    ;The assigned device address
   130 00000001 ??                  <1>     .bBus       db ?    ;Host Bus [Root hub]
   131 00000002 ??                  <1>     .bHostHub   db ?    ;Address of Hub we are attached to or 0 for Root
   132 00000003 ??                  <1>     .bHubPort   db ?    ;Port number we are inserted in
   133 00000004 ??                  <1>     .bMaxPacketSize0    db ?    ;Max packet size to endpoint 0
   134 00000005 ??                  <1>     .bNumPorts  db ?    ;Number of downstream ports on hub
   135 00000006 ??                  <1>     .bPowerOn2PowerGood db ?  ;Time in units of 2ms for dev on port to turn on
   136 00000007 ??                  <1>     .bRes       db ?    ;Endpoint address, for when we add interrupt eps
   137                              <1> ;   If bNumPorts=0 => Hub needs to undergo Hub Config
   138                              <1> endstruc
   139                              <1> 
   140                              <1> ;------------------MSD Table equates------------------
   141                              <1> msdDevTblSz     equ 10  ;Number of Entries in the msd device table :)
   142                              <1> struc msdDevTblEntry 
   143 00000000 ??                  <1>     .bAddr      db ?    ;The assigned device address
   144 00000001 ??                  <1>     .bBus       db ?    ;Host Bus [Root hub]
   145 00000002 ??                  <1>     .bHostHub   db ?    ;Address of Hub we are attached to or 0 for Root
   146 00000003 ??                  <1>     .bHubPort   db ?    ;Port number we are inserted in
   147 00000004 ??                  <1>     .bIFNum     db ?    ;Interface number being used
   148 00000005 ??                  <1>     .bIFSClass  db ?    ;A msdIFSC_* value
   149 00000006 ??                  <1>     .bIFProt    db ?    ;A <sdIFProt_* value
   150 00000007 ??                  <1>     .bMaxPacketSize0    db ?    ; Max packet size to endpoint 0
   151 00000008 ??                  <1>     .bEPInAddr  db ?    ;4 bit address of IN EP
   152 00000009 ????                <1>     .wMaxPacketSizeIn   dw ?    ;Max packet size to chosen In endpoint
   153 0000000B ??                  <1>     .bEPOutAddr db ?    ;4 bit address of OUT EP
   154 0000000C ????                <1>     .wMaxPacketSizeOut  dw ?    ;Max packet size to OUT endpoint
   155                              <1> ;These past two bytes are temporarily kept separate! Will bitstuff later
   156 0000000E ??                  <1>     .bInEPdt    db ?    ;In Endpoints' dt bit
   157 0000000F ??                  <1>     .bOutEPdt   db ?    ;Out Endpoints' dt bit
   158                              <1> endstruc
   159                              <1> ;Interface Subclass types for MSD 
   160                              <1> msdIFSC_Dflt    equ 0   ;Default = SCSI Interface Subclass
   161                              <1> msdIFSC_SCSI    equ 6   ;SCSI Interface Subclass 
   162                              <1> msdIFSC_UFI     equ 4   ;UFI Interface Subclass (Not yet supported...)
   163                              <1> ;Interface Protocol types for MSD
   164                              <1> msdIFProt_BBB   equ 50h ;BBB protocol
   165                              <1> msdIFProt_iCBI  equ 0   ;CBI (not supported)
   166                              <1> msdIFProt_CBI   equ 1   ;CBI without interrupt (not supported)
   167                              <1> ;                ------------------------
   168                              <1> ;------------------EHCI Transfer Descriptor size------------------
   169                              <1> ehciSizeOfQH    equ 60h
   170                              <1> ehciSizeOfTD    equ 40h
   171                              <1> ;------------------------------------------------------------
   172                              <1> ;----------------------ATA equates---------------------------
   173                              <1> ata0_base       equ    1F0h
   174                              <1> ata0_ctrl       equ    3F6h
   175                              <1> ata1_base       equ    170h
   176                              <1> ata1_ctrl       equ    376h
   177                              <1> 
   178                              <1> msd_class       equ    01h
   179                              <1> ide_subclass    equ    01h
   180                              <1> sata_subclass   equ    06h
   181                              <1> ;------------------------------------------------------------
   182                              <1> ;----------------------IDE equates---------------------------
   183                              <1> ideCtrlrTblSz   equ     2   ;Max 2 controllers
   184                              <1> struc ideCtrlrTblEntry
   185 00000000 ????????            <1>     .dPCIAddress    dd ?    ;PCI IO address of controller
   186 00000004 ????????            <1>     .dPCIBAR4       dd ?    ;PCI BAR4, the Bus Mastery address
   187                              <1> ; Note that this address is given with the bottom nybble indicating
   188                              <1> ; if the address is IO or MMIO. Bit set => IO
   189                              <1> endstruc
   190                              <1> ;----------------------FDD equates---------------------------
   191                              <1> fdd_base        equ    3F0h
   192                              <1> ;----------------------ATA equates---------------------------
   193                              <1> fdiskTblSz  equ 4   ;Max 4 ATA disks on a system
   194                              <1> struc fdiskTblEntry
   195 00000000 ??                  <1>     .signature  db ? 
   196                              <1>     ;CHS really shouldnt be used
   197 00000001 ????                <1>     .wHeads     dw ?  ;Number of CHS Heads
   198 00000003 ????                <1>     .wCylinder  dw ?  ;Number of CHS Cylinders
   199 00000005 ????                <1>     .wSecTrc    dw ?  ;Number of CHS Sectors per Track
   200 00000007 ????????            <1>     .lbaMax     dd ?  ;Number of maximum sector accessible by LBA28
   201 0000000B ????????????????    <1>     .lbaMax48   dq ?  ;Number of maximum sector accessible by LBA48
   202 00000013 ????                <1>     .ioBase     dw ?  ;IO Base address
   203 00000015 ??                  <1>     .msBit      db ?  ;Master Slave bit in 0A0h/0B0h format
   204                              <1> endstruc
   205                              <1> ;.signature is as follows:
   206                              <1> ;.signature[0] set = Device present and OK to use.
   207                              <1> ;.signature[1] set = LBA 28 supported, detected by non-zero LBA28 field
   208                              <1> ;.signature[2] set = LBA 48 supported, detected by bit set AND non-zero 
   209                              <1> ;                       LBA 48 sectors field
   210                              <1> ;.signature[7:3] = Reserved
   211                              <1> ;Bitfield equates
   212                              <1>     fdePresent  equ 1
   213                              <1>     fdeLBA28    equ 2
   214                              <1>     fdeLBA48    equ 4
   215                              <1> 
   216                              <1> ;Equates for the ATA identify command
   217                              <1>     idCurrCyl   equ 2*54    ;54th word
   218                              <1>     idCurrHed   equ 2*55    ;55th word
   219                              <1>     idCurrSecTk equ 2*56    ;56th word
   220                              <1>     idLBASectrs equ 2*60    ;60th word
   221                              <1>     idLBA48Sec  equ 2*100   ;100th word
   222                              <1> ;----------------------Int 33h Equates-----------------------
   223                              <1> i33DevTblSz     equ 10h   ;10 i33 devices.
   224                              <1> 
   225                              <1> struc i33DevTblEntry
   226 00000000 ??                  <1>     .bDevType   db ?    ;A ddDevType_* type value
   227 00000001 ????                <1>     .wDevAddr   dw ?    ;USB Address/Bus pair OR local device table address
   228 00000003 ????????            <1>     .dBlockSize dd ?    ;Dword size of LBA block (should be 512 for remdev)
   229 00000007 ????????????????    <1>     .qLastLBA   dq ?    ;Last LBA address (OS WILL subtract 1)
   230 0000000F ??                  <1>     .bEPSize    db ?    ;EP size for sector xfr. ddDevEPSize_* value.
   231                              <1> endstruc
   232                              <1> ;REMEMBER: LBA SECTOR 0 IS CHS SECTOR 0,0,1 !!
   233                              <1> 
   234                              <1> ;Disk device Max IO to EP size
   235                              <1> ddDevEPSize_low equ 1   ;64 byte max IO size to EP. Unsupported and not used.
   236                              <1> ddDevEPSize_reg equ 2   ;512 byte IO size to EP.
   237                              <1> ddDevEPSize_big equ 3   ;4096 byte IO size to EP. Not yet supported
   238                              <1> 
   239                              <1> ;Disk device types 
   240                              <1> ddDevType_free  equ 0   ;Free table entry
   241                              <1> ddDevType_eMSD  equ 1   ;MSD on an EHCI bus
   242                              <1> ddDevType_xMSD  equ 2   ;MSD on an xHCI bus
   243                              <1> ddDevType_fdd   equ 3   ;Physical FDD (unsupported)
   244                              <1> ddDevType_ata   equ 4   ;Physical ATA device 
   245                              <1> ddDevType_atapi equ 5   ;Physical ATAPI device (partially supported)
   246                              <1> 
   247                              <1> ;------------------------------------------------------------
   248                              <1> ;------------------------------------------------------------
   249                              <1> ;------------------------Misc--------------------------------
   250                              <1> port61h         equ 61h         ;I/O port 61h
   251                              <1> EOI             equ 20h         ;End of interrupt signal
   252                              <1> waitp           equ 80h         ;debug port used to wait for io cycles
   253                              <1> bochsout        equ 0E9h        ;Emulator debug port
   254                              <1> BREAKPOINT      equ 0CCh        ;Use to manually encode breakpoints in program
   255                              <1> sizeOfMCPAlloc  equ 800h        ;2Kb allocated space
   256                              <1> ;------------------------------------------------------------
     4                                  ;----------------------------------------------------------------
     5                                  ;                 BIOS SYSTEM TABLE AREA                        :
     6                                  ;----------------------------------------------------------------
     7                                  Segment BIOSTables nobits start=BIOSStartAddr align=1
     8                                  %include "./Source/BSS/gtables.asm"
     1                              <1> ;Global Data BIOS tables
     2 00000000 <res 1000h>         <1> BIOSIDTable     resq 2*256  ;256 paragraph entries reserved for IDT
     3 00001000 <res 6000h>         <1> BIOSPageTbl     resq 0C00h  ;6000 bytes for page tables
     4 00007000 <res 18h>           <1> BIOSGDTable     resq 3      ;3 entries in basic GDT
     5 00007018 ????????????????    <1>                 resq 1      ;Alignment qword
     9                                  ;----------------------------------------------------------------
    10                                  ;                    BIOS DATA AREA STARTS HERE                 :
    11                                  ;----------------------------------------------------------------
    12                                  Segment data nobits follows=BIOSTables align=1 
    13                                  %include "./Source/BSS/bda.asm"
     1                              <1> ;Refer to MEMMAP.TXT for memory address reference!
     2                              <1> ;If Interrupt call is faulty, Carry will be set AND either:
     3                              <1> ;                    ah=80h => Invalid function.
     4                              <1> ;                    ah=86h => Not (yet) supported.
     5                              <1> ;------------------------------Data Area-------------------------
     6 00000000 ????                <1> IDTlength       dw ? ;Maximum number of Interrupts is 256
     7                              <1> IDTpointer:
     8 00000002 ????                <1> .Limit          dw ?
     9 00000004 ????????????????    <1> .Base           dq ?
    10                              <1> 
    11 0000000C ????                <1> GDTlength       dw ?
    12                              <1> GDTpointer:
    13 0000000E ????                <1> .Limit          dw ?
    14 00000010 ????????????????    <1> .Base           dq ?
    15                              <1> 
    16 00000018 ????????????????    <1> pageTablePtr:   dq ?
    17                              <1> ;----------------------------------------
    18                              <1> ;       Spurious Interrupt counter      :
    19                              <1> ;----------------------------------------
    20 00000020 ??                  <1> spurint1        db ?    ;Keep track of how many spur ints on pic1
    21 00000021 ??                  <1> spurint2        db ?    ;pic 2
    22                              <1> ;----------------------------------------
    23                              <1> ;            Keyboard Data Area         :
    24                              <1> ;----------------------------------------
    25 00000022 <res 20h>           <1> kb_buffer       dw 10h dup (?)
    26 00000042 ????????????????    <1> kb_buf_head     dq ?    ;Pointer to Keyboard buffer head
    27 0000004A ????????????????    <1> kb_buf_tail     dq ?    ;Pointer to Keyboard buffer tail 
    28 00000052 ????????????????    <1> kb_buf_start    dq ?    ;Pointer for circular buffer start
    29 0000005A ????????????????    <1> kb_buf_end      dq ?    ;Ditto..., for end
    30 00000062 ??                  <1> kb_flags        db ?    ;Keyboard state flags
    31 00000063 ??                  <1> kb_flags_1      db ?    ;Extended flags, empty for now
    32 00000064 ??                  <1> kb_flags_2      db ?    ;Bit 0 = E1 present, Bit 1 = E0 present
    33 00000065 ??                  <1> break_flag      db ?    ;Well, its not for the Print Screen key
    34                              <1> ;----------------------------------------
    35                              <1> ;            Serial Data Area           :
    36                              <1> ;----------------------------------------
    37 00000066 ??                  <1> numCOM          db ?  ;Number of Serial Ports
    38 00000067 ????????????????    <1> com_addresses   dw 4 dup (?)     ;Space for 4 IO addresses
    39                              <1> 
    40                              <1> comX_buffer:
    41 0000006F <res 10h>           <1> com1_buffer     db 10h dup (?)
    42 0000007F <res 10h>           <1> com2_buffer     db 10h dup (?)
    43 0000008F <res 10h>           <1> com3_buffer     db 10h dup (?)
    44 0000009F <res 10h>           <1> com4_buffer     db 10h dup (?)
    45                              <1> 
    46                              <1> comX_buf_head:
    47 000000AF ????????????????    <1> com1_buf_head   dq ?
    48 000000B7 ????????????????    <1> com2_buf_head   dq ?
    49 000000BF ????????????????    <1> com3_buf_head   dq ?
    50 000000C7 ????????????????    <1> com4_buf_head   dq ?
    51                              <1> 
    52                              <1> comX_buf_tail:
    53 000000CF ????????????????    <1> com1_buf_tail   dq ?
    54 000000D7 ????????????????    <1> com2_buf_tail   dq ?
    55 000000DF ????????????????    <1> com3_buf_tail   dq ?
    56 000000E7 ????????????????    <1> com4_buf_tail   dq ?
    57                              <1> 
    58                              <1> comX_buf_start:
    59 000000EF ????????????????    <1> com1_buf_start  dq ?
    60 000000F7 ????????????????    <1> com2_buf_start  dq ?
    61 000000FF ????????????????    <1> com3_buf_start  dq ?
    62 00000107 ????????????????    <1> com4_buf_start  dq ?
    63                              <1> 
    64                              <1> comX_buf_end:
    65 0000010F ????????????????    <1> com1_buf_end    dq ?
    66 00000117 ????????????????    <1> com2_buf_end    dq ?
    67 0000011F ????????????????    <1> com3_buf_end    dq ?
    68 00000127 ????????????????    <1> com4_buf_end    dq ?
    69                              <1> 
    70                              <1> ;----------------------------------------
    71                              <1> ;            Printer Data Area          :
    72                              <1> ;----------------------------------------
    73 0000012F ????????????        <1> prt_addresses   dw 3 dup (?)    ;Space for 3 IO addresses
    74                              <1> ;----------------------------------------
    75                              <1> ;            Timer Data Area            :
    76                              <1> ;----------------------------------------
    77 00000135 ????                <1> pit_divisor     dw ?
    78 00000137 ????????            <1> pit_ticks       dd ?    ;Similar to IBM PC, only with default divisor
    79                              <1> ;[31]=OF cnt, [30:21]=Res [20:16]=Hi cnt, [15,0]=Lo cnt
    80 0000013B ????????????????    <1> rtc_ticks       dq ?
    81                              <1> ;----------------------------------------
    82                              <1> ;            Screen Data Area           :
    83                              <1> ;----------------------------------------
    84 00000143 <res 10h>           <1> scr_curs_pos    dw 8 dup (?)    ;Cursor pos, hi byte = row / lo byte = column
    85 00000153 ??                  <1> scr_cols        db ?    ;80 Cols
    86 00000154 ??                  <1> scr_rows        db ?    ;25 Rows
    87 00000155 ????                <1> scr_curs_shape  dw ?    ;Packed start/end scan line
    88 00000157 ??                  <1> scr_char_attr   db ?    ;Grey text on black background
    89 00000158 ??                  <1> scr_mode        db ?    ;80x25, 16 colours default
    90 00000159 ??                  <1> scr_active_page db ?    ;Mode dependent
    91 0000015A ????                <1> scr_crtc_base   dw ?    ;03D4h for Graphics, 03B4h for MDA
    92 0000015C ????????            <1> scr_page_addr   dd ?    ;CRTC Register 12 changes base address accessed
    93 00000160 ????????????????    <1> scr_mode_params dq ?    ;Stub pointer location for future mode parameters
    94 00000168 <res 40h>           <1> scr_vga_ptrs    dq 8 dup (?)  ;VGA pointers
    95                              <1> ;----------------------------------------
    96                              <1> ;       Mass storage Data Area          :
    97                              <1> ;----------------------------------------
    98 000001A8 ??                  <1> i33Devices      db ?  ;Number of devices Int 33h is aware of
    99 000001A9 ??                  <1> msdStatus       db ?  ;Status byte. Used by BIOS for all transfers with Int 33h.
   100 000001AA ??                  <1> fdiskNum        db ?  ;Number of fixed disks
   101 000001AB ??                  <1> ata0CmdByte     db ?  ;Contains bitfield of instructions, Bit 0 is master/slave, Bit 1 is Data Mutex
   102 000001AC ??                  <1> ata0Status      db ?  ;Contains the status of the last transaction
   103 000001AD ??                  <1> ata1CmdByte     db ?
   104 000001AE ??                  <1> ata1Status      db ?
   105 000001AF ????????????????    <1> diskDptPtr      dq ?
   106 000001B7 ????????????????    <1> fdiskDptPtr     dq ?
   107                              <1> ;----------------------------------------
   108                              <1> ;            SysInit Data Area          :
   109                              <1> ;----------------------------------------
   110 000001BF ????????????????    <1> nextFilePtr     dq ?  ;Pointer to next file to load
   111 000001C7 ????                <1> numSectors      dw ?  ;Number of sectors to copy 
   112                              <1> ;----------------------------------------
   113                              <1> ;            Memory Data Area           :
   114                              <1> ;----------------------------------------
   115 000001C9 ????                <1> MachineWord     dw ?    ;Really Legacy Hardware Bitfield
   116 000001CB ????                <1> convRAM         dw ?  ;Conventional memory word
   117 000001CD ????????????????    <1> userBase        dq ?    ;Start address of the user space
   118 000001D5 ??                  <1> bigmapSize      db ?    ;First byte, in units of 24 bytes
   119 000001D6 ????????????????    <1> srData          dw 4 dup(?)  ;4 words for memory64MB
   120 000001DE ????                <1> srData1         dw ?  ;Reserve 1 word for memory16MB
   121 000001E0 ????????????????    <1> sysMem          dq ?  ;Size of usable system RAM (without SCP/BIOS)
   122 000001E8 ????????            <1> scpSize         dd ?  ;Size of SCP/BIOS allocation
   123                              <1> ;----------------------------------------
   124                              <1> ;            MCP Data Area              :
   125                              <1> ;----------------------------------------
   126 000001EC ????????????????    <1> mcpUserBase     dq ?  ;Pointer to register save space
   127 000001F4 ????????????????    <1> mcpUserRip      dq ?  ;Save the custom user RIP for new jumps
   128 000001FC ????????????????    <1> mcpUserkeybf    dq ?  ;Pointer to the keyboard buffer
   129 00000204 ????????????????    <1> mcpUserRaxStore dq ?  ;Temp rax save space
   130 0000020C ????????????????    <1> mcpStackPtr     dq ?  ;Address of base of user Stack Pointer
   131                              <1> ;----------------------------------------
   132                              <1> ;            USB Data Area              :
   133                              <1> ;----------------------------------------
   134 00000214 ??                  <1> xControllers    db ?
   135 00000215 ??                  <1> eControllers    db ?    ;Number of EHCI controllers
   136 00000216 <res 20h>           <1> eControllerList dq 4 dup (?)    ;Entry = PCI space addr|MMIO addrs
   137 00000236 ??                  <1> usbDevices      db ?    ;Max value, 10 for now!
   138 00000237 ????????????????    <1> eHCErrorHandler dq ?  ;Address of default error handler
   139                              <1> ;----------------------------------------
   140                              <1> ;            EHCI Async Area            :
   141                              <1> ;----------------------------------------
   142 0000023F ????????????????    <1> eCurrAsyncHead  dq ?      ;Point to the current head of the async list
   143 00000247 ??                  <1> eNewBus         db ?      ;Default to 0, if 1, a new bus was selected
   144 00000248 ??                  <1> eActiveCtrlr    db ?      ;Current working controller (default -1)
   145 00000249 ??                  <1> eActiveInt      db ?      ;Gives a copy of the usbsts intr bits
   146 0000024A ??                  <1> eAsyncMutex     db ?    
   147                              <1>     ;Mutex, x1b=data NOT ready, wait. x0b=ready, data ready to access.
   148                              <1>     ;        1xb=Internal buffer. 0xb=user provided buffer.
   149                              <1>     ;        bits [7:2], number of interrupts to ignore (if any)
   150                              <1>     ;            a value of 0 means dont ignore
   151                              <1> ;----------------------------------------
   152                              <1> ;            MSD Data Area              :
   153                              <1> ;----------------------------------------
   154 0000024B ??                  <1> cbwTag  db ?        ;cbw transaction unique id (inc post use)
   155 0000024C ??                  <1> numMSD  db ?        ;Number of MSD devices
   156                              <1> ;----------------------------------------
   157                              <1> ;           USB Tables                  :
   158                              <1> ;----------------------------------------
   159 0000024D <res 1Eh>           <1> usbDevTbl   db usbDevTblSz*usbDevTblEntry_size dup (?)
   160 0000026B <res 50h>           <1> hubDevTbl   db hubDevTblSz*hubDevTblEntry_size dup (?)
   161 000002BB <res A0h>           <1> msdDevTbl   db msdDevTblSz*msdDevTblEntry_size dup (?)
   162                              <1> ;----------------------------------------
   163                              <1> ;           IDE Tables                  :
   164                              <1> ;----------------------------------------
   165                              <1> ;Support up to two IDE controllers
   166 0000035B ??                  <1> ideNumCtrlr db ?
   167 0000035C <res 10h>           <1> ideCtrlrTbl db ideCtrlrTblSz*ideCtrlrTblEntry_size dup (?)
   168                              <1> ;----------------------------------------
   169                              <1> ;           ATA Tables                  :
   170                              <1> ;----------------------------------------
   171 0000036C <res 58h>           <1> fdiskTbl  db fdiskTblSz*fdiskTblEntry_size dup (?) ;Max 4 fixed disks
   172                              <1> ;----------------------------------------
   173                              <1> ;            Int33h Table Area          :
   174                              <1> ;----------------------------------------
   175 000003C4 <res 100h>          <1> i33DevTbl   db i33DevTblSz*i33DevTblEntry_size dup (?)
   176                              <1> ;----------------------------------------------------------------
    14                                  ;----------------------------------------------------------------
    15                                  ;                   MCP Transaction area                        :
    16                                  ;----------------------------------------------------------------
    17                                  Segment MCPseg nobits follows=codeResident align=1
    18 00000000 <res 800h>                              resb sizeOfMCPAlloc   ;2KB space
    19                                  MCPsegEnd:  ;Pointer to the end of the segment
    20                                  ;----------------------------------------------------------------
    21                                  ;                  BIOS Transaction area                        :
    22                                  ;                                                               :
    23                                  ;                   Must be the last segment                    :
    24                                  ;----------------------------------------------------------------
    25                                  Segment xdata nobits follows=MCPseg align=40h    ;eXtra data seg
    26                                  %include "./Source/BSS/xbda.asm"
     1                              <1> ;eXtended BDA area for data transfers
     2                              <1> 
     3                              <1> ;This segment comes after the resident code and is the transaction
     4                              <1> ;area. The ehci async schedule (and eventually periodic) live here.
     5                              <1> ;They are BOTH always postfixed by the big memory map.
     6                              <1> ehciAschedule:                  ;Static label for head of the asyncschedule
     7 00000000 <res 60h>           <1> ehciQHead0      resb ehciSizeOfQH ;96 bytes, for address 0 device only
     8 00000060 <res 20h>           <1>     alignb 40h
     9 00000080 <res 60h>           <1> ehciQHead1      resb ehciSizeOfQH ;Used for cmds with an addressed usb device
    10 000000E0 <res 20h>           <1>     alignb 40h
    11 00000100 <res 280h>          <1> ehciTDSpace     resb 10*ehciSizeOfTD   ;640 bytes of transfer space
    12                              <1>     alignb 40h
    13 00000380 <res 20h>           <1> ehciDataOut     resb 20h               ;32 bytes
    14 000003A0 <res 20h>           <1>     alignb 40h
    15                              <1> sectorbuffer:                       ;Same buffer for multiple purposes
    16 000003C0 <res 200h>          <1> ehciDataIn      resb 200h           ;512 bytes, to get as much data as needed
    17                              <1>     alignb 40h
    18 000005C0 <res 10h>           <1> msdCSW          resb 10h                
    19                              <1> ;13 bytes, special, to be saved after each transfer
    20 000005D0 <res 10h>           <1>     alignb 20h      
    21 000005E0 <res 10h>           <1> prdt:           resq 2      ;2 entries in the prdt
    22                              <1> bigmapptr:                        ;Pointer to big mem map
    27                                  ;----------------------------------------------------------------
    28                                  ;                      SysInit Table                            :
    29                                  ;----------------------------------------------------------------
    30                                  Segment SysInitParams   nobits start=600h
    31                                  ;Use the bootsector reload space (600h-800h) as a temporary stack
    32                                  ; and a storage space for the SysInit table
    33                                  SysInitTable:
    34 00000000 ????                    .numSecW        resw 1
    35 00000002 ????????????????        .FileLBA        resq 1
    36 0000000A ????                    loMachineWord   resw 1
    37                                  ;----------------------------------------------------------------
    38                                  ;                      Real Mode Stack                          :
    39                                  ;----------------------------------------------------------------
    40                                  Segment lowStack    nobits  start=700h
    41 00000000 <res 100h>                              resb 100h
    42                                  lowStackPtr:
    43                                  ;----------------------------------------------------------------
    44                                  ORG 800h
    45                                  ;----------------------------------------------------------------
    46                                  ;                    INIT CODE STARTS HERE                      :
    47                                  ;----------------------------------------------------------------
    48                                  Segment codeInit start=BIOSInitAddr align=1
    49                                  BITS 16
    50                                  %include "./Source/Init/RealInit.asm"
     1                              <1> ;First set stack and save the SysInit Ptr, then set A20, check CPUID and 
     2                              <1> ; exended features. Then tell BIOS that we are going long and perhaps 
     3                              <1> ; protected then get the Int 11h word, store at 0:800h
     4                              <1> realInit:
     5                              <1> ;The Caller Far Jumps to set cs to 0
     6 00000000 FA                  <1>     cli     ;Stop interrupts as we dont know where the stack is
     7 00000001 31C0                <1>     xor ax, ax
     8 00000003 8ED8                <1>     mov ds, ax
     9 00000005 8ED0                <1>     mov ss, ax
    10 00000007 BC[0001]            <1>     mov sp, lowStackPtr ;Set up stack pointer
    11 0000000A FB                  <1>     sti
    12 0000000B 26803F0C            <1>     cmp byte [es:bx], 0Ch   ;Check length
    13 0000000F 0F85F200            <1>     jne .fail   ;If thats not it, error 0
    14 00000013 268B4701            <1>     mov ax, word [es:bx + 1]    ;Get number of sectors into ax 
    15 00000017 B92A00              <1>     mov cx, 42  ;42 sectors maximum
    16 0000001A 39C8                <1>     cmp ax, cx
    17 0000001C 0F43C1              <1>     cmovnb ax, cx
    18 0000001F A3[0000]            <1>     mov word [SysInitTable.numSecW], ax
    19 00000022 26668B4704          <1>     mov eax, dword [es:bx + 4]      ;Get low dword
    20 00000027 66A3[0200]          <1>     mov dword [SysInitTable.FileLBA], eax
    21 0000002B 26668B4708          <1>     mov eax, dword [es:bx + 8]      ;Get high dword
    22 00000030 66A3[0600]          <1>     mov dword [SysInitTable.FileLBA + 4], eax
    23                              <1> 
    24 00000034 B80300              <1>     mov ax, 03
    25 00000037 CD10                <1>     int 10h ;Reset the video graphics mode using BIOS 
    26                              <1>     
    27 00000039 06                  <1>     push es
    28                              <1> .a20Proc:
    29 0000003A 50                  <1>     push ax
    30 0000003B 51                  <1>     push cx ;preserve ax and cx
    31 0000003C 31C9                <1>     xor cx, cx ;clear to use as a timeout counter
    32                              <1>     
    33                              <1> .a20FastEnable:
    34 0000003E E492                <1>     in al, 92h
    35 00000040 A802                <1>     test al, 2
    36 00000042 750B                <1>     jnz .no92
    37 00000044 0C02                <1>     or al, 2
    38 00000046 24FE                <1>     and al, 0FEh
    39 00000048 E692                <1>     out 92h, al
    40                              <1>     
    41 0000004A FEC1                <1>     inc cl    ;increments the time out counter
    42 0000004C E94900              <1>     jmp .a20Check
    43                              <1>     
    44                              <1> .no92:
    45 0000004F B104                <1>     mov cl, 4
    46 00000051 E96A00              <1>     jmp .a20Fail
    47                              <1>     
    48                              <1> .a20KeybEnable: ;communicating with the keyboard controller
    49 00000054 FA                  <1>     cli
    50                              <1>  
    51 00000055 E83200              <1>     call .a20wait
    52 00000058 B0AD                <1>     mov al,0ADh
    53 0000005A E664                <1>     out 64h,al ;disable the keyboard
    54 0000005C E82B00              <1>     call .a20wait
    55 0000005F B0D0                <1>     mov al,0D0h
    56 00000061 E664                <1>     out 64h,al ;read from the keyboard input
    57 00000063 E82B00              <1>     call .a20wait2
    58 00000066 E460                <1>     in al,60h
    59 00000068 6650                <1>     push eax    ;get the keyboard data and push it to the stack
    60 0000006A E81D00              <1>     call .a20wait
    61 0000006D B0D1                <1>     mov al,0D1h
    62 0000006F E664                <1>     out 64h,al    ;output the command to prep to go a20 
    63 00000071 E81600              <1>     call .a20wait
    64 00000074 6658                <1>     pop eax    ;need this be eax and not just ax?
    65 00000076 0C02                <1>     or  al,2
    66 00000078 E660                <1>     out 60h,al    ;output to go a20
    67 0000007A E80D00              <1>     call .a20wait
    68 0000007D B0AE                <1>     mov al,0AEh
    69 0000007F E664                <1>     out 64h,al    ;reenable keyboard
    70 00000081 E80600              <1>     call .a20wait    ;done!
    71 00000084 FB                  <1>     sti
    72                              <1> 
    73 00000085 FEC1                <1>     inc cl    ;increments the time out counter
    74 00000087 E90E00              <1>     jmp .a20Check
    75                              <1>     
    76                              <1> .a20wait:
    77 0000008A E464                <1>     in al,64h
    78 0000008C A802                <1>     test al,2
    79 0000008E 75FA                <1>     jnz .a20wait
    80 00000090 C3                  <1>     ret
    81                              <1>  
    82                              <1> .a20wait2: 
    83 00000091 E464                <1>     in al,64h
    84 00000093 A801                <1>     test al,1
    85 00000095 74FA                <1>     jz .a20wait2
    86 00000097 C3                  <1>     ret
    87                              <1> 
    88                              <1> .a20Check:
    89 00000098 B8FFFF              <1>     mov ax, 0FFFFh
    90 0000009B 50                  <1>     push ax
    91 0000009C 07                  <1>     pop es ;es to FFFF
    92 0000009D BF1000              <1>     mov di, 0010h ;FFFF:0010 == 0000:0000
    93 000000A0 31F6                <1>     xor si, si    ;remember ds = 0000
    94 000000A2 268A05              <1>     mov al, byte [es:di]
    95 000000A5 3E3804              <1>     cmp byte [ds:si], al
    96 000000A8 7414                <1>     je .a20Fail
    97 000000AA FEC0                <1>     inc al    ;make change to al
    98 000000AC 3E8804              <1>     mov byte [ds:si], al ;al is now incremented and saved at address 0000:0000
    99 000000AF 263805              <1>     cmp byte [es:di], al ;check against overflown version
   100 000000B2 740A                <1>     je .a20Fail
   101                              <1>     
   102                              <1> .a20Pass:
   103 000000B4 FEC8                <1>     dec al    ;return al to its original value
   104 000000B6 3E8804              <1>     mov byte [ds:si], al ;return to original position
   105                              <1>     
   106 000000B9 59                  <1>     pop cx
   107 000000BA 58                  <1>     pop ax
   108 000000BB 07                  <1>     pop es
   109 000000BC EB11                <1>     jmp short .a20Exit
   110                              <1>     
   111                              <1> .a20Fail:
   112 000000BE 80F903              <1>     cmp cl, 3
   113 000000C1 0F8E79FF            <1>     jle .a20FastEnable
   114 000000C5 80F906              <1>     cmp cl, 6
   115 000000C8 7E8A                <1>     jle .a20KeybEnable
   116                              <1>     
   117 000000CA 59                  <1>     pop cx
   118 000000CB 58                  <1>     pop ax
   119 000000CC 07                  <1>     pop es
   120 000000CD EB2E                <1>     jmp short .noa20
   121                              <1> 
   122                              <1> .a20Exit:
   123 000000CF 669C                <1>     pushfd
   124 000000D1 6658                <1>     pop eax
   125 000000D3 6689C1              <1>     mov ecx, eax ;save original flag state for later
   126 000000D6 663500002000        <1>     xor eax, 00200000h ;21st bit - CPUID bit, switch it!!
   127 000000DC 6650                <1>     push eax
   128 000000DE 669D                <1>     popfd
   129                              <1>     
   130 000000E0 669C                <1>     pushfd
   131 000000E2 6658                <1>     pop eax
   132 000000E4 6685C8              <1>     test eax, ecx ; compare the registers. If they are the same
   133 000000E7 7416                <1>     je .noCPUID
   134 000000E9 6651                <1>     push ecx
   135 000000EB 669D                <1>     popfd
   136                              <1> 
   137                              <1> .extCheck:
   138 000000ED 66B800000080        <1>     mov eax, 80000000h
   139 000000F3 0FA2                <1>     cpuid
   140 000000F5 663D01000080        <1>     cmp eax, 80000001h ;If this is true, CPU supports extended functionality
   141 000000FB 733C                <1>     jae tellBIOS
   142                              <1> .noa20:
   143 000000FD B401                <1>     mov ah, 1    ;noa20 error code
   144                              <1> .noCPUID:
   145 000000FF B402                <1>     mov ah, 2    ;noCPUID error code
   146 00000101 EB02                <1>     jmp short .fail
   147 00000103 B403                <1>     mov ah, 3    ;no Extended functionality error code
   148                              <1> .fail:
   149 00000105 88E2                <1>     mov dl, ah    ;store ax to get error code printed
   150 00000107 BE[2D01]            <1>     mov si, .msg
   151 0000010A E81100              <1>     call .write
   152 0000010D 88D0                <1>     mov al, dl
   153 0000010F BB0700              <1>     mov bx, 0007h    ;Attribs
   154 00000112 B40E                <1>     mov ah, 0Eh        ;TTY print char
   155 00000114 0430                <1>     add al, 30h        ;add '0' to digit
   156 00000116 CD10                <1>     int 10h
   157 00000118 31C0                <1>     xor ax, ax
   158 0000011A CD16                <1>     int 16h    ;await keystroke
   159 0000011C CD18                <1>     int 18h
   160                              <1> ;Error codes: 
   161                              <1> ;   00h - Bad SysInit Data
   162                              <1> ;   01h - No A20 Line
   163                              <1> ;   02h - No CPUID 
   164                              <1> ;   03h - No Extended Functionality
   165                              <1> .write: ;destroys registers ax and bx
   166 0000011E AC                  <1>     lodsb
   167 0000011F 3C00                <1>     cmp al, 0 ;check for zero
   168 00000121 7409                <1>     je .return
   169 00000123 B40E                <1>     mov ah, 0Eh    ;TTY output
   170 00000125 BB0700              <1>     mov bx, 0007h ;colour
   171 00000128 CD10                <1>     int 10h
   172 0000012A EBF2                <1>     jmp short .write
   173                              <1> .return:
   174 0000012C C3                  <1>     ret
   175 0000012D 426F6F74206572726F- <1> .msg: db 'Boot error:',0
   175 00000136 723A00              <1>
   176                              <1> tellBIOS:
   177 00000139 66B800EC0000        <1>     mov eax, 0EC00h ;Tell BIOS we are going long
   178 0000013F B303                <1>     mov bl, 03h     ;Both Long and Protected modes
   179 00000141 CD15                <1>     int 15h         ;Ignore response
   180 00000143 CD11                <1>     int 11h
   181 00000145 A3[0A00]            <1>     mov word [loMachineWord], ax
   182                              <1> ;Getting Memory Map
   183                              <1> rmE820Map:
   184 00000148 06                  <1>     push es
   185 00000149 1E                  <1>     push ds
   186 0000014A B80010              <1>     mov ax, e820Seg
   187 0000014D 8ED8                <1>     mov ds, ax
   188 0000014F 8EC0                <1>     mov es, ax
   189 00000151 BF0200              <1>     mov di,    e820BaseOff
   190 00000154 6631DB              <1>     xor ebx, ebx
   191 00000157 31ED                <1>     xor bp,bp
   192 00000159 66BA50414D53        <1>     mov edx, 0534D4150h    ;Magic dword
   193 0000015F 66B820E80000        <1>     mov eax, 0E820h
   194 00000165 2666C7451401000000  <1>     mov dword [es:di + 20], 1
   195 0000016E 66B918000000        <1>     mov ecx, 24            ;Get 24 bytes
   196 00000174 CD15                <1>     int 15h
   197 00000176 7257                <1>     jc .mapfail            ;Carry set => Fail
   198 00000178 66BA50414D53        <1>     mov edx, 0534D4150h    ;Magic dword
   199 0000017E 6639D0              <1>     cmp eax, edx        ;Must be equal on success
   200 00000181 754C                <1>     jne .mapfail
   201 00000183 6685DB              <1>     test ebx, ebx         ;One table entry, bad
   202 00000186 7447                <1>     jz .mapfail
   203 00000188 EB1F                <1>     jmp short .map1
   204                              <1> .map0:
   205 0000018A 66B820E80000        <1>     mov eax, 0E820h
   206 00000190 2666C7451401000000  <1>     mov dword  [es:di + 20], 1
   207 00000199 66B918000000        <1>     mov ecx, 24
   208 0000019F CD15                <1>     int 15h
   209 000001A1 722C                <1>     jc .mapexit
   210 000001A3 66BA50414D53        <1>     mov edx, 0534D4150h
   211                              <1> .map1:
   212 000001A9 E31D                <1>     jcxz .map3
   213 000001AB 80F914              <1>     cmp cl, 20
   214 000001AE 7607                <1>     jbe .map2
   215 000001B0 26F6451401          <1>     test byte [es:di + 20], 1
   216 000001B5 7411                <1>     je .map3
   217                              <1> .map2:
   218 000001B7 26668B4D08          <1>     mov ecx, dword [es:di + 8]
   219 000001BC 26660B4D0C          <1>     or ecx, [es:di + 12]
   220 000001C1 7405                <1>     jz .map3
   221 000001C3 45                  <1>     inc bp
   222 000001C4 81C71800            <1>     add di, 24
   223                              <1> .map3:
   224 000001C8 6685DB              <1>     test ebx, ebx
   225 000001CB 75BD                <1>     jne .map0
   226 000001CD EB00                <1>     jmp short .mapexit
   227                              <1> .mapfail:
   228                              <1> .mapexit:
   229 000001CF 26892E0000          <1>     mov word [es:e820SizeOff], bp  ;Num entries in var space (3 qwords/entry)
   230                              <1> ;Second memory test
   231 000001D4 31C9                <1>     xor cx, cx
   232 000001D6 31D2                <1>     xor dx, dx
   233 000001D8 B801E8              <1>     mov ax, 0E801h
   234 000001DB CD15                <1>     int 15h
   235 000001DD 7216                <1>     jc .badmem2
   236 000001DF 80FC86              <1>     cmp ah, 86h    ;unsupported command
   237 000001E2 7411                <1>     je .badmem2
   238 000001E4 3D8000              <1>     cmp ax, 80h    ;invalid command
   239 000001E7 740C                <1>     je .badmem2
   240                              <1> .mem2write:
   241 000001E9 AB                  <1>     stosw
   242 000001EA 89D8                <1>     mov ax, bx
   243 000001EC AB                  <1>     stosw
   244 000001ED 89C8                <1>     mov ax, cx
   245 000001EF AB                  <1>     stosw
   246 000001F0 89D0                <1>     mov ax, dx
   247 000001F2 AB                  <1>     stosw
   248 000001F3 EB0B                <1>     jmp short .mem3test
   249                              <1> .badmem2:
   250 000001F5 31C0                <1>     xor ax, ax
   251 000001F7 31DB                <1>     xor bx, bx
   252 000001F9 31C9                <1>     xor cx, cx
   253 000001FB 31D2                <1>     xor dx, dx
   254 000001FD E9E9FF              <1>     jmp .mem2write
   255                              <1> .mem3test:
   256 00000200 F8                  <1>     clc
   257 00000201 B488                <1>     mov ah, 88h
   258 00000203 CD15                <1>     int 15h
   259 00000205 31DB                <1>     xor bx, bx 
   260 00000207 0F42C3              <1>     cmovc ax, bx    ;if error, store zero
   261 0000020A 3D8600              <1>     cmp ax, 86h
   262 0000020D 0F44C3              <1>     cmovz ax, bx
   263 00000210 3D8000              <1>     cmp ax, 80h
   264 00000213 0F44C3              <1>     cmovz ax, bx
   265 00000216 AB                  <1>     stosw
   266                              <1> .finalmemtest:
   267 00000217 F8                  <1>     clc
   268 00000218 CD12                <1>     int 12h
   269 0000021A 0F42C3              <1>     cmovc ax, bx    ;If carry on, store a zero
   270 0000021D AB                  <1>     stosw    ;Store the word
   271                              <1> rmGetFontPointers:
   272                              <1> ;Get ROM Font Pointers, immediately after Memory map
   273                              <1> ;Each entry is 8 bytes long: es=Seg, bp=Off, cx=bytes/char, dx=# of rows - 1
   274 0000021E 31DB                <1>     xor bx, bx         ;Clear bh
   275                              <1> .gfp1:    
   276                              <1> ;Over protective routine in the event that the BIOS routine clobbers registers
   277 00000220 BE0010              <1>     mov si, 1000h    ;Save segment loader
   278 00000223 31C9                <1>     xor cx, cx
   279 00000225 31D2                <1>     xor dx, dx
   280 00000227 31ED                <1>     xor bp, bp
   281 00000229 53                  <1>     push bx            ;Save bx
   282                              <1> 
   283 0000022A B83011              <1>     mov ax, 1130h    ;Get font pointer function
   284 0000022D CD10                <1>     int 10h
   285                              <1> 
   286 0000022F 8CC0                <1>     mov ax, es        ;Get segment into ax to store
   287 00000231 8EC6                <1>     mov es, si        ;Reload segment for stos to work
   288 00000233 AB                  <1>     stosw
   289 00000234 89E8                <1>     mov ax, bp        ;Get offset
   290 00000236 AB                  <1>     stosw
   291 00000237 89C8                <1>     mov ax, cx        ;bytes/char
   292 00000239 AB                  <1>     stosw
   293 0000023A 88D0                <1>     mov al, dl        ;dl contains # of rows, but zero extended for alignment
   294 0000023C 30E4                <1>     xor ah, ah
   295 0000023E AB                  <1>     stosw
   296 0000023F 5B                  <1>     pop bx            ;Get the count back
   297 00000240 FEC7                <1>     inc bh
   298 00000242 80FF07              <1>     cmp bh, 7
   299 00000245 76D9                <1>     jbe .gfp1        ;Once above 7, fall through
   300                              <1> 
   301 00000247 1F                  <1>     pop ds
   302 00000248 07                  <1>     pop es    ;Bring back original es value
   303                              <1> rmSetTables:
   304                              <1> ;Memory tables live in 0:8000h - 0:E000h range
   305 00000249 66BF00800000        <1>     mov edi, 8000h
   306 0000024F 0F22DF              <1>     mov cr3, edi    ;Cannot lsh cr3
   307 00000252 B90030              <1>     mov cx, 3000h    ;6000h bytes (6x4Kb) of zero to clear table area
   308 00000255 57                  <1>     push di
   309 00000256 31C0                <1>     xor ax, ax
   310 00000258 F3AB                <1>     rep stosw        ;Store 3000h words of zero
   311                              <1> 
   312 0000025A 5F                  <1>     pop di            ;Return zero to the head of the table, at 08000h
   313 0000025B B80390              <1>     mov ax, 9000h|permissionflags    ;9000h is the low word of the address.
   314 0000025E AB                  <1>     stosw    ;store the low word of the address
   315 0000025F 81C7FE0F            <1>     add di, 0FFEh
   316 00000263 B90400              <1>     mov cx, 4
   317                              <1> rmUtables:            ;di should point to 8000h
   318 00000266 050010              <1>     add ax, 1000h
   319 00000269 AB                  <1>     stosw    ;ax is now A003h,B003h,C003h,D003h
   320 0000026A 81C70600            <1>     add di, 6    ;qword alignment
   321 0000026E 49                  <1>     dec cx
   322 0000026F 75F5                <1>     jnz rmUtables
   323                              <1> 
   324 00000271 B90008              <1>     mov cx, 800h    ;4x512 consecutive entries
   325 00000274 31C0                <1>     xor ax, ax
   326 00000276 50                  <1>     push ax            ;push for algorithm to work
   327 00000277 BF00A0              <1>     mov di, 0A000h
   328                              <1> rmPDTentries:
   329 0000027A B88300              <1>     mov ax, 83h        ;bit 7|permission flags
   330 0000027D AB                  <1>     stosw            ;di incremented twice
   331 0000027E 58                  <1>     pop ax            ;get current address
   332 0000027F AB                  <1>     stosw            ;di incremented twice. store the address
   333 00000280 052000              <1>     add ax, 20h        ;add the offset to the next page
   334 00000283 50                  <1>     push ax            ;push current address into memory
   335 00000284 81C70400            <1>     add di, 4        ;qword Align
   336 00000288 49                  <1>     dec cx
   337 00000289 75EF                <1>     jnz rmPDTentries
   338                              <1> 
   339 0000028B 0F20E0              <1>     mov eax, cr4                 
   340 0000028E 660DA0000000        <1>     or eax, 0A0h ;Set PAE and PGE, for glbl page and physical page extensions
   341 00000294 0F22E0              <1>     mov cr4, eax 
   342                              <1>     
   343 00000297 66B9800000C0        <1>     mov ecx, 0C0000080h    ;Read EFER MSD into EDX:EAX
   344 0000029D 0F32                <1>     rdmsr    ; Read information from the msr.
   345 0000029F 660D00010000        <1>     or eax, 00000100h ; Set the Long mode bit!
   346 000002A5 0F30                <1>     wrmsr  ; Write the data back
   347                              <1>     
   348 000002A7 FA                  <1>     cli
   349 000002A8 B0FF                <1>     mov al, 0FFh             ; Out 0xFF to 0xA1 and 0x21 to disable all IRQs.
   350 000002AA E6A1                <1>     out 0A1h, al
   351 000002AC E621                <1>     out 21h, al
   352                              <1> 
   353 000002AE 0F0116[DE02]        <1>     lgdt [GDT.Pointer] ;Load the Global Descriptor Table pointer
   354                              <1> 
   355 000002B3 0F20C0              <1>     mov eax, cr0
   356 000002B6 660D01000080        <1>     or eax, 80000001h ;Set the Paging and Protected Mode bits (Bits 31 and 0)
   357 000002BC 0F22C0              <1>     mov cr0, eax  ;write it back!
   358 000002BF EA[E802]0800        <1>     jmp GDT.Code:longmode_ep
   359                              <1> 
   360                              <1> GDT:                    ;Global Descriptor Table (64-bit).
   361                              <1> .Null: equ $ - GDT      ;The null descriptor.
   362 000002C4 0000000000000000    <1>     dq 0
   363                              <1> .Code: equ $ - GDT      ;The 32-bit code descriptor. Limit = FFFFFh, Base=0
   364 000002CC FFFF                <1>     dw 0FFFFh           ;Limit 0:15
   365 000002CE 0000                <1>     dw 00000h           ;Base 0:15
   366 000002D0 00                  <1>     db 00h              ;Base 16:23
   367 000002D1 9A                  <1>     db 09Ah             ;Access Byte
   368 000002D2 3F                  <1>     db 03Fh             ;Limit 16:19
   369 000002D3 00                  <1>     db 00b              ;Base 24:31
   370                              <1> 
   371                              <1> .Data: equ $ - GDT      ;The 32-bit data descriptor. 
   372 000002D4 FFFF                <1>     dw 0FFFFh           ;Limit 0:15
   373 000002D6 0000                <1>     dw 00000h           ;Base 0:15
   374 000002D8 00                  <1>     db 0h               ;Base 16:23
   375 000002D9 92                  <1>     db 092h             ;Access Byte
   376 000002DA 1F                  <1>     db 01Fh             ;Limit 16:19 then Flags
   377 000002DB 00                  <1>     db 00h              ;Base 24:31
   378                              <1> ALIGN 4
   379 000002DC 0000                <1>     dw 0
   380 000002DE 1900                <1> .Pointer    dw $ - GDT - 1      ; GDT pointer.
   381 000002E0 [C402000000000000]  <1> .Base       dq GDT                 ; GDT offset.
   382                              <1> ;----------------------------------------------------------------
    51                                  BITS 64
    52                                  %include "./Source/Init/LongInit.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                    Long Mode Initialisation                   :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> ;----------------------------------------------------------------
     5                              <1> ; Sets up Segment registers, copies the resident portion of SCPBIOS
     6                              <1> ; high, initialises the BDA, copies data from real mode BIOS to 
     7                              <1> ; SCPBIOS internal area, Identity maps the first 4 Gb, creates 
     8                              <1> ; an IVT and moves the GDT to its final resting place,
     9                              <1> ; and directs cr3, gdtr and idtr to the BDA vars and reinits the video
    10                              <1> ; to VGA Mode 3. Finish by printing boot message and memory sizes.
    11                              <1> ;----------------------------------------------------------------
    12                              <1> longmode_ep:
    13 000002E8 66B81000            <1>     mov ax, 10h
    14 000002EC 668ED8              <1>     mov ds, ax
    15 000002EF 668EC0              <1>     mov es, ax
    16 000002F2 668EE0              <1>     mov fs, ax
    17 000002F5 668EE8              <1>     mov gs, ax
    18 000002F8 668ED0              <1>     mov ss, ax
    19                              <1> ;-----------------Write BDA constants-----------------
    20 000002FB 48BF-               <1>     mov rdi, section.data.start
    20 000002FD [0000000000000000]  <1>
    21 00000305 66B80001            <1>     mov ax, 100h
    22 00000309 66AB                <1>     stosw            ;IDT Length
    23 0000030B 66B8FF0F            <1>     mov ax, (100h*10h) - 1    ;IDT Limit
    24 0000030F 66AB                <1>     stosw
    25 00000311 48B8-               <1>     mov rax, BIOSIDTable    ;IDT Base
    25 00000313 [0000000000000000]  <1>
    26 0000031B 48AB                <1>     stosq
    27 0000031D 66B80300            <1>     mov ax, 3h
    28 00000321 66AB                <1>     stosw
    29 00000323 66B81700            <1>     mov ax, (3h*8h)-1
    30 00000327 66AB                <1>     stosw
    31 00000329 48B8-               <1>     mov rax, BIOSGDTable
    31 0000032B [0070000000000000]  <1>
    32 00000333 48AB                <1>     stosq
    33 00000335 48B8-               <1>     mov rax, BIOSPageTbl
    33 00000337 [0010000000000000]  <1>
    34 0000033F 48AB                <1>     stosq
    35 00000341 31C0                <1>     xor eax, eax    ;Clears upper dword too
    36                              <1> ;Clear spur int counters
    37 00000343 66AB                <1>     stosw
    38                              <1> ;Keyboard area
    39 00000345 B904000000          <1>     mov ecx, 4h
    40 0000034A F348AB              <1>     rep stosq    ;Clear kb buffer for 16 words
    41 0000034D 48B8-               <1>     mov rax, kb_buffer
    41 0000034F [2200000000000000]  <1>
    42 00000357 66B90300            <1>     mov cx, 3h    ;Circular pointers
    43 0000035B F348AB              <1>     rep stosq
    44 0000035E 480520000000        <1>     add rax, 20h    ;End of buffer pointer
    45 00000364 48AB                <1>     stosq
    46 00000366 31C0                <1>     xor eax, eax
    47 00000368 AB                  <1>     stosd    ;Store keyboard flags bytes
    48                              <1> ;Serial Area
    49 00000369 AA                  <1>     stosb   ;Clear number of COM devices byte
    50 0000036A 48AB                <1>     stosq    ;Clear com_addresses (4 words)
    51 0000036C 66B90800            <1>     mov cx, 8
    52 00000370 F348AB              <1>     rep stosq    ;Store 8 qwords for COM buffers
    53                              <1> ;Buffer heads
    54 00000373 48B8-               <1>     mov rax, com1_buffer
    54 00000375 [6F00000000000000]  <1>
    55 0000037D 48AB                <1>     stosq
    56 0000037F 480510000000        <1>     add rax, 10h    ;Com2
    57 00000385 48AB                <1>     stosq
    58 00000387 480510000000        <1>     add rax, 10h    ;Com3
    59 0000038D 48AB                <1>     stosq
    60 0000038F 480510000000        <1>     add rax, 10h    ;Com4
    61 00000395 48AB                <1>     stosq
    62                              <1> ;Buffer Tails
    63 00000397 482D30000000        <1>     sub rax, 30h
    64 0000039D 48AB                <1>     stosq
    65 0000039F 480510000000        <1>     add rax, 10h    ;Com2
    66 000003A5 48AB                <1>     stosq
    67 000003A7 480510000000        <1>     add rax, 10h    ;Com3
    68 000003AD 48AB                <1>     stosq
    69 000003AF 480510000000        <1>     add rax, 10h    ;Com4
    70 000003B5 48AB                <1>     stosq
    71                              <1> ;Buffer start
    72 000003B7 482D30000000        <1>     sub rax, 30h
    73 000003BD 48AB                <1>     stosq
    74 000003BF 480510000000        <1>     add rax, 10h    ;Com2
    75 000003C5 48AB                <1>     stosq
    76 000003C7 480510000000        <1>     add rax, 10h    ;Com3
    77 000003CD 48AB                <1>     stosq
    78 000003CF 480510000000        <1>     add rax, 10h    ;Com4
    79 000003D5 48AB                <1>     stosq
    80                              <1> ;Buffer end
    81 000003D7 482D20000000        <1>     sub rax, 20h
    82 000003DD 48AB                <1>     stosq
    83 000003DF 480510000000        <1>     add rax, 10h    ;Com2
    84 000003E5 48AB                <1>     stosq
    85 000003E7 480510000000        <1>     add rax, 10h    ;Com3
    86 000003ED 48AB                <1>     stosq
    87 000003EF 480510000000        <1>     add rax, 10h    ;Com4
    88 000003F5 48AB                <1>     stosq
    89                              <1> ;Printer area
    90 000003F7 31C0                <1>     xor eax, eax
    91 000003F9 66B90300            <1>     mov cx, 3h
    92 000003FD F366AB              <1>     rep stosw
    93                              <1> ;Timers area
    94 00000400 66AB                <1>     stosw   ;Default pit_divisor, 0 = 65536
    95 00000402 AB                  <1>     stosd    ;pit_ticks
    96 00000403 48AB                <1>     stosq    ;rtc_ticks
    97                              <1> ;Screen area
    98 00000405 66B90200            <1>     mov cx, 2h
    99 00000409 F348AB              <1>     rep stosq    ;rax, is 0
   100 0000040C 66B85000            <1>     mov ax, 50h
   101 00000410 AA                  <1>     stosb
   102 00000411 66B81900            <1>     mov ax, 19h
   103 00000415 AA                  <1>     stosb
   104 00000416 6631C0              <1>     xor ax, ax
   105 00000419 66AB                <1>     stosw
   106 0000041B 66B80700            <1>     mov ax, 07
   107 0000041F AA                  <1>     stosb
   108 00000420 66B80300            <1>     mov ax, 03
   109 00000424 AA                  <1>     stosb
   110 00000425 6631C0              <1>     xor ax, ax
   111 00000428 AA                  <1>     stosb
   112 00000429 66B8D403            <1>     mov ax, vga_index
   113 0000042D 66AB                <1>     stosw
   114 0000042F B800800B00          <1>     mov eax, vga_bpage2
   115 00000434 AB                  <1>     stosd
   116 00000435 31C0                <1>     xor eax, eax    ;zero rax
   117                              <1> ;Store scr_mode_params and scr_vga_ptrs
   118 00000437 B909000000          <1>     mov ecx, 9
   119 0000043C F348AB              <1>     rep stosq
   120                              <1> ;HDD/FDD data area
   121 0000043F 31C0                <1>     xor eax, eax
   122 00000441 66AB                <1>     stosw   ;Int 33h entries and msdStatus
   123 00000443 AA                  <1>     stosb   ;Fixed disk entries
   124 00000444 AB                  <1>     stosd   ;Hard drive status entries
   125 00000445 48B8-               <1>     mov rax, diskdpt
   125 00000447 [981A000000000000]  <1>
   126 0000044F 48AB                <1>     stosq   ;Store the address of the default remdev format table
   127 00000451 48B8-               <1>     mov rax, fdiskdpt
   127 00000453 [A31A000000000000]  <1>
   128 0000045B 48AB                <1>     stosq
   129 0000045D 31C0                <1>     xor eax, eax
   130                              <1> ;SysInit area
   131 0000045F 488B0425[02000000]  <1>     mov rax, qword [SysInitTable.FileLBA]
   132 00000467 48AB                <1>     stosq   ;NextFileLBA
   133 00000469 0FB70425[00000000]  <1>     movzx eax, word [SysInitTable.numSecW] 
   134 00000471 66AB                <1>     stosw   ;numSectors Word
   135 00000473 31C0                <1>     xor eax, eax
   136                              <1> ;Memory Data area
   137 00000475 AB                  <1>     stosd    ;0 MachineWord and convRAM 
   138 00000476 48AB                <1>     stosq   ;0 userBase
   139 00000478 AA                  <1>     stosb    ;0 bigmapSize
   140 00000479 48AB                <1>     stosq   ;0 srData, 4 words
   141 0000047B 66AB                <1>     stosw   ;0 srData1, 1 word
   142 0000047D 48AB                <1>     stosq   ;0 sysMem, 1 qword
   143 0000047F AB                  <1>     stosd   ;0 scpSize, 1 dword
   144                              <1> ;MCP data area
   145 00000480 48C70425[EC010000]- <1>     mov qword [mcpUserBase], section.MCPseg.start
   145 00000488 [00000000]          <1>
   146 0000048C 48C70425[F4010000]- <1>     mov qword [mcpUserRip], section.MCPseg.start + 180h
   146 00000494 [80010000]          <1>
   147 00000498 48C70425[FC010000]- <1>     mov qword [mcpUserkeybf], section.MCPseg.start + 100h
   147 000004A0 [00010000]          <1>
   148 000004A4 48C70425[0C020000]- <1>     mov qword [mcpStackPtr], MCPsegEnd
   148 000004AC [00080000]          <1>
   149 000004B0 48C70425[04020000]- <1>     mov qword [mcpUserRaxStore], 0
   149 000004B8 00000000            <1>
   150 000004BC 4881C728000000      <1>     add rdi, 5*8    ;Go forwards by 5 entries
   151                              <1> ;USB Area
   152 000004C3 AA                  <1>     stosb
   153 000004C4 66B90400            <1>     mov cx, 4
   154 000004C8 F348AB              <1>     rep stosq    ;eControllerList
   155 000004CB AA                  <1>     stosb
   156 000004CC 48B8-               <1>     mov rax, USB.ehciCriticalErrorHandler ;Get the critical error handler ptr
   156 000004CE [023A000000000000]  <1>
   157 000004D6 48AB                <1>     stosq       ;Install eHCErrorHandler
   158 000004D8 31C0                <1>     xor eax, eax    ;Rezero rax
   159 000004DA 66FFC8              <1>     dec ax
   160 000004DD 48AB                <1>     stosq       ;eCurrAsyncHead
   161 000004DF AA                  <1>     stosb       ;eActiveAddr
   162 000004E0 AA                  <1>     stosb        ;eActiveCtrlr
   163 000004E1 66FFC0              <1>     inc ax
   164 000004E4 AB                  <1>     stosd
   165                              <1> ;USB Tables
   166 000004E5 66B91E00            <1>     mov cx, usbDevTblSz*usbDevTblEntry_size
   167 000004E9 F3AA                <1>     rep stosb
   168 000004EB 66B95000            <1>     mov cx, hubDevTblSz*hubDevTblEntry_size
   169 000004EF F3AA                <1>     rep stosb
   170 000004F1 66B9A000            <1>     mov cx, msdDevTblSz*msdDevTblEntry_size
   171 000004F5 F3AA                <1>     rep stosb
   172                              <1> ;IDE and Int 33h stuff
   173 000004F7 AA                  <1>     stosb       ;ideNumCtrlr
   174 000004F8 66B91000            <1>     mov cx, ideCtrlrTblSz*ideCtrlrTblEntry_size ;ideCtrlrTbl
   175 000004FC F3AA                <1>     rep stosb
   176 000004FE 66B95800            <1>     mov cx, fdiskTblSz*fdiskTblEntry_size
   177 00000502 F3AA                <1>     rep stosb
   178 00000504 66B90001            <1>     mov cx, i33DevTblSz*i33DevTblEntry_size
   179 00000508 F3AA                <1>     rep stosb
   180                              <1> ;End of BDA variable init
   181                              <1> 
   182                              <1> ;Copy the resident portion of SCPBIOS.SYS to its offset
   183                              <1> Relocate:
   184 0000050A 48BE-               <1>     mov rsi, section.codeResident.start
   184 0000050C [0000000000000000]  <1>
   185 00000514 48BF-               <1>     mov rdi, section.codeResident.vstart    ;address for the end of the section
   185 00000516 [0000000000000000]  <1>
   186 0000051E 48B90D0B0000000000- <1>     mov rcx, (residentLength/8) + 1
   186 00000527 00                  <1>
   187 00000528 F348A5              <1>     rep movsq    ;Copy resident portion high
   188                              <1> 
   189                              <1> ;Copy machine word into var from 600h
   190 0000052B 668B0425[0A000000]  <1>     mov ax, word [loMachineWord]
   191 00000533 66890425[C9010000]  <1>     mov word [MachineWord], ax
   192                              <1> 
   193                              <1> ;Copy Memory Maps DIRECTLY after USB dynamic space.
   194 0000053B 48BF-               <1>     mov rdi, bigmapptr
   194 0000053D [F005000000000000]  <1>
   195                              <1> .move820_0:    ;Add to the end
   196 00000545 48BE00000100000000- <1>     mov rsi, e820SizeAddr
   196 0000054E 00                  <1>
   197 0000054F 66AD                <1>     lodsw    ;Get number of entries for big map
   198 00000551 480FB6C0            <1>     movzx rax, al    ;zero extend
   199 00000555 488D0C40            <1>     lea rcx, qword [rax + 2*rax]    ;Save 3*#of entries for countdown loop
   200                              <1> .mv0:
   201 00000559 F348A5              <1>     rep movsq    ;Transfer 3*al qwords
   202 0000055C 0402                <1>     add al, 2    ;Two more entries for BIOS
   203 0000055E 880425[D5010000]    <1>     mov byte [bigmapSize], al    ;Save entries in al
   204                              <1> ;Compute the size of BIOS allocation + space for two more entries up to next KB
   205 00000565 4881C718000000      <1>     add rdi, 3*8 ;rdi now points to start of last allocated entry (added)
   206 0000056C 4889FB              <1>     mov rbx, rdi 
   207 0000056F 4881C318000000      <1>     add rbx, 3*8h   ;Add size of last new entry
   208                              <1> ;Round to nearest KB
   209 00000576 4881E300FCFFFF      <1>     and rbx, ~3FFh
   210 0000057D 4881C300040000      <1>     add rbx, 400h
   211 00000584 48891C25[CD010000]  <1>     mov qword [userBase], rbx    ;Save userbase
   212 0000058C 4881EB00001100      <1>     sub rbx, BIOSStartAddr 
   213 00000593 891C25[E8010000]    <1>     mov dword [scpSize], ebx    ;Save Size
   214                              <1> ;Calculate amount of system RAM available
   215                              <1> .readSystemSize:
   216 0000059A 48BB-               <1>     mov rbx, bigmapptr
   216 0000059C [F005000000000000]  <1>
   217 000005A4 48BA01000000010000- <1>     mov rdx, 0000000100000001h      ;Valid entry signature
   217 000005AD 00                  <1>
   218 000005AE 0FB6C8              <1>     movzx ecx, al       ;Get the number of 24 byte entries
   219 000005B1 81E902000000        <1>     sub ecx, 2          ;Remove the allocated entries from the count
   220 000005B7 31C0                <1>     xor eax, eax                    ;Zero rax, use to hold cumulative sum
   221                              <1> .rss1:
   222 000005B9 48395310            <1>     cmp qword [rbx + 2*8], rdx   ;Check valid entry
   223 000005BD 7504                <1>     jnz .rss2
   224 000005BF 48034308            <1>     add rax, qword [rbx + 8]    ;Add size to rax
   225                              <1> .rss2:
   226 000005C3 4881C318000000      <1>     add rbx, 3*8                ;Goto next entry
   227 000005CA FFC9                <1>     dec ecx                     ;Decrement count
   228 000005CC 75EB                <1>     jnz .rss1                   ;Not at zero, keep going
   229 000005CE 48890425[E0010000]  <1>     mov qword [sysMem], rax
   230                              <1> ;Create and insert new entry. If no space found for new, just add to end
   231                              <1> .addEntry:
   232 000005D6 0FB60C25[D5010000]  <1>     movzx ecx, byte [bigmapSize]
   233 000005DE 81E902000000        <1>     sub ecx, 2          ;Remove the allocated entries from the count   
   234 000005E4 31D2                <1>     xor edx, edx    ;Use as index pointer
   235                              <1> .ae0:
   236 000005E6 4881BA[F0050000]00- <1>     cmp qword [bigmapptr+rdx], 100000h    ;Start of extended memory
   236 000005EE 001000              <1>
   237 000005F1 7438                <1>     je .ae1
   238 000005F3 4881C218000000      <1>     add rdx, 18h    ;Go to next entry
   239 000005FA FFC9                <1>     dec ecx 
   240 000005FC 75E8                <1>     jnz .ae0
   241                              <1> ;If address not found, just add it to the end, deal with that here
   242                              <1> ;Ignore the extra calculated allocated entry
   243                              <1> ;rdi points to last new entry, so sub rdi to point to second to last entry
   244 000005FE 4881EF18000000      <1>     sub rdi, 3*8h
   245 00000605 48C70700001100      <1>     mov qword [rdi], BIOSStartAddr
   246 0000060C 488B0425[E8010000]  <1>     mov rax, qword [scpSize]
   247 00000614 48894708            <1>     mov qword [rdi + 8h], rax
   248 00000618 48B802000000010000- <1>     mov rax, 100000002h
   248 00000621 00                  <1>
   249 00000622 48894708            <1>     mov qword [rdi + 8h], rax
   250 00000626 E99F000000          <1>     jmp .altRAM
   251                              <1> .ae1:
   252                              <1> ;Address found, add new entry
   253                              <1> ;ecx contains number of entries that need to be shifted + 1
   254 0000062B 56                  <1>     push rsi
   255 0000062C 57                  <1>     push rdi
   256 0000062D 4889FE              <1>     mov rsi, rdi
   257 00000630 4881EE30000000      <1>     sub rsi, 2*18h
   258 00000637 FFC9                <1>     dec ecx
   259 00000639 89C8                <1>     mov eax, ecx    ;Use eax as row counter
   260                              <1> .ae2:
   261 0000063B B903000000          <1>     mov ecx, 3      ;3 8 byte entries
   262 00000640 F348A5              <1>     rep movsq
   263 00000643 4881EE30000000      <1>     sub rsi, 2*18h
   264 0000064A 4881EF30000000      <1>     sub rdi, 2*18h
   265 00000651 FFC8                <1>     dec eax
   266 00000653 75E6                <1>     jnz .ae2
   267 00000655 5F                  <1>     pop rdi
   268 00000656 5E                  <1>     pop rsi
   269                              <1> ;Values copied, time to change values
   270                              <1> ;Change HMA entry
   271 00000657 4881C2[F0050000]    <1>     add rdx, bigmapptr    ;Add offset into table to rdx
   272 0000065E 488B4A08            <1>     mov rcx, qword [rdx + 8h]       ;Save size from entry into rax
   273 00000662 48C7420800000100    <1>     mov qword [rdx + 8h], 10000h    ;Free 64Kb entry (HMA)
   274 0000066A 4881C218000000      <1>     add rdx, 3*8h   ;Move to new SCP reserved entry
   275                              <1> ;Now Create the SCPBIOS Space Entry
   276 00000671 48C70200001100      <1>     mov qword [rdx], BIOSStartAddr
   277 00000678 31DB                <1>     xor ebx, ebx
   278 0000067A 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]
   279 00000681 48895A08            <1>     mov qword [rdx + 8h], rbx
   280 00000685 48BB02000000010000- <1>     mov rbx, 100000002h
   280 0000068E 00                  <1>
   281 0000068F 48895A10            <1>     mov qword [rdx + 10h], rbx  ;Reserved flags
   282 00000693 4881C218000000      <1>     add rdx, 3*8h
   283                              <1> ;Now modify the Free space entry
   284 0000069A 488B0425[CD010000]  <1>     mov rax, qword [userBase]
   285 000006A2 488902              <1>     mov qword [rdx], rax
   286 000006A5 31C0                <1>     xor eax, eax
   287 000006A7 8B0425[E8010000]    <1>     mov eax, dword [scpSize]
   288 000006AE 4829C1              <1>     sub rcx, rax
   289 000006B1 4881E900000100      <1>     sub rcx, 10000h ;Sub HMA size
   290 000006B8 48894A08            <1>     mov qword [rdx + 8h], rcx    ;Put entry back
   291 000006BC 48BB01000000010000- <1>     mov rbx, 100000001h
   291 000006C5 00                  <1>
   292 000006C6 48895A10            <1>     mov qword [rdx + 10h], rbx  ;Free flags
   293                              <1> .altRAM:
   294                              <1> ;Copy Alt RAM values
   295 000006CA 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]
   296 000006D1 C1EB0A              <1>     shr ebx, 0Ah    ;Rescale from byts to KB
   297 000006D4 81C340000000        <1>     add ebx, 40h    ;Add the HMA (64Kb)
   298 000006DA 48BF-               <1>     mov rdi, srData    ;Save qword in srData ah=E801h
   298 000006DC [D601000000000000]  <1>
   299 000006E4 48AD                <1>     lodsq    ;Get into rax, inc rsi
   300 000006E6 6629D8              <1>     sub ax, bx      ;bx preserved, contains number of KB's plus 1
   301 000006E9 48C1C820            <1>     ror rax, 20h    ;Rotate over 32 bits
   302 000006ED 6629D8              <1>     sub ax, bx
   303 000006F0 48C1C820            <1>     ror rax, 20h    ;Rotate over 32 bits again
   304 000006F4 48AB                <1>     stosq            ;Save, inc rdi
   305 000006F6 48BF-               <1>     mov rdi, srData1    ;Save word for ah=88h
   305 000006F8 [DE01000000000000]  <1>
   306 00000700 66A5                <1>     movsw    ;Save value, then reduce by BIOS size
   307 00000702 66295FFE            <1>     sub word [rdi - 2], bx    ;Reduce the size of the previous stored val
   308 00000706 48BF-               <1>     mov rdi, convRAM    ;Int 12h value
   308 00000708 [CB01000000000000]  <1>
   309 00000710 66A5                <1>     movsw
   310                              <1> ;Copy VGA fonts to Internal Int 30h area
   311 00000712 48BF-               <1>     mov rdi, scr_vga_ptrs
   311 00000714 [6801000000000000]  <1>
   312 0000071C 48B908000000000000- <1>     mov rcx, 8
   312 00000725 00                  <1>
   313 00000726 F348A5              <1>     rep movsq
   314                              <1> ;-----------------Write Long Mode Page Tables-----------------
   315                              <1> ;Creates a 4Gb ID mapped page 
   316 00000729 48BF-               <1>     mov rdi, BIOSPageTbl
   316 0000072B [0010000000000000]  <1>
   317 00000733 57                  <1>     push rdi
   318                              <1> Ptablefinal:
   319 00000734 48B9000C0000000000- <1>     mov rcx, 6000h/8;6000h bytes (6x4Kb) of zero to clear table area
   319 0000073D 00                  <1>
   320 0000073E 57                  <1>     push rdi
   321 0000073F 4831C0              <1>     xor rax, rax
   322 00000742 F348AB              <1>     rep stosq        ;Clear the space
   323                              <1> 
   324 00000745 5F                  <1>     pop rdi            ;Return zero to the head of the table, at 08000h
   325 00000746 4889F8              <1>     mov rax, rdi    ;Load rax with the PML4 table location
   326 00000749 480500100000        <1>     add rax, 1000h  ;Move rax to point to PDPT
   327 0000074F 480D03000000        <1>     or rax, permissionflags    ;Write the PDPT entry as present and r/w
   328 00000755 48AB                <1>     stosq    ;store the low word of the address
   329 00000757 4881C7F80F0000      <1>     add rdi, 0FF8h
   330 0000075E B904000000          <1>     mov ecx, 4
   331                              <1> .utables:
   332 00000763 480500100000        <1>     add rax, 1000h  ;Write four entries in PDPT for each GB range
   333 00000769 48AB                <1>     stosq
   334 0000076B FFC9                <1>     dec ecx
   335 0000076D 75F4                <1>     jnz .utables
   336                              <1> 
   337 0000076F 4881C7E00F0000      <1>     add rdi, 0FE0h  ;rdi points to the new page tables, copy!
   338 00000776 48BE00A00000000000- <1>     mov rsi, 0A000h ;Get the first Page table
   338 0000077F 00                  <1>
   339 00000780 B900080000          <1>     mov ecx, 4000h/8 ;Number of bytes to copy 
   340 00000785 F348A5              <1>     rep movsq       ;Get the 4Gb tables into place
   341 00000788 5F                  <1>     pop rdi            ;Bring back Table base
   342 00000789 0F22DF              <1>     mov cr3, rdi    ;Finalise change in paging address
   343                              <1> 
   344                              <1> ;----------------------Write Interrupts----------------------
   345 0000078C 48B900010000000000- <1>     mov rcx, 0100h    ;256 entries
   345 00000795 00                  <1>
   346 00000796 48B8-               <1>     mov rax, dummy_return_64
   346 00000798 [3358000000000000]  <1>
   347 000007A0 BB08000000          <1>     mov ebx, codedescriptor
   348 000007A5 31F6                <1>     xor esi, esi
   349 000007A7 66BA008F            <1>     mov dx, 8F00h    
   350                              <1>     ;Toggle attribs. 8F = Interrupt Present, accessable from ring 0 and greater,
   351                              <1>     ;0 (so collectively 08h) and gate type 0Fh (64-bit trap gate (gate which 
   352                              <1>     ;leaves interrupts on))
   353                              <1> idtFillDummy:
   354 000007AB E8(CB000000)        <1>     call idtWriteEntry
   355 000007B0 66FFC9              <1>     dec cx
   356 000007B3 75F6                <1>     jnz idtFillDummy
   357                              <1> 
   358 000007B5 31F6                <1>     xor esi, esi
   359 000007B7 48B940000000000000- <1>     mov rcx, ((IDT_TABLE_Length >> 3))
   359 000007C0 00                  <1>
   360 000007C1 48BD-               <1>     mov rbp, IDT_TABLE
   360 000007C3 [BF18000000000000]  <1>
   361                              <1> idtLoop:
   362 000007CB 488B44F500          <1>     mov rax, qword [rbp+(rsi*8)]
   363 000007D0 E8(CB000000)        <1>     call idtWriteEntry
   364 000007D5 48FFC9              <1>     dec rcx
   365 000007D8 75F1                <1>     jnz idtLoop
   366                              <1> 
   367 000007DA 48BC00000800000000- <1>     mov rsp, 80000h    ;Realign stack pointer
   367 000007E3 00                  <1>
   368                              <1> ;Reload the interrupt table
   369 000007E4 0F011C25[02000000]  <1>     lidt [IDTpointer]
   370                              <1> ;Write GDT to its final High location
   371 000007EC 48BE-               <1>     mov rsi, GDT
   371 000007EE [C402000000000000]  <1>
   372 000007F6 48BF-               <1>     mov rdi, BIOSGDTable
   372 000007F8 [0070000000000000]  <1>
   373 00000800 48B903000000000000- <1>     mov rcx, 3
   373 00000809 00                  <1>
   374 0000080A F348A5              <1>     rep movsq    ;copy the three descriptors high
   375                              <1> ;Reload the GDT Pointer
   376 0000080D 0F011425[0E000000]  <1>     lgdt [GDTpointer]
   377                              <1> 
   378                              <1> ;Video Initialisation: VGA mode, CRTC at 3D4h, Mode 03h, 128k VRAM
   379                              <1> ;For now, only unlock upper WO CRTC registers, by using undocumented 
   380                              <1> ; CRTC register 11h.
   381 00000815 668B1425[5A010000]  <1>     mov dx, word [scr_crtc_base]    ;Get current set CRTC index register
   382 0000081D B011                <1>     mov al, 11h     ;Register 11
   383 0000081F 88D8                <1>     mov al, bl
   384 00000821 EE                  <1>     out dx, al
   385 00000822 E680                <1>     out waitp, al   ;Wait an I/O cycle
   386 00000824 66FFC2              <1>     inc dx  ;Point to data register
   387 00000827 EC                  <1>     in al, dx   ;get register 11h
   388 00000828 247F                <1>     and al, 7Fh ;Clear upper bit
   389 0000082A 86C3                <1>     xchg al, bl ;Get address back into al, save new register value in bl  
   390 0000082C 66FFCA              <1>     dec dx  ;Return to index
   391 0000082F EE                  <1>     out dx, al
   392 00000830 FEC2                <1>     inc dl
   393 00000832 86C3                <1>     xchg al, bl
   394 00000834 EE                  <1>     out dx, al  ;Output new byte, unlock upper WO CRTC registers for use!
   395                              <1> ;Boot message/Verification of successful VGA card reset!
   396                              <1> ;Print Boot Message
   397 00000835 66B80413            <1>     mov ax, 1304h
   398 00000839 48BD-               <1>     mov rbp, startboot
   398 0000083B [F915000000000000]  <1>
   399 00000843 CD30                <1>     int 30h
   400                              <1> 
   401 00000845 E8A30E0000          <1>     call memprint    ;Print Memory status
   402                              <1> 
   403                              <1> ;----------------------------------------------------------------
   404                              <1> ;                        End of Initialisation                  :
   405                              <1> ;----------------------------------------------------------------
    53                                  %include "./Source/Init/Hardware/PIC/picinit.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                PIC Initialisation procedure                   :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> ;Remapping the IO ports to Interrupt 0x40
     5                              <1> PICremap:
     6 0000084A B011                <1>     mov al, 11h        ;bit 10h and 1h = Start initialisation
     7 0000084C E620                <1>     out pic1command, al
     8 0000084E E680                <1>     out waitp, al    
     9 00000850 E6A0                <1>     out pic2command, al
    10 00000852 E680                <1>     out waitp, al    
    11                              <1>     
    12 00000854 B020                <1>     mov al, 20h       ;PIC1 to take Int 20h - 27h
    13 00000856 E621                <1>     out pic1data, al
    14 00000858 E680                <1>     out waitp, al    
    15 0000085A 0408                <1>     add al, 8        ;PIC2 to take Int 28h - 2Fh
    16 0000085C E6A1                <1>     out pic2data, al 
    17 0000085E E680                <1>     out waitp, al    
    18                              <1>     
    19 00000860 B004                <1>     mov al, 4
    20 00000862 E621                <1>     out pic1data, al    ;Tell PIC 1 that there is a PIC 2 at IRQ2 (00000100)
    21 00000864 E680                <1>     out waitp, al    
    22 00000866 FEC8                <1>     dec al
    23 00000868 FEC8                <1>     dec al
    24 0000086A E6A1                <1>     out pic2data, al    ;Tell PIC 2 its cascade identity (00000010)
    25 0000086C E680                <1>     out waitp, al
    26                              <1>     
    27 0000086E B001                <1>     mov al, 01h        ;Initialise in 8086 mode
    28 00000870 E621                <1>     out pic1data, al
    29 00000872 E680                <1>     out waitp, al    
    30 00000874 E6A1                <1>     out pic2data, al
    31 00000876 E680                <1>     out waitp, al    
    32                              <1>     
    33 00000878 B0FF                <1>     mov al, 0FFh    ;Mask all interrupts 
    34 0000087A E621                <1>     out pic1data, al
    35 0000087C E6A1                <1>     out pic2data, al
    36                              <1> 
    37                              <1> ;Ensure that interrupts are still masked
    38                              <1> ;----------------------------------------------------------------
    39                              <1> ;                        End of Initialisation                  :
    40                              <1> ;----------------------------------------------------------------
    54                                  %include "./Source/Init/Hardware/PCI/init.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                            PCI Enumeration                    :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> ; This proc enumerates only the PCI devices we care for
     5                              <1> ;----------------------------------------------------------------
     6 0000087E 4831ED              <1>     xor rbp, rbp
     7 00000881 66892C2500E00000    <1>     mov word [lousbtablesize], bp
     8 00000889 4889E9              <1>     mov rcx, rbp    ;reset cx now too, for below
     9                              <1> pci_scan:    ;Enumerate PCI devices (formerly, USB devices)
    10 0000088C 4831DB              <1>     xor rbx, rbx       ;Used to save the value of eax temporarily
    11 0000088F 48B808000081000000- <1>     mov rax, 81000008h ;Set bit 31 and lower byte to 2, for register 2/offset 8
    11 00000898 00                  <1>
    12                              <1>                        ;also make it the largest register so that we enumerate 
    13                              <1>                        ;backwards and set up USB controllers in order from 
    14                              <1>                        ;newest to oldest.
    15                              <1> .u1:
    16 00000899 2D00010000          <1>     sub eax, 100h      ;mov eax into valid PCI range, go to next device
    17 0000089E 66BAF80C            <1>     mov dx, pci_index  ;PCI index register
    18 000008A2 EF                  <1>     out dx, eax   ;output the next packed bus,device,function,register combo
    19                              <1> 
    20 000008A3 89C3                <1>     mov ebx, eax       ;save to be used later, to access PCI BARS
    21                              <1>     
    22 000008A5 66BAFC0C            <1>     mov dx, pci_data   ;PCI data register
    23 000008A9 ED                  <1>     in eax, dx    ;Get Class, subclass and interface value in upper three bytes
    24                              <1>     
    25 000008AA C1E808              <1>     shr eax, 8                ;shift down the details by a byte
    26                              <1> ;IF any of these are satisfied, remember ebx has the device index
    27 000008AD 3D00030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+uhci_interface)
    28 000008B2 0F844B010000        <1>     je .uhci_found
    29 000008B8 3D10030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+ohci_interface)
    30 000008BD 0F8482010000        <1>     je .ohci_found
    31 000008C3 3D20030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+ehci_interface)
    32 000008C8 0F8481010000        <1>     je .ehci_found
    33 000008CE 3D30030C00          <1>     cmp eax, ((usb_class << 16) +(usb_subclass << 8)+xhci_interface)
    34 000008D3 0F84D5010000        <1>     je .xhci_found
    35 000008D9 50                  <1>     push rax
    36 000008DA C1E808              <1>     shr eax, 8              ;roll over rid of function number
    37 000008DD 3D01010000          <1>     cmp eax, (msd_class << 8) + (ide_subclass)
    38 000008E2 7452                <1>     je .idePCIEnum
    39 000008E4 3D06010000          <1>     cmp eax, (msd_class << 8) + (sata_subclass)
    40 000008E9 7414                <1>     je .sataPCIEnum
    41 000008EB 58                  <1>     pop rax
    42                              <1> .u11:    ;After a device found, jump here to continue enumeration
    43 000008EC 6681E50F00          <1>     and bp, 000Fh       ;Zero the upper nybble again.
    44 000008F1 89D8                <1>     mov eax, ebx        ;Return pci value into eax
    45 000008F3 3D08000080          <1>     cmp eax, 80000008h  ;The lowest value
    46 000008F8 7F9F                <1>     jg .u1
    47 000008FA E9AE040000          <1>     jmp pciExit
    48                              <1> .sataPCIEnum:
    49 000008FF 58                  <1>     pop rax
    50 00000900 50                  <1>     push rax
    51 00000901 55                  <1>     push rbp
    52 00000902 66B80413            <1>     mov ax, 1304h
    53 00000906 48BD-               <1>     mov rbp, .spemsg
    53 00000908 [1909000000000000]  <1>
    54 00000910 CD30                <1>     int 30h
    55 00000912 5D                  <1>     pop rbp
    56 00000913 58                  <1>     pop rax
    57 00000914 E9D3FFFFFF          <1>     jmp .u11
    58 00000919 0A0D41484349205341- <1> .spemsg: db 0Ah, 0Dh, "AHCI SATA controller found", 0
    58 00000922 544120636F6E74726F- <1>
    58 0000092B 6C6C657220666F756E- <1>
    58 00000934 6400                <1>
    59                              <1> .idePCIEnum:
    60 00000936 58                  <1>     pop rax
    61 00000937 50                  <1>     push rax
    62 00000938 55                  <1>     push rbp
    63 00000939 66B80413            <1>     mov ax, 1304h
    64 0000093D 48BD-               <1>     mov rbp, .ipemsg
    64 0000093F [B109000000000000]  <1>
    65 00000947 CD30                <1>     int 30h
    66 00000949 5D                  <1>     pop rbp
    67 0000094A 58                  <1>     pop rax
    68 0000094B 50                  <1>     push rax
    69 0000094C B404                <1>     mov ah, 04h
    70 0000094E CD30                <1>     int 30h
    71 00000950 58                  <1>     pop rax
    72                              <1> ;If function is 80h, then it will respond to default IO addresses
    73 00000951 A880                <1>     test al, 80h ;Check if bus mastery is enabled. Only support DMA transfers
    74 00000953 7497                <1>     jz .u11      ;Exit if not enabled
    75 00000955 3C80                <1>     cmp al, 80h  ;If 80h, device hardwired bus master legacy mode, all good.
    76 00000957 742B                <1>     je .ipeWriteTable
    77                              <1> ;Bit bash, and reread, if it works, yay, if not, fail cancel
    78 00000959 66BAF80C            <1>     mov dx, pci_index
    79 0000095D 89D8                <1>     mov eax, ebx
    80 0000095F EF                  <1>     out dx, eax     ;Register offset 8
    81 00000960 6681C20400          <1>     add dx, 4       ;Point to pci_data
    82 00000965 25FFFAFFFF          <1>     and eax, 0FFFFFAFFh     ;Zero bits 0 and 2 of nybble 3
    83 0000096A EF                  <1>     out dx, eax
    84 0000096B 6681EA0400          <1>     sub dx, 4
    85 00000970 89D8                <1>     mov eax, ebx
    86 00000972 EF                  <1>     out dx, eax
    87 00000973 6681C20400          <1>     add dx, 4
    88 00000978 ED                  <1>     in eax, dx
    89 00000979 A900050000          <1>     test eax, 00000500h  ;Test bits 0 and 2 of nybble 3 have been zeroed
    90 0000097E 0F8568FFFFFF        <1>     jnz .u11    ;IF not, fail
    91                              <1> .ipeWriteTable:
    92                              <1> ;Now the controller and devices have been set to legacy, they should
    93                              <1> ; respond to the default IO addresses and IRQ. Save BAR 5 for Bus mastering.
    94 00000984 50                  <1>     push rax
    95 00000985 55                  <1>     push rbp
    96 00000986 48BD-               <1>     mov rbp, .ipemsg2
    96 00000988 [D409000000000000]  <1>
    97 00000990 66B80413            <1>     mov ax, 1304h
    98 00000994 CD30                <1>     int 30h
    99 00000996 5D                  <1>     pop rbp
   100 00000997 58                  <1>     pop rax
   101 00000998 89D8                <1>     mov eax, ebx    
   102 0000099A B020                <1>     mov al, 20h ;BAR4 Address
   103 0000099C 66BAF80C            <1>     mov dx, pci_index
   104 000009A0 EF                  <1>     out dx, eax
   105 000009A1 6681C20400          <1>     add dx, 4
   106 000009A6 ED                  <1>     in eax, dx  ;Get BAR 4 address
   107 000009A7 E8B5080000          <1>     call IDE.addControllerTable ;Function will not add if we maxed out controllers
   108 000009AC E93BFFFFFF          <1>     jmp .u11
   109 000009B1 0A0D49444520415441- <1> .ipemsg:    db 0Ah, 0Dh,"IDE ATA Controller found. Type: ", 0
   109 000009BA 20436F6E74726F6C6C- <1>
   109 000009C3 657220666F756E642E- <1>
   109 000009CC 20547970653A2000    <1>
   110 000009D4 0A0D49444520415441- <1> .ipemsg2:   db 0Ah, 0Dh, "IDE ATA Controller set to compatibility mode",0
   110 000009DD 20436F6E74726F6C6C- <1>
   110 000009E6 65722073657420746F- <1>
   110 000009EF 20636F6D7061746962- <1>
   110 000009F8 696C697479206D6F64- <1>
   110 00000A01 6500                <1>
   111                              <1> ;bp lo = status register, 
   112                              <1> ;bp hi = controller being serviced (ie 1000xxxx => xHCI being serviced)
   113                              <1> .uhci_found:
   114 00000A03 6681CD1100          <1>     or bp, 00010001b    ;set bit 0/mask = 1
   115 00000A08 55                  <1>     push rbp
   116 00000A09 50                  <1>     push rax
   117 00000A0A 53                  <1>     push rbx
   118 00000A0B 66B80413            <1>     mov ax, 1304h
   119 00000A0F 30FF                <1>     xor bh, bh
   120 00000A11 48BD-               <1>     mov rbp, .uhci_succ
   120 00000A13 [250A000000000000]  <1>
   121 00000A1B CD30                <1>     int 30h
   122 00000A1D 5B                  <1>     pop rbx
   123 00000A1E 58                  <1>     pop rax
   124 00000A1F 5D                  <1>     pop rbp
   125 00000A20 E9A6000000          <1>     jmp .controlController
   126 00000A25 0A0D5548434920636F- <1> .uhci_succ:    db    0Ah, 0Dh,'UHCI controller found on IRQ ', 0
   126 00000A2E 6E74726F6C6C657220- <1>
   126 00000A37 666F756E64206F6E20- <1>
   126 00000A40 4952512000          <1>
   127                              <1> .ohci_found:
   128 00000A45 6681CD2200          <1>     or bp, 00100010b    ;set bit 1/mask = 2
   129 00000A4A E99DFEFFFF          <1>     jmp .u11
   130                              <1> .ehci_found:
   131 00000A4F 6681CD4400          <1>     or bp, 01000100b    ;set bit 2/mask = 4
   132 00000A54 55                  <1>     push rbp
   133 00000A55 50                  <1>     push rax
   134 00000A56 53                  <1>     push rbx
   135 00000A57 66B80413            <1>     mov ax, 1304h
   136 00000A5B 30FF                <1>     xor bh, bh
   137 00000A5D 48BD-               <1>     mov rbp, .ehci_succ
   137 00000A5F [6E0A000000000000]  <1>
   138 00000A67 CD30                <1>     int 30h
   139 00000A69 5B                  <1>     pop rbx
   140 00000A6A 58                  <1>     pop rax
   141 00000A6B 5D                  <1>     pop rbp
   142 00000A6C EB5D                <1>     jmp short .controlController
   143 00000A6E 0A0D4548434920636F- <1> .ehci_succ:    db    0Ah, 0Dh,'EHCI controller found on IRQ ', 0
   143 00000A77 6E74726F6C6C657220- <1>
   143 00000A80 666F756E64206F6E20- <1>
   143 00000A89 4952512000          <1>
   144 00000A8E 0A0D7848434920636F- <1> .xhci_succ:    db    0Ah, 0Dh,'xHCI controller found on IRQ ', 0
   144 00000A97 6E74726F6C6C657220- <1>
   144 00000AA0 666F756E64206F6E20- <1>
   144 00000AA9 4952512000          <1>
   145                              <1> .xhci_found:
   146 00000AAE 55                  <1>     push rbp
   147 00000AAF 50                  <1>     push rax
   148 00000AB0 53                  <1>     push rbx
   149 00000AB1 66B80413            <1>     mov ax, 1304h
   150 00000AB5 30FF                <1>     xor bh, bh
   151 00000AB7 48BD-               <1>     mov rbp, .xhci_succ
   151 00000AB9 [8E0A000000000000]  <1>
   152 00000AC1 CD30                <1>     int 30h
   153 00000AC3 5B                  <1>     pop rbx
   154 00000AC4 58                  <1>     pop rax
   155 00000AC5 5D                  <1>     pop rbp
   156 00000AC6 6681CD8800          <1>     or bp, 10001000b    ;set bit 3/mask = 8
   157                              <1> 
   158                              <1> .controlController:
   159                              <1> ;This for now will get the IRQ line for all controllers,
   160                              <1> ;and install a USB handler there, then disabling the HC rather than just the 
   161                              <1> ;legacy support.
   162                              <1> ;EAX doesnt need to be saved since the first instruction of .u11 is to move the 
   163                              <1> ;value of ebx back into eax.
   164                              <1> ;EDX doesnt need to be saved since the port data gets loaded in the proc above
   165                              <1> ;DO NOT MODIFY EBX
   166 00000ACB 31D2                <1>     xor edx, edx
   167 00000ACD 89D8                <1>     mov eax, ebx    ;Move a copy of ebx, the PCI config space device address
   168 00000ACF B03C                <1>     mov al, 3Ch     ;offset 3C has interrupt masks in lower word
   169 00000AD1 66BAF80C            <1>     mov dx, pci_index
   170 00000AD5 EF                  <1>     out dx, eax       ;set to give interrupt masks
   171 00000AD6 66BAFC0C            <1>     mov dx, pci_data
   172 00000ADA ED                  <1>     in eax, dx        ;Get info into eax (formally, al)
   173 00000ADB 50                  <1>     push rax
   174 00000ADC 240F                <1>     and al, 0Fh
   175 00000ADE B404                <1>     mov ah, 04h
   176 00000AE0 CD30                <1>     int 30h
   177 00000AE2 58                  <1>     pop rax
   178 00000AE3 66F7C54000          <1>     test bp, 40h      ;Check if EHCI
   179 00000AE8 0F8490000000        <1>     jz .cc1           ;Skip mapping
   180 00000AEE 240F                <1>     and al, 0Fh       ;Clear upper nybble for good measure
   181 00000AF0 3C10                <1>     cmp al, 10h
   182 00000AF2 0F8786000000        <1>     ja .cc1           ;Cant map it
   183 00000AF8 3C08                <1>     cmp al, 08h        
   184 00000AFA 733E                <1>     jae .cc0
   185 00000AFC 56                  <1>     push rsi
   186 00000AFD 52                  <1>     push rdx
   187 00000AFE 50                  <1>     push rax
   188 00000AFF 53                  <1>     push rbx
   189 00000B00 480FB6F0            <1>     movzx rsi, al
   190 00000B04 81C620000000        <1>     add esi, 20h
   191 00000B0A 66BA008F            <1>     mov dx, 8F00h
   192 00000B0E 48B8-               <1>     mov rax, ehci_IRQ.pic1    ;PIC1 ep
   192 00000B10 [0F0B000000000000]  <1>
   193 00000B18 BB08000000          <1>     mov ebx, codedescriptor
   194 00000B1D E8(CB000000)        <1>     call idtWriteEntry
   195 00000B22 5B                  <1>     pop rbx
   196 00000B23 58                  <1>     pop rax
   197 00000B24 5A                  <1>     pop rdx
   198 00000B25 5E                  <1>     pop rsi
   199 00000B26 51                  <1>     push rcx
   200 00000B27 88C1                <1>     mov cl, al
   201 00000B29 B001                <1>     mov al, 1
   202 00000B2B D2E0                <1>     shl al, cl          ;Shift bit to appropriate position
   203 00000B2D F6D0                <1>     not al              ;Turn into a bitmask
   204 00000B2F 88C4                <1>     mov ah, al          ;Save in ah
   205 00000B31 E421                <1>     in al, pic1data
   206 00000B33 20E0                <1>     and al, ah          ;Add bitmask to current mask
   207 00000B35 E621                <1>     out pic1data, al    ;Unmask this line
   208 00000B37 59                  <1>     pop rcx
   209 00000B38 EB44                <1>     jmp short .cc1
   210                              <1> .cc0:
   211 00000B3A 56                  <1>     push rsi
   212 00000B3B 52                  <1>     push rdx
   213 00000B3C 50                  <1>     push rax
   214 00000B3D 53                  <1>     push rbx
   215 00000B3E 480FB6F0            <1>     movzx rsi, al
   216 00000B42 81C620000000        <1>     add esi, 20h    ;Start of PIC range
   217 00000B48 66BA008F            <1>     mov dx, 8F00h
   218 00000B4C 48B8-               <1>     mov rax, ehci_IRQ
   218 00000B4E [080B000000000000]  <1>
   219 00000B56 BB08000000          <1>     mov ebx, codedescriptor
   220 00000B5B E8(CB000000)        <1>     call idtWriteEntry
   221 00000B60 5B                  <1>     pop rbx
   222 00000B61 58                  <1>     pop rax
   223 00000B62 5A                  <1>     pop rdx
   224 00000B63 5E                  <1>     pop rsi
   225 00000B64 51                  <1>     push rcx
   226 00000B65 2C08                <1>     sub al, 8
   227 00000B67 88C1                <1>     mov cl, al
   228 00000B69 E421                <1>     in al, pic1data
   229 00000B6B 24FB                <1>     and al, 0FBh  ;Clear Cascade bit
   230 00000B6D E621                <1>     out pic1data, al
   231 00000B6F B001                <1>     mov al, 1
   232 00000B71 D2E0                <1>     shl al, cl    ;Shift bit to appropriate position
   233 00000B73 F6D0                <1>     not al        ;Turn into a bitmask
   234 00000B75 88C4                <1>     mov ah, al    ;Save in ah
   235 00000B77 E4A1                <1>     in al, pic2data
   236 00000B79 20E0                <1>     and al, ah    ;Add bitmask to current mask
   237 00000B7B E6A1                <1>     out pic2data, al    ;Unmask this line
   238 00000B7D 59                  <1>     pop rcx
   239                              <1> .cc1:
   240 00000B7E 89D8                <1>     mov eax, ebx    ;Bring back a copy of ebx, the PCI config space addr to eax
   241 00000B80 B010                <1>     mov al, 10h     ;Change the register from Class code to BAR0
   242                              <1>     
   243 00000B82 66BAF80C            <1>     mov dx, pci_index
   244 00000B86 EF                  <1>     out dx, eax        ;Set to give BAR0
   245 00000B87 66BAFC0C            <1>     mov dx, pci_data
   246 00000B8B ED                  <1>     in eax, dx        ;get unrefined BAR0/BASE pointer into eax
   247                              <1> 
   248 00000B8C 2500FFFFFF          <1>     and eax, 0FFFFFF00h    ;refine eax into an mmio register
   249 00000B91 50                  <1>     push rax    ;push BASE pointer onto stack
   250                              <1> 
   251                              <1> ;Write USB controller table:
   252                              <1> ;Each table entry (tword), as follows:
   253                              <1> ;Offset:
   254                              <1> ; 00h - hci type (bp) [word]
   255                              <1> ; 02h - PCI address (ebx) [dword]
   256                              <1> ; 06h - MMIO address (eax) [dword]
   257                              <1> ;ALL REGISTERS PRESERVED, data stored at usbtablebase, size at usbtablesize
   258 00000B92 56                  <1>     push rsi
   259 00000B93 51                  <1>     push rcx
   260 00000B94 0FB70C2500E00000    <1>     movzx ecx, word [lousbtablesize]    ;get number of table entries
   261 00000B9C 89CE                <1>     mov esi, ecx
   262 00000B9E D1E1                <1>     shl ecx, 1    ;Multiply by 2
   263 00000BA0 678DB4F102E00000    <1>     lea esi, [8*esi + ecx + lousbtablebase] 
   264                              <1>     ;multiply esi by 10 to get table offset & add to table base
   265                              <1>     ;store table offset back in esi
   266 00000BA8 6667892E            <1>     mov word [esi], bp    ;Store controller type
   267 00000BAC 81C602000000        <1>     add esi, 2
   268 00000BB2 67891E              <1>     mov dword [esi], ebx    
   269                              <1>         ;Store PCI device config space address (set to register 2)
   270 00000BB5 81C604000000        <1>     add esi, 4
   271 00000BBB 678906              <1>     mov dword [esi], eax    ;Store device MMIO Address (refined BAR0 value)
   272 00000BBE 59                  <1>     pop rcx
   273 00000BBF 5E                  <1>     pop rsi
   274 00000BC0 66FF042500E00000    <1>     inc word [lousbtablesize]
   275                              <1> 
   276 00000BC8 6681FD8000          <1>     cmp bp, 80h    ;Are we servicing xHCI, EHCI or UHCI?
   277 00000BCD 7D7A                <1>     jge .controlxHCI
   278 00000BCF 6681FD4000          <1>     cmp bp, 40h    ;Are we servicing EHCI or UHCI? 
   279 00000BD4 0F8DC9000000        <1>     jge .controlEHCI
   280                              <1> ;If neither of these, collapse into UHCI
   281                              <1> .controlUHCI:
   282                              <1> ;eax points to the refined base pointer
   283 00000BDA 53                  <1>     push rbx                    ;temp stack save 
   284 00000BDB 89D8                <1>     mov eax, ebx     ;get the current packed bus,device,function,register combo
   285 00000BDD 2500F8FFFF          <1>     and eax, 0FFFFF800h         ;Clear bottom 10 bytes.
   286 00000BE2 0DC0020000          <1>     or eax, 2C0h                ;Function 2, register offset C0h
   287                              <1> 
   288 00000BE7 50                  <1>     push rax                    ;temp save address value on stack
   289                              <1> 
   290 00000BE8 66BAF80C            <1>     mov dx, pci_index
   291 00000BEC EF                  <1>     out dx, eax
   292 00000BED 80C204              <1>     add dl, 4                   ;dx now points to pci_index
   293 00000BF0 ED                  <1>     in eax, dx                  ;Bring register value into eax
   294                              <1> 
   295 00000BF1 66B8008F            <1>     mov ax, 8F00h               ;Clear all SMI bits (no SMI pls)
   296 00000BF5 89C3                <1>     mov ebx, eax                ;save temporarily in ebx
   297                              <1> 
   298 00000BF7 58                  <1>     pop rax                     ;bring back address value from stack
   299                              <1> 
   300 00000BF8 80EA04              <1>     sub dl, 4                   ;put dx back to pci_index
   301 00000BFB EF                  <1>     out dx, eax                 ;select legsup register
   302                              <1> 
   303 00000BFC 80C204              <1>     add dl, 4                   ;aim dx back to pci_data
   304 00000BFF 89D8                <1>     mov eax, ebx                ;bring back new legsup value
   305 00000C01 EF                  <1>     out dx, eax                 ;send it back!
   306                              <1> 
   307                              <1> ;Now set bit 6 of the command register to 1 (semaphore)
   308 00000C02 5B                  <1>     pop rbx                     ;Return original ebx value
   309 00000C03 89D8                <1>     mov eax, ebx  ;Move a copy of ebx, PCI config space device address (index)
   310 00000C05 B020                <1>     mov al, 20h                 ;Change the register from Class code to BAR4 
   311 00000C07 6681EA0400          <1>     sub dx, 4                   ;Point dx back to pci_index
   312 00000C0C EF                  <1>     out dx, eax                 ;Get the data we want!
   313 00000C0D 6681C20400          <1>     add dx, 4
   314 00000C12 ED                  <1>     in eax, dx              ;Bring the value of BAR4 into eax, to add to BASE
   315 00000C13 25FCFFFFFF          <1>     and eax, 0FFFFFFFCh         ;Refine the IO address that we got
   316 00000C18 6689C2              <1>     mov dx, ax                  ;Mov the base IO address into dx
   317                              <1> ;dx contains the base io address!
   318 00000C1B 66B80200            <1>     mov ax, 0002h               ;Reset the HC
   319 00000C1F 66EF                <1>     out dx, ax
   320 00000C21 51                  <1>     push rcx
   321                              <1> .cu0:
   322 00000C22 4831C9              <1>     xor rcx, rcx
   323 00000C25 FEC9                <1>     dec cl
   324                              <1> .cu1:
   325 00000C27 E2FE                <1>     loop .cu1    ;wait
   326                              <1> 
   327 00000C29 66ED                <1>     in ax, dx    ;Bring value in
   328 00000C2B 66250200            <1>     and ax, 0002h
   329 00000C2F 75F1                <1>     jnz .cu0     ;Reset still in progress, loop again
   330 00000C31 59                  <1>     pop rcx
   331                              <1> 
   332 00000C32 6631C0              <1>     xor ax, ax
   333 00000C35 6681C20400          <1>     add dx, 4   ;point to USBINTR
   334 00000C3A 66EF                <1>     out dx, ax
   335 00000C3C 6681EA0400          <1>     sub dx, 4   ;return to cmd
   336 00000C41 66EF                <1>     out dx, ax  ;zero everything.
   337                              <1> 
   338 00000C43 58                  <1>     pop rax     ;Get BASE (dereferenced BAR0) value back (stack align)
   339 00000C44 E9A3FCFFFF          <1>     jmp .u11                     ;return
   340                              <1> ;End UHCI
   341                              <1> 
   342                              <1> .controlxHCI:
   343                              <1> ;mov HCCPARAMS1 into edx, eax contains BASE pointer from BAR0 (offset 10h for 
   344                              <1> ; register)
   345 00000C49 678B5010            <1>     mov edx, dword [eax + 10h]    
   346 00000C4D 81E20000FFFF        <1>     and edx, 0FFFF0000h
   347                              <1> ;mov hi word into lo word and shl by 2 to adjust that we are in units of DWORDS
   348 00000C53 C1EA0E              <1>     shr edx, 0Eh            
   349 00000C56 01D0                <1>     add eax, edx            ;add offset from base onto base
   350                              <1>                             ;eax now pointing at USBLEGSUP
   351                              <1> .suohoc0: 
   352 00000C58 678B10              <1>     mov edx, dword [eax]    ;store upper byte of USBLEGSUP into dl
   353 00000C5B 81CA00000001        <1>     or edx, (1<<24)         ;Set the HCOSSEM Semaphore
   354 00000C61 678910              <1>     mov dword [eax], edx    ;replace the upper byte with HCOSSEM set
   355                              <1> 
   356 00000C64 51                  <1>     push rcx                ;push poll counter
   357 00000C65 4831C9              <1>     xor rcx, rcx            
   358                              <1> .suohoc1:    ;Remove control from BIOS and check for confirmation
   359 00000C68 66FFC9              <1>     dec cx                  ;drop counter by one
   360 00000C6B 0F84DE000000        <1>     jz .weirdEHCI1          ;temporary label
   361 00000C71 F390                <1>     pause                   ;wait
   362 00000C73 678B10              <1>     mov edx, dword [eax]    ;Check if owned by BIOS
   363 00000C76 81E200000100        <1>     and edx, (1<<16)
   364 00000C7C 75EA                <1>     jnz .suohoc1            ;not zero, keep polling
   365                              <1> 
   366 00000C7E 66B9FFFF            <1>     mov cx, 0FFFFh
   367                              <1> .suohoc2:    ;Check if control to OS has been given
   368 00000C82 66FFC9              <1>     dec cx
   369 00000C85 740D                <1>     jz .suohoc21            ;timeout, assume it has.
   370 00000C87 F390                <1>     pause                
   371 00000C89 678B10              <1>     mov edx, dword [eax]
   372 00000C8C 81E200000001        <1>     and edx, (1<<24)
   373 00000C92 74EE                <1>     jz .suohoc2             ;if zero, keep polling until bit set => owned by OS
   374                              <1> .suohoc21:    ;Check for legsup being present, assume for now.
   375 00000C94 59                  <1>     pop rcx                   ;return poll counter
   376                              <1> .suohoc3:
   377 00000C95 67C7400400000000    <1>     mov dword [eax + 4], 0    ;Set all SMI bytes to 0 so no SMIs will be set.
   378 00000C9D 58                  <1>     pop rax                   ;Bring back BAR0 into eax
   379 00000C9E E949FCFFFF          <1>     jmp .u11                  ;return
   380                              <1> 
   381                              <1> .controlEHCI:
   382 00000CA3 678B5008            <1>     mov edx, dword [eax + 8h]
   383 00000CA7 81E200FF0000        <1>     and edx, 0000FF00h
   384 00000CAD 66C1EA08            <1>     shr dx, 8
   385 00000CB1 81FA40000000        <1>     cmp edx, 40h        
   386 00000CB7 7C05                <1>     jl .ce0            ;No EECP pointer present, skip BIOS/OS EHCI handover
   387 00000CB9 E81B000000          <1>     call .ehcieecpsetup
   388                              <1> .ce0:
   389 00000CBE 31D2                <1>     xor edx, edx       ;clear edx
   390 00000CC0 58                  <1>     pop rax            ;Bring back refined base into eax
   391 00000CC1 678B10              <1>     mov edx, dword [eax]
   392 00000CC4 81E2FF000000        <1>     and edx, 000000FFh
   393 00000CCA 01D0                <1>     add eax, edx
   394 00000CCC 67816040FEFFFFFF    <1>     and dword [eax + 40h], 0FFFFFFFEh
   395                              <1>                             ;located at offset 40 of the opregs.
   396                              <1> 
   397 00000CD4 E913FCFFFF          <1>     jmp .u11                ;return
   398                              <1> .ehcieecpsetup:
   399                              <1> ;eax has hccparams
   400                              <1> ;ebx has pci register, to get class code
   401 00000CD9 50                  <1>     push rax
   402 00000CDA 52                  <1>     push rdx
   403 00000CDB 53                  <1>     push rbx
   404 00000CDC 51                  <1>     push rcx
   405 00000CDD 88D3                <1>     mov bl, dl       ;Move EECP pointer into low byte of PCI address
   406 00000CDF 89D8                <1>     mov eax, ebx     ;Move this address to eax
   407 00000CE1 66BAF80C            <1>     mov dx, pci_index
   408 00000CE5 EF                  <1>     out dx, eax      ;Return EHCI EECP register
   409 00000CE6 66BAFC0C            <1>     mov dx, pci_data
   410 00000CEA ED                  <1>     in eax, dx       ;Get this register into eax
   411 00000CEB 0D00000001          <1>     or eax, 1000000h ;Set bit 24, to tell bios to give up control!
   412 00000CF0 93                  <1>     xchg eax, ebx    ;Swap these two temporarily
   413 00000CF1 66BAF80C            <1>     mov dx, pci_index
   414 00000CF5 EF                  <1>     out dx, eax
   415 00000CF6 93                  <1>     xchg eax, ebx    ;Bring back out value to eax
   416 00000CF7 66BAFC0C            <1>     mov dx, pci_data
   417 00000CFB EF                  <1>     out dx, eax      ;Tell BIOS who is boss of the EHCI controller
   418                              <1>     
   419 00000CFC 4831C9              <1>     xor rcx, rcx
   420 00000CFF 89D8                <1>     mov eax, ebx     ;Get address back into eax
   421                              <1> .ees1:
   422 00000D01 66FFC9              <1>     dec cx
   423 00000D04 7449                <1>     jz .weirdEHCI1
   424 00000D06 E680                <1>     out waitp, al    ;Wait a bit, for device to process request
   425                              <1> 
   426 00000D08 66BAF80C            <1>     mov dx, pci_index
   427 00000D0C EF                  <1>     out dx, eax
   428 00000D0D 66BAFC0C            <1>     mov dx, pci_data
   429 00000D11 ED                  <1>     in eax, dx       ;Get word back into eax
   430 00000D12 2500000100          <1>     and eax, 10000h  ;BIOS should set this bit to zero
   431 00000D17 75E8                <1>     jnz .ees1        ;Not zero yet, try again!
   432                              <1> 
   433 00000D19 4831C9              <1>     xor rcx, rcx
   434 00000D1C 89D8                <1>     mov eax, ebx    ;Get address back into eax    
   435                              <1> .ees2:
   436 00000D1E 66FFC9              <1>     dec cx
   437 00000D21 742C                <1>     jz .weirdEHCI1
   438 00000D23 E680                <1>     out waitp, al    ;Wait a bit, for device to process request
   439                              <1> 
   440 00000D25 66BAF80C            <1>     mov dx, pci_index
   441 00000D29 EF                  <1>     out dx, eax
   442 00000D2A 66BAFC0C            <1>     mov dx, pci_data
   443 00000D2E ED                  <1>     in eax, dx        ;Get word back into eax
   444 00000D2F 2500000001          <1>     and eax, 1000000h    ;This should set this bit to one now (OS control)
   445 00000D34 74E8                <1>     jz .ees2        ;Not set yet, try again!
   446                              <1> ;Now we have control! :D Finally, now lets clear SMI bits
   447 00000D36 81C304000000        <1>     add ebx, 4h
   448 00000D3C 89D8                <1>     mov eax, ebx
   449 00000D3E 66BAF80C            <1>     mov dx, pci_index
   450 00000D42 EF                  <1>     out dx, eax
   451 00000D43 31C0                <1>     xor eax, eax
   452 00000D45 66BAFC0C            <1>     mov dx, pci_data
   453 00000D49 EF                  <1>     out dx, eax        ;NO MORE SMI INTERRUPTS
   454                              <1> 
   455 00000D4A 59                  <1>     pop rcx
   456 00000D4B 5B                  <1>     pop rbx
   457 00000D4C 5A                  <1>     pop rdx
   458 00000D4D 58                  <1>     pop rax
   459 00000D4E C3                  <1>     ret
   460                              <1> 
   461                              <1> .weirdEHCI1:
   462 00000D4F 48B804130000000000- <1>     mov rax, 1304h
   462 00000D58 00                  <1>
   463 00000D59 48BB07000000000000- <1>     mov rbx, 0007h
   463 00000D62 00                  <1>
   464 00000D63 48B931000000000000- <1>     mov rcx, failmsglen
   464 00000D6C 00                  <1>
   465 00000D6D 48BD-               <1>     mov rbp, .failmsg
   465 00000D6F [7C0D000000000000]  <1>
   466 00000D77 CD30                <1>     int 30h    ; write strng
   467 00000D79 F390                <1>     pause
   468 00000D7B F4                  <1>     hlt
   469 00000D7C 0A0D78484349206F72- <1> .failmsg: db 0Ah,0Dh,"xHCI or EHCI controller fail, halting system", 0Ah, 0Dh, 0
   469 00000D85 204548434920636F6E- <1>
   469 00000D8E 74726F6C6C65722066- <1>
   469 00000D97 61696C2C2068616C74- <1>
   469 00000DA0 696E67207379737465- <1>
   469 00000DA9 6D0A0D00            <1>
   470                              <1> failmsglen    equ    $ - .failmsg
   471                              <1> 
   472                              <1> pciExit:
   473                              <1> ;----------------------------------------------------------------
   474                              <1> ;                            End Proc                           :
   475                              <1> ;----------------------------------------------------------------
    55                                  %include "./Source/Init/Hardware/Timers/pitinit.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                PIT Initialisation procedure                   :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> PITreset:       ;Set Timer 0 to trigger every 55ms
     5 00000DAD B036                <1>     mov al, 36h    ;Set bitmap for frequency write to channel 0 of pit
     6 00000DAF E643                <1>     out PITcommand, al    ;43h = PIT command register
     7 00000DB1 668B0425[35010000]  <1>     mov ax, word [pit_divisor]
     8 00000DB9 E640                <1>     out PIT0, al    ;mov low byte into divisor register
     9 00000DBB 88E0                <1>     mov al, ah      ;bring hi byte into low byte
    10 00000DBD E640                <1>     out PIT0, al    ;mov hi byte into divisor register
    11                              <1> ;PIT unmasked below
    12                              <1> ;----------------------------------------------------------------
    13                              <1> ;                     End of Initialisation                     :
    14                              <1> ;----------------------------------------------------------------
    56                                  %include "./Source/Init/Hardware/Timers/rtcinit.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                RTC Initialisation procedure                   :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> rtc_init:
     5                              <1> ;Set tick rate to 1024Hz and ensure RTC doesnt generate IRQ8
     6 00000DBF 66B88A8A            <1>     mov ax, 8A8Ah    ;Status A register with NMI disable
     7 00000DC3 E670                <1>     out cmos_base, al
     8 00000DC5 E680                <1>     out waitp, al    ;Latch wait
     9 00000DC7 EB00                <1>     jmp short $+2
    10 00000DC9 B026                <1>     mov al, 00100110b ;32KHz timebase, 1024Hz square wave output
    11 00000DCB E671                <1>     out cmos_data, al
    12                              <1> ;Now ensure NO interrupts are cooked
    13 00000DCD FEC4                <1>     inc ah    ;ah=8Bh
    14 00000DCF 88E0                <1>     mov al, ah
    15 00000DD1 E670                <1>     out cmos_base, al
    16 00000DD3 E680                <1>     out waitp, al  ;Latch wait
    17 00000DD5 EB00                <1>     jmp short $+2
    18 00000DD7 B002                <1>     mov al, 02h    ;Zero all int bits, time: BCD, 24hr, Daylight saving off
    19 00000DD9 E671                <1>     out cmos_data, al
    20                              <1> ;Clear any cooked IRQs
    21 00000DDB FEC4                <1>     inc ah    ;ah=8Ch
    22 00000DDD 88E0                <1>     mov al, ah
    23 00000DDF E670                <1>     out cmos_base, al
    24 00000DE1 E680                <1>     out waitp, al    ;Latch wait
    25 00000DE3 EB00                <1>     jmp short $+2
    26 00000DE5 E471                <1>     in al, cmos_data
    27                              <1> ;Get final CMOS RAM status byte
    28 00000DE7 B00D                <1>     mov al, 0Dh     ;Status D register with NMI enable
    29 00000DE9 E670                <1>     out cmos_base, al
    30 00000DEB E680                <1>     out waitp, al    ;Latch wait
    31 00000DED EB00                <1>     jmp short $+2
    32 00000DEF E471                <1>     in al, cmos_data
    33                              <1> ;Unmask RTC and PIT here!
    34 00000DF1 E4A1                <1>     in al, pic2data    ;Get current state
    35 00000DF3 24FE                <1>     and al, 0FEh    ;Unmask RTC
    36 00000DF5 E6A1                <1>     out pic2data, al
    37 00000DF7 E421                <1>     in al, pic1data
    38 00000DF9 24FA                <1>     and al, 0FAh    ;Unmask PIT and Cascade
    39 00000DFB E621                <1>     out pic1data, al
    40 00000DFD FB                  <1>     sti             ;Enable maskable interrupts
    41                              <1> ;----------------------------------------------------------------
    42                              <1> ;                     End of Initialisation                     :
    43                              <1> ;----------------------------------------------------------------
    57                                  %include "./Source/Init/Hardware/Timers/beepOK.asm"
     1                              <1>     ;This is a short routine to just confirm 
     2                              <1>     ;that the timer initialisation worked fine
     3 00000DFE 48B9C8000000000000- <1>     mov rcx, 200    ;Beep for a 200ms
     3 00000E07 00                  <1>
     4 00000E08 BBA9040000          <1>     mov ebx, 04A9h  ;Frequency divisor for 1000Hz tone
     5 00000E0D 66B800C5            <1>     mov ax, 0C500h
     6 00000E11 CD35                <1>     int 35h
    58                                  %include "./Source/Init/Hardware/Serial/rs232ini.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                Serial Port Initialisation procedure           :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> ;Initial init procedure, check which ports exist and 
     5                              <1> ; write the address to Data area
     6 00000E13 66B85A5A            <1>     mov ax, 5A5Ah
     7 00000E17 4831C9              <1>     xor rcx, rcx
     8 00000E1A 48BD-               <1>     mov rbp, com_addresses
     8 00000E1C [6700000000000000]  <1>
     9                              <1> checkCOM:
    10 00000E24 668B9409[7E1D0000]  <1>     mov dx, word [serial_abt + rcx*2]    ;Multiplied by 2 for word offsets
    11 00000E2C 6681C20700          <1>     add dx, 7    ;Scratch register
    12 00000E31 EE                  <1>     out dx, al    ;Output
    13 00000E32 EB00                <1>     jmp short $ + 2
    14 00000E34 EC                  <1>     in al, dx    ;Read the value
    15 00000E35 38C4                <1>     cmp ah, al   ;Check if theyre the same 
    16 00000E37 7514                <1>     jne COMinitproceed ;Scratch register non-existant, IO registers not present
    17 00000E39 6681EA0700          <1>     sub dx, 7    ;point dx back to base
    18 00000E3E 66899409[67000000]  <1>     mov word [com_addresses + rcx*2], dx    ;Save dx into data area table
    19 00000E46 FEC1                <1>     inc cl
    20 00000E48 80F904              <1>     cmp cl, 4
    21 00000E4B 75D7                <1>     jne checkCOM    ;Keep looping
    22                              <1> COMinitproceed:
    23                              <1> ;Sets all active COM ports to 2400,N,8,1, FIFO on, hware handshaking
    24 00000E4D 880C25[66000000]    <1>     mov byte [numCOM], cl
    25 00000E54 30C9                <1>     xor cl, cl
    26                              <1> serialinit:
    27 00000E56 668B9409[67000000]  <1>     mov dx, word [com_addresses + rcx*2]  ;get the serial port base addr in dx
    28 00000E5E 6685D2              <1>     test dx, dx
    29 00000E61 743E                <1>     jz COMinitexit    ;invalid address, port doesnt exist, init complete
    30                              <1> ;Disable interrupts
    31 00000E63 66FFC2              <1>     inc dx        ;point at base + 1
    32 00000E66 30C0                <1>     xor al, al    ;get zero to out it to the interrupt register
    33 00000E68 EE                  <1>     out dx, al    ;Disable all interrupts
    34                              <1> ;Set DLAB
    35 00000E69 6681C20200          <1>     add dx, 2    ;point dx to the Line Control register (LCR)
    36 00000E6E EC                  <1>     in al, dx    ;get the LCR byte into al
    37 00000E6F 0C80                <1>     or al, 10000000b    ;set bit 7, DLAB bit on
    38 00000E71 EE                  <1>     out dx, al    ;output the set bit
    39                              <1> ;Set baud rate
    40 00000E72 6681EA0300          <1>     sub dx, 3    ;word of baud divisor
    41 00000E77 66B83000            <1>     mov ax, 0030h    ;the divisor for 2400 baud (cf table below)
    42 00000E7B 66EF                <1>     out dx, ax    ;out put the divisor word
    43                              <1> ;Clear DLAB, set the parity, break stop and word length
    44 00000E7D 6681C20300          <1>     add dx, 3    ;repoint at LCR (base + 3)
    45 00000E82 B003                <1>     mov al, 00000011b  ;DLAB off, 8,n,1, no break, no stick
    46 00000E84 EE                  <1>     out dx, al    ;out that byte
    47                              <1> ;Clear FIFO
    48 00000E85 66FFCA              <1>     dec dx        ;base + 2, FIFO register
    49 00000E88 B006                <1>     mov al, 00000110b    ;Clear FIFO, set char mode
    50 00000E8A EE                  <1>     out dx, al    ;out that stuff
    51                              <1> ;Enable interrupts and RTS/DTR
    52 00000E8B 66FFCA              <1>     dec dx        ;base + 1, Interrupt Enable Register
    53 00000E8E B001                <1>     mov al, 1     ;ONLY set the data receive interrupt, none of the other 
    54                              <1>                   ; status or transmit type interrupts
    55 00000E90 EE                  <1>     out dx, al
    56                              <1> 
    57 00000E91 6681C20300          <1>     add dx, 3    ;base + 4, Modem control register
    58 00000E96 EC                  <1>     in al, dx    ;preserve reserved upper bits
    59 00000E97 24E0                <1>     and al, 11100000b
    60 00000E99 0C0B                <1>     or al, 00001011b    ;Set OUT2 (ie IRQ enable), set RTS/DTR.
    61 00000E9B EE                  <1>     out dx, al
    62 00000E9C 66FFC1              <1>     inc cx
    63 00000E9F EBB5                <1>     jmp short serialinit
    64                              <1> COMinitexit:
    65                              <1> ;Unmask com ports here!
    66 00000EA1 E421                <1>     in al, pic1data
    67 00000EA3 24E7                <1>     and al, 0E7h    ;Unmask Com lines 1 and 2 (bits 3 and 4)
    68 00000EA5 E621                <1>     out pic1data, al
    69                              <1> ;----------------------------------------------------------------
    70                              <1> ;                     End of Initialisation                     :
    71                              <1> ;----------------------------------------------------------------
    59                                  %include "./Source/Init/Hardware/PS2/ps2init.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;             PS/2 Keyboard Initialisation procedure            :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> keybsetup:
     5 00000EA7 48BD-               <1>     mov rbp, ps2Str.startMsg
     5 00000EA9 [5810000000000000]  <1>
     6 00000EB1 48B804130000000000- <1>     mov rax, 1304h    ;print 0 terminated string
     6 00000EBA 00                  <1>
     7 00000EBB 30FF                <1>     xor bh, bh
     8 00000EBD CD30                <1>     int 30h
     9                              <1> ;----------------------------------------------------------------
    10                              <1> ;Do all writes using ps2talk:
    11                              <1> ;    .rStat - Read Status port into al
    12                              <1> ;    .rDat - Read Data port into al
    13                              <1> ;    .wCmd - Write al into Command port 
    14                              <1> ;    .wDat - Write al into Data port
    15                              <1> ;----------------------------------------------------------------
    16                              <1> ;Step 1
    17 00000EBF B0AD                <1>     mov al, 0ADh
    18 00000EC1 E865010000          <1>     call ps2talk.wCmd
    19 00000EC6 B0A7                <1>     mov al, 0A7h        ;Cancel second interface if it exists (DO NOT REENABLE)
    20 00000EC8 E85E010000          <1>     call ps2talk.wCmd
    21                              <1> ;Step 2
    22 00000ECD B110                <1>     mov cl, 10h
    23                              <1> initFlush:
    24 00000ECF E460                <1>     in al, ps2data     ;manually flush ps2data port
    25 00000ED1 FEC9                <1>     dec cl
    26 00000ED3 75FA                <1>     jnz initFlush
    27                              <1> ;Step 3
    28                              <1> keyb0:
    29 00000ED5 B020                <1>     mov al, 20h
    30 00000ED7 E84F010000          <1>     call ps2talk.wCmd    ;out ps2command, al
    31 00000EDC E83D010000          <1>     call ps2talk.rDat    ;Read config byte into al
    32                              <1> ;Step 4
    33 00000EE1 88C3                <1>     mov bl, al        ;copy al into bl to check for bit 2
    34 00000EE3 80E3BC              <1>     and bl, 0BCh      ;Disable translation, enable later
    35                              <1> ;Step 5
    36 00000EE6 B060                <1>     mov al, 60h
    37 00000EE8 E83E010000          <1>     call ps2talk.wCmd    ;Write config byte command
    38 00000EED 88D8                <1>     mov al, bl
    39 00000EEF E83F010000          <1>     call ps2talk.wDat    ;Out new config byte
    40                              <1> ;Step 6
    41 00000EF4 B0AA                <1>     mov al, 0AAh ;Can reset the config byte, out bl to ps2data at end of stage
    42 00000EF6 E830010000          <1>     call ps2talk.wCmd
    43 00000EFB E81E010000          <1>     call ps2talk.rDat
    44 00000F00 3C55                <1>     cmp al, 55h
    45 00000F02 0F8533010000        <1>     jne ps2error
    46                              <1>     
    47 00000F08 B060                <1>     mov al, 60h  ;Previous code may have reset our new config byte, resend it!
    48 00000F0A E81C010000          <1>     call ps2talk.wCmd            ;Write config byte command
    49 00000F0F 88D8                <1>     mov al, bl
    50 00000F11 E81D010000          <1>     call ps2talk.wDat            ;Out new config byte
    51                              <1> ;Step 7
    52 00000F16 B0AB                <1>     mov al, 0ABh            ;Test port 1
    53 00000F18 E80E010000          <1>     call ps2talk.wCmd
    54 00000F1D E8FC000000          <1>     call ps2talk.rDat
    55 00000F22 84C0                <1>     test al, al             ;Check al is zero
    56 00000F24 0F8511010000        <1>     jnz ps2error
    57                              <1> ;Step 8
    58 00000F2A B0AE                <1>     mov al, 0AEh            ;Enable port 1
    59 00000F2C E8FA000000          <1>     call ps2talk.wCmd
    60                              <1> ;Step 9
    61 00000F31 31C9                <1>     xor ecx, ecx
    62                              <1> keyb1:
    63 00000F33 FEC9                <1>     dec cl ;timeout counter
    64 00000F35 0F8400010000        <1>     jz ps2error
    65 00000F3B B0FF                <1>     mov al, 0FFh        ;Reset device
    66 00000F3D E8F1000000          <1>     call ps2talk.wDat
    67                              <1> .k1:
    68 00000F42 E8D7000000          <1>     call ps2talk.rDat   ;read from ps2data
    69 00000F47 3CFA                <1>     cmp al, 0FAh
    70 00000F49 75E8                <1>     jne keyb1           ;If not ACK, restart the process
    71 00000F4B E8CE000000          <1>     call ps2talk.rDat   ;Now read operation status 
    72 00000F50 3CAA                <1>     cmp al, 0AAh        
    73 00000F52 75DF                <1>     jne keyb1           ;If not success, restart the whole process
    74                              <1>     
    75                              <1> ;Step 10
    76                              <1> keyb2:
    77 00000F54 B0EE                <1>     mov al, 0EEh     ;Echo command
    78 00000F56 E8D8000000          <1>     call ps2talk.wDat
    79 00000F5B 30C0                <1>     xor al, al       ;Zero al to ensure that the result is EEh
    80                              <1> .k1:
    81 00000F5D E8BC000000          <1>     call ps2talk.rDat
    82 00000F62 3CEE                <1>     cmp al, 0EEh
    83 00000F64 7410                <1>     je keyb3           ;If equal, continue
    84 00000F66 488D2C25[46100000]  <1>     lea rbp, ps2Str.noecho
    85 00000F6E 66B80413            <1>     mov ax, 1304h
    86 00000F72 30FF                <1>     xor bh, bh
    87 00000F74 CD30                <1>     int 30h
    88                              <1> 
    89                              <1> keyb3:    ;Set typematic rate/delay, 250ms, 30 reports/second
    90 00000F76 B0F3                <1>     mov al, 0F3h     ;Set typematic rate
    91 00000F78 E8B6000000          <1>     call ps2talk.wDat
    92 00000F7D E89C000000          <1>     call ps2talk.rDat
    93 00000F82 30C0                <1>     xor al, al       ;Set rate
    94 00000F84 E8AA000000          <1>     call ps2talk.wDat
    95 00000F89 30C9                <1>     xor cl, cl
    96                              <1> .k1:
    97 00000F8B FEC9                <1>     dec cl
    98 00000F8D 0F84A8000000        <1>     jz ps2error
    99 00000F93 E886000000          <1>     call ps2talk.rDat
   100 00000F98 3CFA                <1>     cmp al, 0FAh    ;Ack?
   101 00000F9A 75EF                <1>     jnz .k1
   102                              <1> 
   103                              <1> keyb4:      ;Set scancode 2
   104 00000F9C B1FF                <1>     mov cl, -1
   105 00000F9E B302                <1>     mov bl, 2   ;Scancode 2
   106                              <1> .k1:
   107 00000FA0 FEC9                <1>     dec cl
   108 00000FA2 0F8493000000        <1>     jz ps2error
   109 00000FA8 B0F0                <1>     mov al, 0F0h    ;Scancode command
   110 00000FAA E884000000          <1>     call ps2talk.wDat
   111 00000FAF E86A000000          <1>     call ps2talk.rDat
   112 00000FB4 3CFA                <1>     cmp al, 0FAh    ;Ack?
   113 00000FB6 75E8                <1>     jne .k1
   114                              <1> 
   115 00000FB8 B1FF                <1>     mov cl, -1
   116                              <1> .k2:
   117 00000FBA FEC9                <1>     dec cl
   118 00000FBC 747D                <1>     jz ps2error
   119 00000FBE 88D8                <1>     mov al, bl  ;Get scancode set into al
   120 00000FC0 E86E000000          <1>     call ps2talk.wDat
   121 00000FC5 E854000000          <1>     call ps2talk.rDat
   122 00000FCA 3CFA                <1>     cmp al, 0FAh    ;Ack?   
   123 00000FCC 75D2                <1>     jne .k1 ;Restart the whole process
   124                              <1> 
   125 00000FCE B1FF                <1>     mov cl, -1
   126                              <1> keyb5:
   127                              <1> ;Enable the keyboard to transmit scancodes
   128 00000FD0 FEC9                <1>     dec cl
   129 00000FD2 7467                <1>     jz ps2error
   130 00000FD4 B0F4                <1>     mov al, 0F4h    ;Enable scanning
   131 00000FD6 E858000000          <1>     call ps2talk.wDat
   132 00000FDB E83E000000          <1>     call ps2talk.rDat
   133 00000FE0 3CFA                <1>     cmp al, 0FAh    ;Ack?
   134 00000FE2 75EC                <1>     jne keyb5
   135                              <1> 
   136                              <1> keybinitend:
   137                              <1> ;Enable scancode translation and enable Interrupts on port 1
   138 00000FE4 B020                <1>     mov al, 20h      ;Get command byte from command port
   139 00000FE6 E840000000          <1>     call ps2talk.wCmd  ;al should contain command byte
   140 00000FEB E82E000000          <1>     call ps2talk.rDat
   141 00000FF0 88C4                <1>     mov ah, al       ;temp save cmd byte in ah
   142                              <1>     ;Set translate bit on and set scancode 2
   143 00000FF2 80CC41              <1>     or ah, 41h  ;Set translate on and IRQ on port 1 on
   144 00000FF5 80E4EF              <1>     and ah, 0EFh    ;Clear bit 4, to set port clock on
   145 00000FF8 B060                <1>     mov al, 60h
   146 00000FFA E82C000000          <1>     call ps2talk.wCmd
   147 00000FFF 88E0                <1>     mov al, ah  ;Move command with bit set into al
   148 00001001 E82D000000          <1>     call ps2talk.wDat   ;And send
   149                              <1> 
   150                              <1> ;Unmask IRQ1 here
   151 00001006 E421                <1>     in al, pic1data
   152 00001008 24FD                <1>     and al, 0FDh    ;Unmask bit 1
   153 0000100A E621                <1>     out pic1data, al
   154                              <1> ;Now keep looping until the keyboard buffer is empty
   155                              <1> .cleanBuffer:
   156 0000100C B401                <1>     mov ah, 01
   157 0000100E CD36                <1>     int 36h
   158 00001010 745F                <1>     jz endPS2Init
   159 00001012 30E4                <1>     xor ah, ah
   160 00001014 CD36                <1>     int 36h
   161 00001016 E9F1FFFFFF          <1>     jmp .cleanBuffer
   162                              <1> ;Relevant Procs for PS/2 keyboard setup
   163                              <1> ps2talk:
   164                              <1> ;    .rStat - Read Status port into al
   165                              <1> ;    .rDat - Read Data port into al
   166                              <1> ;    .wCmd - Write al into Command port 
   167                              <1> ;    .wDat - Write al into Data port
   168                              <1> .rStat:
   169 0000101B E464                <1>     in al, ps2status
   170 0000101D C3                  <1>     ret
   171                              <1> .rDat:
   172 0000101E EB00                <1>     jmp short $ + 2
   173 00001020 E464                <1>     in al, ps2status
   174 00001022 A801                <1>     test al, 1    ;Can something be read from KB?
   175 00001024 74F8                <1>     jz .rDat        ;Zero if no. Not zero = read.
   176 00001026 EB00                <1>     jmp short $ + 2
   177 00001028 E460                <1>     in al, ps2data  ;Read it in
   178 0000102A C3                  <1>     ret
   179                              <1> .wCmd:
   180 0000102B E8(B6000000)        <1>     call ps2wait    ;preserves ax
   181 00001030 E664                <1>     out ps2command, al
   182 00001032 C3                  <1>     ret
   183                              <1> .wDat:
   184 00001033 E8(B6000000)        <1>     call ps2wait
   185 00001038 E660                <1>     out ps2data, al
   186 0000103A C3                  <1>     ret
   187                              <1> ps2error:
   188 0000103B B0FF                <1>     mov al, -1  ;MASK IRQ lines if error
   189 0000103D E621                <1>     out pic1data, al
   190 0000103F E6A1                <1>     out pic2data, al
   191 00001041 F390                <1>     pause
   192 00001043 F4                  <1>     hlt
   193 00001044 EBF5                <1>     jmp short ps2error
   194                              <1> ps2Str:
   195 00001046 4E6F204563686F2072- <1> .noecho  db "No Echo recieved ", 0
   195 0000104F 656369657665642000  <1>
   196 00001058 0A0D50532F32204B65- <1> .startMsg db 0Ah, 0Dh,'PS/2 Keyboard... ',0 
   196 00001061 79626F6172642E2E2E- <1>
   196 0000106A 2000                <1>
   197 0000106C 4F4B0A0D00          <1> .okMsg  db "OK",0Ah,0Dh,0
   198                              <1> endPS2Init:
   199 00001071 48BD-               <1>     mov rbp, ps2Str.okMsg
   199 00001073 [6C10000000000000]  <1>
   200 0000107B 48B804130000000000- <1>     mov rax, 1304h    ;print 0 terminated string
   200 00001084 00                  <1>
   201 00001085 30FF                <1>     xor bh, bh
   202 00001087 CD30                <1>     int 30h
   203                              <1> ;----------------------------------------------------------------
   204                              <1> ;                      End of Initialisation                    :
   205                              <1> ;----------------------------------------------------------------
    60                                  %include "./Source/Sysdebug/init.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;              Debugger Initialisation procedures               :
     3                              <1> ;----------------------------------------------------------------
     4                              <1> debuggerInit:
     5                              <1> ;Int 40h can be used by the Debugger to return to it or if a DOS present, 
     6                              <1> ; to return to DOS.
     7 00001089 48B8-               <1>     mov rax, MCP_int ;The application return point
     7 0000108B [9E23000000000000]  <1>
     8 00001093 48BE40000000000000- <1>     mov rsi, 40h
     8 0000109C 00                  <1>
     9 0000109D 66BA008F            <1>     mov dx, 8F00h    ;Attribs
    10 000010A1 BB08000000          <1>     mov ebx, codedescriptor
    11 000010A6 E8(CB000000)        <1>     call idtWriteEntry    
    61                                  ;----------------------------------------------------------------
    62                                  ;              Drive Enum and Initialisation procedures         :
    63                                  ;----------------------------------------------------------------
    64                                  %include "./Source/Init/Hardware/IDE/ideinit.asm"
     1                              <1> 
     2                              <1> IDE:
     3                              <1> .ideInitialisation:
     4                              <1> ;Check primary and secondary bus for master and slave drives
     5                              <1> ; Maximum of 4 "fixed" ATA drives
     6                              <1> ;Due to being in compatibility mode, they respond to 
     7                              <1> ; default addresses.
     8                              <1> ;By default BIOS numbers will be assigned as follows: 
     9                              <1> ;               80h = Ctrlr 1, Master
    10                              <1> ;               81h = Ctrlr 1, Slave
    11                              <1> ;               82h = Ctrlr 2, Master
    12                              <1> ;               83h = Ctrlr 2, Slave
    13                              <1> 
    14                              <1> ;To make algorithm work, set ataXCmdByte to 1
    15 000010AB C60425[AB010000]01  <1>     mov byte [ata0CmdByte], 1
    16 000010B3 C60425[AD010000]01  <1>     mov byte [ata1CmdByte], 1
    17                              <1> 
    18                              <1> ;Here, consider resetting drives on both channels
    19                              <1>     ;ATA Channel 0 Master
    20 000010BB 488D1C25[6C030000]  <1>     lea rbx, fdiskTbl
    21 000010C3 B0A0                <1>     mov al, 0A0h
    22 000010C5 88C4                <1>     mov ah, al  ;Save in ah
    23 000010C7 BAF0010000          <1>     mov edx, ata0_base
    24 000010CC E8(3E350000)        <1>     call ATA.selectDrive    ;Ignore status for master
    25 000010D1 88E0                <1>     mov al, ah  ;Bring back
    26 000010D3 7205                <1>     jc .ii0    ;If Master failed to select, ignore trying to identify it
    27 000010D5 E879000000          <1>     call .identifyDrive ;Master ata0
    28                              <1> .ii0:
    29                              <1>     ;ATA Channel 0 Slave
    30 000010DA 4881C316000000      <1>     add rbx, fdiskTblEntry_size
    31 000010E1 0C10                <1>     or al, 10h ;Change from A0h to B0h
    32 000010E3 88C4                <1>     mov ah, al
    33 000010E5 E8(3E350000)        <1>     call ATA.selectDrive ;Master should set slave status to 0 if non-existent
    34 000010EA 7302                <1>     jnc .ii1   ;If slave successfully was selected, skip the next line
    35 000010EC 30C0                <1>     xor al, al  ;Mock the "00" response that would be placed on the bus by the master
    36                              <1> .ii1:
    37 000010EE 84C0                <1>     test al, al
    38 000010F0 88E0                <1>     mov al, ah  ;Bring back
    39 000010F2 7405                <1>     jz .ii2 ;If al was zero, skip slave identification
    40 000010F4 E85A000000          <1>     call .identifyDrive  ;Slave ata0
    41                              <1> 
    42                              <1> .ii2:
    43                              <1>     ;ATA Channel 1 Master
    44 000010F9 4881C316000000      <1>     add rbx, fdiskTblEntry_size
    45 00001100 BA70010000          <1>     mov edx, ata1_base
    46 00001105 24EF                <1>     and al, 0EFh    ;Clear bit 4
    47 00001107 88C4                <1>     mov ah, al  ;Save in ah
    48 00001109 E8(3E350000)        <1>     call ATA.selectDrive    ;Ignore status for master
    49 0000110E 88E0                <1>     mov al, ah  ;Bring back
    50 00001110 7205                <1>     jc .ii3     ;If Master failed to select, ignore trying to identify it
    51 00001112 E83C000000          <1>     call .identifyDrive ;Master ata1
    52                              <1> .ii3:
    53                              <1>     ;ATA Channel 1 Slave
    54 00001117 4881C316000000      <1>     add rbx, fdiskTblEntry_size
    55 0000111E 0C10                <1>     or al, 10h ;Change from A0h to B0h
    56 00001120 88C4                <1>     mov ah, al
    57 00001122 E8(3E350000)        <1>     call ATA.selectDrive ;Master should set slave status to 0 if non-existent
    58 00001127 7302                <1>     jnc .ii4   ;If slave successfully was selected, skip the next line
    59 00001129 30C0                <1>     xor al, al  ;Mock the "00" response that would be placed on the bus by the master
    60                              <1> .ii4:
    61 0000112B 84C0                <1>     test al, al
    62 0000112D 88E0                <1>     mov al, ah  ;Bring back
    63 0000112F 7405                <1>     jz .ii5 ;If al was zero, skip slave identification
    64 00001131 E81D000000          <1>     call .identifyDrive ;Slave ata1
    65                              <1> .ii5:
    66                              <1> ;Now return the control of each host to the master drives
    67                              <1> 
    68 00001136 B0A0                <1>     mov al, 0A0h
    69 00001138 BAF0010000          <1>     mov edx, ata0_base
    70 0000113D E8(3E350000)        <1>     call ATA.selectDrive
    71                              <1> 
    72 00001142 B0A0                <1>     mov al, 0A0h
    73 00001144 BA70010000          <1>     mov edx, ata1_base
    74 00001149 E8(3E350000)        <1>     call ATA.selectDrive
    75                              <1> 
    76 0000114E E944010000          <1>     jmp .ideInitEnd
    77                              <1> ;===========================
    78                              <1> ;     Callable procs       :
    79                              <1> ;===========================
    80                              <1> .identifyDrive:
    81                              <1> ;Zeros out the sector buffer entries we check
    82                              <1> ; and calls identify device. If it succeeds, it then
    83                              <1> ; proceeds to add the entry to the appropriate position
    84                              <1> ; in the table.
    85                              <1> ;If it fails, doesnt inc the fixed drives number counter
    86                              <1> ;Called with:   dx = ataX base register
    87                              <1> ;               rbx = Points to table entry to write
    88                              <1> ;               al = A0h for master, B0h for slave
    89                              <1> 
    90 00001153 50                  <1>     push rax
    91 00001154 52                  <1>     push rdx
    92 00001155 31C9                <1>     xor ecx, ecx
    93 00001157 488D3C25[C0030000]  <1>     lea rdi, sectorbuffer
    94                              <1>     ;Clean entries we want to read before hand
    95 0000115F 66894F6C            <1>     mov word [rdi + idCurrCyl], cx     ;Clear current cylinders
    96 00001163 66894F6E            <1>     mov word [rdi + idCurrHed], cx     ;Clear current heads
    97 00001167 66894F70            <1>     mov word [rdi + idCurrSecTk], cx   ;Clear current sectors/track
    98 0000116B 66898FA6000000      <1>     mov word [rdi + 83*2], cx          ;Clear LBA48 supported bit word
    99 00001172 894F78              <1>     mov dword [rdi + idLBASectrs], ecx ;Clear UserAddressableSectors
   100 00001175 48898FC8000000      <1>     mov qword [rdi + idLBA48Sec], rcx  ;Clear UserAddressableSectors for LBA48
   101 0000117C 57                  <1>     push rdi
   102 0000117D E8(E1340000)        <1>     call ATA.identifyDevice
   103 00001182 5F                  <1>     pop rdi
   104 00001183 0F82D5000000        <1>     jc .idExit  ;If the carry flag set, the device timed out
   105                              <1>     ;Now get information and build tables here
   106 00001189 C60300              <1>     mov byte [rbx + fdiskTblEntry.signature], 0    ;Clear signature byte in table
   107 0000118C 66895313            <1>     mov word [rbx + fdiskTblEntry.ioBase], dx      ;Add iobase and masterslave status
   108 00001190 884315              <1>     mov byte [rbx + fdiskTblEntry.msBit], al       
   109                              <1> ;CHS, none of CHS is allowed to be 0 but may be because obsolete on new drives
   110 00001193 668B476C            <1>     mov ax, word [rdi + idCurrCyl]
   111 00001197 6685C0              <1>     test ax, ax
   112 0000119A 741E                <1>     jz .id0
   113 0000119C 66894303            <1>     mov word [rbx + fdiskTblEntry.wCylinder], ax
   114 000011A0 668B476E            <1>     mov ax, word [rdi + idCurrHed]
   115 000011A4 6685C0              <1>     test ax, ax
   116 000011A7 7411                <1>     jz .id0
   117 000011A9 66894301            <1>     mov word [rbx + fdiskTblEntry.wHeads], ax
   118 000011AD 668B4770            <1>     mov ax, word [rdi + idCurrSecTk]
   119 000011B1 6685C0              <1>     test ax, ax
   120 000011B4 7404                <1>     jz .id0
   121 000011B6 66894305            <1>     mov word [rbx + fdiskTblEntry.wSecTrc], ax
   122                              <1> .id0:
   123                              <1> ;LBA28
   124 000011BA 8B4778              <1>     mov eax, dword [rdi + idLBASectrs]
   125 000011BD 85C0                <1>     test eax, eax   ;Is this number 0? Check LBA48 or solely on CHS
   126 000011BF 740D                <1>     jz .id1
   127 000011C1 A9000000F0          <1>     test eax, 0F0000000h ;Test if we above max LBA 28 number
   128 000011C6 7506                <1>     jnz .id1 ;If above, ignore LBA28
   129 000011C8 800B02              <1>     or byte [rbx + fdiskTblEntry.signature], fdeLBA28 ;Set LBA28 present bit
   130 000011CB 894307              <1>     mov dword [rbx + fdiskTblEntry.lbaMax], eax
   131                              <1> .id1:
   132                              <1> ;LBA48
   133                              <1> ;Check LBA48 bit first
   134 000011CE 66F787A60000000004  <1>     test word [rdi + 83*2], 400h    ;If bit 10 set, LBA48 supported
   135 000011D7 741A                <1>     jz .id2
   136 000011D9 488B87C8000000      <1>     mov rax, qword [rdi + idLBA48Sec]
   137 000011E0 480FC8              <1>     bswap rax   ;Bring high word low
   138 000011E3 66A9FFFF            <1>     test ax, 0FFFFh ;Test if high word was set
   139 000011E7 480FC8              <1>     bswap rax
   140 000011EA 7507                <1>     jnz .id2    ;If above, ignore LBA 48
   141 000011EC 4889430B            <1>     mov qword [rbx + fdiskTblEntry.lbaMax48], rax
   142 000011F0 800B04              <1>     or byte [rbx + fdiskTblEntry.signature], fdeLBA48
   143                              <1> .id2:
   144                              <1> ;Now check if either LBA28 or LBA48 are set or CHS is non-zero
   145 000011F3 F60306              <1>     test byte [rbx + fdiskTblEntry.signature], fdeLBA28 | fdeLBA48
   146 000011F6 755C                <1>     jnz .idDeviceOK ;If either LBA28 or 48 set, confirm device OK!
   147                              <1>     ;We arrive here ONLY IF LBA 28 or LBA 48 not set
   148                              <1>     ; That means drive must be small, so floating bus values in CHS
   149                              <1>     ; cannot be valid.
   150                              <1>     ;Check C/H/S values are all non-zero
   151                              <1>     ;If any are zero, then device not configured for use
   152                              <1>     ;If any values dont make sense (such as 7F7Fh FFFFh) then fail those too
   153 000011F8 0FB74303            <1>     movzx eax, word [rbx + fdiskTblEntry.wCylinder]
   154 000011FC 85C0                <1>     test eax, eax
   155 000011FE 7434                <1>     jz .id3 ;If zero, dont confirm device
   156 00001200 663DFFFF            <1>     cmp ax, 0FFFFh
   157 00001204 742E                <1>     je .id3
   158 00001206 663D7F7F            <1>     cmp ax, 07F7Fh
   159 0000120A 7428                <1>     je .id3
   160 0000120C 0FB74301            <1>     movzx eax, word [rbx + fdiskTblEntry.wHeads]
   161 00001210 85C0                <1>     test eax, eax
   162 00001212 7420                <1>     jz .id3 ;If zero, dont confirm device
   163 00001214 663DFFFF            <1>     cmp ax, 0FFFFh
   164 00001218 741A                <1>     je .id3
   165 0000121A 663D7F7F            <1>     cmp ax, 07F7Fh
   166 0000121E 7414                <1>     je .id3
   167 00001220 0FB74305            <1>     movzx eax, word [rbx + fdiskTblEntry.wSecTrc]
   168 00001224 85C0                <1>     test eax, eax
   169 00001226 740C                <1>     jz .id3
   170 00001228 663DFFFF            <1>     cmp ax, 0FFFFh
   171 0000122C 7406                <1>     je .id3
   172 0000122E 663D7F7F            <1>     cmp ax, 7F7Fh
   173 00001232 7520                <1>     jne .idDeviceOK ;Values are probably sane, all ok
   174                              <1> .id3:
   175                              <1> ;Only arrive here if none of CHS, LBA28 or LBA48 were verified as ok
   176                              <1> ;Clean any data that mightve been copied (from Floating Bus reads perhaps)
   177 00001234 31C0                <1>     xor eax, eax
   178 00001236 8803                <1>     mov byte [rbx + fdiskTblEntry.signature], al
   179 00001238 894307              <1>     mov dword [rbx + fdiskTblEntry.lbaMax], eax
   180 0000123B 4889430B            <1>     mov qword [rbx + fdiskTblEntry.lbaMax48], rax
   181 0000123F 66894303            <1>     mov word [rbx + fdiskTblEntry.wCylinder], ax
   182 00001243 66894301            <1>     mov word [rbx + fdiskTblEntry.wHeads], ax
   183 00001247 66894305            <1>     mov word [rbx + fdiskTblEntry.wSecTrc], ax
   184 0000124B 66894313            <1>     mov word [rbx + fdiskTblEntry.ioBase], ax
   185 0000124F 884315              <1>     mov byte [rbx + fdiskTblEntry.msBit], al
   186 00001252 EB0A                <1>     jmp short .idExit
   187                              <1> .idDeviceOK:
   188 00001254 800B01              <1>     or byte [rbx + fdiskTblEntry.signature], fdePresent
   189 00001257 FE0425[AA010000]    <1>     inc byte [fdiskNum] ;Number of usable fixed disks increased
   190                              <1> .idExit:
   191 0000125E 5A                  <1>     pop rdx
   192 0000125F 58                  <1>     pop rax
   193 00001260 C3                  <1>     ret
   194                              <1> 
   195                              <1> .addControllerTable:
   196                              <1> ;Adds a PCI IDE controller to the internal data tables, if there is space
   197                              <1> ; If there is no space, returns with carry set.
   198                              <1> ;Input: eax = BAR5 address
   199                              <1> ;       ebx = PCI IO address
   200                              <1> ;Output: CF=NC, all ok, CF=CY, device not added.
   201 00001261 56                  <1>     push rsi
   202 00001262 803C25[5B030000]02  <1>     cmp byte [ideNumCtrlr], 2
   203 0000126A 7428                <1>     je .actfail ;If it is 2, fail
   204 0000126C FE0425[5B030000]    <1>     inc byte [ideNumCtrlr]
   205 00001273 48BE-               <1>     mov rsi, ideCtrlrTbl
   205 00001275 [5C03000000000000]  <1>
   206 0000127D 803E00              <1>     cmp byte [rsi], 0   ;Is the first entry empty?
   207 00001280 7407                <1>     jz .act0    ;If yes, write entry
   208 00001282 4881C608000000      <1>     add rsi, ideCtrlrTblEntry_size  ;Else, goto second entry space
   209                              <1> .act0:
   210 00001289 891E                <1>     mov dword [rsi], ebx    ;Move first PCI IO addr
   211 0000128B C60600              <1>     mov byte [rsi], 0       ;Zero the register index
   212 0000128E 894604              <1>     mov dword [rsi + 4], eax    ;Move next data
   213 00001291 F8                  <1>     clc
   214                              <1> .actexit:
   215 00001292 5E                  <1>     pop rsi
   216 00001293 C3                  <1>     ret
   217                              <1> .actfail:
   218 00001294 F9                  <1>     stc
   219 00001295 EBFB                <1>     jmp short .actexit
   220                              <1> 
   221                              <1> ;============================
   222                              <1> ;     Exit target label     :
   223                              <1> ;============================
   224                              <1> .ideInitEnd:
    65                                  %include "./Source/Init/Hardware/USB/xHCI/xhciinit.asm"
    66                                  %include "./Source/Init/Hardware/USB/EHCI/ehciinit.asm"
     1                              <1> ;            ------------USB section below------------
     2                              <1> ;                   ---- PCI table parse ----
     3                              <1> ;Parse the PCI tables for ehci controllers
     4                              <1> hciParse:
     5 00001297 C60425[4C020000]00  <1>     mov byte [numMSD], 0
     6 0000129F 4C0FB70C2500E00000  <1>     movzx r9, word [lousbtablesize]
     7 000012A8 BE02E00000          <1>     mov esi, lousbtablebase
     8 000012AD BF[16020000]        <1>     mov edi, eControllerList
     9                              <1> .hcip1:
    10 000012B2 6667F7064000        <1>     test word [esi], ehcimask    ;check if we at a ehci mask
    11 000012B8 7418                <1>     jz .hcip2   ;If not, skip adding to ehci table
    12                              <1>     ;First catch all clause (temporary for version 1 of BIOS with max 4 
    13                              <1>     ; controllers)
    14 000012BA 803C25[15020000]04  <1>     cmp byte [eControllers], 4
    15 000012C2 7430                <1>     je .pr0    ;escape this whole setup proc if at 4 controllers
    16 000012C4 67488B4602          <1>     mov rax, qword [esi + 2]    ;take pci and mmio address into rax
    17 000012C9 48AB                <1>     stosq                        ;store into rdi and inc rdi by 8 to next entry
    18 000012CB FE0425[15020000]    <1>     inc byte [eControllers]    ;increase the number of controllers variable
    19                              <1> .hcip2:
    20                              <1> ;Any additional data saving occurs here
    21 000012D2 81C60A000000        <1>     add esi, 10    ;Goto next table entry
    22 000012D8 41FEC9              <1>     dec r9b     ;Once all table entries exhausted, fall through
    23 000012DB 75D5                <1>     jnz .hcip1
    24                              <1>     
    25                              <1> ;               ---- EHCI controller enumeration ----
    26                              <1> ;Enumerate each ehci ctrlr root hub for valid usb devices (hubs and valid MSD)
    27 000012DD 8A0C25[15020000]    <1>     mov cl, byte [eControllers]
    28 000012E4 66B80413            <1>     mov ax, 1304h
    29 000012E8 48BD-               <1>     mov rbp, .echiInitMsg
    29 000012EA [6913000000000000]  <1>
    30 000012F2 CD30                <1>     int 30h
    31                              <1> .pr0:   ;If ctrlr failure or ports exhausted, ret to here for next ctrlr
    32 000012F4 84C9                <1>     test cl, cl
    33 000012F6 0F8496000000        <1>     jz .noEHCI    ;No EHCI controllers or last controler?
    34 000012FC FEC9                <1>     dec cl    ;Undo the absolute count from above
    35 000012FE 88C8                <1>     mov al, cl
    36 00001300 E8(363A0000)        <1>     call USB.setupEHCIcontroller
    37 00001305 72ED                <1>     jc .pr0    ;Continue to next controller
    38 00001307 E8(B13B0000)        <1>     call USB.ehciRunCtrlr       ;Activate online controller
    39 0000130C 72E6                <1>     jc .pr0
    40 0000130E E8(123C0000)        <1>     call USB.ehciAdjustAsyncSchedCtrlr ;Start schedule and lock ctrlr as online
    41 00001313 72DF                <1>     jc .pr0
    42 00001315 E8(8F3C0000)        <1>     call USB.ehciCtrlrGetNumberOfPorts
    43 0000131A 88C2                <1>     mov dl, al      ;Save the number of ports in dl
    44 0000131C 8A3425[48020000]    <1>     mov dh, byte [eActiveCtrlr]    ;Save current active ctrlr in dh
    45 00001323 4D31D2              <1>     xor r10, r10    ;Host hub 0 [ie Root Hub enum only] (for enum)
    46                              <1> .pr1:
    47 00001326 FECA                <1>     dec dl
    48 00001328 49BC03000000000000- <1>     mov r12, 3      ;Attempt three times to enumerate
    48 00001331 00                  <1>
    49                              <1> .pr11:
    50 00001332 E8(2B400000)        <1>     call USB.ehciEnumerateRootPort
    51 00001337 7413                <1>     jz .pr2
    52 00001339 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h  ;General Controller Failure
    53 00001341 0F84(FB390000)      <1>     je USB.ehciCriticalErrorWrapper
    54 00001347 49FFCC              <1>     dec r12
    55 0000134A 75E6                <1>     jnz .pr11
    56                              <1> .pr2:
    57 0000134C 84D2                <1>     test dl, dl
    58 0000134E 75D6                <1>     jnz .pr1
    59 00001350 84C9                <1>     test cl, cl ;Once cl is zero we have gone through all controllers
    60 00001352 75A0                <1>     jnz .pr0
    61                              <1> 
    62 00001354 B804130000          <1>     mov eax, 1304h
    63 00001359 48BD-               <1>     mov rbp, remDevInit.ok  ;Reuse the OK from the other proc
    63 0000135B [6F14000000000000]  <1>
    64 00001363 30FF                <1>     xor bh, bh
    65 00001365 CD30                <1>     int 30h
    66 00001367 EB2E                <1>     jmp short .exit
    67 00001369 0A0D496E697469616C- <1> .echiInitMsg db 0Ah,0Dh,"Initialising USB and EHCI root hubs...",0
    67 00001372 6973696E6720555342- <1>
    67 0000137B 20616E642045484349- <1>
    67 00001384 20726F6F7420687562- <1>
    67 0000138D 732E2E2E00          <1>
    68                              <1> .noEHCI:
    69                              <1> ;If no EHCI, skip MSD search on EHCI bus. Goto Int 33h init
    70 00001392 E95F010000          <1>     jmp int33hinit.i33iend  ;Could go to int33hinit, but this is minutely faster
    71                              <1> .exit:
    67                                  %include "./Source/Init/Hardware/USB/MSD/msdinit.asm"
     1                              <1> remDevInit:
     2                              <1> ;Devices on root hubs have been enumerated, and added to tables,
     3                              <1> ;Now we reset them (in the case of MSD) and enumerate further (on Hubs)
     4 00001397 66B80413            <1>     mov ax, 1304h
     5 0000139B 80F70B              <1>     xor bh, 0bh
     6 0000139E 48BD-               <1>     mov rbp, .rmhmsg
     6 000013A0 [5314000000000000]  <1>
     7 000013A8 CD30                <1>     int 30h
     8                              <1> .hubs_init:
     9 000013AA 48BE-               <1>     mov rsi, hubDevTbl
     9 000013AC [6B02000000000000]  <1>
    10                              <1> ;First we scan for hubs only
    11                              <1> .redi1:
    12 000013B4 803E00              <1>     cmp byte [rsi], 0   ;Not an entry
    13 000013B7 7417                <1>     jz .hubnextentry
    14 000013B9 807E0500            <1>     cmp byte [rsi + 5], 0   ;If number of ports on hub is 0, dev uncofigured
    15 000013BD 7511                <1>     jnz .hubnextentry  ;Device must be already enumerated
    16                              <1> 
    17 000013BF 8A4601              <1>     mov al, byte [rsi + 1]  ;Get bus number into al
    18                              <1> 
    19 000013C2 E8(123C0000)        <1>     call USB.ehciAdjustAsyncSchedCtrlr
    20 000013C7 7207                <1>     jc .hubnextentry
    21                              <1> 
    22 000013C9 E8(7A460000)        <1>     call USB.ehciDevSetupHub  ;Only needs a valid device in rsi
    23 000013CE 7200                <1>     jc .hubnextentry
    24                              <1> .hubnextentry:
    25 000013D0 4881C608000000      <1>     add rsi, hubDevTblEntry_size ;Goto next table entry
    26 000013D7 4881FE[BB020000]    <1>     cmp rsi, hubDevTbl + hubDevTblSz*hubDevTblEntry_size  ;End of table address
    27 000013DE 72D4                <1>     jb .redi1  ;We are still in table
    28                              <1> .hub_rescan:
    29                              <1> ;Now we check that all hubs are initialised
    30 000013E0 48BE-               <1>     mov rsi, hubDevTbl  ;Return to head of table
    30 000013E2 [6B02000000000000]  <1>
    31                              <1> ;Leave as a stub for now. Dont support deeper than 1 level of devices
    32                              <1> ;The specification allows for a maximum of 7 levels of depth.
    33                              <1> .msds_init:
    34 000013EA 66B80413            <1>     mov ax, 1304h
    35 000013EE 80F70B              <1>     xor bh, 0bh
    36 000013F1 48BD-               <1>     mov rbp, .ok
    36 000013F3 [6F14000000000000]  <1>
    37 000013FB CD30                <1>     int 30h
    38 000013FD 66B80413            <1>     mov ax, 1304h
    39 00001401 80F70B              <1>     xor bh, 0bh
    40 00001404 48BD-               <1>     mov rbp, .msdmsg
    40 00001406 [7314000000000000]  <1>
    41 0000140E CD30                <1>     int 30h
    42 00001410 48BE-               <1>     mov rsi, msdDevTbl
    42 00001412 [BB02000000000000]  <1>
    43                              <1> .msd1:
    44 0000141A 803E00              <1>     cmp byte [rsi], 0   ;Not an entry
    45 0000141D 740F                <1>     jz .msdNextEntry
    46 0000141F E8(094A0000)        <1>     call USB.ehciMsdInitialise
    47 00001424 7308                <1>     jnc .msdNextEntry
    48 00001426 FEC8                <1>     dec al
    49 00001428 0F84(FB390000)      <1>     jz USB.ehciCriticalErrorWrapper ;al = 1 => Host error, 
    50                              <1> ;                                    al = 2 => Bad dev, removed from MSD tables
    51                              <1> .msdNextEntry:
    52 0000142E 4881C610000000      <1>     add rsi, msdDevTblEntry_size ;Goto next entry
    53 00001435 4881FE[5B030000]    <1>     cmp rsi, msdDevTbl + msdDevTblSz*msdDevTblEntry_size
    54 0000143C 75DC                <1>     jne .msd1
    55                              <1> .rediexit:
    56 0000143E 66B80413            <1>     mov ax, 1304h
    57 00001442 80F70B              <1>     xor bh, 0bh
    58 00001445 48BD-               <1>     mov rbp, .ok
    58 00001447 [6F14000000000000]  <1>
    59 0000144F CD30                <1>     int 30h
    60 00001451 EB3E                <1>     jmp short .exit
    61 00001453 0A0D496E697469616C- <1> .rmhmsg db 0Ah,0Dh,"Initialising USB ports...",0
    61 0000145C 6973696E6720555342- <1>
    61 00001465 20706F7274732E2E2E- <1>
    61 0000146E 00                  <1>
    62 0000146F 204F4B00            <1> .ok db " OK",0
    63 00001473 0A0D496E697469616C- <1> .msdmsg db 0Ah,0Dh,"Initialising MSD devices...",0
    63 0000147C 6973696E67204D5344- <1>
    63 00001485 20646576696365732E- <1>
    63 0000148E 2E2E00              <1>
    64                              <1> .exit:
    68                                  %include "./Source/Init/Hardware/MSD/i33init.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                      Int 33h Initialisation                   :
     3                              <1> ;----------------------------------------------------------------    
     4                              <1> int33hinit:
     5                              <1> ;Create Int 33h data table entry for each MSD/floppy device using steps 1-3.
     6                              <1> ;Go through MSD table and add devices to i33DevTbl
     7 00001491 48BD-               <1>     mov rbp, usbDevTbl
     7 00001493 [4D02000000000000]  <1>
     8 0000149B 48BF-               <1>     mov rdi, i33DevTbl
     8 0000149D [C403000000000000]  <1>
     9                              <1> .i33i1:
    10 000014A5 807D0208            <1>     cmp byte [rbp + 2], 08h ;MSD USB Class code
    11 000014A9 7525                <1>     jne .i33proceed
    12                              <1> ;Successfully found a valid MSD device. Talk to it
    13 000014AB 668B4500            <1>     mov ax, word [rbp]  ;Get address/bus pair
    14 000014AF E8(E3440000)        <1>     call USB.ehciGetDevicePtr    ;Get pointer to MSD dev in rsi
    15 000014B4 E8(051A0000)        <1>     call disk_io.deviceInit
    16 000014B9 3C01                <1>     cmp al, 1   ;Critical error
    17 000014BB 0F84(FB390000)      <1>     je USB.ehciCriticalErrorWrapper
    18 000014C1 3C02                <1>     cmp al, 2   ;Device stopped responding, remove from USB data tables
    19 000014C3 7420                <1>     je .i33ibad 
    20 000014C5 3C03                <1>     cmp al, 3   ;Device not added to data tables
    21 000014C7 7407                <1>     je .i33proceed
    22                              <1> ;Valid device added, increment rdi to next i33DevTbl table entry
    23 000014C9 4881C710000000      <1>     add rdi, i33DevTblEntry_size
    24                              <1> .i33proceed:
    25 000014D0 4881FD[6B020000]    <1>     cmp rbp, usbDevTbl + usbDevTblSz*usbDevTblEntry_size
    26 000014D7 741D                <1>     je .i33iend
    27 000014D9 4881C503000000      <1>     add rbp, usbDevTblEntry_size
    28 000014E0 E9C0FFFFFF          <1>     jmp .i33i1
    29                              <1> .i33ibad:   ;If it goes here, clear table entry
    30 000014E5 48C70700000000      <1>     mov qword [rdi], 0  ;Remove from diskDevice table
    31 000014EC 668B06              <1>     mov ax, word [rsi]
    32 000014EF E8(6E430000)        <1>     call USB.ehciRemoveDevFromTables    ;Remove from USB tables
    33 000014F4 EBDA                <1>     jmp short .i33proceed ;Goto next device
    34                              <1> .i33iend:
    35 000014F6 8A0425[4C020000]    <1>     mov al, byte [numMSD]
    36 000014FD 000425[A8010000]    <1>     add byte [i33Devices], al   ;Add the number of MSD devices to Int 33h total
    37 00001504 8A0425[AA010000]    <1>     mov al, byte [fdiskNum]
    38 0000150B 000425[A8010000]    <1>     add byte [i33Devices], al   ;Add the number of Fixed Disks to Int 33h total
    69                                  ;----------------------------------------------------------------
    70                                  ;                         End of Enum                           :
    71                                  ;----------------------------------------------------------------    
    72                                  %include "./Source/Init/InitEnd.asm"
     1                              <1> ;----------------------------------------------------------------
     2                              <1> ;                End of Enum and Initialisation                 :
     3                              <1> ;----------------------------------------------------------------   
     4                              <1> end:
     5                              <1> ;Finally, unmask all IRQ lines for usage
     6 00001512 30C0                <1>     xor al, al
     7 00001514 E6A1                <1>     out pic2data, al
     8 00001516 E621                <1>     out pic1data, al
     9                              <1> 
    10 00001518 66B80413            <1>     mov ax, 1304h
    11 0000151C 48BD-               <1>     mov rbp, dbgmsg
    11 0000151E [9F16000000000000]  <1>
    12 00001526 CD30                <1>     int 30h
    13 00001528 8A0425[4C020000]    <1>     mov al, byte [numMSD]
    14 0000152F B404                <1>     mov ah, 04h
    15 00001531 CD30                <1>     int 30h
    16                              <1> 
    17 00001533 66B80413            <1>     mov ax, 1304h
    18 00001537 48BD-               <1>     mov rbp, dbgmsg4
    18 00001539 [D716000000000000]  <1>
    19 00001541 CD30                <1>     int 30h
    20 00001543 8A0425[AA010000]    <1>     mov al, byte [fdiskNum]
    21 0000154A B404                <1>     mov ah, 04h
    22 0000154C CD30                <1>     int 30h
    23                              <1> 
    24 0000154E 66B80413            <1>     mov ax, 1304h
    25 00001552 48BD-               <1>     mov rbp, dbgmsg2
    25 00001554 [B516000000000000]  <1>
    26 0000155C CD30                <1>     int 30h
    27 0000155E 8A0425[A8010000]    <1>     mov al, byte [i33Devices]
    28 00001565 B404                <1>     mov ah, 04h
    29 00001567 CD30                <1>     int 30h
    30                              <1> 
    31 00001569 66B80413            <1>     mov ax, 1304h
    32 0000156D 48BD-               <1>     mov rbp, dbgmsg3
    32 0000156F [C916000000000000]  <1>
    33 00001577 CD30                <1>     int 30h
    34 00001579 8A0425[66000000]    <1>     mov al, byte [numCOM]
    35 00001580 B404                <1>     mov ah, 04h
    36 00001582 CD30                <1>     int 30h
    37                              <1> 
    38 00001584 803C25[A8010000]00  <1>     cmp byte [i33Devices], 0    ;If there are no i33 devices, skip bootstrap
    39 0000158C 7402                <1>     jz endNoDevFound
    40                              <1> 
    41 0000158E CD39                <1>     int 39h             ;Bootstrap loader
    42                              <1> endNoDevFound:
    43 00001590 48BD-               <1>     mov rbp, endboot
    43 00001592 [0F16000000000000]  <1>
    44 0000159A 66B80413            <1>     mov ax, 1304h
    45 0000159E CD30                <1>     int 30h
    46                              <1>     
    47 000015A0 6631C0              <1>     xor ax, ax  ;Pause for any key
    48 000015A3 CD36                <1>     int 36h
    49                              <1> 
    50 000015A5 66BB0700            <1>     mov bx, 0007h    ;cls attribs
    51 000015A9 E8(F7000000)        <1>     call cls
    52                              <1> 
    53 000015AE 6631C9              <1>     xor cx, cx
    54 000015B1 6631D2              <1>     xor dx, dx
    55 000015B4 B402                <1>     mov ah, 2
    56 000015B6 30FF                <1>     xor bh, bh
    57 000015B8 CD30                <1>     int 30h 
    58                              <1> 
    59 000015BA 66B80413            <1>     mov ax, 1304h
    60 000015BE 48BD-               <1>     mov rbp, endboot2
    60 000015C0 [7F16000000000000]  <1>
    61 000015C8 CD30                <1>     int 30h
    62                              <1> 
    63 000015CA 4831C0              <1>     xor rax, rax
    64 000015CD 4831DB              <1>     xor rbx, rbx
    65 000015D0 4831C9              <1>     xor rcx, rcx
    66 000015D3 4831D2              <1>     xor rdx, rdx
    67 000015D6 4831F6              <1>     xor rsi, rsi
    68 000015D9 4831FF              <1>     xor rdi, rdi
    69 000015DC 4831ED              <1>     xor rbp, rbp
    70 000015DF 4D31C0              <1>     xor r8, r8
    71 000015E2 4D31C9              <1>     xor r9, r9
    72 000015E5 4D31D2              <1>     xor r10, r10
    73 000015E8 4D31DB              <1>     xor r11, r11
    74 000015EB 4D31E4              <1>     xor r12, r12
    75 000015EE 4D31ED              <1>     xor r13, r13
    76 000015F1 4D31F6              <1>     xor r14, r14
    77 000015F4 4D31FF              <1>     xor r15, r15
    78                              <1> 
    79 000015F7 CD38                <1>     int 38h
    80                              <1> 
    81                              <1> 
    82 000015F9 4C6F6164696E672053- <1> startboot:  db "Loading SCP/BIOS...", 0Ah, 0Dh, 0
    82 00001602 43502F42494F532E2E- <1>
    82 0000160B 2E0A0D00            <1>
    83 0000160F 0A0D5343502F42494F- <1> endboot:    db    0Ah,0Dh,"SCP/BIOS system initialisation complete", 0Ah, 0Dh 
    83 00001618 532073797374656D20- <1>
    83 00001621 696E697469616C6973- <1>
    83 0000162A 6174696F6E20636F6D- <1>
    83 00001633 706C6574650A0D      <1>
    84 0000163A 4E6F204F7065726174- <1>         db "No Operating System detected. Strike any key to launch SYSDEBUG."
    84 00001643 696E67205379737465- <1>
    84 0000164C 6D2064657465637465- <1>
    84 00001655 642E20537472696B65- <1>
    84 0000165E 20616E79206B657920- <1>
    84 00001667 746F206C61756E6368- <1>
    84 00001670 205359534445425547- <1>
    84 00001679 2E                  <1>
    85 0000167A 2E2E0A0D00          <1>             db "..",0Ah, 0Dh,0
    86 0000167F 5374617274696E6720- <1> endboot2:   db "Starting SCP/BIOS SYSDEBUG...",0Ah,0Dh,0
    86 00001688 5343502F42494F5320- <1>
    86 00001691 53595344454255472E- <1>
    86 0000169A 2E2E0A0D00          <1>
    87 0000169F 0A0A0D555342205265- <1> dbgmsg:     db 0Ah,0Ah,0Dh,"USB Rem. Devices: ",0
    87 000016A8 6D2E20446576696365- <1>
    87 000016B1 733A2000            <1>
    88 000016B5 0A0D496E7420333368- <1> dbgmsg2:    db 0Ah,0Dh,"Int 33h Devices: ",0
    88 000016BE 20446576696365733A- <1>
    88 000016C7 2000                <1>
    89 000016C9 0A0D434F4D20506F72- <1> dbgmsg3:    db 0Ah,0Dh,"COM Ports: ",0
    89 000016D2 74733A2000          <1>
    90 000016D7 0A0D41544120466978- <1> dbgmsg4:    db 0Ah,0Dh,"ATA Fixed Devices: ", 0
    90 000016E0 656420446576696365- <1>
    90 000016E9 733A2000            <1>
    91                              <1> memprint:
    92                              <1> ;Simple proc to print memory status
    93 000016ED 6631DB              <1>     xor bx, bx 
    94 000016F0 48BD-               <1>     mov rbp, .convmemmsg
    94 000016F2 [4618000000000000]  <1>
    95 000016FA 66B80413            <1>     mov ax, 1304h
    96 000016FE CD30                <1>     int 30h
    97 00001700 CD32                <1>     int 32h    ;Get conv Size
    98 00001702 25FFFF0000          <1>     and eax, 0FFFFh ;Clear upper bits
    99 00001707 E8F4000000          <1>     call .printdecimalword
   100 0000170C 48BD-               <1>     mov rbp, .kb
   100 0000170E [BD18000000000000]  <1>
   101 00001716 66B80413            <1>     mov ax, 1304h
   102 0000171A CD30                <1>     int 30h
   103                              <1> 
   104 0000171C 66B801E8            <1>     mov ax, 0E801h
   105 00001720 CD35                <1>     int 35h
   106 00001722 25FFFF0000          <1>     and eax, 0FFFFh
   107 00001727 81E3FFFF0000        <1>     and ebx, 0FFFFh
   108 0000172D 81E1FFFF0000        <1>     and ecx, 0FFFFh
   109 00001733 81E2FFFF0000        <1>     and edx, 0FFFFh
   110 00001739 53                  <1>     push rbx
   111 0000173A 52                  <1>     push rdx
   112 0000173B 4839C8              <1>     cmp rax, rcx
   113 0000173E 740C                <1>     je .sense1    ;Sensible
   114 00001740 4885C0              <1>     test rax, rax
   115 00001743 480F44C1            <1>     cmovz rax, rcx
   116 00001747 4885C0              <1>     test rax, rax
   117 0000174A 7427                <1>     jz .pt2
   118                              <1> .sense1:
   119 0000174C 50                  <1>     push rax
   120 0000174D 48BD-               <1>     mov rbp, .extmemmsg
   120 0000174F [6318000000000000]  <1>
   121 00001757 66B80413            <1>     mov ax, 1304h
   122 0000175B CD30                <1>     int 30h
   123 0000175D 58                  <1>     pop rax
   124 0000175E E89D000000          <1>     call .printdecimalword
   125 00001763 48BD-               <1>     mov rbp, .kb
   125 00001765 [BD18000000000000]  <1>
   126 0000176D 66B80413            <1>     mov ax, 1304h
   127 00001771 CD30                <1>     int 30h
   128                              <1> .pt2:
   129 00001773 58                  <1>     pop rax
   130 00001774 59                  <1>     pop rcx
   131 00001775 4839C8              <1>     cmp rax, rcx
   132 00001778 740C                <1>     je .sense2    ;Sensible
   133 0000177A 4885C0              <1>     test rax, rax
   134 0000177D 480F44C1            <1>     cmovz rax, rcx
   135 00001781 4885C0              <1>     test rax, rax
   136 00001784 742B                <1>     jz .pt3
   137                              <1> .sense2:
   138 00001786 50                  <1>     push rax
   139 00001787 48BD-               <1>     mov rbp, .extmemmsg2
   139 00001789 [8118000000000000]  <1>
   140 00001791 66B80413            <1>     mov ax, 1304h
   141 00001795 CD30                <1>     int 30h
   142 00001797 58                  <1>     pop rax
   143                              <1> 
   144 00001798 48C1E006            <1>     shl rax, 6    ;Turn 64Kb into Kb
   145 0000179C E85F000000          <1>     call .printdecimalword
   146 000017A1 48BD-               <1>     mov rbp, .kb
   146 000017A3 [BD18000000000000]  <1>
   147 000017AB 66B80413            <1>     mov ax, 1304h
   148 000017AF CD30                <1>     int 30h
   149                              <1> .pt3:   ;Read total free size from big map
   150 000017B1 50                  <1>     push rax
   151 000017B2 48BD-               <1>     mov rbp, .totalmem
   151 000017B4 [A018000000000000]  <1>
   152 000017BC B804130000          <1>     mov eax, 1304h
   153 000017C1 CD30                <1>     int 30h
   154 000017C3 58                  <1>     pop rax
   155 000017C4 488B0425[E0010000]  <1>     mov rax, qword [sysMem]
   156 000017CC 31DB                <1>     xor ebx, ebx
   157 000017CE 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]
   158 000017D5 4829D8              <1>     sub rax, rbx
   159 000017D8 48C1E80A            <1>     shr rax, 0Ah                ;Get number of Kb's free
   160 000017DC E81F000000          <1>     call .printdecimalword  
   161 000017E1 48BD-               <1>     mov rbp, .kb
   161 000017E3 [BD18000000000000]  <1>
   162 000017EB 66B80413            <1>     mov ax, 1304h
   163 000017EF CD30                <1>     int 30h
   164                              <1> 
   165 000017F1 B80A0E0000          <1>     mov eax, 0E0Ah
   166 000017F6 CD30                <1>     int 30h
   167 000017F8 B80D0E0000          <1>     mov eax, 0E0Dh   ;CR/LF
   168 000017FD CD30                <1>     int 30h
   169                              <1> 
   170 000017FF C3                  <1>     ret
   171                              <1> 
   172                              <1> .printdecimalword:
   173                              <1> ;Takes the qword in rax and prints its decimal representation
   174 00001800 52                  <1>     push rdx
   175 00001801 51                  <1>     push rcx
   176 00001802 53                  <1>     push rbx
   177 00001803 50                  <1>     push rax
   178 00001804 55                  <1>     push rbp
   179 00001805 4831C9              <1>     xor rcx, rcx
   180 00001808 6631ED              <1>     xor bp, bp    ;Use bp as #of digits counter
   181 0000180B 48BB0A000000000000- <1>     mov rbx, 0Ah  ;Divide by 10
   181 00001814 00                  <1>
   182                              <1> .pdw0:
   183 00001815 FFC5                <1>     inc ebp
   184 00001817 48C1E108            <1>     shl rcx, 8    ;Space for next nybble
   185 0000181B 31D2                <1>     xor edx, edx
   186 0000181D 48F7F3              <1>     div rbx
   187 00001820 80C230              <1>     add dl, '0'
   188 00001823 80FA39              <1>     cmp dl, '9'
   189 00001826 7603                <1>     jbe .pdw1
   190 00001828 80C207              <1>     add dl, 'A'-'0'-10
   191                              <1> .pdw1:
   192 0000182B 88D1                <1>     mov cl, dl    ;Save remainder byte
   193 0000182D 4885C0              <1>     test rax, rax
   194 00001830 75E3                <1>     jnz .pdw0
   195                              <1> .pdw2:
   196 00001832 88C8                <1>     mov al, cl    ;Get most sig digit into al
   197 00001834 48C1E908            <1>     shr rcx, 8    ;Get next digit down
   198 00001838 B40E                <1>     mov ah, 0Eh
   199 0000183A CD30                <1>     int 30h
   200 0000183C FFCD                <1>     dec ebp
   201 0000183E 75F2                <1>     jnz .pdw2
   202                              <1> 
   203 00001840 5D                  <1>     pop rbp
   204 00001841 58                  <1>     pop rax
   205 00001842 5B                  <1>     pop rbx
   206 00001843 59                  <1>     pop rcx
   207 00001844 5A                  <1>     pop rdx
   208 00001845 C3                  <1>     ret
   209 00001846 0A0D4672656520436F- <1> .convmemmsg:        db 0Ah,0Dh,"Free Conventional Memory: ",0
   209 0000184F 6E76656E74696F6E61- <1>
   209 00001858 6C204D656D6F72793A- <1>
   209 00001861 2000                <1>
   210 00001863 0A0D546F74616C204C- <1> .extmemmsg:         db 0Ah,0Dh,"Total Low Extended Memory: ",0    
   210 0000186C 6F7720457874656E64- <1>
   210 00001875 6564204D656D6F7279- <1>
   210 0000187E 3A2000              <1>
   211 00001881 0A0D546F74616C2048- <1> .extmemmsg2:        db 0Ah,0Dh,"Total High Extended Memory: ",0
   211 0000188A 69676820457874656E- <1>
   211 00001893 646564204D656D6F72- <1>
   211 0000189C 793A2000            <1>
   212 000018A0 0A0D546F74616C2046- <1> .totalmem:          db 0Ah,0Dh,"Total Free System Memory: ",0
   212 000018A9 726565205379737465- <1>
   212 000018B2 6D204D656D6F72793A- <1>
   212 000018BB 2000                <1>
   213 000018BD 4B00                <1> .kb:                db "K",0
    73                                  %include "./Source/Init/IntTable.asm"
     1                              <1> ;----------------------Interrupt Tables--------------------------
     2                              <1> IDT_TABLE:
     3                              <1> CPU_IDT:
     4 000018BF [1454000000000000]  <1>     dq i0
     5 000018C7 [1C54000000000000]  <1>     dq i1
     6 000018CF [2B54000000000000]  <1>     dq i2
     7 000018D7 [3A54000000000000]  <1>     dq i3
     8 000018DF [4954000000000000]  <1>     dq i4
     9 000018E7 [5854000000000000]  <1>     dq i5
    10 000018EF [6754000000000000]  <1>     dq i6
    11 000018F7 [7654000000000000]  <1>     dq i7
    12 000018FF [8554000000000000]  <1>     dq i8
    13 00001907 [9454000000000000]  <1>     dq i9
    14 0000190F [A354000000000000]  <1>     dq i10
    15 00001917 [B254000000000000]  <1>     dq i11
    16 0000191F [C154000000000000]  <1>     dq i12
    17 00001927 [D054000000000000]  <1>     dq i13
    18 0000192F [DC54000000000000]  <1>     dq i14
    19 00001937 [E854000000000000]  <1>     dq i15
    20 0000193F [F454000000000000]  <1>     dq i16
    21 00001947 [0055000000000000]  <1>     dq i17
    22 0000194F [0C55000000000000]  <1>     dq i18
    23 00001957 [1855000000000000]  <1>     dq i19
    24 0000195F [2455000000000000]  <1>     dq i20
    25 00001967 [3055000000000000]  <1>     dq i21
    26 0000196F [3358000000000000]- <1>     times 0Ah dq dummy_return_64    ;just return, reserved interrupts!
    26 0000196F <rep Ah>            <1>
    27                              <1> HW_IDT:
    28                              <1> ;--------PIC1--------:    ;Int 20h-27h
    29 000019BF [0F01000000000000]  <1>     dq timer_IRQ0
    30 000019C7 [4F01000000000000]  <1>     dq kb_IRQ1
    31 000019CF [2D58000000000000]  <1>     dq dummy_interrupt.pic1
    32 000019D7 [DB09000000000000]  <1>     dq ser_IRQ3
    33 000019DF [ED09000000000000]  <1>     dq ser_IRQ4
    34 000019E7 [2D58000000000000]  <1>     dq dummy_interrupt.pic1
    35 000019EF [B60A000000000000]  <1>     dq fdd_IRQ6
    36 000019F7 [8A0B000000000000]  <1>     dq default_IRQ7
    37                              <1> ;--------PIC2--------:    ;Int 28h-2Fh
    38 000019FF [BE0A000000000000]  <1>     dq rtc_IRQ8
    39 00001A07 [2658000000000000]  <1>     dq dummy_interrupt.pic2
    40 00001A0F [2658000000000000]  <1>     dq dummy_interrupt.pic2
    41 00001A17 [2658000000000000]  <1>     dq dummy_interrupt.pic2
    42 00001A1F [2658000000000000]  <1>     dq dummy_interrupt.pic2
    43 00001A27 [2658000000000000]  <1>     dq dummy_interrupt.pic2
    44 00001A2F [F10A000000000000]  <1>     dq hdd_IRQ14
    45 00001A37 [A90B000000000000]  <1>     dq default_IRQ15
    46                              <1> SW_IDT:    ;Int 30h onwards!
    47 00001A3F [830C000000000000]  <1>     dq scr_io            ;Int 30h, VGA Screen drawing/TTY functions
    48 00001A47 [0D13000000000000]  <1>     dq machineWord_io    ;Int 31h, Give the BIOS hardware bitfield
    49 00001A4F [4413000000000000]  <1>     dq convRAM_io        ;Int 32h, Give conv memory available
    50 00001A57 [6713000000000000]  <1>     dq disk_io           ;Int 33h, Storage device Functions
    51 00001A5F [861D000000000000]  <1>     dq serial_io         ;Int 34h, Serial Port Functions
    52 00001A67 [D91E000000000000]  <1>     dq misc_io           ;Int 35h, Misc functions
    53 00001A6F [7B22000000000000]  <1>     dq kb_io             ;Int 36h, Keyboard functions
    54 00001A77 [FD22000000000000]  <1>     dq printer_io        ;Int 37h, Reserved [Who uses parallel anymore?]
    55 00001A7F [9E23000000000000]  <1>     dq MCP_int           ;Int 38h, launch MCP, and install its "API" handle
    56 00001A87 [A531000000000000]  <1>     dq bootstrapInt      ;Int 39h, restart the PC using an interrupt
    57 00001A8F [3E32000000000000]  <1>     dq timerInt          ;Int 3Ah, Time of day
    58 00001A97 [A934000000000000]  <1>     dq ctrlbreak_io      ;Int 3Bh, user Break
    59 00001A9F [3358000000000000]  <1>     dq dummy_return_64   ;Int 3Ch, user IRQ0 hook
    60 00001AA7 [AB34000000000000]  <1>     dq scr_params_io     ;Int 3Dh, Screen Mode parameters return function
    61 00001AAF [B734000000000000]  <1>     dq disk_params_io    ;Int 3Eh, disk parameters return function
    62 00001AB7 [C934000000000000]  <1>     dq cga_ret_io        ;Int 3Fh, video extention return function
    63                              <1> IDT_TABLE_Length equ $ - IDT_TABLE
    74                                  seg0len equ ($ - $$)
    75                                  
    76                                  ;----------------------------------------------------------------
    77                                  ;                BIOS RESIDENT CODE AREA STARTS HERE            :
    78                                  ;----------------------------------------------------------------
    79                                  Segment codeResident follows=codeInit vfollows=data align=1 valign=1
    80                                  %include "./Source/Resident/Misc/Procs/common.asm"
     1                              <1> ;A file containing common procs
     2                              <1> 
     3                              <1> ;---------------------------------Procs--------------------------
     4                              <1> e820print:
     5 00000000 56                  <1>     push rsi
     6 00000001 52                  <1>     push rdx
     7 00000002 51                  <1>     push rcx
     8 00000003 53                  <1>     push rbx
     9 00000004 50                  <1>     push rax
    10 00000005 48BE-               <1>     mov rsi, bigmapptr
    10 00000007 [F005000000000000]  <1>
    11 0000000F 480FB61425-         <1>     movzx rdx, byte [bigmapSize]    ;Get the number of 24 byte entries
    11 00000014 [D5010000]          <1>
    12                              <1> .e0:
    13 00000018 48AD                <1>     lodsq
    14 0000001A E82D000000          <1>     call .printqword
    15 0000001F E845000000          <1>     call .printpipe
    16 00000024 48AD                <1>     lodsq
    17 00000026 E821000000          <1>     call .printqword
    18 0000002B E839000000          <1>     call .printpipe
    19 00000030 48AD                <1>     lodsq   
    20 00000032 E815000000          <1>     call .printqword
    21 00000037 E844000000          <1>     call .printcrlf
    22 0000003C 6631C0              <1>     xor ax, ax
    23 0000003F CD36                <1>     int 36h
    24 00000041 48FFCA              <1>     dec rdx
    25 00000044 75D2                <1>     jnz .e0
    26 00000046 58                  <1>     pop rax
    27 00000047 5B                  <1>     pop rbx
    28 00000048 59                  <1>     pop rcx
    29 00000049 5A                  <1>     pop rdx
    30 0000004A 5E                  <1>     pop rsi
    31 0000004B C3                  <1>     ret
    32                              <1> .printqword:
    33 0000004C 4889C3              <1>     mov rbx, rax
    34 0000004F 480FCB              <1>     bswap rbx
    35 00000052 48B908000000000000- <1>     mov rcx, 8
    35 0000005B 00                  <1>
    36                              <1> .pq1:
    37 0000005C 88D8                <1>     mov al, bl
    38 0000005E B404                <1>     mov ah, 04h
    39 00000060 CD30                <1>     int 30h
    40 00000062 48C1EB08            <1>     shr rbx, 8
    41 00000066 E2F4                <1>     loop .pq1
    42 00000068 C3                  <1>     ret
    43                              <1> .printpipe:
    44 00000069 55                  <1>     push rbp
    45 0000006A 48BD-               <1>     mov rbp, .pipestr
    45 0000006C [7C00000000000000]  <1>
    46 00000074 66B80413            <1>     mov ax, 1304h
    47 00000078 CD30                <1>     int 30h
    48 0000007A 5D                  <1>     pop rbp
    49 0000007B C3                  <1>     ret
    50 0000007C 207C2000            <1> .pipestr:   db " | ",0
    51                              <1> .printcrlf:
    52 00000080 55                  <1>     push rbp
    53 00000081 48BD-               <1>     mov rbp, .crlfstr
    53 00000083 [9300000000000000]  <1>
    54 0000008B 66B80413            <1>     mov ax, 1304h
    55 0000008F CD30                <1>     int 30h
    56 00000091 5D                  <1>     pop rbp
    57 00000092 C3                  <1>     ret
    58 00000093 0A0D00              <1> .crlfstr: db 0Ah,0Dh, 0
    59                              <1> beep:
    60                              <1> ;Destroys old PIT2 divisor.
    61                              <1> ;Input: 
    62                              <1> ;   bx = Frequency divisor to use for tone
    63                              <1> ;   rcx = # of ms to beep for
    64                              <1> ;All registers preserved
    65 00000096 50                  <1>     push rax
    66 00000097 B0B6                <1>     mov al, 0B6h ;Get PIT command bitfield, PIT2, lo/hi, Mode 3, Binary
    67 00000099 E643                <1>     out PITcommand, al
    68                              <1> 
    69 0000009B 6689D8              <1>     mov ax, bx       ;Move frequency divisor into ax
    70 0000009E E642                <1>     out PIT2, al     ;Output lo byte of divisor
    71 000000A0 88E0                <1>     mov al, ah
    72 000000A2 E642                <1>     out PIT2, al     ;Output hi byte of divisor
    73                              <1> 
    74 000000A4 E461                <1>     in al, port61h  ;Save original state of port 61h in ah
    75 000000A6 0C03                <1>     or al, 3        ;Set bits 0 and 1 to turn on the speaker
    76 000000A8 E661                <1>     out port61h, al
    77                              <1> 
    78 000000AA B486                <1>     mov ah, 86h     ;Wait for beep to complete
    79 000000AC CD35                <1>     int 35h
    80                              <1> 
    81 000000AE E461                <1>     in al, port61h    ;Read state of port 61h afresh
    82 000000B0 24FC                <1>     and al, ~3        ;Clear bits 0 and 1 to turn off the speaker
    83 000000B2 E661                <1>     out port61h, al
    84                              <1> 
    85 000000B4 58                  <1>     pop rax
    86 000000B5 C3                  <1>     ret
    87                              <1> 
    88                              <1> ps2wait:
    89 000000B6 50                  <1>     push rax
    90                              <1> .wnok:
    91 000000B7 EB00                <1>     jmp short $ + 2
    92 000000B9 E464                <1>     in al, ps2status
    93 000000BB A801                <1>     test al, 1    ;Can something be read from KB?
    94 000000BD 7406                <1>     jz .wok       ;Zero = no, so loop back. Not zero = proceed to check if 
    95                              <1>                   ; something can be written
    96 000000BF EB00                <1>     jmp short $ + 2
    97 000000C1 E460                <1>     in al, ps2data    ;Read it in
    98 000000C3 EBF2                <1>     jmp short .wnok
    99                              <1> .wok:
   100 000000C5 A802                <1>     test al, 2   ;Can something be written to KB?
   101 000000C7 75EE                <1>     jnz .wnok    ;Zero if yes and proceed.
   102 000000C9 58                  <1>     pop rax
   103 000000CA C3                  <1>     ret
   104                              <1>     
   105                              <1> idtWriteEntry:
   106                              <1> ;----------------------------------------------------------------
   107                              <1> ;This proc writes an interrupt handler to a particular IDT entry.
   108                              <1> ; rax = Interrupt handler ptr    (qword)
   109                              <1> ; rsi = Interrupt Number         (qword)
   110                              <1> ; dx = Attributes word           (word)
   111                              <1> ; bx = Segment selector          (word)
   112                              <1> ;On return:
   113                              <1> ; rsi incremented by 1
   114                              <1> ; Entry written
   115                              <1> ;----------------------------------------------------------------
   116 000000CB 56                  <1>     push rsi
   117 000000CC 48C1E604            <1>     shl rsi, 4h     ;Multiply IDT entry number by 16
   118 000000D0 48033425[04000000]  <1>     add rsi, qword [IDTpointer.Base]    ;rsx points to IDT entry
   119 000000D8 668906              <1>     mov word [rsi], ax  ;Get low word into offset 15...0
   120 000000DB 66895E02            <1>     mov word [rsi + 2], bx  ;Move segment selector into place
   121 000000DF 66895604            <1>     mov word [rsi + 4], dx  ;Move attribute word into place
   122 000000E3 48C1E810            <1>     shr rax, 10h    ;Bring next word low
   123 000000E7 66894606            <1>     mov word [rsi + 6], ax  ;Get low word into offset 31...16
   124 000000EB 48C1E810            <1>     shr rax, 10h    ;Bring last dword low
   125 000000EF 894608              <1>     mov dword [rsi + 8], eax
   126 000000F2 5E                  <1>     pop rsi
   127 000000F3 48FFC6              <1>     inc rsi         ;rsi contains number of next interrupt handler
   128 000000F6 C3                  <1>     ret
   129                              <1>     
   130                              <1> cls:    ;Clear the screen, bl attrib, always clear active scr
   131 000000F7 50                  <1>     push rax
   132 000000F8 52                  <1>     push rdx
   133 000000F9 B40F                <1>     mov ah, 0Fh
   134 000000FB CD30                <1>     int 30h ;Get current active page
   135                              <1> 
   136 000000FD B402                <1>     mov ah, 02h    ;Set cursor pos
   137 000000FF 6631D2              <1>     xor dx, dx
   138 00000102 CD30                <1>     int 30h
   139 00000104 88DF                <1>     mov bh, bl
   140                              <1> ;No need for coordinates since al=00 means reset fullscreen
   141 00000106 66B80006            <1>     mov ax, 0600h
   142 0000010A CD30                <1>     int 30h    ;scroll page with grey on black
   143 0000010C 5A                  <1>     pop rdx
   144 0000010D 58                  <1>     pop rax
   145 0000010E C3                  <1>     ret
    81                                  ;--------------------Interrupt Service routines------------------
    82                                  
    83                                  ;======================HARDWARE INTERRUPTS=======================
    84                                  %include "./Source/Resident/Hardware/Timers/pitInt.asm"
     1                              <1> ;----------------Timer Interrupt IRQ 0/Int 20h-------------------
     2                              <1> ;This interrupt simply increments an internal timer and 
     3                              <1> ; calls a software interrupt (5Ch) which can be used by user 
     4                              <1> ; applications.
     5                              <1> ;----------------------------------------------------------------
     6                              <1> timer_IRQ0:
     7 0000010F FB                  <1>     sti    
     8 00000110 50                  <1>     push rax
     9 00000111 FF0425[37010000]    <1>     inc dword [pit_ticks]
    10 00000118 8B0425[37010000]    <1>     mov eax, dword [pit_ticks]
    11 0000011F 25FFFF1F00          <1>     and eax, 1FFFFFh    ;Clear OF bit [mask on bits 20:0]
    12 00000124 3DB0001800          <1>     cmp eax, 1800B0h    ;Ticks in one full day
    13 00000129 7519                <1>     jnz .tret            ;Not quite there
    14 0000012B 66C70425[37010000]- <1>     mov word [pit_ticks], 0     ;Zero lo count
    14 00000133 0000                <1>
    15 00000135 C60425[39010000]00  <1>     mov byte [pit_ticks + 2], 0    ;Zero hi count
    16 0000013D FE0425[3A010000]    <1>     inc byte [pit_ticks + 3]    ;Increment day OF counter    
    17                              <1> .tret:
    18 00000144 CD3C                <1>     int 3Ch        ;Call user handler
    19                              <1> 
    20 00000146 B020                <1>     mov al, EOI
    21 00000148 E620                <1>     out pic1command, al
    22 0000014A E680                <1>     out waitp, al    ;allow one io cycle to run
    23                              <1> 
    24 0000014C 58                  <1>     pop rax
    25 0000014D 48CF                <1>     iretq
    26                              <1> ;-------------------------End of Interrupt-----------------------
    85                                  %include "./Source/Resident/Hardware/PS2/keybInt.asm"
     1                              <1> ;----------------Keyboard Interrupt IRQ 1/Int 21h----------------
     2                              <1> ;This interrupt takes scancodes from the PC keyboard, translates 
     3                              <1> ; them into scancode/ASCII char pair and stores the pair into 
     4                              <1> ; the buffer for the software keyboard interrupt to use.
     5                              <1> ;----------------------------------------------------------------
     6                              <1> kb_IRQ1:
     7 0000014F FB                  <1>     sti        ;Reenable interrupts
     8 00000150 50                  <1>     push rax
     9 00000151 53                  <1>     push rbx
    10 00000152 51                  <1>     push rcx
    11 00000153 57                  <1>     push rdi
    12 00000154 31C0                <1>     xor eax, eax
    13                              <1> 
    14                              <1> .k0:
    15 00000156 E460                <1>     in al, ps2data    ;Get the scancode (Set 1)
    16 00000158 85C0                <1>     test eax, eax    ;Check to see if we got an error code from the keyboard.
    17 0000015A 0F84AE020000        <1>     jz .kb_error
    18 00000160 483D80000000        <1>     cmp rax, 80h
    19 00000166 0F8ED8000000        <1>     jle .basickey    ;A normal keypress, nothing too magical.
    20 0000016C 483DE0000000        <1>     cmp rax, 0E0h    ;Compare against special keys
    21 00000172 7472                <1>     je .special_keys
    22 00000174 483DE1000000        <1>     cmp rax, 0E1h    ;Pause
    23 0000017A 747D                <1>     je .pause
    24 0000017C 483DAA000000        <1>     cmp rax, 0AAh    ;LShift released
    25 00000182 0F8490000000        <1>     je .lshift_released
    26 00000188 483DB6000000        <1>     cmp rax, 0B6h    ;RShift released
    27 0000018E 0F8488000000        <1>     je .rshift_released
    28 00000194 483DB8000000        <1>     cmp rax, 0B8h    ;Alt Shift released
    29 0000019A 7474                <1>     je .alt_shift_released
    30 0000019C 483D9D000000        <1>     cmp rax, 9Dh    ;Ctrl Shift released
    31 000001A2 7470                <1>     je .ctrl_shift_released
    32 000001A4 483DD2000000        <1>     cmp rax, 0D2h    ;Toggle Insert
    33 000001AA 7460                <1>     je .insert_released
    34 000001AC EB25                <1>     jmp short .kb1_exit    ;Just exit if something weird gets sent
    35                              <1> 
    36                              <1> .kb_store_in_buffer:
    37 000001AE 488B1C25[4A000000]  <1>     mov rbx, qword [kb_buf_tail]    ;point rbx to tail
    38 000001B6 4889DF              <1>     mov rdi, rbx ;Save bx in di for storing the data in AX after bx gets inc 
    39 000001B9 E826210000          <1>     call kb_io.kb_ptr_adv            ;safely advance the pointer
    40 000001BE 483B1C25[42000000]  <1>     cmp rbx, qword [kb_buf_head]    ;Have we wrapped around?
    41 000001C6 745F                <1>     je .kb_buf_full_beep            ;discard and beep
    42 000001C8 668907              <1>     mov word [rdi], ax                ;mov scancode/ascii pair into buffer
    43 000001CB 48891C25[4A000000]  <1>     mov qword [kb_buf_tail], rbx    ;store new pointer back into tail
    44                              <1> 
    45                              <1> .kb1_exit:
    46 000001D3 B0FC                <1>     mov al, ~(kb_flag2_e0 | kb_flag2_e1)        ;move the notted version into al
    47 000001D5 200425[64000000]    <1>     and byte [kb_flags_2], al        ;Nullify the e0 and e1 flag
    48                              <1> .kb1_exit_e0:
    49 000001DC B020                <1>     mov al, EOI
    50 000001DE E620                <1>     out pic1command, al    ;End of interrupt to pic1 command port
    51                              <1> 
    52 000001E0 5F                  <1>     pop rdi
    53 000001E1 59                  <1>     pop rcx
    54 000001E2 5B                  <1>     pop rbx
    55 000001E3 58                  <1>     pop rax
    56 000001E4 48CF                <1>     iretq
    57                              <1> 
    58                              <1> .special_keys:    ;An E0 process
    59 000001E6 B002                <1>     mov al, kb_flag2_e0         ;Set the bit for the flag
    60 000001E8 080425[64000000]    <1>     or byte [kb_flags_2], al    ;Set the flag
    61 000001EF 802425[64000000]FE  <1>     and byte [kb_flags_2], ~kb_flag2_e1    ;clear the E1 bit
    62 000001F7 EBE3                <1>     jmp short .kb1_exit_e0      ;Exit from IRQ without resetting flags 
    63                              <1> .pause:    ;An E1 process
    64 000001F9 B001                <1>     mov al, kb_flag2_e1         ;Set the bit for the flag
    65 000001FB 080425[64000000]    <1>     or byte [kb_flags_2], al    ;Toggle the flag, since 9D and C5 will be 
    66                              <1>                                 ; ignored by the Int handler
    67 00000202 802425[64000000]FD  <1>     and byte [kb_flags_2], ~kb_flag2_e0    ;clear the E0 bit
    68 0000020A EBD0                <1>     jmp short .kb1_exit_e0
    69                              <1> 
    70                              <1> .insert_released:
    71 0000020C B07F                <1>     mov al, ~kb_flag_insset     ;Flag negation
    72 0000020E EB0E                <1>     jmp short .shift_release_common
    73                              <1> .alt_shift_released:
    74 00000210 B0F7                <1>     mov al, ~kb_flag_alt        ;Flag negation
    75 00000212 EB0A                <1>     jmp short .shift_release_common
    76                              <1> .ctrl_shift_released:
    77 00000214 B0FB                <1>     mov al, ~kb_flag_ctrl       ;Flag negation
    78 00000216 EB06                <1>     jmp short .shift_release_common
    79                              <1> .lshift_released:
    80 00000218 B0FD                <1>     mov al, ~kb_flag_lshift     ;Flag negation
    81 0000021A EB02                <1>     jmp short .shift_release_common
    82                              <1> .rshift_released:
    83 0000021C B0FE                <1>     mov al, ~kb_flag_rshift     ;Flag negation
    84                              <1> .shift_release_common:
    85 0000021E 200425[62000000]    <1>     and byte [kb_flags], al     ;Clear the relevant bit
    86 00000225 EBAC                <1>     jmp short .kb1_exit
    87                              <1> 
    88                              <1> 
    89                              <1> .kb_buf_full_beep:
    90 00000227 53                  <1>     push rbx
    91 00000228 51                  <1>     push rcx
    92 00000229 BBA9040000          <1>     mov ebx, 04A9h ;Frequency divisor for 1000Hz tone
    93 0000022E 48B9F4010000000000- <1>     mov rcx, 500   ;Beep for a 1/2 second
    93 00000237 00                  <1>
    94 00000238 E859FEFFFF          <1>     call beep
    95 0000023D 59                  <1>     pop rcx
    96 0000023E 5B                  <1>     pop rbx
    97 0000023F E98FFFFFFF          <1>     jmp .kb1_exit
    98                              <1> 
    99                              <1> .basickey:          ;al contains the scancode
   100 00000244 483D46000000        <1>     cmp rax, 46h
   101 0000024A 0F8421010000        <1>     je .e0special   ;ctrl+break checker (E0 46h is make for break haha)
   102                              <1> .kbbk1:
   103 00000250 483D2A000000        <1>     cmp rax, 2Ah    ;Left Shift scancode
   104 00000256 0F84E4000000        <1>     je .lshift_pressed
   105 0000025C 483D36000000        <1>     cmp rax, 36h    ;Right Shift scancode
   106 00000262 0F84DC000000        <1>     je .rshift_pressed
   107 00000268 483D38000000        <1>     cmp rax, 38h    ;Alt Shift key scancode
   108 0000026E 0F84C4000000        <1>     je .alt_shift_pressed
   109 00000274 483D1D000000        <1>     cmp rax, 1Dh    ;Ctrl Shift key scancode
   110 0000027A 0F84BC000000        <1>     je .ctrl_shift_pressed
   111                              <1>     
   112 00000280 483D3A000000        <1>     cmp rax, 3Ah    ;Caps lock key
   113 00000286 0F84CA000000        <1>     je .caps_lock
   114 0000028C 483D45000000        <1>     cmp rax, 45h    ;Num lock key
   115 00000292 0F84C2000000        <1>     je .num_lock
   116                              <1> ;    cmp rax, 46h    ;Scroll lock key
   117                              <1> ;    je .scroll_lock
   118 00000298 483D52000000        <1>     cmp rax, 52h    ;Insert key pressed
   119 0000029E 0F84AE000000        <1>     je .ins_toggle    
   120 000002A4 483D53000000        <1>     cmp rax, 53h    ;Delete key, for CTRL+ALT+DEL
   121 000002AA 0F8408010000        <1>     je .ctrl_alt_del
   122                              <1> .keylookup:
   123 000002B0 48BB-               <1>     mov rbx, .kb_sc_ascii_lookup
   123 000002B2 [4B04000000000000]  <1>
   124                              <1>                     ; upper 7 bytes of rax are completely clear
   125 000002BA 66C1E004            <1>     shl ax, 4       ;multiply ax, the scancode, by 16, to offset to correct row
   126 000002BE 4801C3              <1>     add rbx, rax    ;offset rbx to the correct row
   127                              <1> ;Now check shift states, to align with column. rax is free again
   128 000002C1 8A0425[62000000]    <1>     mov al, byte [kb_flags]
   129                              <1> 
   130 000002C8 A802                <1>     test al, kb_flag_lshift
   131 000002CA 7525                <1>     jnz .addshiftvalue            ;If that bit is set, jump!
   132 000002CC A801                <1>     test al, kb_flag_rshift
   133 000002CE 7521                <1>     jnz .addshiftvalue
   134 000002D0 A804                <1>     test al, kb_flag_ctrl
   135 000002D2 752E                <1>     jnz .addctrlvalue
   136 000002D4 A808                <1>     test al, kb_flag_alt
   137 000002D6 7533                <1>     jnz .addaltvalue
   138 000002D8 A820                <1>     test al, kb_flag_numset
   139 000002DA 7538                <1>     jnz .addnumvalue
   140 000002DC A840                <1>     test al, kb_flag_capsset
   141 000002DE 753D                <1>     jnz .addcapsvalue
   142                              <1> 
   143                              <1> .keyget:
   144 000002E0 668B03              <1>     mov ax, word [rbx] ;Get correct word into ax!
   145 000002E3 6685C0              <1>     test ax, ax        ;check if the value is zero, if so, dont store in buffer
   146 000002E6 0F84E7FEFFFF        <1>     jz .kb1_exit
   147 000002EC E9BDFEFFFF          <1>     jmp .kb_store_in_buffer
   148                              <1> 
   149                              <1> .addshiftvalue:    ;first check if we shift with caps or num
   150 000002F1 A820                <1>     test al, kb_flag_numset
   151 000002F3 753A                <1>     jnz .addshiftnum
   152 000002F5 A840                <1>     test al, kb_flag_capsset
   153 000002F7 752D                <1>     jnz .addshiftcaps
   154                              <1>     ;Collapse through, it is just shift, add 2 to rbx
   155 000002F9 4881C302000000      <1>     add rbx, 1h*2h
   156 00000300 EBDE                <1>     jmp short .keyget
   157                              <1> .addctrlvalue:
   158 00000302 4881C304000000      <1>     add rbx, 2h*2h
   159 00000309 EBD5                <1>     jmp short .keyget
   160                              <1> .addaltvalue:
   161 0000030B 4881C306000000      <1>     add rbx, 3h*2h
   162 00000312 EBCC                <1>     jmp short .keyget
   163                              <1> .addnumvalue:
   164 00000314 4881C308000000      <1>     add rbx, 4h*2h
   165 0000031B EBC3                <1>     jmp short .keyget
   166                              <1> .addcapsvalue:
   167 0000031D 4881C30A000000      <1>     add rbx, 5h*2h
   168 00000324 EBBA                <1>     jmp short .keyget
   169                              <1> .addshiftcaps:
   170 00000326 4881C30C000000      <1>     add rbx, 6h*2h
   171 0000032D EBB1                <1>     jmp short .keyget
   172                              <1> .addshiftnum:
   173 0000032F 4881C30E000000      <1>     add rbx, 7h*2h
   174 00000336 EBA8                <1>     jmp short .keyget
   175                              <1> 
   176                              <1> .alt_shift_pressed:
   177 00000338 B008                <1>     mov al, kb_flag_alt
   178 0000033A EB0A                <1>     jmp short .shift_pressed_common
   179                              <1> .ctrl_shift_pressed:
   180 0000033C B004                <1>     mov al, kb_flag_ctrl
   181 0000033E EB06                <1>     jmp short .shift_pressed_common
   182                              <1> .lshift_pressed:
   183 00000340 B002                <1>     mov al, kb_flag_lshift
   184 00000342 EB02                <1>     jmp short .shift_pressed_common
   185                              <1> .rshift_pressed:
   186 00000344 B001                <1>     mov al, kb_flag_rshift
   187                              <1> .shift_pressed_common:
   188 00000346 080425[62000000]    <1>     or byte [kb_flags], al    ;toggle flag bits
   189 0000034D E981FEFFFF          <1>     jmp .kb1_exit             ;Exit
   190                              <1> 
   191                              <1> .ins_toggle:
   192 00000352 B080                <1>     mov al, kb_flag_insset
   193 00000354 EB0A                <1>     jmp short .lock_common
   194                              <1> .caps_lock:
   195 00000356 B040                <1>     mov al, kb_flag_capsset
   196 00000358 EB06                <1>     jmp short .lock_common
   197                              <1> .num_lock:
   198 0000035A B020                <1>     mov al, kb_flag_numset
   199 0000035C EB02                <1>     jmp short .lock_common
   200                              <1> .scroll_lock:
   201 0000035E B010                <1>     mov al, kb_flag_scrlset
   202                              <1> .lock_common:
   203 00000360 300425[62000000]    <1>     xor byte [kb_flags], al    ;toggle bit
   204 00000367 E883000000          <1>     call .set_kb_lights
   205 0000036C E962FEFFFF          <1>     jmp .kb1_exit
   206                              <1> 
   207                              <1> .e0special:
   208 00000371 F60425[64000000]02  <1>     test byte [kb_flags_2], 00000010b    ;Check for E0 set
   209 00000379 7505                <1>     jnz .ctrl_break
   210 0000037B E9DEFFFFFF          <1>     jmp .scroll_lock    ;Assume scroll lock set
   211                              <1> .ctrl_break:
   212 00000380 800C25[65000000]01  <1>     or byte [break_flag], 1        ;set break_flag
   213 00000388 6631C0              <1>     xor ax, ax
   214 0000038B 53                  <1>     push rbx
   215 0000038C 48BB-               <1>     mov rbx, kb_buffer            ;mov the buffer addr to rbx
   215 0000038E [2200000000000000]  <1>
   216 00000396 48891C25[42000000]  <1>     mov qword [kb_buf_head], rbx
   217 0000039E 48891C25[4A000000]  <1>     mov qword [kb_buf_tail], rbx
   218 000003A6 668903              <1>     mov word [rbx], ax    ;Store zero as the first two bytes of the
   219 000003A9 5B                  <1>     pop rbx
   220 000003AA CD3B                <1>     int 3Bh                      ;Call the CTRL+Break handler
   221 000003AC 200425[65000000]    <1>     and byte [break_flag], al    ;clear break_flag
   222 000003B3 E91BFEFFFF          <1>     jmp .kb1_exit        ;return clearing E0
   223                              <1> 
   224                              <1> .ctrl_alt_del:
   225 000003B8 50                  <1>     push rax    ;save scancode
   226 000003B9 8A0425[64000000]    <1>     mov al, byte [kb_flags_2]
   227 000003C0 A802                <1>     test al, kb_flag2_e0    ;Delete scancode is E0, 53, check if we first had E0
   228 000003C2 7425                <1>     jz .ctrl_alt_del_no_reset
   229                              <1> 
   230 000003C4 8A0425[62000000]    <1>     mov al, byte [kb_flags]
   231 000003CB 240C                <1>     and al,  kb_flag_ctrl | kb_flag_alt
   232 000003CD 3C0C                <1>     cmp al, kb_flag_ctrl | kb_flag_alt    ;Test if Ctrl + Alt is being pressed
   233 000003CF 7518                <1>     jne .ctrl_alt_del_no_reset
   234                              <1>     ;Nuke IDT and tightloop until the CPU triple faults
   235 000003D1 0F011C25[DF030000]  <1>     lidt [.ctrl_alt_del_reset_idt] ;Triple fault the machine
   236 000003D9 EB00                <1>     jmp short .ctrl_alt_del_to_hell
   237                              <1> .ctrl_alt_del_to_hell:
   238 000003DB CD00                <1>     int 00h ;Call div by 0 to trigger reboot if not somehow failed yet
   239 000003DD EBFC                <1>     jmp short .ctrl_alt_del_to_hell
   240                              <1> .ctrl_alt_del_reset_idt:
   241 000003DF 0000                <1>     dw 0
   242 000003E1 0000000000000000    <1>     dq 0
   243                              <1> .ctrl_alt_del_no_reset:
   244 000003E9 58                  <1>     pop rax        ;return the OG scancode and proceed as normal
   245 000003EA E9C1FEFFFF          <1>     jmp .keylookup
   246                              <1> 
   247                              <1> 
   248                              <1> .set_kb_lights:
   249 000003EF 50                  <1>     push rax
   250                              <1> 
   251 000003F0 E8C1FCFFFF          <1>     call ps2wait
   252                              <1> 
   253 000003F5 B0ED                <1>     mov al, 0EDh
   254 000003F7 E660                <1>     out ps2data, al
   255                              <1> 
   256 000003F9 E8B8FCFFFF          <1>     call ps2wait
   257                              <1>     
   258 000003FE 8A0425[62000000]    <1>     mov al, byte [kb_flags]    ;get flag into al
   259 00000405 C0E804              <1>     shr al, 4
   260 00000408 2407                <1>     and al, 111b    ;mask Insert bit off to isolate the NUM,CAPS,SCRL status 
   261                              <1>                     ; bits <=> LED status.
   262 0000040A E660                <1>     out ps2data, al    ;send the led status away
   263                              <1> 
   264 0000040C 58                  <1>     pop rax
   265 0000040D C3                  <1>     ret
   266                              <1> 
   267                              <1> .kb_error:     ;If error recieved from Keyboard, hang the system, cold reboot 
   268                              <1>                ; needed.
   269 0000040E FA                  <1>     cli        ;Disable interrupts/Further keystrokes
   270 0000040F 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   271 00000413 E8DFFCFFFF          <1>     call cls    ;clear the screen
   272 00000418 66B80413            <1>     mov ax, 1304h
   273 0000041C 30FF                <1>     xor bh, bh
   274 0000041E 48BD-               <1>     mov rbp, .kb_error_msg
   274 00000420 [2E04000000000000]  <1>
   275 00000428 CD30                <1>     int 30h
   276                              <1> .kber1:
   277 0000042A F390                <1>     pause
   278 0000042C EBFC                <1>     jmp short .kber1
   279 0000042E 4B6579626F61726420- <1> .kb_error_msg:    db    "Keyboard Error. Halting...", 0Ah, 0Dh, 0
   279 00000437 4572726F722E204861- <1>
   279 00000440 6C74696E672E2E2E0A- <1>
   279 00000449 0D00                <1>
   280                              <1> 
   281                              <1> .kb_sc_ascii_lookup:    ;Scancodes 00h-58h
   282                              <1> ; Scancodes 00h-0Fh
   283                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   284 0000044B 000000000000000000- <1>  dw 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h ;NUL
   284 00000454 00000000000000      <1>
   285 0000045B 1B011B011B011B011B- <1>  dw 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh ;Esc
   285 00000464 011B011B011B01      <1>
   286 0000046B 310221020000007831- <1>  dw 0231h, 0221h, 0000h, 7800h, 0231h, 0231h, 0221h, 0221h ;1 !
   286 00000474 02310221022102      <1>
   287 0000047B 320322030003007932- <1>  dw 0332h, 0322h, 0300h, 7900h, 0332h, 0332h, 0322h, 0322h ;2 "
   287 00000484 03320322032203      <1>
   288 0000048B 33049C040000007A33- <1>  dw 0433h, 049Ch, 0000h, 7A00h, 0433h, 0433h, 049Ch, 049Ch ;3 
   288 00000494 0433049C049C04      <1>
   289 0000049B 340524050000007B34- <1>  dw 0534h, 0524h, 0000h, 7B00h, 0534h, 0534h, 0524h, 0524h ;4 $
   289 000004A4 05340524052405      <1>
   290 000004AB 350625060000007C35- <1>  dw 0635h, 0625h, 0000h, 7C00h, 0635h, 0635h, 0625h, 0625h ;5 %
   290 000004B4 06350625062506      <1>
   291 000004BB 36075E071E07007D36- <1>  dw 0736h, 075Eh, 071Eh, 7D00h, 0736h, 0736h, 075Eh, 075Eh ;6 ^
   291 000004C4 0736075E075E07      <1>
   292 000004CB 370826080000007E37- <1>  dw 0837h, 0826h, 0000h, 7E00h, 0837h, 0837h, 0826h, 0826h ;7 &
   292 000004D4 08370826082608      <1>
   293 000004DB 38092A090000007F38- <1>  dw 0938h, 092Ah, 0000h, 7F00h, 0938h, 0938h, 092Ah, 092Ah ;8 *
   293 000004E4 0938092A092A09      <1>
   294 000004EB 390A280A0000008039- <1>  dw 0A39h, 0A28h, 0000h, 8000h, 0A39h, 0A39h, 0A28h, 0A28h ;9 (
   294 000004F4 0A390A280A280A      <1>
   295 000004FB 300B290B0000008130- <1>  dw 0B30h, 0B29h, 0000h, 8100h, 0B30h, 0B30h, 0B29h, 0B29h ;0 )
   295 00000504 0B300B290B290B      <1>
   296 0000050B 2D0C5F0C000000822D- <1>  dw 0C2Dh, 0C5Fh, 0000h, 8200h, 0C2Dh, 0C2Dh, 0C5Fh, 0C5Fh ;- _
   296 00000514 0C2D0C5F0C5F0C      <1>
   297 0000051B 3D0D2B0D000000833D- <1>  dw 0D3Dh, 0D2Bh, 0000h, 8300h, 0D3Dh, 0D3Dh, 0D2Bh, 0D2Bh ;= +
   297 00000524 0D3D0D2B0D2B0D      <1>
   298 0000052B 080E080E7F0E000008- <1>  dw 0E08h, 0E08h, 0E7Fh, 0000h, 0E08h, 0E08h, 0E08h, 0E08h ;bksp (ctrl -> del)
   298 00000534 0E080E080E080E      <1>
   299 0000053B 090F000F0000000009- <1>  dw 0F09h, 0F00h, 0000h, 0000h, 0F09h, 0F09h, 0F00h, 0F00h ;L2R Horizontal Tab
   299 00000544 0F090F000F000F      <1>
   300                              <1> 
   301                              <1> ; Scancodes 10h-1Fh
   302                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   303 0000054B 711051101110001071- <1>  dw 1071h, 1051h, 1011h, 1000h, 1071h, 1051h, 1071h, 1051h ;q Q
   303 00000554 10511071105110      <1>
   304 0000055B 771157111711001177- <1>  dw 1177h, 1157h, 1117h, 1100h, 1177h, 1157h, 1177h, 1157h ;w W
   304 00000564 11571177115711      <1>
   305 0000056B 651245120512001265- <1>  dw 1265h, 1245h, 1205h, 1200h, 1265h, 1245h, 1265h, 1245h ;e E
   305 00000574 12451265124512      <1>
   306 0000057B 721352131213001372- <1>  dw 1372h, 1352h, 1312h, 1300h, 1372h, 1352h, 1372h, 1352h ;r R
   306 00000584 13521372135213      <1>
   307 0000058B 741454141414001474- <1>  dw 1474h, 1454h, 1414h, 1400h, 1474h, 1454h, 1474h, 1454h ;t T
   307 00000594 14541474145414      <1>
   308 0000059B 791559151915001579- <1>  dw 1579h, 1559h, 1519h, 1500h, 1579h, 1559h, 1579h, 1559h ;y Y
   308 000005A4 15591579155915      <1>
   309 000005AB 751655161516001675- <1>  dw 1675h, 1655h, 1615h, 1600h, 1675h, 1655h, 1675h, 1655h ;u U
   309 000005B4 16551675165516      <1>
   310 000005BB 691749170917001769- <1>  dw 1769h, 1749h, 1709h, 1700h, 1769h, 1749h, 1769h, 1749h ;i I
   310 000005C4 17491769174917      <1>
   311 000005CB 6F184F180F1800186F- <1>  dw 186Fh, 184Fh, 180Fh, 1800h, 186Fh, 184Fh, 186Fh, 184Fh ;o O
   311 000005D4 184F186F184F18      <1>
   312 000005DB 701950191019001970- <1>  dw 1970h, 1950h, 1910h, 1900h, 1970h, 1950h, 1970h, 1950h ;p P
   312 000005E4 19501970195019      <1>
   313 000005EB 5B1A7B1A1B1A00005B- <1>  dw 1A5Bh, 1A7Bh, 1A1Bh, 0000h, 1A5Bh, 1A5Bh, 1A7Bh, 1A7Bh ;[ {
   313 000005F4 1A5B1A7B1A7B1A      <1>
   314 000005FB 5D1B7D1B1D1B00005D- <1>  dw 1B5Dh, 1B7Dh, 1B1Dh, 0000h, 1B5Dh, 1B5Dh, 1B7Dh, 1B7Dh ;] }
   314 00000604 1B5D1B7D1B7D1B      <1>
   315 0000060B 0D1C0D1C0A1C00000D- <1>  dw 1C0Dh, 1C0Dh, 1C0Ah, 0000h, 1C0Dh, 1C0Dh, 1C0Ah, 1C0Ah ;Enter (CR/LF)
   315 00000614 1C0D1C0A1C0A1C      <1>
   316 0000061B 001D001D001D001D00- <1>  dw 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h ;CTRL (left)
   316 00000624 1D001D001D001D      <1>
   317 0000062B 611E411E011E001E61- <1>  dw 1E61h, 1E41h, 1E01h, 1E00h, 1E61h, 1E41h, 1E61h, 1E41h ;a A
   317 00000634 1E411E611E411E      <1>
   318 0000063B 731F531F131F001F73- <1>  dw 1F73h, 1F53h, 1F13h, 1F00h, 1F73h, 1F53h, 1F73h, 1F53h ;s S
   318 00000644 1F531F731F531F      <1>
   319                              <1> 
   320                              <1> ; Scancodes 20h-2Fh
   321                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   322 0000064B 642044200420002064- <1>  dw 2064h, 2044h, 2004h, 2000h, 2064h, 2044h, 2064h, 2044h ;d D
   322 00000654 20442064204420      <1>
   323 0000065B 662146210621002166- <1>  dw 2166h, 2146h, 2106h, 2100h, 2166h, 2146h, 2166h, 2146h ;f F
   323 00000664 21462166214621      <1>
   324 0000066B 672247220722002267- <1>  dw 2267h, 2247h, 2207h, 2200h, 2267h, 2247h, 2267h, 2247h ;g G
   324 00000674 22472267224722      <1>
   325 0000067B 682348230823002368- <1>  dw 2368h, 2348h, 2308h, 2300h, 2368h, 2348h, 2368h, 2348h ;h H
   325 00000684 23482368234823      <1>
   326 0000068B 6A244A240A2400246A- <1>  dw 246Ah, 244Ah, 240Ah, 2400h, 246Ah, 244Ah, 246Ah, 244Ah ;j J
   326 00000694 244A246A244A24      <1>
   327 0000069B 6B254B250B2500256B- <1>  dw 256Bh, 254Bh, 250Bh, 2500h, 256Bh, 254Bh, 256Bh, 254Bh ;k K
   327 000006A4 254B256B254B25      <1>
   328 000006AB 6C264C260C2600266C- <1>  dw 266Ch, 264Ch, 260Ch, 2600h, 266Ch, 264Ch, 266Ch, 264Ch ;l L
   328 000006B4 264C266C264C26      <1>
   329 000006BB 3B273A27000000003B- <1>  dw 273Bh, 273Ah, 0000h, 0000h, 273Bh, 273Bh, 273Ah, 273Ah ;; :
   329 000006C4 273B273A273A27      <1>
   330 000006CB 272840280000000027- <1>  dw 2827h, 2840h, 0000h, 0000h, 2827h, 2827h, 2840h, 2840h ;' @
   330 000006D4 28272840284028      <1>
   331 000006DB 5C297C29000000005C- <1>  dw 295Ch, 297Ch, 0000h, 0000h, 295Ch, 295Ch, 297Ch, 297Ch ;\ |
   331 000006E4 295C297C297C29      <1>
   332 000006EB 002A002A002A002A00- <1>  dw 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h ;LShift (2Ah)
   332 000006F4 2A002A002A002A      <1>
   333 000006FB 232B7E2B1C2B000023- <1>  dw 2B23h, 2B7Eh, 2B1Ch, 0000h, 2B23h, 2B23h, 2B7Eh, 2B7Eh ;# ~
   333 00000704 2B232B7E2B7E2B      <1>
   334 0000070B 7A2C5A2C1A2C002C7A- <1>  dw 2C7Ah, 2C5Ah, 2C1Ah, 2C00h, 2C7Ah, 2C5Ah, 2C7Ah, 2C5Ah ;z Z
   334 00000714 2C5A2C7A2C5A2C      <1>
   335 0000071B 782D582D182D002D78- <1>  dw 2D78h, 2D58h, 2D18h, 2D00h, 2D78h, 2D58h, 2D78h, 2D58h ;x X
   335 00000724 2D582D782D582D      <1>
   336 0000072B 632E432E032E002E63- <1>  dw 2E63h, 2E43h, 2E03h, 2E00h, 2E63h, 2E43h, 2E63h, 2E43h ;c C
   336 00000734 2E432E632E432E      <1>
   337 0000073B 762F562F162F002F76- <1>  dw 2F76h, 2F56h, 2F16h, 2F00h, 2F76h, 2F56h, 2F76h, 2F56h ;v V
   337 00000744 2F562F762F562F      <1>
   338                              <1> 
   339                              <1> ; Scancodes 30h-3Fh
   340                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   341 0000074B 623042300230003062- <1>  dw 3062h, 3042h, 3002h, 3000h, 3062h, 3042h, 3062h, 3042h ;b B
   341 00000754 30423062304230      <1>
   342 0000075B 6E314E310E3100316E- <1>  dw 316Eh, 314Eh, 310Eh, 3100h, 316Eh, 314Eh, 316Eh, 314Eh ;n N
   342 00000764 314E316E314E31      <1>
   343 0000076B 6D324D320D3200326D- <1>  dw 326Dh, 324Dh, 320Dh, 3200h, 326Dh, 324Dh, 326Dh, 324Dh ;m M
   343 00000774 324D326D324D32      <1>
   344 0000077B 2C333C33000000002C- <1>  dw 332Ch, 333Ch, 0000h, 0000h, 332Ch, 332Ch, 333Ch, 333Ch ;, <
   344 00000784 332C333C333C33      <1>
   345 0000078B 2E343E34000000002E- <1>  dw 342Eh, 343Eh, 0000h, 0000h, 342Eh, 342Eh, 343Eh, 343Eh ;. >
   345 00000794 342E343E343E34      <1>
   346 0000079B 2F353F35000000002F- <1>  dw 352Fh, 353Fh, 0000h, 0000h, 352Fh, 352Fh, 353Fh, 353Fh ;/ ?
   346 000007A4 352F353F353F35      <1>
   347 000007AB 003600360036003600- <1>  dw 3600h, 3600h, 3600h, 3600h, 3600h, 3600h, 3600h, 3600h ;RShift
   347 000007B4 36003600360036      <1>
   348 000007BB 2A370000103700002A- <1>  dw 372Ah, 0000h, 3710h, 0000h, 372Ah, 372Ah, 0000h, 0000h ;KP *
   348 000007C4 372A3700000000      <1>
   349 000007CB 003800380038003800- <1>  dw 3800h, 3800h, 3800h, 3800h, 3800h, 3800h, 3800h, 3800h ;Alt
   349 000007D4 38003800380038      <1>
   350 000007DB 203920390039000020- <1>  dw 3920h, 3920h, 3900h, 0000h, 3920h, 3920h, 3920h, 3920h ;Space
   350 000007E4 39203920392039      <1>
   351 000007EB 003A003A003A003A00- <1>  dw 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h ;Caps Lock
   351 000007F4 3A003A003A003A      <1>
   352 000007FB 003B0054005E006800- <1>  dw 3B00h, 5400h, 5E00h, 6800h, 3B00h, 3B00h, 5400h, 5400h ;F1
   352 00000804 3B003B00540054      <1>
   353 0000080B 003C0055005F006900- <1>  dw 3C00h, 5500h, 5F00h, 6900h, 3C00h, 3C00h, 5500h, 5500h ;F2
   353 00000814 3C003C00550055      <1>
   354 0000081B 003D00560060006A00- <1>  dw 3D00h, 5600h, 6000h, 6A00h, 3D00h, 3D00h, 5600h, 5600h ;F3
   354 00000824 3D003D00560056      <1>
   355 0000082B 003E00570061006B00- <1>  dw 3E00h, 5700h, 6100h, 6B00h, 3E00h, 3E00h, 5700h, 5700h ;F4
   355 00000834 3E003E00570057      <1>
   356 0000083B 003F00580062006C00- <1>  dw 3F00h, 5800h, 6200h, 6C00h, 3F00h, 3F00h, 5800h, 5800h ;F5
   356 00000844 3F003F00580058      <1>
   357                              <1> 
   358                              <1> ; Scancodes 40h-4Fh
   359                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   360 0000084B 004000590063006D00- <1>  dw 4000h, 5900h, 6300h, 6D00h, 4000h, 4000h, 5900h, 5900h ;F6
   360 00000854 40004000590059      <1>
   361 0000085B 0041005A0064006E00- <1>  dw 4100h, 5A00h, 6400h, 6E00h, 4100h, 4100h, 5A00h, 5A00h ;F7
   361 00000864 410041005A005A      <1>
   362 0000086B 0042005B0065006F00- <1>  dw 4200h, 5B00h, 6500h, 6F00h, 4200h, 4200h, 5B00h, 5B00h ;F8
   362 00000874 420042005B005B      <1>
   363 0000087B 0043005C0066007000- <1>  dw 4300h, 5C00h, 6600h, 7000h, 4300h, 4300h, 5C00h, 5C00h ;F9
   363 00000884 430043005C005C      <1>
   364 0000088B 0044005D0067007100- <1>  dw 4400h, 5D00h, 6700h, 7100h, 4400h, 4400h, 5D00h, 5D00h ;F10
   364 00000894 440044005D005D      <1>
   365 0000089B 004500450045004500- <1>  dw 4500h, 4500h, 4500h, 4500h, 4500h, 4500h, 4500h, 4500h ;Num Lock
   365 000008A4 45004500450045      <1>
   366 000008AB 004600460046004600- <1>  dw 4600h, 4600h, 4600h, 4600h, 4600h, 4600h, 4600h, 4600h ;Scroll Lock
   366 000008B4 46004600460046      <1>
   367 000008BB 004737470077000037- <1>  dw 4700h, 4737h, 7700h, 0000h, 4737h, 4700h, 4737h, 4700h ;(KP)Home
   367 000008C4 47004737470047      <1>
   368 000008CB 004838480000000038- <1>  dw 4800h, 4838h, 0000h, 0000h, 4838h, 4800h, 4838h, 4800h ;(KP)Up arrow
   368 000008D4 48004838480048      <1>
   369 000008DB 004939490084000039- <1>  dw 4900h, 4939h, 8400h, 0000h, 4939h, 4900h, 4939h, 4900h ;(KP)PgUp 
   369 000008E4 49004939490049      <1>
   370 000008EB 2D4A2D4A000000002D- <1>  dw 4A2Dh, 4A2Dh, 0000h, 0000h, 4A2Dh, 4A2Dh, 4A2Dh, 4A2Dh ;(KP)-
   370 000008F4 4A2D4A2D4A2D4A      <1>
   371 000008FB 004B344B0073000034- <1>  dw 4B00h, 4B34h, 7300h, 0000h, 4B34h, 4B00h, 4B34h, 4B00h ;(KP)Left arrow
   371 00000904 4B004B344B004B      <1>
   372 0000090B 004C354C0000000035- <1>  dw 4C00h, 4C35h, 0000h, 0000h, 4C35h, 4C00h, 4C35h, 4C00h ;(KP)Center
   372 00000914 4C004C354C004C      <1>
   373 0000091B 004D364D0074000036- <1>  dw 4D00h, 4D36h, 7400h, 0000h, 4D36h, 4D00h, 4D36h, 4D00h ;(KP)Right arrow
   373 00000924 4D004D364D004D      <1>
   374 0000092B 2B4E2B4E000000002B- <1>  dw 4E2Bh, 4E2Bh, 0000h, 0000h, 4E2Bh, 4E2Bh, 4E2Bh, 4E2Bh ;(KP)+
   374 00000934 4E2B4E2B4E2B4E      <1>
   375 0000093B 004F314F0075000031- <1>  dw 4F00h, 4F31h, 7500h, 0000h, 4F31h, 4F00h, 4F31h, 4F00h ;(KP)End
   375 00000944 4F004F314F004F      <1>
   376                              <1> 
   377                              <1> ; Scancodes 50h-58h
   378                              <1> ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
   379 0000094B 005032500000000032- <1>  dw 5000h, 5032h, 0000h, 0000h, 5032h, 5000h, 5032h, 5000h ;(KB)Down arrow
   379 00000954 50005032500050      <1>
   380 0000095B 005133510076000033- <1>  dw 5100h, 5133h, 7600h, 0000h, 5133h, 5100h, 5133h, 5100h ;(KB)PgDn
   380 00000964 51005133510051      <1>
   381 0000096B 005230520000000030- <1>  dw 5200h, 5230h, 0000h, 0000h, 5230h, 5200h, 5230h, 5200h ;(KB)Ins
   381 00000974 52005230520052      <1>
   382 0000097B 00532E53000000002E- <1>  dw 5300h, 532Eh, 0000h, 0000h, 532Eh, 5300h, 532Eh, 5300h ;(KB)Del
   382 00000984 5300532E530053      <1>
   383 0000098B 005400540054005400- <1>  dw 5400h, 5400h, 5400h, 5400h, 5400h, 5400h, 5400h, 5400h ;ALT+PRTSC -> Sysreq
   383 00000994 54005400540054      <1>
   384 0000099B 000000000000000000- <1>  dw 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h ;xxxxNOTUSEDxxxx
   384 000009A4 00000000000000      <1>
   385 000009AB 5C567C56000000005C- <1>  dw 565Ch, 567Ch, 0000h, 0000h, 565Ch, 565Ch, 567Ch, 567Ch ;\ |
   385 000009B4 565C567C567C56      <1>
   386 000009BB 005700000000000000- <1>  dw 5700h, 0000h, 0000h, 0000h, 5700h, 5700h, 0000h, 0000h ;F11
   386 000009C4 57005700000000      <1>
   387 000009CB 005800000000000000- <1>  dw 5800h, 0000h, 0000h, 0000h, 5800h, 5800h, 0000h, 0000h ;F12
   387 000009D4 58005800000000      <1>
   388                              <1> ;------------------------End of Interrupt------------------------
    86                                  %include "./Source/Resident/Hardware/Serial/serInt.asm"
     1                              <1> ;------------------Serial Interrupt IRQ 3/Int 23h----------------
     2                              <1> ;Serves serial ports 1 and 3 should they exist. Only considers 
     3                              <1> ; data recieving. Disregards all sending data interrupts.
     4                              <1> ;Puts recieved data into respective buffer and clears RTS 
     5                              <1> ; (base+5) if buffer full.
     6                              <1> ;----------------------------------------------------------------
     7                              <1> ser_IRQ3:
     8 000009DB FA                  <1>     cli
     9 000009DC 50                  <1>     push rax
    10 000009DD 52                  <1>     push rdx
    11 000009DE 55                  <1>     push rbp
    12 000009DF 51                  <1>     push rcx
    13 000009E0 57                  <1>     push rdi
    14 000009E1 53                  <1>     push rbx
    15                              <1> 
    16 000009E2 BB08000000          <1>     mov ebx, 8
    17 000009E7 66BAFA02            <1>     mov dx, com2_base + 2 ;Interrupt ID register
    18 000009EB EB10                <1>     jmp short ser_common
    19                              <1> ;------------------------End of Interrupt------------------------
    20                              <1> ;---------------------Serial Interrupt IRQ 3/Int 23h-------------
    21                              <1> ;Serves serial ports 1 and 3 should they exist. Only considers 
    22                              <1> ; data recieving. Disregards all sending data interrupts.
    23                              <1> ;Puts recieved data into respective buffer and clears RTS 
    24                              <1> ; (base+5) if buffer full.
    25                              <1> ;----------------------------------------------------------------
    26                              <1> ser_IRQ4:
    27 000009ED FA                  <1>     cli
    28 000009EE 50                  <1>     push rax
    29 000009EF 52                  <1>     push rdx
    30 000009F0 55                  <1>     push rbp
    31 000009F1 51                  <1>     push rcx
    32 000009F2 57                  <1>     push rdi
    33 000009F3 53                  <1>     push rbx
    34                              <1> 
    35 000009F4 BB06000000          <1>     mov ebx, 6
    36 000009F9 66BAFA03            <1>     mov dx, com1_base + 2 ;Interrupt ID register
    37                              <1> ser_common:
    38 000009FD EC                  <1>     in al, dx
    39 000009FE A801                <1>     test al, 1    ;Check if bit zero is clear ie interrupt pending
    40 00000A00 741F                <1>     jz .si1       ;Clear, interrupt pending on COM 1 port
    41                              <1> .si0:
    42 00000A02 668B93[67000000]    <1>     mov dx, word [com_addresses + rbx] ;now point to HI COM Interrupt ID registr
    43 00000A09 6685D2              <1>     test dx, dx
    44 00000A0C 0F8497000000        <1>     jz .siexit            ;Nothing here, exit
    45 00000A12 66FFC2              <1>     inc dx
    46 00000A15 66FFC2              <1>     inc dx                ;dx = base + 2
    47 00000A18 EC                  <1>     in al, dx
    48 00000A19 A801                <1>     test al, 1     ;Check if bit zero is clear
    49 00000A1B 0F8588000000        <1>     jnz .siexit    ;Bad behavior, or no Int on com3 after com1 processed, exit
    50                              <1> .si1:
    51                              <1> ;Confirm Data available Interrupt (ie bits 1,2,3 are 010b)
    52 00000A21 A804                <1>     test al, 00000100b
    53 00000A23 0F8480000000        <1>     jz .siexit   ;bad behavior, exit
    54 00000A29 6681C20300          <1>     add dx, 3    ;dx = base + 5
    55                              <1> .si41:
    56 00000A2E EC                  <1>     in al, dx
    57 00000A2F 2401                <1>     and al, 1
    58 00000A31 74FB                <1>     jz .si41
    59                              <1> 
    60 00000A33 6681EA0500          <1>     sub dx, 5
    61 00000A38 EC                  <1>     in al, dx    ;get char into al
    62 00000A39 88C4                <1>     mov ah, al   ;save al in ah temporarily
    63 00000A3B 4831C9              <1>     xor rcx, rcx
    64                              <1> .si2:    ;Get offset into table structures into cx
    65 00000A3E 663B9409[67000000]  <1>     cmp dx, word [com_addresses + rcx*2]    ;table of addresses, dx is at base
    66 00000A46 740C                <1>     je .si3
    67 00000A48 66FFC1              <1>     inc cx
    68 00000A4B 6681F90400          <1>     cmp cx, 4    ;rcx should be {0,3}
    69 00000A50 7CEC                <1>     jl .si2
    70 00000A52 EB55                <1>     jmp short .siexit    ;bad value, exit
    71                              <1> .si3:    ;Store in buffer algorithm
    72 00000A54 488B1CCD[CF000000]  <1>     mov rbx, qword [comX_buf_tail + rcx*8]
    73 00000A5C 4889DF              <1>     mov rdi, rbx
    74 00000A5F 48FFC3              <1>     inc rbx        ;increment by one char
    75 00000A62 483B1CCD[0F010000]  <1>     cmp rbx, qword [comX_buf_end + rcx*8]
    76 00000A6A 7508                <1>     jne .si4
    77 00000A6C 488B1CCD[EF000000]  <1>     mov rbx, qword [comX_buf_start + rcx*8]    ;Wrap around buffer
    78                              <1> .si4:
    79 00000A74 483B1CCD[AF000000]  <1>     cmp rbx, qword [comX_buf_head + rcx*8]    ;Check if buffer full
    80 00000A7C 740F                <1>     je .si5    ;Buffer full, indicate wait to data source
    81                              <1> 
    82 00000A7E 8827                <1>     mov byte [rdi], ah    ;store char into buffer
    83 00000A80 48891CCD[CF000000]  <1>     mov qword [comX_buf_tail + rcx*8], rbx    ;store new tail into variable
    84                              <1> 
    85 00000A88 E975FFFFFF          <1>     jmp .si0    ;If com1/2, now check that com 3/4 didnt fire interrupt.
    86                              <1> 
    87                              <1> .si5:    ;Buffer full, Deassert DTR bit 
    88                              <1> ;dx points at the base register
    89 00000A8D 6681C20400          <1>     add dx, 4    ;Point at Modem Control Register
    90 00000A92 EC                  <1>     in al, dx
    91 00000A93 24FE                <1>     and al, 11111110b    ;Clear the bottom bit
    92 00000A95 EE                  <1>     out dx, al    ;Set the DTR bit down (not ready to recieve data)
    93 00000A96 6681C20300          <1>     add dx, 3    ;Point to scratch register
    94 00000A9B 88E0                <1>     mov al, ah    ;return ah into al
    95 00000A9D EE                  <1>     out dx, al    ;put the overrun char into scratch register
    96 00000A9E 6681F90200          <1>     cmp cx, 2    ;If this was com1/2, now check for com 3/4.
    97 00000AA3 0F8559FFFFFF        <1>     jne .si0
    98                              <1> ;exit since we dont want to take whats in the UART buffer just yet.
    99                              <1> .siexit:
   100 00000AA9 B020                <1>     mov al, EOI
   101 00000AAB E620                <1>     out pic1command, al
   102                              <1> 
   103 00000AAD 5B                  <1>     pop rbx
   104 00000AAE 5F                  <1>     pop rdi
   105 00000AAF 59                  <1>     pop rcx
   106 00000AB0 5D                  <1>     pop rbp
   107 00000AB1 5A                  <1>     pop rdx
   108 00000AB2 58                  <1>     pop rax
   109 00000AB3 FB                  <1>     sti
   110 00000AB4 48CF                <1>     iretq
   111                              <1> ;------------------------End of Interrupt------------------------
    87                                  %include "./Source/Resident/Hardware/MSD/fddInt.asm"
     1                              <1> ;----------------FDD Interrupt IRQ 6/Int 26h---------------------
     2                              <1> fdd_IRQ6:
     3 00000AB6 50                  <1>     push rax
     4 00000AB7 B020                <1>     mov al, EOI
     5 00000AB9 E620                <1>     out pic1command, al
     6 00000ABB 58                  <1>     pop rax
     7 00000ABC 48CF                <1>     iretq
     8                              <1> ;------------------------End of Interrupt------------------------
    88                                  %include "./Source/Resident/Hardware/Timers/rtcInt.asm"
     1                              <1> ;---------------RTC Interrupt IRQ 8/Int 28h----------------------
     2                              <1> ; This IRQ should only trigger for the periodic and alarm 
     3                              <1> ; interrupts. If a programmer wishes to use the time update 
     4                              <1> ; complete interrupt feature, they should hook their own 
     5                              <1> ; interrupt handler.
     6                              <1> ;----------------------------------------------------------------
     7                              <1> rtc_IRQ8:
     8 00000ABE 50                  <1>     push rax
     9 00000ABF FA                  <1>     cli             ;Disable interrupts
    10 00000AC0 B08C                <1>     mov al, 8Ch     ;Register C with NMI disabled
    11 00000AC2 E670                <1>     out cmos_base, al
    12 00000AC4 E680                <1>     out waitp, al    ;allow one io cycle to run
    13 00000AC6 EB00                <1>     jmp short $+2
    14 00000AC8 E471                <1>     in al, cmos_data    ;Get the data byte to confirm IRQ recieved
    15 00000ACA 2460                <1>     and al, 060h        ;Isolate Alarm and Periodic bits only
    16 00000ACC A840                <1>     test al, 40h        ;Periodic?
    17 00000ACE 7408                <1>     jz .noPeriodic      ;No, skip the periodic
    18                              <1> .periodic:
    19 00000AD0 48FF0C25[3B010000]  <1>     dec qword [rtc_ticks]
    20                              <1> .noPeriodic:
    21 00000AD8 A820                <1>     test al, 20h        ;Alarm?
    22 00000ADA 7402                <1>     jz .exit
    23                              <1> .alarm:
    24 00000ADC CD6A                <1>     int 6Ah    ;User Alarm handler, behaves like Int 4Ah on 16-bit BIOS
    25                              <1> .exit:
    26 00000ADE B00D                <1>     mov al, 0Dh     ;Read Register D and reenable NMI
    27 00000AE0 E670                <1>     out cmos_base, al
    28 00000AE2 E680                <1>     out waitp, al    ;allow one io cycle to run
    29 00000AE4 EB00                <1>     jmp short $+2
    30 00000AE6 E471                <1>     in al, cmos_data    
    31 00000AE8 B020                <1>     mov al, EOI
    32 00000AEA E6A0                <1>     out pic2command, al
    33 00000AEC E620                <1>     out pic1command, al
    34 00000AEE 58                  <1>     pop rax
    35 00000AEF 48CF                <1>     iretq
    36                              <1> ;------------------------End of Interrupt------------------------
    89                                  %include "./Source/Resident/Hardware/MSD/hddInt.asm"
     1                              <1> ;---------------HDD Interrupt IRQ 14/Int 2Eh---------------------
     2                              <1> hdd_IRQ14:
     3 00000AF1 50                  <1>     push rax
     4 00000AF2 52                  <1>     push rdx
     5 00000AF3 802425[AB010000]FD  <1>     and byte [ata0CmdByte], 0FDh    ;Clear bit 1
     6 00000AFB 66BAF701            <1>     mov dx, ata0_base + 7   ;Since this interrupt ONLY occurs on ata0
     7 00000AFF EC                  <1>     in al, dx   ;Read the status, and stop the controller from firing again
     8                              <1> 
     9 00000B00 B020                <1>     mov al, EOI
    10 00000B02 E620                <1>     out pic1command, al
    11 00000B04 5A                  <1>     pop rdx
    12 00000B05 58                  <1>     pop rax
    13 00000B06 48CF                <1>     iretq
    14                              <1> ;------------------------End of Interrupt------------------------
    90                                  %include "./Source/Resident/Hardware/USB/EHCI/ehciInt.asm"
     1                              <1> ;-------------------EHCI Int Handler/Int 2Xh---------------------
     2                              <1> ;This is installed by the PCI proc at runtime, onto the 
     3                              <1> ; appropriate IRQ.
     4                              <1> ;
     5                              <1> ;If USB Host controller is doing transaction, this HC is 
     6                              <1> ; nominally turned off. Bits [7:2] in the eAsyncMutex identify 
     7                              <1> ; how many interrupts to ignore, before switching off the 
     8                              <1> ; Schedule. This value is nominally zero.
     9                              <1> ;----------------------------------------------------------------
    10                              <1> ehci_IRQ:
    11 00000B08 68[26580000]        <1>     push qword dummy_interrupt.pic2
    12 00000B0D EB05                <1>     jmp short .intr
    13                              <1> .pic1:
    14 00000B0F 68[2D580000]        <1>     push qword dummy_interrupt.pic1
    15                              <1> .intr:
    16                              <1> ;EHCI Interrupt Handler 
    17 00000B14 53                  <1>     push rbx
    18 00000B15 50                  <1>     push rax
    19                              <1> 
    20 00000B16 8A0425[48020000]    <1>     mov al, byte [eActiveCtrlr]
    21 00000B1D 3CFF                <1>     cmp al, -1    ;Spurious case, replace with manual poll then discard proc
    22 00000B1F 743F                <1>     je .spur
    23                              <1> 
    24 00000B21 E8D3480000          <1>     call USB.ehciGetOpBase    ;returns opreg base in rax
    25                              <1> .nonIRQmain:
    26 00000B26 678B5804            <1>     mov ebx, dword [eax + ehcists]  ;save USBSTS and clear usb interrupt
    27 00000B2A 67095804            <1>     or dword [eax + ehcists], ebx   ;WC all interrupt status
    28 00000B2E 881C25[49020000]    <1>     mov byte [eActiveInt], bl    ;save interrupt status
    29                              <1> 
    30                              <1> ;Test based on which bits are set. Higher bits have higher priority
    31                              <1>     ;test bl, 10h            ;Check if host error bit set
    32                              <1>     ;test bl, 8              ;Frame List rollover
    33                              <1>     ;test bl, 4              ;Port status change detected
    34 00000B35 F6C302              <1>     test bl, 2              ;Check if transation error bit is set
    35 00000B38 7542                <1>     jnz .transactionError
    36 00000B3A F6C301              <1>     test bl, 1              ;Check if short packet/interrupt bit set
    37 00000B3D 741E                <1>     jz .exit                ;If none of the bits were set, continue IRQ chain
    38                              <1> ;IoC and Short Packet section
    39 00000B3F 8A0425[4A020000]    <1>     mov al, byte [eAsyncMutex]    ;check if we should ignore interrupt
    40 00000B46 24FC                <1>     and al, 11111100b    ;clear out bottom two bits (dont care)
    41 00000B48 84C0                <1>     test al, al            ;Set zero flag if al is zero
    42 00000B4A 7509                <1>     jnz .usbignoreirq    ;If not zero, ignore irq (and dec counter!)
    43                              <1> 
    44 00000B4C 880425[4A020000]    <1>     mov byte [eAsyncMutex], al ;Wait no longer!! Data available
    45                              <1> 
    46 00000B53 EB08                <1>     jmp short .exit    ;Ignore the "ignore usb" section
    47                              <1> .usbignoreirq:
    48 00000B55 802C25[4A020000]04  <1>     sub byte [eAsyncMutex], 4    ;sub the semaphore 
    49                              <1> .exit:
    50 00000B5D 58                  <1>     pop rax
    51 00000B5E 5B                  <1>     pop rbx
    52 00000B5F C3                  <1>     ret
    53                              <1> .spur:
    54 00000B60 30C0                <1>     xor al, al
    55                              <1> .s1:
    56 00000B62 E892480000          <1>     call USB.ehciGetOpBase
    57 00000B67 678B5804            <1>     mov ebx, dword [eax + ehcists] ;save USBSTS and clear usb interrupt 
    58 00000B6B 67095804            <1>     or dword [eax + ehcists], ebx    ;WC all interrupt status
    59 00000B6F FEC0                <1>     inc al    ;Clear all interrupts on all controllers
    60 00000B71 3A0425[15020000]    <1>     cmp al, byte [eControllers]
    61 00000B78 72E8                <1>     jb .s1
    62 00000B7A EBE1                <1>     jmp short .exit
    63                              <1> .transactionError:
    64 00000B7C C60425[4A020000]00  <1>     mov byte [eAsyncMutex], 0   ;Unblock wait
    65 00000B84 EBD7                <1>     jmp short .exit
    66                              <1> .nonIRQep:
    67 00000B86 53                  <1>     push rbx
    68 00000B87 50                  <1>     push rax
    69 00000B88 EB9C                <1>     jmp short .nonIRQmain
    70                              <1> ;------------------------End of Interrupt------------------------
    91                                  %include "./Source/Resident/Hardware/spurInt.asm"
     1                              <1> ;-----------------Spurious Int Handler/Int 27h-------------------
     2                              <1> ; Catches and handles spurious interrupts on the first pic.
     3                              <1> ;----------------------------------------------------------------
     4                              <1> default_IRQ7:
     5 00000B8A 50                  <1>     push rax
     6 00000B8B B00B                <1>     mov al, 0Bh    ;Read ISR 
     7 00000B8D E620                <1>     out pic1command, al
     8 00000B8F E680                <1>     out waitp, al    ;Latch wait
     9 00000B91 EB00                <1>     jmp short $+2
    10 00000B93 E420                <1>     in al, pic1command    ;Get the ISR
    11 00000B95 A880                <1>     test al, 80h
    12 00000B97 7509                <1>     jne .exit
    13 00000B99 FE0425[20000000]    <1>     inc byte [spurint1]
    14 00000BA0 EB04                <1>     jmp short .e2    ;Avoid sending EOI
    15                              <1> .exit:
    16 00000BA2 B020                <1>     mov al, EOI
    17 00000BA4 E620                <1>     out pic1command, al
    18                              <1> .e2:
    19 00000BA6 58                  <1>     pop rax
    20 00000BA7 48CF                <1>     iretq
    21                              <1> 
    22                              <1> ;-----------------Spurious Int Handler/Int 2Fh-------------------
    23                              <1> ; Catches and handles spurious interrupts on the second pic.
    24                              <1> ;----------------------------------------------------------------
    25                              <1> default_IRQ15:
    26 00000BA9 50                  <1>     push rax
    27 00000BAA F60425[AD010000]01  <1>     test byte [ata1CmdByte], 1   ;Check if mutex bit set
    28 00000BB2 740F                <1>     jz .spurcheck                ;If not set, then just check spur
    29 00000BB4 802425[AD010000]FD  <1>     and byte [ata1CmdByte], 0FDh ;Clear bit 
    30 00000BBC 52                  <1>     push rdx
    31 00000BBD 66BA7701            <1>     mov dx, ata1_base + 7   ;Goto ata1 status reg
    32 00000BC1 EC                  <1>     in al, dx   ;Stop ctrlr from firing interrupts again!
    33 00000BC2 5A                  <1>     pop rdx
    34                              <1> .spurcheck:
    35 00000BC3 B00B                <1>     mov al, 0Bh    ;Read ISR 
    36 00000BC5 E6A0                <1>     out pic2command, al
    37 00000BC7 E680                <1>     out waitp, al    ;Latch wait
    38 00000BC9 EB00                <1>     jmp short $+2
    39 00000BCB E4A0                <1>     in al, pic2command    ;Get the ISR
    40 00000BCD A880                <1>     test al, 80h
    41 00000BCF B020                <1>     mov al, EOI    ;Still need to send EOI to pic1
    42 00000BD1 7509                <1>     jne .exit
    43 00000BD3 FE0425[21000000]    <1>     inc byte [spurint2]
    44 00000BDA EB02                <1>     jmp short .e2    ;Avoid sending EOI
    45                              <1> .exit:
    46 00000BDC E6A0                <1>     out pic2command, al
    47                              <1> .e2:
    48 00000BDE E620                <1>     out pic1command, al
    49 00000BE0 58                  <1>     pop rax
    50 00000BE1 48CF                <1>     iretq
    51                              <1> ;------------------------End of Interrupt------------------------
    92                                  ;========================SOFTWARE INTERRUPTS=====================
    93                                  %include "./Source/Resident/Services/Int30h.asm"
     1                              <1> ;----------------------Video Interrupt Int 30h-------------------
     2                              <1> scr_io_table:
     3 00000BE3 [B00C000000000000]  <1>     dq    scr_io.change_mode     ;AH = 0 -> Change Screen Mode (Currently no 
     4                              <1>                                  ; options)
     5 00000BEB [BF0C000000000000]  <1>     dq    scr_io.set_curs_shape  ;AH = 1 -> Set Cursor Shape
     6 00000BF3 [D20C000000000000]  <1>     dq    scr_io.set_curs_pos    ;AH = 2 -> Set Cursor Position
     7 00000BFB [F60C000000000000]  <1>     dq    scr_io.get_curs_pos    ;AH = 3 -> Get Cursor Position
     8 00000C03 [160D000000000000]  <1>     dq    scr_io.write_register  ;AH = 4 -> Reserved, Undoc, Write al in ASCII 
     9                              <1>                                  ; at cursor 
    10 00000C0B [5F0D000000000000]  <1>     dq    scr_io.select_page     ;AH = 5 -> Select Active Page
    11 00000C13 [050E000000000000]  <1>     dq    scr_io.scroll_up       ;AH = 6 -> Scroll Active Page up
    12 00000C1B [C30E000000000000]  <1>     dq    scr_io.scroll_down     ;AH = 7 -> Scroll Active Page down
    13 00000C23 [550F000000000000]  <1>     dq    scr_io.read_att_char   ;AH = 8 -> Read Attribute and Char at curs pos
    14 00000C2B [870F000000000000]  <1>     dq    scr_io.write_att_char  ;AH = 9 -> Write Attribute and Char at curs pos
    15 00000C33 [C70F000000000000]  <1>     dq    scr_io.write_char      ;AH = 0Ah -> Write Char at curs position 
    16                              <1>                                  ; (using default attribute)
    17 00000C3B [0F10000000000000]  <1>     dq    scr_io.gset_col_palette ;AH = 0Bh -> Graphics, Set Colour Palette
    18 00000C43 [1E10000000000000]  <1>     dq    scr_io.gwritedot       ;AH = 0Ch -> Graphics, Write a Dot to screen
    19 00000C4B [2D10000000000000]  <1>     dq    scr_io.greaddot        ;AH = 0Dh -> Graphics, Read a Dot from screen
    20 00000C53 [3C10000000000000]  <1>     dq    scr_io.write_tty       ;AH = 0Eh -> Write Teletype
    21 00000C5B [0A11000000000000]  <1>     dq    scr_io.get_mode        ;AH = 0Fh -> Get Screen Mode (currently, no 
    22                              <1>                                  ; options)
    23 00000C63 [A50C000000000000]  <1>     dq    scr_io.exitf           ;AH = 10h -> Reserved
    24 00000C6B [A50C000000000000]  <1>     dq  scr_io.exitf             ;AH = 11h -> Reserved
    25 00000C73 [A50C000000000000]  <1>     dq    scr_io.exitf           ;AH = 12h -> Reserved
    26 00000C7B [3311000000000000]  <1>     dq  scr_io.write_string      ;AH = 13h -> Write string
    27                              <1> scr_io_table_length    equ    $ - scr_io_table
    28                              <1> scr_io:
    29 00000C83 FC                  <1>     cld        ;set direction to read the right way
    30 00000C84 56                  <1>     push rsi
    31 00000C85 50                  <1>     push rax
    32 00000C86 C0E403              <1>     shl ah, 3  ;Use ah as offset into table
    33 00000C89 80FC98              <1>     cmp ah, (scr_io_table_length - 8)    ;Ensure function number is within table
    34 00000C8C 7717                <1>     ja .exitf
    35 00000C8E 88E0                <1>     mov al, ah
    36 00000C90 480FB6C0            <1>     movzx rax, al               ;Zero extend ax into rax
    37 00000C94 4889C6              <1>     mov rsi, rax                ;Note rsi is not being saved here!
    38 00000C97 58                  <1>     pop rax                     ;recover back into ax
    39 00000C98 8A2425[58010000]    <1>     mov ah, byte [scr_mode]     ;Get the current mode into ah
    40 00000C9F FFA6[E30B0000]      <1>     jmp [scr_io_table + rsi]    ;Jump to correct function
    41                              <1> .exitf:
    42 00000CA5 58                  <1>     pop rax
    43 00000CA6 B480                <1>     mov ah, 80h ;Function not supported
    44 00000CA8 804C241801          <1>     or byte [rsp + 3*8h], 1 ;Set Carry flag, invalid function, skip rsi on stack
    45                              <1> .exit:
    46 00000CAD 5E                  <1>     pop rsi
    47 00000CAE 48CF                <1>     iretq
    48                              <1>     
    49                              <1> .change_mode:
    50 00000CB0 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
    50 00000CB9 00                  <1>
    51 00000CBA E9EEFFFFFF          <1>     jmp .exit    ;Currently unsupported function    
    52                              <1> .set_curs_shape:
    53                              <1> ;Input: CH = Scan Row Start, CL = Scan Row End
    54 00000CBF 52                  <1>     push rdx
    55 00000CC0 66890C25[55010000]  <1>     mov word [scr_curs_shape], cx
    56                              <1> 
    57 00000CC8 B00A                <1>     mov al, 0Ah
    58 00000CCA E86B050000          <1>     call .write_crtc_word
    59                              <1>     
    60 00000CCF 5A                  <1>     pop rdx
    61 00000CD0 EBDB                <1>     jmp short .exit
    62                              <1> .set_curs_pos:
    63                              <1> ;Input: DH = Row, DL = Column, BH = active page
    64 00000CD2 51                  <1>     push rcx
    65 00000CD3 52                  <1>     push rdx
    66                              <1>     
    67 00000CD4 53                  <1>     push rbx
    68 00000CD5 88FB                <1>     mov bl, bh
    69 00000CD7 480FB6DB            <1>     movzx rbx, bl
    70 00000CDB 6689941B[43010000]  <1>     mov word [scr_curs_pos + 2*rbx], dx
    71 00000CE3 5B                  <1>     pop rbx
    72 00000CE4 3A3C25[59010000]    <1>     cmp bh, byte [scr_active_page]
    73 00000CEB 7505                <1>     jne .scpexit    ;if the page is not the active page
    74 00000CED E8E3050000          <1>     call .cursor_proc
    75                              <1> .scpexit:
    76 00000CF2 5A                  <1>     pop rdx
    77 00000CF3 59                  <1>     pop rcx
    78 00000CF4 EBB7                <1>     jmp short .exit
    79                              <1>     
    80                              <1> 
    81                              <1> .get_curs_pos:
    82                              <1> ;Return: AX = 0, CH = Start scan line, CL = End scan line, DH = Row, DL = Column
    83 00000CF6 53                  <1>     push rbx
    84                              <1> 
    85 00000CF7 88FB                <1>     mov bl, bh
    86 00000CF9 480FB6DB            <1>     movzx rbx, bl
    87 00000CFD 668B941B[43010000]  <1>     mov dx, word [scr_curs_pos + 2*rbx] 
    88 00000D05 668B0C25[55010000]  <1>     mov cx, word [scr_curs_shape]    ;Get cursor shape
    89                              <1> 
    90 00000D0D 5B                  <1>     pop rbx
    91 00000D0E 6631C0              <1>     xor ax, ax 
    92 00000D11 E997FFFFFF          <1>     jmp .exit
    93                              <1> 
    94                              <1> .write_register:    ;al contains the byte to convert
    95 00000D16 52                  <1>     push rdx
    96 00000D17 53                  <1>     push rbx
    97 00000D18 50                  <1>     push rax
    98                              <1> 
    99 00000D19 88C2                <1>     mov dl, al           ;save byte in dl
   100 00000D1B 6625F000            <1>     and ax, 00F0h        ;Hi nybble
   101 00000D1F 6681E20F00          <1>     and dx, 000Fh        ;Lo nybble
   102 00000D24 66C1E804            <1>     shr ax, 4            ;shift one hex place value pos right
   103 00000D28 E810000000          <1>     call .wrchar
   104 00000D2D 6689D0              <1>     mov ax, dx           ;mov lo nybble, to print
   105 00000D30 E808000000          <1>     call .wrchar
   106                              <1> 
   107 00000D35 58                  <1>     pop rax
   108 00000D36 5B                  <1>     pop rbx
   109 00000D37 5A                  <1>     pop rdx
   110 00000D38 E970FFFFFF          <1>     jmp .exit
   111                              <1> .wrchar:
   112 00000D3D 48BB-               <1>     mov rbx, .wrascii
   112 00000D3F [4F0D000000000000]  <1>
   113 00000D47 D7                  <1>     xlatb    ;point al to entry in ascii table, using al as offset into table
   114 00000D48 B40E                <1>     mov ah, 0Eh
   115 00000D4A B307                <1>     mov bl, 07h
   116 00000D4C CD30                <1>     int 30h  ;print char
   117 00000D4E C3                  <1>     ret
   118 00000D4F 303132333435363738- <1> .wrascii:    db    '0123456789ABCDEF'
   118 00000D58 39414243444546      <1>
   119                              <1> .select_page:
   120                              <1> ;ah contains the current screen mode
   121                              <1> ;al contains new screen page
   122                              <1> ;vga just returns as invalid FOR NOW
   123                              <1> ;Handled differently between vga and classic modes
   124 00000D5F 80FC04              <1>     cmp ah, 04
   125 00000D62 761D                <1>     jbe .sp1
   126 00000D64 80FC07              <1>     cmp ah, 07
   127 00000D67 7418                <1>     je .sp1
   128 00000D69 80FC0D              <1>     cmp ah, 0Dh
   129 00000D6C 0F838E000000        <1>     jae .sp_vga
   130                              <1> .spbad:
   131 00000D72 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   131 00000D7B 00                  <1>
   132 00000D7C E92CFFFFFF          <1>     jmp .exit    ;Bad argument
   133                              <1> .sp1:
   134 00000D81 3C08                <1>     cmp al, 8
   135 00000D83 73ED                <1>     jae .spbad    ;page should be 0-7
   136                              <1> .spmain:
   137 00000D85 50                  <1>     push rax
   138 00000D86 53                  <1>     push rbx
   139 00000D87 51                  <1>     push rcx
   140 00000D88 52                  <1>     push rdx
   141 00000D89 880425[59010000]    <1>     mov byte [scr_active_page], al    ;change active page
   142                              <1> ;----Modify this proc with data tables when finalised!!----
   143 00000D90 48BE00080000000000- <1>     mov rsi, 800h    ;mode 0,1 page size
   143 00000D99 00                  <1>
   144 00000D9A 48BB00100000000000- <1>     mov rbx, 1000h    ;mode 2,3,7 page size
   144 00000DA3 00                  <1>
   145 00000DA4 480FB6C8            <1>     movzx rcx, al    ;Get count into rcx
   146 00000DA8 80FC02              <1>     cmp ah, 2
   147 00000DAB 480F42DE            <1>     cmovb rbx, rsi
   148 00000DAF 48BA00800B00000000- <1>     mov rdx, vga_bpage2
   148 00000DB8 00                  <1>
   149 00000DB9 48BE00000B00000000- <1>     mov rsi, vga_bpage1    ;Base addr for mode 7
   149 00000DC2 00                  <1>
   150                              <1> ;----Modify this proc with data tables when finalised!!----
   151 00000DC3 80FC07              <1>     cmp ah, 7
   152 00000DC6 480F44D6            <1>     cmove rdx, rsi
   153 00000DCA 52                  <1>     push rdx    ;Push the saved page 0 address
   154 00000DCB E307                <1>     jrcxz .spm2    ;If 0th page, dont add
   155                              <1> .spm1:
   156 00000DCD 4801DA              <1>     add rdx, rbx
   157 00000DD0 FEC9                <1>     dec cl
   158 00000DD2 75F9                <1>     jnz .spm1
   159                              <1> .spm2:
   160 00000DD4 5E                  <1>     pop rsi     ;Get saved base into rsi
   161 00000DD5 891425[5C010000]    <1>     mov dword [scr_page_addr], edx    ;Get new base addr
   162 00000DDC 4829F2              <1>     sub rdx, rsi    ;rsi has conditionally b8000 or b0000
   163 00000DDF 50                  <1>     push rax
   164 00000DE0 66D1EA              <1>     shr dx, 1    ;Divide dx by 2 to get # of PELs
   165 00000DE3 6689D1              <1>     mov cx, dx    ;Get offset from crtc base addr
   166 00000DE6 66B80C00            <1>     mov ax, 0Ch    ;6845 Start Addr register
   167 00000DEA E84B040000          <1>     call .write_crtc_word    ;Change "crtc view window"
   168                              <1> 
   169 00000DEF 58                  <1>     pop rax        ;Get original ax back for page number
   170 00000DF0 88C7                <1>     mov bh, al
   171 00000DF2 E8DE040000          <1>     call .cursor_proc    ;Move cursor on page
   172                              <1>     
   173 00000DF7 5A                  <1>     pop rdx
   174 00000DF8 59                  <1>     pop rcx
   175 00000DF9 5B                  <1>     pop rbx
   176 00000DFA 58                  <1>     pop rax
   177 00000DFB E9ADFEFFFF          <1>     jmp .exit    ;Bad argument
   178                              <1> .sp_vga:
   179 00000E00 E96DFFFFFF          <1>     jmp .spbad
   180                              <1> 
   181                              <1> .scroll_up:
   182                              <1> ;Scrolls ACTIVE SCREEN only
   183                              <1> ;Called with AL=number of lines to scroll, BH=Attribute for new area
   184                              <1> ;    CH=ycor of top of scroll, CL=xcor of top of scroll
   185                              <1> ;    DH=ycor of bottom of scroll, DL=xcor of bottom of scroll
   186                              <1> ;If AL=0 then entire window is blanked, BH is used for blank attrib
   187                              <1> ;ah contains the current screen mode
   188 00000E05 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   189 00000E08 7209                <1>     jb .su0
   190 00000E0A 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   191 00000E0D 0F8509040000        <1>     jne .gscrollup    ;We in graphics mode, go to correct proc
   192                              <1> .su0:
   193 00000E13 55                  <1>     push rbp
   194 00000E14 57                  <1>     push rdi
   195 00000E15 50                  <1>     push rax    ;Treat AX more or less as clobbered 
   196                              <1>     
   197 00000E16 84C0                <1>     test al, al   ;Check if zero
   198 00000E18 747F                <1>     je .sblank    ;recall ah=06 then reset cursor and exit
   199 00000E1A 88C3                <1>     mov bl, al    ;Save number of lines to scroll in bl
   200                              <1> .su1:
   201 00000E1C 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]    ;zeros upper dword
   202 00000E23 4889F7              <1>     mov rdi, rsi  ;Point both pointers at base of active page
   203 00000E26 6689C8              <1>     mov ax, cx    ;Bottom top corner into ax
   204 00000E29 E870040000          <1>     call .offset_from_ax    ;Get the page offset of dx
   205 00000E2E 480FB7C0            <1>     movzx rax, ax
   206 00000E32 48D1E0              <1>     shl rax, 1    ;Multiply by two for words
   207 00000E35 4801C7              <1>     add rdi, rax  ;point to the top left of window
   208 00000E38 4801C6              <1>     add rsi, rax
   209 00000E3B 480FB60425-         <1>     movzx rax, byte [scr_cols]
   209 00000E40 [53010000]          <1>
   210 00000E44 48D1E0              <1>     shl rax, 1      ;number of columns * 2 for words!
   211 00000E47 4801C6              <1>     add rsi, rax    ;Point rsi one row down
   212 00000E4A 51                  <1>     push rcx
   213 00000E4B 52                  <1>     push rdx
   214                              <1> 
   215 00000E4C 28EE                <1>     sub dh, ch    ;work out number of rows to copy
   216                              <1> .su2:
   217 00000E4E 56                  <1>     push rsi
   218 00000E4F 57                  <1>     push rdi
   219 00000E50 E865040000          <1>     call .text_scroll_c1    ;Scroll the selected row
   220 00000E55 5F                  <1>     pop rdi
   221 00000E56 5E                  <1>     pop rsi
   222 00000E57 4801C7              <1>     add rdi, rax    ;goto next row
   223 00000E5A 4801C6              <1>     add rsi, rax
   224 00000E5D FECE                <1>     dec dh
   225 00000E5F 75ED                <1>     jnz .su2
   226                              <1> 
   227 00000E61 5A                  <1>     pop rdx
   228 00000E62 59                  <1>     pop rcx
   229                              <1> ;Draw blank line
   230 00000E63 50                  <1>     push rax
   231 00000E64 51                  <1>     push rcx
   232 00000E65 57                  <1>     push rdi
   233                              <1> 
   234 00000E66 6689C8              <1>     mov ax, cx
   235 00000E69 88F4                <1>     mov ah, dh    ;Starting column from cx, starting row from dx
   236 00000E6B E82E040000          <1>     call .offset_from_ax
   237 00000E70 8B3C25[5C010000]    <1>     mov edi, dword [scr_page_addr]
   238 00000E77 480FB7C0            <1>     movzx rax, ax
   239 00000E7B 48D1E0              <1>     shl rax, 1
   240 00000E7E 01C7                <1>     add edi, eax   ;point to new line
   241 00000E80 88FC                <1>     mov ah, bh
   242 00000E82 B020                <1>     mov al, 20h    ;Blank char
   243 00000E84 4889E9              <1>     mov rcx, rbp   ;move word count into cx
   244 00000E87 F366AB              <1>     rep stosw      ;write the word bp number of times
   245 00000E8A 5F                  <1>     pop rdi
   246 00000E8B 59                  <1>     pop rcx
   247 00000E8C 58                  <1>     pop rax
   248 00000E8D FECB                <1>     dec bl
   249 00000E8F 758B                <1>     jnz .su1    ;Once we have done bl rows, exit
   250                              <1> 
   251                              <1> .suexit:
   252 00000E91 58                  <1>     pop rax
   253 00000E92 5F                  <1>     pop rdi
   254 00000E93 5D                  <1>     pop rbp
   255 00000E94 E914FEFFFF          <1>     jmp .exit
   256                              <1> .sblank:
   257                              <1> ;Fast clear function
   258 00000E99 51                  <1>     push rcx
   259 00000E9A 52                  <1>     push rdx
   260                              <1> 
   261 00000E9B 88FC                <1>     mov ah, bh    ;mov attrib into ah
   262 00000E9D B020                <1>     mov al, 20h    ;Space char
   263 00000E9F 8B3C25[5C010000]    <1>     mov edi, dword [scr_page_addr]
   264 00000EA6 480FB61425-         <1>     movzx rdx, byte [scr_rows]
   264 00000EAB [54010000]          <1>
   265                              <1> .sbl0:
   266 00000EAF 480FB60C25-         <1>     movzx rcx, byte [scr_cols]
   266 00000EB4 [53010000]          <1>
   267 00000EB8 F366AB              <1>     rep stosw
   268 00000EBB FECA                <1>     dec dl
   269 00000EBD 75F0                <1>     jnz .sbl0
   270                              <1> 
   271 00000EBF 5A                  <1>     pop rdx
   272 00000EC0 59                  <1>     pop rcx
   273 00000EC1 EBCE                <1>     jmp short .suexit
   274                              <1> 
   275                              <1> .scroll_down:
   276                              <1> ;Scrolls ACTIVE SCREEN only
   277                              <1> ;Called with AL=number of lines to scroll, BH=Attribute for new area
   278                              <1> ;    CH=ycor of top of scroll, CL=xcor of top of scroll
   279                              <1> ;    DH=ycor of bottom of scroll, DL=xcor of bottom of scroll
   280                              <1> ;If AL=0 then entire window is blanked, BH is used for blank attrib
   281                              <1> ;ah contains the current screen mode
   282 00000EC3 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   283 00000EC6 7209                <1>     jb .sd0
   284 00000EC8 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   285 00000ECB 0F855A030000        <1>     jne .gscrolldown    ;We in graphics mode, go to correct proc
   286                              <1> .sd0:
   287 00000ED1 55                  <1>     push rbp
   288 00000ED2 57                  <1>     push rdi
   289 00000ED3 50                  <1>     push rax    ;Treat AX more or less as clobbered
   290                              <1> 
   291 00000ED4 84C0                <1>     test al, al    ;Check if zero
   292 00000ED6 74C1                <1>     je .sblank    ;recall ah=06 then reset cursor and exit
   293 00000ED8 88C3                <1>     mov bl, al    ;Save number of lines to scroll in bl
   294 00000EDA FD                  <1>     std    ;change the direction of string operations
   295                              <1> .sd1:
   296 00000EDB 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]    ;point esi to bottom
   297 00000EE2 6689D0              <1>     mov ax, dx    ;point to bottom right 
   298 00000EE5 E8B4030000          <1>     call .offset_from_ax
   299 00000EEA 480FB7C0            <1>     movzx rax, ax
   300 00000EEE 48D1E0              <1>     shl rax, 1
   301 00000EF1 4801C6              <1>     add rsi, rax
   302 00000EF4 4889F7              <1>     mov rdi, rsi
   303 00000EF7 480FB60425-         <1>     movzx rax, byte [scr_cols]
   303 00000EFC [53010000]          <1>
   304 00000F00 48D1E0              <1>     shl rax, 1
   305 00000F03 4829C6              <1>     sub rsi, rax    ;Point rsi one row above rdi
   306                              <1> 
   307 00000F06 51                  <1>     push rcx
   308 00000F07 52                  <1>     push rdx
   309 00000F08 28EE                <1>     sub dh, ch    ;Number of rows to copy
   310                              <1> .sd2:
   311 00000F0A 56                  <1>     push rsi
   312 00000F0B 57                  <1>     push rdi
   313 00000F0C E8A9030000          <1>     call .text_scroll_c1
   314 00000F11 5F                  <1>     pop rdi
   315 00000F12 5E                  <1>     pop rsi
   316 00000F13 4829C7              <1>     sub rdi, rax
   317 00000F16 4829C6              <1>     sub rsi, rax
   318 00000F19 FECE                <1>     dec dh
   319 00000F1B 75ED                <1>     jnz .sd2
   320                              <1> 
   321 00000F1D 5A                  <1>     pop rdx
   322 00000F1E 59                  <1>     pop rcx
   323                              <1> ;Draw blank line
   324 00000F1F 50                  <1>     push rax
   325 00000F20 51                  <1>     push rcx
   326 00000F21 57                  <1>     push rdi
   327                              <1> 
   328 00000F22 6689D0              <1>     mov ax, dx
   329 00000F25 88EC                <1>     mov ah, ch    ;Starting column from dx, starting row from cx
   330 00000F27 E872030000          <1>     call .offset_from_ax
   331 00000F2C 8B3C25[5C010000]    <1>     mov edi, dword [scr_page_addr]
   332 00000F33 480FB7C0            <1>     movzx rax, ax
   333 00000F37 48D1E0              <1>     shl rax, 1
   334 00000F3A 01C7                <1>     add edi, eax    ;Point to appropriate line and col
   335 00000F3C 88FC                <1>     mov ah, bh
   336 00000F3E B020                <1>     mov al, 20h
   337 00000F40 4889E9              <1>     mov rcx, rbp
   338 00000F43 F366AB              <1>     rep stosw    ;Store backwards
   339 00000F46 5F                  <1>     pop rdi
   340 00000F47 59                  <1>     pop rcx
   341 00000F48 58                  <1>     pop rax
   342 00000F49 FECB                <1>     dec bl
   343 00000F4B 758E                <1>     jnz .sd1
   344                              <1> 
   345                              <1> .sdexit:
   346 00000F4D 58                  <1>     pop rax
   347 00000F4E 5F                  <1>     pop rdi
   348 00000F4F 5D                  <1>     pop rbp
   349 00000F50 E958FDFFFF          <1>     jmp .exit
   350                              <1> .read_att_char:
   351                              <1> ;Get ASCII char and attr at current cursor position on chosen page
   352                              <1> ;Called with AH=08h, BH=Page number (if supported),
   353                              <1> ;Returns, AH=Attrib, AL=Char
   354                              <1> 
   355                              <1> ;On entry, ah contains current screen mode
   356 00000F55 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   357 00000F58 7209                <1>     jb .rac1
   358 00000F5A 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   359 00000F5D 0F859B020000        <1>     jne .gread    ;We in graphics mode, go to correct proc
   360                              <1> .rac1:
   361 00000F63 80FF07              <1>     cmp bh, 7
   362 00000F66 0F8739FDFFFF        <1>     ja .exitf    ;All A/N modes can have 8 pages, any more, fail
   363                              <1> 
   364 00000F6C 88E3                <1>     mov bl, ah    ;Move screen mode into bl for function call
   365 00000F6E 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   366 00000F75 E814030000          <1>     call .page_cursor_offset    ;bx preserved
   367 00000F7A 48D1E0              <1>     shl rax, 1        
   368 00000F7D 4801C6              <1>     add rsi, rax    ;rsi should point to attrib/char 
   369 00000F80 66AD                <1>     lodsw            ;Load ah with attrib/char
   370 00000F82 E926FDFFFF          <1>     jmp .exit    ;Restoring rsi
   371                              <1> 
   372                              <1> .write_att_char:
   373                              <1> ;Puts ASCII char and attribute/colour at cursor
   374                              <1> ;Called with AH=09h, AL=Char, BH=Page, 
   375                              <1> ;    BL=Attrib/Color, CX=number of repeats
   376                              <1> ;Returns nothing (just prints in page)
   377                              <1> 
   378                              <1> ;When called, ah contains current screen mode
   379 00000F87 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   380 00000F8A 7209                <1>     jb .wac1
   381 00000F8C 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   382 00000F8F 0F8578020000        <1>     jne .gwrite    ;We in graphics mode, go to correct proc
   383                              <1> .wac1:
   384 00000F95 80FF07              <1>     cmp bh, 7
   385 00000F98 0F8707FDFFFF        <1>     ja .exitf    ;All A/N modes can have 8 pages, any more, fail
   386                              <1> 
   387 00000F9E 86DC                <1>     xchg bl, ah ;swap attrib and scr mode bytes
   388 00000FA0 57                  <1>     push rdi
   389 00000FA1 50                  <1>     push rax    ;Save the char/attrib word
   390 00000FA2 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   391 00000FA9 E8E0020000          <1>     call .page_cursor_offset    ;bx preserved
   392 00000FAE 4889F7              <1>     mov rdi, rsi    ;Change register for string ops
   393 00000FB1 48D1E0              <1>     shl rax, 1
   394 00000FB4 4801C7              <1>     add rdi, rax    ;rsi now points to right place on right page
   395 00000FB7 58                  <1>     pop rax
   396                              <1> 
   397 00000FB8 51                  <1>     push rcx
   398 00000FB9 480FB7C9            <1>     movzx rcx, cx    ;zero upper bytes
   399 00000FBD F366AB              <1>     rep stosw        ;Store packed ah/al cx times
   400 00000FC0 59                  <1>     pop rcx
   401 00000FC1 5F                  <1>     pop rdi
   402 00000FC2 E9E6FCFFFF          <1>     jmp .exit    ;Restoring rsi
   403                              <1> 
   404                              <1> .write_char:
   405                              <1> ;Puts ASCII char and attribute/colour at cursor
   406                              <1> ;Called with AH=0Ah, AL=Char, BH=Page, 
   407                              <1> ;    BL=Color (G modes ONLY), CX=number of repeats
   408                              <1> ;Returns nothing (just prints in page)
   409 00000FC7 80FC04              <1>     cmp ah, 04    ;Test for Alpha mode
   410 00000FCA 7209                <1>     jb .wc1
   411 00000FCC 80FC07              <1>     cmp ah, 07    ;Test for MDA Alpha mode
   412 00000FCF 0F8538020000        <1>     jne .gwrite    ;We in graphics mode, go to correct proc
   413                              <1> .wc1:
   414 00000FD5 80FF07              <1>     cmp bh, 7
   415 00000FD8 0F87C7FCFFFF        <1>     ja .exitf    ;All A/N modes can have 8 pages, any more, fail
   416                              <1> 
   417 00000FDE 88E3                <1>     mov bl, ah ;mov scr mode byte into bl
   418 00000FE0 57                  <1>     push rdi
   419 00000FE1 50                  <1>     push rax    ;Save the char word
   420 00000FE2 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   421 00000FE9 E8A0020000          <1>     call .page_cursor_offset    ;bx preserved
   422 00000FEE 4889F7              <1>     mov rdi, rsi    ;Change register for string ops
   423 00000FF1 48D1E0              <1>     shl rax, 1
   424 00000FF4 4801C7              <1>     add rdi, rax    ;rdi now points to right place on right page
   425 00000FF7 58                  <1>     pop rax
   426                              <1> 
   427 00000FF8 51                  <1>     push rcx
   428 00000FF9 480FB7C9            <1>     movzx rcx, cx    ;zero upper bytes
   429 00000FFD E309                <1>     jrcxz .wc3    ;If cx is zero, dont print anything, exit
   430                              <1> .wc2:
   431 00000FFF AA                  <1>     stosb
   432 00001000 48FFC7              <1>     inc rdi
   433 00001003 48FFC9              <1>     dec rcx
   434 00001006 75F7                <1>     jnz .wc2
   435                              <1> .wc3:
   436 00001008 59                  <1>     pop rcx
   437 00001009 5F                  <1>     pop rdi
   438 0000100A E99EFCFFFF          <1>     jmp .exit    ;Exit restoring rsi
   439                              <1> 
   440                              <1> .gset_col_palette:
   441 0000100F 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   441 00001018 00                  <1>
   442 00001019 E98FFCFFFF          <1>     jmp .exit    ;Currently unsupported function
   443                              <1> .gwritedot:
   444 0000101E 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   444 00001027 00                  <1>
   445 00001028 E980FCFFFF          <1>     jmp .exit    ;Currently unsupported function
   446                              <1> .greaddot:
   447 0000102D 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   447 00001036 00                  <1>
   448 00001037 E971FCFFFF          <1>     jmp .exit    ;Currently unsupported function
   449                              <1> 
   450                              <1> .write_tty:
   451                              <1> ;Called with al=char, bl=foreground color (graphics)
   452                              <1> ;When called, ah contains current screen mode
   453 0000103C 51                  <1>     push rcx
   454 0000103D 52                  <1>     push rdx
   455 0000103E 53                  <1>     push rbx
   456 0000103F 50                  <1>     push rax
   457                              <1> 
   458 00001040 8A3C25[59010000]    <1>     mov bh, byte [scr_active_page]    ;Get active page
   459 00001047 50                  <1>     push rax
   460 00001048 B403                <1>     mov ah, 3    ;Get cursor into dx
   461 0000104A CD30                <1>     int 30h
   462 0000104C 58                  <1>     pop rax
   463                              <1> 
   464 0000104D 3C08                <1>     cmp al, 08h    ;Check for backspace
   465 0000104F 746B                <1>     je .wttybspace
   466 00001051 3C0A                <1>     cmp al, 0Ah    ;Check for line feed
   467 00001053 747F                <1>     je .wttylf
   468 00001055 3C0D                <1>     cmp al, 0Dh    ;Check for carriage return
   469 00001057 0F848D000000        <1>     je .wttycr
   470 0000105D 3C07                <1>     cmp al, 07h    ;ASCII bell
   471 0000105F 0F848C000000        <1>     je .wttybell
   472                              <1> 
   473                              <1> .wttywrite:
   474 00001065 48B901000000000000- <1>     mov rcx, 1    
   474 0000106E 00                  <1>
   475 0000106F B40A                <1>     mov ah, 0Ah    ;Write 1 char w/o attrib byte
   476 00001071 CD30                <1>     int 30h    ;bh contains page to write for
   477                              <1> 
   478                              <1> .wttycursorupdate:
   479 00001073 FEC2                <1>     inc dl
   480 00001075 3A1425[53010000]    <1>     cmp dl, byte [scr_cols]
   481 0000107C 730D                <1>     jae .wttycu0    ;go down by a line, and start of the line
   482                              <1> .wttycursorupdatego:
   483 0000107E B402                <1>     mov ah, 2
   484 00001080 CD30                <1>     int 30h     ;set cursor
   485                              <1> .wttyexit:
   486 00001082 58                  <1>     pop rax
   487 00001083 5B                  <1>     pop rbx
   488 00001084 5A                  <1>     pop rdx
   489 00001085 59                  <1>     pop rcx
   490 00001086 E922FCFFFF          <1>     jmp .exit
   491                              <1> 
   492                              <1> .wttycu0:
   493 0000108B 30D2                <1>     xor dl, dl    ;Return to start of line
   494 0000108D FEC6                <1>     inc dh
   495 0000108F 3A3425[54010000]    <1>     cmp dh, byte [scr_rows]    ;are past the bottom of the screen?
   496 00001096 72E6                <1>     jb .wttycursorupdatego    ;we are not past the bottom of the screen
   497                              <1> .wttyscrollupone:
   498 00001098 53                  <1>     push rbx
   499 00001099 B408                <1>     mov ah, 08h    ;Read char/attrib at cursor
   500 0000109B CD30                <1>     int 30h
   501 0000109D 88E7                <1>     mov bh, ah    ;Move attrib byte into bh
   502 0000109F 4831C9              <1>     xor rcx, rcx
   503 000010A2 668B1425[53010000]  <1>     mov dx, word [scr_cols]    ;word access all ok
   504 000010AA FECE                <1>     dec dh
   505 000010AC FECA                <1>     dec dl
   506 000010AE 66B80106            <1>     mov ax, 0601h    ;scroll up one line
   507 000010B2 CD30                <1>     int 30h
   508                              <1> 
   509 000010B4 30D2                <1>     xor dl, dl 
   510 000010B6 5B                  <1>     pop rbx
   511 000010B7 E9C2FFFFFF          <1>     jmp .wttycursorupdatego
   512                              <1> .wttybspace:
   513 000010BC 84D2                <1>     test dl, dl    ;compare if the column is zero
   514 000010BE 750D                <1>     jnz .wttybs1   ;if not just decrement row pos
   515 000010C0 84F6                <1>     test dh, dh    ;compare if zero row, if so do nothing
   516 000010C2 74BE                <1>     jz .wttyexit   ;at top left, just exit
   517 000010C4 FECE                <1>     dec dh
   518 000010C6 8A1425[53010000]    <1>     mov dl, byte [scr_cols]    ;move to end of prev row + 1
   519                              <1> .wttybs1:
   520 000010CD FECA                <1>     dec dl
   521 000010CF E9AAFFFFFF          <1>     jmp .wttycursorupdatego
   522                              <1> 
   523                              <1> .wttylf:
   524 000010D4 52                  <1>     push rdx
   525 000010D5 8A1425[54010000]    <1>     mov dl, byte [scr_rows]
   526 000010DC FECA                <1>     dec dl
   527 000010DE 38D6                <1>     cmp dh, dl
   528 000010E0 5A                  <1>     pop rdx
   529 000010E1 74B5                <1>     je .wttyscrollupone    ;if we need to scroll, scroll
   530 000010E3 FEC6                <1>     inc dh    ;otherwise just send cursor down by one
   531 000010E5 E994FFFFFF          <1>     jmp    .wttycursorupdatego
   532                              <1> .wttycr:
   533 000010EA B200                <1>     mov dl, 0    ;Set to 0 on row
   534 000010EC E98DFFFFFF          <1>     jmp .wttycursorupdatego
   535                              <1> .wttybell:
   536 000010F1 48B9E8030000000000- <1>     mov rcx, 1000   ;Beep for a second
   536 000010FA 00                  <1>
   537 000010FB BBA9040000          <1>     mov ebx, 04A9h  ;Frequency divisor for 1000Hz tone
   538 00001100 E891EFFFFF          <1>     call beep
   539 00001105 E978FFFFFF          <1>     jmp .wttyexit
   540                              <1> 
   541                              <1> .get_mode:
   542                              <1> ;Takes no arguments
   543                              <1> ;Returns ah=Number of Columns, al=Current Screen mode, bh=active page
   544 0000110A 8A2425[53010000]    <1>     mov ah, byte [scr_cols]
   545 00001111 8A0425[58010000]    <1>     mov al, byte [scr_mode]
   546 00001118 8A3C25[59010000]    <1>     mov bh, byte [scr_active_page]
   547 0000111F E989FBFFFF          <1>     jmp .exit
   548                              <1> 
   549                              <1> 
   550                              <1> ;Bad string argument for below function
   551                              <1> .wsbad:
   552 00001124 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   552 0000112D 00                  <1>
   553 0000112E E97AFBFFFF          <1>     jmp .exit
   554                              <1> .write_string:
   555                              <1> ;bh=page to print on, bl=attribute, cx=number of chars to print
   556                              <1> ;dh=y coord to print at, dl=x coord to print at, rbp=string
   557                              <1> ;al contains subfunction
   558                              <1> ;al=0 attrib in bl, cursor NOT updated
   559                              <1> ;al=1 attrib in bl, cursor updated
   560                              <1> ;al=2 string alt attrib/char, cursor NOT updated
   561                              <1> ;al=3 string alt attrib/char, cursor updated
   562                              <1> ;al=4 print 0 terminated string
   563 00001133 3C04                <1>     cmp al, 4h
   564 00001135 0F84AA000000        <1>     je .wszero    ;If its a zero terminated string, go down
   565 0000113B E3E7                <1>     jrcxz .wsbad
   566 0000113D 3C04                <1>     cmp al, 4h    ;Bad argument
   567 0000113F 77E3                <1>     ja .wsbad
   568                              <1> .ws:
   569 00001141 56                  <1>     push rsi
   570 00001142 51                  <1>     push rcx
   571 00001143 52                  <1>     push rdx
   572 00001144 53                  <1>     push rbx
   573 00001145 50                  <1>     push rax
   574                              <1> 
   575 00001146 53                  <1>     push rbx
   576 00001147 88FB                <1>     mov bl, bh
   577 00001149 0FB6DB              <1>     movzx ebx, bl
   578 0000114C 66678BB41B-         <1>     mov si, word [scr_curs_pos + 2*ebx]    ;Fast get cursor position
   578 00001151 [43010000]          <1>
   579 00001155 5B                  <1>     pop rbx
   580 00001156 56                  <1>     push rsi    ;Save the current cursor position
   581                              <1> 
   582 00001157 50                  <1>     push rax
   583 00001158 B402                <1>     mov ah, 02h    ;Set cursor at dx
   584 0000115A CD30                <1>     int 30h
   585 0000115C 58                  <1>     pop rax
   586                              <1> 
   587                              <1> .ws0:
   588 0000115D 51                  <1>     push rcx
   589 0000115E 53                  <1>     push rbx
   590 0000115F 50                  <1>     push rax
   591 00001160 88C4                <1>     mov ah, al
   592 00001162 8A4500              <1>     mov al, byte [rbp] ;Get char
   593 00001165 48FFC5              <1>     inc rbp
   594 00001168 3C07                <1>     cmp al, 07h
   595 0000116A 7462                <1>     je .wsctrlchar
   596 0000116C 3C08                <1>     cmp al, 08h
   597 0000116E 745E                <1>     je .wsctrlchar
   598 00001170 3C0A                <1>     cmp al, 0Ah
   599 00001172 745A                <1>     je .wsctrlchar
   600 00001174 3C0D                <1>     cmp al, 0Dh
   601 00001176 7456                <1>     je .wsctrlchar
   602                              <1> 
   603 00001178 80FC02              <1>     cmp ah, 2    ;Check if we need to get the char attrib too
   604 0000117B 7206                <1>     jb .ws1
   605 0000117D 8A5D00              <1>     mov bl, byte [rbp]    ;Get char attrib
   606 00001180 48FFC5              <1>     inc rbp
   607                              <1> .ws1:
   608 00001183 66B90100            <1>     mov cx, 1
   609 00001187 B409                <1>     mov ah, 09h    ;Print char and attrib (either given or taken)
   610 00001189 CD30                <1>     int 30h
   611                              <1> 
   612 0000118B FEC2                <1>     inc dl
   613 0000118D 3A1425[53010000]    <1>     cmp dl, byte [scr_cols]    ;Check if we passed the end of the row
   614 00001194 7515                <1>     jne .ws2    ;We havent, skip the reset
   615 00001196 30D2                <1>     xor dl, dl    ;Reset horizontal pos
   616 00001198 FEC6                <1>     inc dh        ;Goto next row
   617 0000119A 3A3425[53010000]    <1>     cmp dh, byte [scr_cols]    ;Have we passed the last row?
   618 000011A1 7508                <1>     jne .ws2    ;No, put cursor
   619 000011A3 66B80A0E            <1>     mov ax, 0E0Ah    ;Yes, do  TTY Line feed
   620 000011A7 CD30                <1>     int 30h
   621 000011A9 FECE                <1>     dec dh        ;Mov cursor to start of last row on page
   622                              <1> .ws2:
   623 000011AB B402                <1>     mov ah, 02
   624 000011AD CD30                <1>     int 30h    ;Put cursor at new location
   625                              <1> .ws3:
   626 000011AF 58                  <1>     pop rax
   627 000011B0 5B                  <1>     pop rbx
   628 000011B1 59                  <1>     pop rcx
   629                              <1> 
   630 000011B2 66FFC9              <1>     dec cx
   631 000011B5 75A6                <1>     jnz .ws0
   632                              <1> 
   633                              <1> .wsexitupdate:    ;Exit returning char to original position
   634 000011B7 5A                  <1>     pop rdx
   635 000011B8 3C01                <1>     cmp al, 01h
   636 000011BA 7408                <1>     je .wsexit
   637 000011BC 3C03                <1>     cmp al, 03h
   638 000011BE 7404                <1>     je .wsexit
   639                              <1> ;Exit returning char to original position    
   640 000011C0 B402                <1>     mov ah, 02h
   641 000011C2 CD30                <1>     int 30h 
   642                              <1> .wsexit:
   643 000011C4 58                  <1>     pop rax
   644 000011C5 5B                  <1>     pop rbx
   645 000011C6 5A                  <1>     pop rdx
   646 000011C7 59                  <1>     pop rcx
   647 000011C8 5E                  <1>     pop rsi
   648 000011C9 E9DFFAFFFF          <1>     jmp .exit
   649                              <1> .wsctrlchar:
   650                              <1> ;Handles Control Characters: ASCII Bell, Bspace, LF and CR
   651 000011CE B40E                <1>     mov ah, 0Eh
   652 000011D0 CD30                <1>     int 30h    ;Print control char as TTY
   653 000011D2 88FB                <1>     mov bl, bh
   654 000011D4 0FB6DB              <1>     movzx ebx, bl
   655 000011D7 66678B941B-         <1>     mov dx, word [scr_curs_pos + 2*ebx]    ;Fast get cursor position
   655 000011DC [43010000]          <1>
   656 000011E0 E9CAFFFFFF          <1>     jmp .ws3
   657                              <1> .wszero:
   658                              <1> ;Print zero terminated string at cursor on current active page
   659                              <1> ;Called with ax=1304, rbp=pointer to string
   660 000011E5 55                  <1>     push rbp
   661 000011E6 50                  <1>     push rax
   662                              <1> .wsz1:
   663 000011E7 8A4500              <1>     mov al, byte [rbp]
   664 000011EA 84C0                <1>     test al, al    ;Check al got a zero char
   665 000011EC 7409                <1>     jz .wsz2
   666 000011EE 48FFC5              <1>     inc rbp
   667 000011F1 B40E                <1>     mov ah, 0Eh
   668 000011F3 CD30                <1>     int 30h
   669 000011F5 EBF0                <1>     jmp short .wsz1
   670                              <1> .wsz2:
   671 000011F7 58                  <1>     pop rax
   672 000011F8 5D                  <1>     pop rbp
   673 000011F9 E9AFFAFFFF          <1>     jmp .exit
   674                              <1> 
   675                              <1> ;Graphics mode specific versions!
   676                              <1> .gread:
   677 000011FE 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   677 00001207 00                  <1>
   678 00001208 E9A0FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   679                              <1> .gwrite:
   680 0000120D 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   680 00001216 00                  <1>
   681 00001217 E991FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   682                              <1> .gscrollup:
   683 0000121C 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   683 00001225 00                  <1>
   684 00001226 E982FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   685                              <1> .gscrolldown:
   686 0000122B 48B8FFFF0000000000- <1>     mov rax, 0FFFFh
   686 00001234 00                  <1>
   687 00001235 E973FAFFFF          <1>     jmp .exit    ;Currently unsupported function
   688                              <1> 
   689                              <1> .write_crtc_word: ;Writes cx to the CRTC register in al and al+1
   690 0000123A 52                  <1>     push rdx
   691                              <1> 
   692 0000123B 668B1425[5A010000]  <1>     mov dx, word [scr_crtc_base]
   693 00001243 EE                  <1>     out dx, al
   694 00001244 FEC2                <1>     inc dl
   695 00001246 88C4                <1>     mov ah, al    ;Temp save al
   696 00001248 88E8                <1>     mov al, ch    ;Set high bits first
   697 0000124A EE                  <1>     out dx, al
   698                              <1> 
   699 0000124B FECA                <1>     dec dl
   700 0000124D 88E0                <1>     mov al, ah    ;Bring back al into al
   701 0000124F FEC0                <1>     inc al ;GOTO next CTRC address
   702                              <1> 
   703 00001251 EE                  <1>     out dx, al
   704 00001252 FEC2                <1>     inc dl
   705 00001254 88C8                <1>     mov al, cl
   706 00001256 EE                  <1>     out dx, al 
   707                              <1> 
   708 00001257 5A                  <1>     pop rdx
   709 00001258 C3                  <1>     ret
   710                              <1> 
   711                              <1> .get_page_base:
   712                              <1> ;Returns in rsi, the base address of the selected page
   713                              <1> ;Called with BH = page number, BL=screen mode
   714                              <1> ;return RSI=Base of selected page, since rsi is already clobbered
   715 00001259 51                  <1>     push rcx
   716 0000125A 53                  <1>     push rbx
   717                              <1> 
   718 0000125B 88F9                <1>     mov cl, bh    ;mov into cl, free bx
   719 0000125D 480FB6C9            <1>     movzx rcx, cl
   720                              <1> ;----Modify this proc with data tables when finalised!!----
   721 00001261 80FB02              <1>     cmp bl, 2
   722 00001264 66BB0010            <1>     mov bx, 1000h    ;Doesnt affect flags
   723 00001268 48BE00080000000000- <1>     mov rsi, 800h    ;si is a free register
   723 00001271 00                  <1>
   724 00001272 660F42DE            <1>     cmovb bx, si    ;if below, replace with 800h
   725 00001276 480FB7DB            <1>     movzx rbx, bx        ;zero extend
   726 0000127A 8B3425[5C010000]    <1>     mov esi, dword [scr_page_addr]
   727 00001281 E308                <1>     jrcxz .gpb1        ;Dont enter the loop if cx is zero
   728                              <1> .gpb0:
   729 00001283 4801DE              <1>     add rsi, rbx    ;add pagesize cx times
   730 00001286 48FFC9              <1>     dec rcx
   731 00001289 75F8                <1>     jnz .gpb0        ;go around
   732                              <1> 
   733                              <1> .gpb1:
   734 0000128B 5B                  <1>     pop rbx
   735 0000128C 59                  <1>     pop rcx
   736 0000128D C3                  <1>     ret
   737                              <1> 
   738                              <1> .page_cursor_offset:
   739                              <1> ;Returns in rax the offset into the RAM page of the cursor
   740                              <1> ;Works for A/N modes and graphic, though must be shl by 1 for A/N modes
   741                              <1> ;bh contains page to work out address 
   742 0000128E 53                  <1>     push rbx
   743 0000128F 88FB                <1>     mov bl, bh    ;bring the page number from bh into bl
   744 00001291 480FB6DB            <1>     movzx rbx, bl            
   745 00001295 668B841B[43010000]  <1>     mov ax, word [scr_curs_pos + 2*rbx]    ;move cursor position into ax
   746 0000129D 5B                  <1>     pop rbx
   747                              <1> .offset_from_ax:
   748                              <1> ;Same as above but now ax needs to be packed as in the cursor
   749 0000129E 52                  <1>     push rdx
   750 0000129F 53                  <1>     push rbx
   751 000012A0 4831DB              <1>     xor rbx, rbx
   752 000012A3 00C3                <1>     add bl, al    ;move columns into bl
   753 000012A5 66C1E808            <1>     shr ax, 8    ;mov rows from ah to al to use 8 bit mul
   754                              <1>     
   755 000012A9 F62425[53010000]    <1>     mul byte [scr_cols]    ;multiply the row we are on by columns, store in ax
   756 000012B0 6601D8              <1>     add ax, bx        ;add number of columns to this mix!
   757 000012B3 480FB7C0            <1>     movzx rax, ax
   758                              <1> 
   759 000012B7 5B                  <1>     pop rbx
   760 000012B8 5A                  <1>     pop rdx
   761 000012B9 C3                  <1>     ret
   762                              <1> .text_scroll_c1:
   763                              <1> ;Common function
   764                              <1> ;Scrolls a single pair of lines from column given in cl to dl
   765                              <1> ;rsi/rdi assumed to be pointing at the right place
   766                              <1> ;Direction to be set by calling function
   767                              <1> ;All registers EXCEPT pointers preserved, rbp returns # of words
   768 000012BA 51                  <1>     push rcx
   769 000012BB 52                  <1>     push rdx
   770 000012BC 4831ED              <1>     xor rbp, rbp
   771 000012BF 88CE                <1>     mov dh, cl    ;Save upper left corner in dh, freeing cx
   772 000012C1 88D1                <1>     mov cl, dl    
   773 000012C3 28F1                <1>     sub cl, dh    ;Get correct number of words to copy into cl
   774 000012C5 480FB6C9            <1>     movzx rcx, cl
   775 000012C9 48FFC1              <1>     inc rcx    ;absolute value, not offset
   776 000012CC 4889CD              <1>     mov rbp, rcx    ;Save number of words in rbp
   777 000012CF F366A5              <1>     rep movsw    ;Move char/attrib for one row
   778 000012D2 5A                  <1>     pop rdx
   779 000012D3 59                  <1>     pop rcx
   780 000012D4 C3                  <1>     ret
   781                              <1> .cursor_proc:
   782                              <1> ;Called with bh containing page number
   783                              <1> ;Sets cursor on page in bh
   784                              <1> ;Returns nothing
   785 000012D5 E8B4FFFFFF          <1>     call .page_cursor_offset    ;rax rets offset, no shift needed
   786                              <1> 
   787 000012DA 88F9                <1>     mov cl, bh
   788 000012DC 480FB6C9            <1>     movzx rcx, cl
   789                              <1> ;----Modify this proc with data tables when finalised!!----
   790 000012E0 6631F6              <1>     xor si, si    
   791 000012E3 66BA0008            <1>     mov dx, 800h ;Most legacy Pages are sized 800h PELs, VGA greater
   792 000012E7 803C25[58010000]02  <1>     cmp byte [scr_mode], 2
   793 000012EF 7303                <1>     jae .cp1
   794 000012F1 66D1EA              <1>     shr dx, 1    ;If in modes 0,1, 400h PELs per page
   795                              <1> .cp1:
   796 000012F4 84C9                <1>     test cl, cl
   797 000012F6 7407                <1>     jz .cpwrite
   798 000012F8 6601D6              <1>     add si, dx 
   799 000012FB FEC9                <1>     dec cl
   800 000012FD 75F5                <1>     jnz .cp1
   801                              <1> 
   802                              <1> .cpwrite:
   803 000012FF 6689C1              <1>     mov cx, ax    ;move ax into cx
   804 00001302 6601F1              <1>     add cx, si
   805 00001305 B00E                <1>     mov al, 0Eh    ;Cursor row
   806 00001307 E82EFFFFFF          <1>     call .write_crtc_word    ;cx has data to output, al is crtc reg
   807                              <1> 
   808 0000130C C3                  <1>     ret
   809                              <1> ;------------------------End of Interrupt------------------------
    94                                  %include "./Source/Resident/Services/Int31h.asm"
     1                              <1> ;-----------------------Basic Config Int 31h---------------------
     2                              <1> ;This interrupt returns in ax the Hardware Bitfield from the 
     3                              <1> ; data area and the mass storage device details.
     4                              <1> ;----------------------------------------------------------------
     5                              <1> machineWord_io:
     6 0000130D 668B0425[C9010000]  <1>     mov ax, word [MachineWord]    ;Return the legacy bitfield
     7                              <1> 
     8 00001315 4C0FB60425-         <1>     movzx r8, byte [i33Devices] ;Get Number of i33h devices
     8 0000131A [A8010000]          <1>
     9 0000131E 49C1E008            <1>     shl r8, 8   ;Shift up by a byte
    10 00001322 448A0425[4C020000]  <1>     mov r8b, byte [numMSD]  ;Get the number of Mass Storage Devices (on EHCI)
    11 0000132A 49C1E008            <1>     shl r8, 8   ;Shift up by a byte again
    12 0000132E 448A0425[AA010000]  <1>     mov r8b, byte [fdiskNum]    ;Get the number of fixed disks
    13 00001336 49C1E008            <1>     shl r8, 8  ;Shift up by a byte again
    14 0000133A 448A0425[66000000]  <1>     mov r8b, byte [numCOM]      ;Get the number of COM ports
    15                              <1> 
    16 00001342 48CF                <1>     iretq
    17                              <1> ;------------------------End of Interrupt------------------------
    95                                  %include "./Source/Resident/Services/Int32h.asm"
     1                              <1> ;------------------------Basic RAM Int 32h-----------------------
     2                              <1> ;This interrupt returns in ax amount of conventional memory in ax
     3                              <1> ;----------------------------------------------------------------
     4                              <1> convRAM_io:
     5 00001344 668B0425[CB010000]  <1>     mov ax, word [convRAM]    ;Return the amount of conventional RAM
     6 0000134C 4C8B0425[CD010000]  <1>     mov r8, qword [userBase]    ;Return the userbase to a caller
     7 00001354 4C8B0C25[F0050000]  <1>     mov r9, qword [bigmapptr]   ;Return the big Map pointer 
     8 0000135C 4C0FB61425-         <1>     movzx r10, byte [bigmapSize]    ;Return the number of 24 byte entries
     8 00001361 [D5010000]          <1>
     9 00001365 48CF                <1>     iretq
    10                              <1> ;------------------------End of Interrupt------------------------
    96                                  %include "./Source/Resident/Services/Int33h.asm"
     1                              <1> ;---------------------Storage Interrupt Int 33h------------------
     2                              <1> ;Input : dl = Drive number, rbx = Address of buffer, 
     3                              <1> ;        al = number of sectors, ch = Track number, 
     4                              <1> ;        cl = Sector number, dh = Head number
     5                              <1> ;Input LBA: dl = Drive Number, rbx = Address of Buffer, 
     6                              <1> ;           al = number of sectors, rcx = LBA number
     7                              <1> ;
     8                              <1> ;All registers not mentioned above, preserved
     9                              <1> ;----------------------------------------------------------------
    10                              <1> disk_io:
    11 00001367 FC                  <1>     cld ;Ensure all string reads/writes are in the right way
    12 00001368 F6C280              <1>     test dl, 80h
    13 0000136B 0F8542070000        <1>     jnz fdisk_io    ;If bit 7 set, goto Fixed disk routines
    14 00001371 52                  <1>     push rdx
    15 00001372 FEC2                <1>     inc dl          ;Inc device number count to absolute value
    16 00001374 3A1425[4C020000]    <1>     cmp dl, byte [numMSD]   ;For now, numMSD, eventually, numRemDrv
    17 0000137B 5A                  <1>     pop rdx
    18 0000137C 0F8786000000        <1>     ja .baddev
    19 00001382 80FC16              <1>     cmp ah, 16h
    20 00001385 0F84E3030000        <1>     jz .deviceChanged   ;Pick it off
    21                              <1> 
    22 0000138B E8B7040000          <1>     call .busScan   ;Bus scan only in valid cases
    23 00001390 803C25[A9010000]40  <1>     cmp byte [msdStatus], 40h   ;Media seek failed
    24 00001398 747E                <1>     je .noDevInDrive
    25                              <1> 
    26 0000139A 84E4                <1>     test ah, ah
    27 0000139C 0F8484000000        <1>     jz .reset           ;ah = 00h Reset Device
    28 000013A2 FECC                <1>     dec ah
    29 000013A4 0F84AF000000        <1>     jz .statusreport    ;ah = 01h Get status of last op and req. sense if ok 
    30                              <1> 
    31 000013AA C60425[A9010000]00  <1>     mov byte [msdStatus], 00    ;Reset status byte for following operations
    32                              <1> 
    33 000013B2 FECC                <1>     dec ah
    34 000013B4 0F841E010000        <1>     jz .readsectors     ;ah = 02h CHS Read Sectors
    35 000013BA FECC                <1>     dec ah
    36 000013BC 0F843E010000        <1>     jz .writesectors    ;ah = 03h CHS Write Sectors
    37 000013C2 FECC                <1>     dec ah
    38 000013C4 0F8457010000        <1>     jz .verify          ;ah = 04h CHS Verify Sectors
    39 000013CA FECC                <1>     dec ah
    40 000013CC 0F8470010000        <1>     jz .format          ;ah = 05h CHS Format Track (Select Head and Cylinder)
    41                              <1> 
    42 000013D2 80FC02              <1>     cmp ah, 02h
    43 000013D5 0F84A1020000        <1>     je .formatLowLevel  ;ah = 07h (SCSI) Low Level Format Device
    44                              <1> 
    45 000013DB 80FC7D              <1>     cmp ah, 7Dh         ;ah = 82h LBA Read Sectors
    46 000013DE 0F84E5010000        <1>     je .lbaread
    47 000013E4 80FC7E              <1>     cmp ah, 7Eh         ;ah = 83h LBA Write Sectors
    48 000013E7 0F8401020000        <1>     je .lbawrite
    49 000013ED 80FC7F              <1>     cmp ah, 7Fh         ;ah = 84h LBA Verify Sectors
    50 000013F0 0F841D020000        <1>     je .lbaverify
    51 000013F6 80FC80              <1>     cmp ah, 80h         ;ah = 85h LBA Format Sectors
    52 000013F9 0F8439020000        <1>     je .lbaformat
    53 000013FF 80FC83              <1>     cmp ah, 83h         ;ah = 88h LBA Read Drive Parameters
    54 00001402 0F8496020000        <1>     je .lbareadparams
    55                              <1> .baddev:
    56 00001408 B401                <1>     mov ah, 01h
    57 0000140A 882425[A9010000]    <1>     mov byte [msdStatus], ah   ;Invalid function requested signature
    58                              <1> .bad:
    59 00001411 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
    60 00001416 48CF                <1>     iretq
    61                              <1> .noDevInDrive:
    62 00001418 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
    63 0000141F 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
    64 00001424 48CF                <1>     iretq
    65                              <1> .reset: ;Device Reset
    66 00001426 56                  <1>     push rsi
    67 00001427 52                  <1>     push rdx
    68 00001428 E8F2020000          <1>     call .i33ehciGetDevicePtr
    69 0000142D E8E0270000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
    70 00001432 E867370000          <1>     call USB.ehciMsdBOTResetRecovery
    71                              <1> .rrexit:
    72 00001437 5A                  <1>     pop rdx
    73 00001438 5E                  <1>     pop rsi
    74 00001439 720E                <1>     jc .rrbad
    75 0000143B 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
    76 00001442 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
    77 00001447 48CF                <1>     iretq
    78                              <1> .rrbad:
    79 00001449 B405                <1>     mov ah, 5   ;Reset failed
    80 0000144B 882425[A9010000]    <1>     mov byte [msdStatus], ah
    81 00001452 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
    82 00001457 48CF                <1>     iretq
    83                              <1> .statusreport:  
    84                              <1> ;If NOT a host/bus/ctrlr type error, request sense and ret code
    85 00001459 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Get last status into ah
    86 00001460 84E4                <1>     test ah, ah ;If status is zero, exit
    87 00001462 7507                <1>     jnz .srmain
    88 00001464 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh     ;Clear CF
    89 00001469 48CF                <1>     iretq
    90                              <1> .srmain:
    91 0000146B C60425[A9010000]00  <1>     mov byte [msdStatus], 00    ;Reset status byte
    92 00001473 80FC20              <1>     cmp ah, 20h     ;General Controller failure?
    93 00001476 7448                <1>     je .srexit
    94 00001478 80FC80              <1>     cmp ah, 80h     ;Timeout?
    95 0000147B 7443                <1>     je .srexit
    96                              <1> ;Issue a Request sense command
    97 0000147D 56                  <1>     push rsi
    98 0000147E 50                  <1>     push rax    ;Save original error code in ah on stack
    99 0000147F E89B020000          <1>     call .i33ehciGetDevicePtr
   100 00001484 E889270000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   101 00001489 7240                <1>     jc .srexitbad1
   102 0000148B E8CF3C0000          <1>     call USB.ehciMsdBOTRequestSense
   103 00001490 E8DE370000          <1>     call USB.ehciMsdBOTCheckTransaction
   104 00001495 84E4                <1>     test ah, ah
   105 00001497 58                  <1>     pop rax         ;Get back original error code
   106 00001498 752D                <1>     jnz .srexitbad2
   107 0000149A 4C0FB60425-         <1>     movzx r8, byte [ehciDataIn + 13]  ;Get ASCQ into r8
   107 0000149F [CD030000]          <1>
   108 000014A3 49C1E008            <1>     shl r8, 8                        ;Make space in lower byte of r8 for ASC key
   109 000014A7 448A0425[CC030000]  <1>     mov r8b, byte [ehciDataIn + 12]   ;Get ASC into r8
   110 000014AF 49C1E008            <1>     shl r8, 8                    ;Make space in lower byte of r8 for sense key
   111 000014B3 448A0425[C2030000]  <1>     mov r8b, byte [ehciDataIn + 2]  ;Get sense key into al
   112 000014BB 4180C8F0            <1>     or r8b, 0F0h                    ;Set sense signature (set upper nybble F)
   113 000014BF 5E                  <1>     pop rsi
   114                              <1> .srexit:
   115 000014C0 804C241001          <1>     or byte [rsp + 2*8h], 1 ;Non-zero error, requires CF=CY
   116 000014C5 48CF                <1>     iretq
   117                              <1> .srexitbad2:
   118 000014C7 B4FF                <1>     mov ah, -1  ;Sense operation failed
   119 000014C9 EB03                <1>     jmp short .srexitbad
   120                              <1> .srexitbad1:
   121 000014CB 58                  <1>     pop rax ;Pop the original error code from the stack
   122 000014CC B420                <1>     mov ah, 20h ;General Controller Failure
   123                              <1> .srexitbad:
   124 000014CE 5E                  <1>     pop rsi
   125 000014CF 882425[A9010000]    <1>     mov byte [msdStatus], ah
   126 000014D6 EBE8                <1>     jmp short .srexit
   127                              <1> 
   128                              <1> .readsectors:
   129 000014D8 57                  <1>     push rdi
   130 000014D9 48BF-               <1>     mov rdi, USB.ehciMsdBOTInSector512
   130 000014DB [8152000000000000]  <1>
   131 000014E3 E8EB010000          <1>     call .sectorsEHCI
   132 000014E8 5F                  <1>     pop rdi
   133 000014E9 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   134 000014F0 7207                <1>     jc .rsbad
   135 000014F2 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   136 000014F7 48CF                <1>     iretq
   137                              <1> .rsbad:
   138 000014F9 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   139 000014FE 48CF                <1>     iretq
   140                              <1> 
   141                              <1> .writesectors:
   142 00001500 57                  <1>     push rdi
   143 00001501 48BF-               <1>     mov rdi, USB.ehciMsdBOTOutSector512
   143 00001503 [3852000000000000]  <1>
   144 0000150B E8C3010000          <1>     call .sectorsEHCI
   145 00001510 5F                  <1>     pop rdi
   146 00001511 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   147 00001518 72DF                <1>     jc .rsbad
   148 0000151A 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   149 0000151F 48CF                <1>     iretq
   150                              <1> 
   151                              <1> .verify:
   152 00001521 57                  <1>     push rdi
   153 00001522 48BF-               <1>     mov rdi, USB.ehciMsdBOTVerify
   153 00001524 [1151000000000000]  <1>
   154 0000152C E8A2010000          <1>     call .sectorsEHCI   ;Verify sector by sector
   155 00001531 5F                  <1>     pop rdi
   156 00001532 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   157 00001539 72BE                <1>     jc .rsbad
   158 0000153B 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   159 00001540 48CF                <1>     iretq
   160                              <1> .format:
   161                              <1> ;Cleans sectors on chosen track. DOES NOT Low Level Format.
   162                              <1> ;Fills sectors with fill byte from table
   163 00001542 50                  <1>     push rax
   164 00001543 53                  <1>     push rbx
   165 00001544 51                  <1>     push rcx
   166 00001545 56                  <1>     push rsi
   167 00001546 57                  <1>     push rdi
   168 00001547 55                  <1>     push rbp
   169                              <1> 
   170 00001548 51                  <1>     push rcx                    ;Save ch = Cylinder number
   171 00001549 488B3425[AF010000]  <1>     mov rsi, qword [diskDptPtr]
   172 00001551 B880000000          <1>     mov eax, 80h                 ;128 bytes
   173 00001556 8A4E03              <1>     mov cl, byte [rsi + 3]  ;Bytes per track
   174 00001559 D3E0                <1>     shl eax, cl                  ;Multiply 128 bytes per sector by multiplier
   175 0000155B 89C1                <1>     mov ecx, eax
   176 0000155D 8A4608              <1>     mov al, byte [rsi + 8]  ;Fill byte for format
   177 00001560 48BF-               <1>     mov rdi, sectorbuffer       ;Large enough buffer
   177 00001562 [C003000000000000]  <1>
   178 0000156A F3AA                <1>     rep stosb                   ;Create mock sector
   179                              <1> 
   180 0000156C 8A4E04              <1>     mov cl, byte [rsi + 4]  ;Get sectors per track
   181 0000156F 0FB6E9              <1>     movzx ebp, cl               ;Put number of sectors in Cylinder in ebp
   182                              <1> 
   183 00001572 59                  <1>     pop rcx                     ;Get back Cylinder number in ch
   184 00001573 B101                <1>     mov cl, 1                   ;Ensure start at sector 1 of Cylinder
   185                              <1> 
   186 00001575 E8D3010000          <1>     call .convertCHSLBA ;Converts to valid 32 bit LBA in ecx for geometry type
   187                              <1>     ;ecx now has LBA
   188                              <1> .formatcommon:
   189 0000157A E8A0010000          <1>     call .i33ehciGetDevicePtr
   190 0000157F 7245                <1>     jc .fbad
   191 00001581 89CA                <1>     mov edx, ecx    ;Load edx for function call
   192                              <1> ;Replace this section with a single USB function
   193 00001583 E88A260000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   194 00001588 48BB-               <1>     mov rbx, sectorbuffer
   194 0000158A [C003000000000000]  <1>
   195                              <1> .f0:
   196 00001592 E8A13C0000          <1>     call USB.ehciMsdBOTOutSector512
   197 00001597 0F8277010000        <1>     jc .sebadBB
   198 0000159D FFC2                <1>     inc edx ;Inc LBA
   199 0000159F FFCD                <1>     dec ebp ;Dec number of sectors to act on
   200 000015A1 75EF                <1>     jnz .f0
   201 000015A3 F8                  <1>     clc
   202                              <1> .formatexit:
   203 000015A4 5D                  <1>     pop rbp
   204 000015A5 5F                  <1>     pop rdi
   205 000015A6 5E                  <1>     pop rsi
   206 000015A7 59                  <1>     pop rcx
   207 000015A8 5B                  <1>     pop rbx
   208 000015A9 58                  <1>     pop rax
   209 000015AA 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   210 000015B1 0F8242FFFFFF        <1>     jc .rsbad
   211 000015B7 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   212 000015BC 48CF                <1>     iretq
   213                              <1> .fbadBB:
   214 000015BE C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh  ;Unknown Error, request sense
   215                              <1> .fbad:
   216 000015C6 F9                  <1>     stc
   217 000015C7 EBDB                <1>     jmp short .formatexit
   218                              <1> .lbaread:
   219 000015C9 57                  <1>     push rdi
   220 000015CA 48BF-               <1>     mov rdi, USB.ehciMsdBOTInSector512
   220 000015CC [8152000000000000]  <1>
   221 000015D4 E88D000000          <1>     call .lbaCommon
   222 000015D9 5F                  <1>     pop rdi
   223 000015DA 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   224 000015E1 0F8212FFFFFF        <1>     jc .rsbad
   225 000015E7 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   226 000015EC 48CF                <1>     iretq   
   227                              <1> .lbawrite:
   228 000015EE 57                  <1>     push rdi
   229 000015EF 48BF-               <1>     mov rdi, USB.ehciMsdBOTOutSector512
   229 000015F1 [3852000000000000]  <1>
   230 000015F9 E868000000          <1>     call .lbaCommon
   231 000015FE 5F                  <1>     pop rdi
   232 000015FF 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   233 00001606 0F82EDFEFFFF        <1>     jc .rsbad
   234 0000160C 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   235 00001611 48CF                <1>     iretq
   236                              <1> .lbaverify:
   237 00001613 57                  <1>     push rdi
   238 00001614 48BF-               <1>     mov rdi, USB.ehciMsdBOTVerify
   238 00001616 [1151000000000000]  <1>
   239 0000161E E843000000          <1>     call .lbaCommon
   240 00001623 5F                  <1>     pop rdi
   241 00001624 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Return Error code in ah
   242 0000162B 0F82C8FEFFFF        <1>     jc .rsbad
   243 00001631 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   244 00001636 48CF                <1>     iretq
   245                              <1> .lbaformat:
   246 00001638 50                  <1>     push rax
   247 00001639 53                  <1>     push rbx
   248 0000163A 51                  <1>     push rcx
   249 0000163B 56                  <1>     push rsi
   250 0000163C 57                  <1>     push rdi
   251 0000163D 55                  <1>     push rbp
   252 0000163E 0FB6E8              <1>     movzx ebp, al ;Save the number of sectors to format in ebp
   253 00001641 51                  <1>     push rcx
   254 00001642 52                  <1>     push rdx
   255 00001643 B900020000          <1>     mov ecx, 200h
   256 00001648 48BF-               <1>     mov rdi, sectorbuffer
   256 0000164A [C003000000000000]  <1>
   257 00001652 488B1425[AF010000]  <1>     mov rdx, qword [diskDptPtr]
   258 0000165A 8A4208              <1>     mov al, byte [rdx + 8]  ;Fill byte for format
   259 0000165D F3AA                <1>     rep stosb
   260 0000165F 5A                  <1>     pop rdx
   261 00001660 59                  <1>     pop rcx
   262 00001661 E914FFFFFF          <1>     jmp .formatcommon
   263                              <1> 
   264                              <1> .lbaCommon:
   265 00001666 50                  <1>     push rax
   266 00001667 56                  <1>     push rsi
   267 00001668 53                  <1>     push rbx
   268 00001669 51                  <1>     push rcx
   269 0000166A 52                  <1>     push rdx
   270 0000166B 55                  <1>     push rbp
   271 0000166C 84C0                <1>     test al, al
   272 0000166E 0F8499000000        <1>     jz .se2 ;If al=0, skip copying sectors, clears CF
   273 00001674 0FB6E8              <1>     movzx ebp, al
   274 00001677 E969000000          <1>     jmp .seCommon
   275                              <1> 
   276                              <1> ;Low level format, ah=07h
   277                              <1> .formatLowLevel:
   278 0000167C 56                  <1>     push rsi
   279 0000167D 50                  <1>     push rax
   280 0000167E E89C000000          <1>     call .i33ehciGetDevicePtr   ;al = bus num, rsi = ehci device structure ptr
   281 00001683 E8223A0000          <1>     call USB.ehciMsdBOTFormatUnit
   282 00001688 58                  <1>     pop rax
   283 00001689 5E                  <1>     pop rsi
   284 0000168A 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   285 00001691 0F8262FEFFFF        <1>     jc .rsbad
   286 00001697 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   287 0000169C 48CF                <1>     iretq
   288                              <1> .lbareadparams:
   289                              <1> ;Reads drive parameters (for drive dl which is always valid at this point)
   290                              <1> ;Output: rbx = dBlockSize (Dword for LBA block size)
   291                              <1> ;        rcx = qLastLBANum (Qword address of last LBA)
   292                              <1> ;         dl = Number of removable devices 
   293                              <1> ;         ah = 0
   294 0000169E 52                  <1>     push rdx
   295 0000169F 50                  <1>     push rax
   296 000016A0 480FB6C2            <1>     movzx rax, dl   ;Move drive number offset into rax
   297 000016A4 48BA10000000000000- <1>     mov rdx, i33DevTblEntry_size
   297 000016AD 00                  <1>
   298 000016AE 48F7E2              <1>     mul rdx
   299 000016B1 488D90[C4030000]    <1>     lea rdx, qword [i33DevTbl + rax]  ;Move address into rdx
   300 000016B8 31DB                <1>     xor ebx, ebx
   301 000016BA 8B5A03              <1>     mov ebx, dword [rdx + 3]    ;Get dBlockSize for device
   302 000016BD 488B4A07            <1>     mov rcx, qword [rdx + 7]    ;Get qLastLBANum for device
   303 000016C1 58                  <1>     pop rax
   304 000016C2 5A                  <1>     pop rdx
   305 000016C3 8A1425[4C020000]    <1>     mov dl, byte [numMSD]
   306 000016CA 30E4                <1>     xor ah, ah
   307 000016CC 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   308 000016D1 48CF                <1>     iretq
   309                              <1> .sectorsEHCI:
   310                              <1> ;Input: rdi = Address of USB EHCI MSD BBB function
   311                              <1> ;Output: CF = CY: Error, exit
   312                              <1> ;        CF = NC: No Error
   313 000016D3 50                  <1>     push rax
   314 000016D4 56                  <1>     push rsi
   315 000016D5 53                  <1>     push rbx
   316 000016D6 51                  <1>     push rcx
   317 000016D7 52                  <1>     push rdx
   318 000016D8 55                  <1>     push rbp
   319 000016D9 84C0                <1>     test al, al
   320 000016DB 7430                <1>     jz .se2 ;If al=0, skip copying sectors, clears CF
   321 000016DD 0FB6E8              <1>     movzx ebp, al   ;Move the number of sectors into ebp
   322 000016E0 E868000000          <1>     call .convertCHSLBA ;Converts to valid 32 bit LBA in ecx for geometry type
   323                              <1>     ;ecx now has LBA
   324                              <1> .seCommon:  ;Entered with ebp = Number of Sectors and ecx = Start LBA
   325 000016E5 E835000000          <1>     call .i33ehciGetDevicePtr
   326 000016EA 7230                <1>     jc .sebad
   327 000016EC 4889CA              <1>     mov rdx, rcx    ;Load edx for function call
   328                              <1> ;Replace this section with a single USB function
   329 000016EF E81E250000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   330 000016F4 30C0                <1>     xor al, al      ;Sector counter
   331                              <1> .se1:
   332 000016F6 FEC0                <1>     inc al  ;Inc Sector counter
   333 000016F8 50                  <1>     push rax
   334 000016F9 FFD7                <1>     call rdi
   335 000016FB 58                  <1>     pop rax
   336 000016FC 7216                <1>     jc .sebadBB
   337 000016FE 4881C300020000      <1>     add rbx, 200h   ;Goto next sector
   338 00001705 48FFC2              <1>     inc rdx ;Inc LBA
   339 00001708 FFCD                <1>     dec ebp ;Dec number of sectors to act on
   340 0000170A 75EA                <1>     jnz .se1
   341 0000170C F8                  <1>     clc
   342                              <1> .se2:
   343 0000170D 5D                  <1>     pop rbp
   344 0000170E 5A                  <1>     pop rdx
   345 0000170F 59                  <1>     pop rcx
   346 00001710 5B                  <1>     pop rbx
   347 00001711 5E                  <1>     pop rsi
   348 00001712 58                  <1>     pop rax
   349 00001713 C3                  <1>     ret
   350                              <1> .sebadBB:
   351 00001714 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh  ;Unknown Error, request sense
   352                              <1> .sebad:
   353 0000171C F9                  <1>     stc
   354 0000171D EBEE                <1>     jmp short .se2
   355                              <1> 
   356                              <1> .i33ehciGetDevicePtr:
   357                              <1> ;Input: dl = Int 33h number whose 
   358                              <1> ;Output: rsi = Pointer to ehci msd device parameter block
   359                              <1> ;        al = EHCI bus the device is on
   360 0000171F 53                  <1>     push rbx    ;Need to temporarily preserve rbx
   361 00001720 480FB6C2            <1>     movzx rax, dl   ;Move drive number offset into rax
   362 00001724 48BA10000000000000- <1>     mov rdx, i33DevTblEntry_size
   362 0000172D 00                  <1>
   363 0000172E 48F7E2              <1>     mul rdx
   364 00001731 488D90[C4030000]    <1>     lea rdx, qword [i33DevTbl + rax]  ;Move address into rdx
   365 00001738 803A00              <1>     cmp byte [rdx], 0   ;Check to see if the device type is 0 (ie doesnt exist)
   366 0000173B 740E                <1>     jz .i33egdpbad ;If not, exit
   367 0000173D 668B4201            <1>     mov ax, word [rdx + 1]  ;Get address/Bus pair into ax
   368 00001741 E89D2D0000          <1>     call USB.ehciGetDevicePtr   ;Get device pointer into rsi
   369 00001746 88E0                <1>     mov al, ah          ;Get the bus into al
   370 00001748 5B                  <1>     pop rbx
   371 00001749 F8                  <1>     clc
   372 0000174A C3                  <1>     ret
   373                              <1> .i33egdpbad:
   374 0000174B F9                  <1>     stc
   375 0000174C C3                  <1>     ret
   376                              <1> 
   377                              <1> .convertCHSLBA:
   378                              <1> ;Converts a CHS address to LBA
   379                              <1> ;Input: dl = Drive number, if dl < 80h, use diskdpt. If dl > 80h, use hdiskdpt
   380                              <1> ;       ch = Track number, cl = Sector number, dh = Head number 
   381                              <1> ;Output: ecx = LBA address
   382                              <1> ;----------Reference Equations----------
   383                              <1> ;C = LBA / (HPC x SPT)
   384                              <1> ;H = (LBA / SPT) mod HPC
   385                              <1> ;S = (LBA mod SPT) + 1
   386                              <1> ;+++++++++++++++++++++++++++++++++++++++
   387                              <1> ;LBA = (( C x HPC ) + H ) x SPT + S - 1
   388                              <1> ;---------------------------------------
   389                              <1> ;Use diskdpt.spt for sectors per track value! 
   390                              <1> ;1.44Mb geometry => H=2, C=80, S=18
   391 0000174D 50                  <1>     push rax
   392 0000174E 56                  <1>     push rsi
   393 0000174F 488B3425[AF010000]  <1>     mov rsi, qword [diskDptPtr]
   394 00001757 D0E5                <1>     shl ch, 1   ;Multiply by HPC=2
   395 00001759 00F5                <1>     add ch, dh  ;Add head number
   396 0000175B 88E8                <1>     mov al, ch  ;al = ch = (( C x HPC ) + H )
   397 0000175D F66604              <1>     mul byte [rsi + 4]  ;Sectors per track
   398 00001760 30ED                <1>     xor ch, ch  
   399 00001762 6601C8              <1>     add ax, cx  ;Add sector number to ax
   400 00001765 66FFC8              <1>     dec ax
   401 00001768 0FB7C8              <1>     movzx ecx, ax
   402 0000176B 5E                  <1>     pop rsi
   403 0000176C 58                  <1>     pop rax
   404 0000176D C3                  <1>     ret
   405                              <1> .deviceChanged:
   406                              <1> ;Entry: dl = Drive number
   407                              <1> ;Exit: ah = 00h, No device changed occured, CF = CN
   408                              <1> ;      ah = 01h, Device changed occured, CF = CN
   409                              <1> ;      CF = CY if an error occured or device removed
   410 0000176E 53                  <1>     push rbx
   411 0000176F 51                  <1>     push rcx
   412 00001770 52                  <1>     push rdx
   413 00001771 56                  <1>     push rsi
   414 00001772 57                  <1>     push rdi
   415 00001773 55                  <1>     push rbp
   416 00001774 4150                <1>     push r8
   417 00001776 4151                <1>     push r9
   418 00001778 4152                <1>     push r10
   419 0000177A 4153                <1>     push r11
   420                              <1> 
   421 0000177C 50                  <1>     push rax
   422                              <1> 
   423 0000177D 4C0FB61C25-         <1>     movzx r11, byte [msdStatus] ;Preserve the original status byte
   423 00001782 [A9010000]          <1>
   424 00001786 0FB6EA              <1>     movzx ebp, dl               ;Save the device number in ebp
   425 00001789 E891FFFFFF          <1>     call .i33ehciGetDevicePtr   ;Get MSD dev data block ptr in rsi and bus in al
   426                              <1> ;Check port on device for status change.
   427 0000178E 807E0200            <1>     cmp byte [rsi + 2], 0   ;Check if root hub
   428 00001792 0F8493000000        <1>     jz .dcRoot
   429                              <1> ;External Hub procedure
   430 00001798 668B4601            <1>     mov ax, word [rsi + 1]  ;Get bus and host hub address
   431 0000179C 86C4                <1>     xchg al, ah             ;Swap endianness
   432 0000179E 4989F1              <1>     mov r9, rsi
   433 000017A1 E83D2D0000          <1>     call USB.ehciGetDevicePtr   ;Get the hub address in rsi
   434 000017A6 88E0                <1>     mov al, ah
   435 000017A8 E865240000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   436 000017AD C70425[C0030000]00- <1>     mov dword [ehciDataIn], 0
   436 000017B5 000000              <1>
   437 000017B8 48BAA3000000000004- <1>     mov rdx, 00040000000000A3h ;Get Port status
   437 000017C1 00                  <1>
   438 000017C2 410FB65903          <1>     movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
   439 000017C7 48C1E320            <1>     shl rbx, 4*8    ;Shift port number to right position
   440 000017CB 4809D3              <1>     or rbx, rdx
   441 000017CE 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
   442 000017D2 8A06                <1>     mov al, byte [rsi]      ;Get upstream hub address
   443 000017D4 E82F260000          <1>     call USB.ehciGetRequest
   444 000017D9 723A                <1>     jc .dcError
   445                              <1> 
   446 000017DB 49B8-               <1>     mov r8, USB.ehciEnumerateHubPort    ;Store address for if bit is set
   446 000017DD [6E47000000000000]  <1>
   447 000017E5 8B1425[C0030000]    <1>     mov edx, dword [ehciDataIn]
   448 000017EC 81E200000100        <1>     and edx, 10000h ;Isolate the port status changed bit
   449 000017F2 C1EA10              <1>     shr edx, 10h    ;Shift status from bit 16 to bit 0
   450                              <1> .dcNoError:
   451 000017F5 44881C25[A9010000]  <1>     mov byte [msdStatus], r11b  ;Return back the original status byte
   452 000017FD 58                  <1>     pop rax
   453 000017FE 88D4                <1>     mov ah, dl                  ;Place return value in ah
   454 00001800 415B                <1>     pop r11
   455 00001802 415A                <1>     pop r10
   456 00001804 4159                <1>     pop r9
   457 00001806 4158                <1>     pop r8
   458 00001808 5D                  <1>     pop rbp
   459 00001809 5F                  <1>     pop rdi
   460 0000180A 5E                  <1>     pop rsi
   461 0000180B 5A                  <1>     pop rdx
   462 0000180C 59                  <1>     pop rcx
   463 0000180D 5B                  <1>     pop rbx
   464 0000180E 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear CF
   465 00001813 48CF                <1>     iretq
   466                              <1> .dcError:
   467 00001815 58                  <1>     pop rax ;Just return the old rax value
   468 00001816 415B                <1>     pop r11
   469 00001818 415A                <1>     pop r10
   470 0000181A 4159                <1>     pop r9
   471 0000181C 4158                <1>     pop r8
   472 0000181E 5D                  <1>     pop rbp
   473 0000181F 5F                  <1>     pop rdi
   474 00001820 5E                  <1>     pop rsi
   475 00001821 5A                  <1>     pop rdx
   476 00001822 59                  <1>     pop rcx
   477 00001823 5B                  <1>     pop rbx
   478 00001824 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
   479 00001829 48CF                <1>     iretq
   480                              <1> .dcRoot:
   481                              <1> ;Root hub procedure.
   482 0000182B E8E2230000          <1>     call USB.ehciAdjustAsyncSchedCtrlr  ;Reset the bus if needed
   483 00001830 E8C43B0000          <1>     call USB.ehciGetOpBase      ;Get opbase into rax
   484 00001835 0FB65E03            <1>     movzx ebx, byte [rsi + 3]   ;Get MSD port number into dl
   485 00001839 FFCB                <1>     dec ebx                     ;Reduce by one
   486 0000183B 678B549844          <1>     mov edx, dword [eax + 4*ebx + ehciportsc]  ;Get port status into eax
   487 00001840 80E202              <1>     and dl, 2h      ;Only save bit 1, status changed bit
   488 00001843 D0EA                <1>     shr dl, 1       ;Shift down by one bit
   489 00001845 EBAE                <1>     jmp short .dcNoError    ;Exit
   490                              <1> .busScan:
   491                              <1> ;Will request the hub bitfield from the RMH the device is plugged in to.
   492                              <1> ;Preserves ALL registers.
   493                              <1> ;dl = Device number
   494                              <1> 
   495                              <1> ;If status changed bit set, call appropriate enumeration function.
   496                              <1> ;If enumeration returns empty device, keep current device data blocks in memory,
   497                              <1> ; but return Int 33h error 40h = Seek operation Failed.
   498 00001847 50                  <1>     push rax
   499 00001848 53                  <1>     push rbx
   500 00001849 51                  <1>     push rcx
   501 0000184A 52                  <1>     push rdx
   502 0000184B 56                  <1>     push rsi
   503 0000184C 57                  <1>     push rdi
   504 0000184D 55                  <1>     push rbp
   505 0000184E 4150                <1>     push r8
   506 00001850 4151                <1>     push r9
   507 00001852 4152                <1>     push r10
   508 00001854 4153                <1>     push r11
   509                              <1> 
   510 00001856 4C0FB61C25-         <1>     movzx r11, byte [msdStatus] ;Preserve the original status
   510 0000185B [A9010000]          <1>
   511                              <1> 
   512 0000185F 0FB6EA              <1>     movzx ebp, dl               ;Save the device number in ebp
   513 00001862 E8B8FEFFFF          <1>     call .i33ehciGetDevicePtr   ;Get MSD dev data block ptr in rsi and bus in al
   514                              <1> ;Check port on device for status change.
   515 00001867 807E0200            <1>     cmp byte [rsi + 2], 0   ;Check if root hub
   516 0000186B 0F84CE000000        <1>     jz .bsRoot
   517                              <1> ;External Hub procedure
   518 00001871 668B4601            <1>     mov ax, word [rsi + 1]  ;Get bus and host hub address
   519 00001875 86C4                <1>     xchg al, ah             ;Swap endianness
   520 00001877 4989F1              <1>     mov r9, rsi
   521 0000187A E8642C0000          <1>     call USB.ehciGetDevicePtr   ;Get the hub address in rsi
   522 0000187F 88E0                <1>     mov al, ah
   523 00001881 E88C230000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   524 00001886 C70425[C0030000]00- <1>     mov dword [ehciDataIn], 0
   524 0000188E 000000              <1>
   525 00001891 48BAA3000000000004- <1>     mov rdx, 00040000000000A3h ;Get Port status
   525 0000189A 00                  <1>
   526 0000189B 410FB65903          <1>     movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
   527 000018A0 48C1E320            <1>     shl rbx, 4*8    ;Shift port number to right position
   528 000018A4 4809D3              <1>     or rbx, rdx
   529 000018A7 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
   530 000018AB 8A06                <1>     mov al, byte [rsi]      ;Get upstream hub address
   531 000018AD E856250000          <1>     call USB.ehciGetRequest
   532 000018B2 722C                <1>     jc .bsErrorExit
   533                              <1> 
   534 000018B4 49B8-               <1>     mov r8, USB.ehciEnumerateHubPort    ;Store address for if bit is set
   534 000018B6 [6E47000000000000]  <1>
   535 000018BE 8B1425[C0030000]    <1>     mov edx, dword [ehciDataIn]
   536 000018C5 81E201000100        <1>     and edx, 10001h
   537 000018CB F7C200000100        <1>     test edx, 10000h
   538 000018D1 752A                <1>     jnz .bsClearPortChangeStatus    ;If top bit set, clear port change bit
   539                              <1> .bsret:
   540 000018D3 F6C201              <1>     test dl, 1h
   541 000018D6 7418                <1>     jz .bsrExit06h  ;Bottom bit not set, exit media changed Error (edx = 00000h)
   542                              <1> .bsexit:    ;The fall through is (edx = 00001h), no change to dev in port
   543 000018D8 44881C25[A9010000]  <1>     mov byte [msdStatus], r11b  ;Get back the original status byte
   544                              <1> .bsErrorExit:
   545 000018E0 415B                <1>     pop r11
   546 000018E2 415A                <1>     pop r10
   547 000018E4 4159                <1>     pop r9
   548 000018E6 4158                <1>     pop r8
   549 000018E8 5D                  <1>     pop rbp
   550 000018E9 5F                  <1>     pop rdi
   551 000018EA 5E                  <1>     pop rsi
   552 000018EB 5A                  <1>     pop rdx
   553 000018EC 59                  <1>     pop rcx
   554 000018ED 5B                  <1>     pop rbx
   555 000018EE 58                  <1>     pop rax
   556 000018EF C3                  <1>     ret
   557                              <1> .bsrExit06h:    ;If its clear, nothing in port, return media changed error
   558 000018F0 49BB06000000000000- <1>     mov r11, 06h ;Change the msdStatus byte, media changed or removed
   558 000018F9 00                  <1>
   559 000018FA F9                  <1>     stc
   560 000018FB EBDB                <1>     jmp short .bsexit
   561                              <1> .bsClearPortChangeStatus:
   562 000018FD 52                  <1>     push rdx
   563 000018FE C70425[C0030000]00- <1>     mov dword [ehciDataIn], 0
   563 00001906 000000              <1>
   564 00001909 48BA23011000000000- <1>     mov rdx, 0000000000100123h  ;Set Port status
   564 00001912 00                  <1>
   565 00001913 410FB65903          <1>     movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
   566 00001918 48C1E320            <1>     shl rbx, 4*8    ;Shift port number to right position
   567 0000191C 4809D3              <1>     or rbx, rdx
   568 0000191F 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
   569 00001923 8A06                <1>     mov al, byte [rsi]      ;Get device address
   570 00001925 E83F240000          <1>     call USB.ehciSetNoData
   571 0000192A 5A                  <1>     pop rdx
   572 0000192B 72B3                <1>     jc .bsErrorExit  ;If error exit by destroying the old msdStatus
   573                              <1> 
   574 0000192D F6C201              <1>     test dl, 1h
   575 00001930 74BE                <1>     jz .bsrExit06h  ;Bottom bit not set, exit media changed error (edx = 10000h)
   576 00001932 EB4E                <1>     jmp short .bsCommonEP   ;Else new device in port needs enum (edx = 10001h)
   577                              <1> .bsRtNoDev:
   578 00001934 67814C984402000000  <1>     or dword [eax + 4*ebx + ehciportsc], 2  ;Clear the bit
   579 0000193D EBB1                <1>     jmp short .bsrExit06h   ;Exit with seek error
   580                              <1> .bsRoot:
   581                              <1> ;Root hub procedure.
   582 0000193F E8CE220000          <1>     call USB.ehciAdjustAsyncSchedCtrlr  ;Reset the bus if needed
   583 00001944 E8B03A0000          <1>     call USB.ehciGetOpBase      ;Get opbase into rax
   584 00001949 0FB65E03            <1>     movzx ebx, byte [rsi + 3]   ;Get MSD port number into dl
   585 0000194D FFCB                <1>     dec ebx                     ;Reduce by one
   586 0000194F 678B549844          <1>     mov edx, dword [eax + 4*ebx + ehciportsc]  ;Get port status into eax
   587 00001954 80E203              <1>     and dl, 3h      ;Only save bottom two bits
   588 00001957 84D2                <1>     test dl, dl     ;No device in port  (dl=00b)
   589 00001959 7495                <1>     jz .bsrExit06h  ;Exit media changed error
   590 0000195B FECA                <1>     dec dl          ;Device in port     (dl=01b)
   591 0000195D 0F8475FFFFFF        <1>     jz .bsexit      ;Exit, no status change
   592 00001963 FECA                <1>     dec dl          ;New device, Device removed from port   (dl=10b)
   593 00001965 74CD                <1>     jz .bsRtNoDev   ;Clear state change bit and exit Seek error
   594                              <1> ;Fallthrough case, New device, Device inserted in port  (dl=11b)
   595 00001967 67814C984402000000  <1>     or dword [eax + 4*ebx + ehciportsc], 2  ;Clear the state change bit
   596 00001970 49B8-               <1>     mov r8,  USB.ehciEnumerateRootPort   ;The enumeration function to call
   596 00001972 [2B40000000000000]  <1>
   597 0000197A 4989F1              <1>     mov r9, rsi        ;Store the device pointer in r9
   598 0000197D BE00000000          <1>     mov esi, 0         ;Store 0 for root hub parameter block                 
   599                              <1> .bsCommonEP:
   600                              <1> ;Invalidate USB MSD and Int 33h table entries for device
   601                              <1> ;r9 has device pointer block and rsi has host hub pointer (if on RMH)
   602 00001982 66418B19            <1>     mov bx, word [r9]          ;bl = Address, bh = Bus
   603 00001986 88FE                <1>     mov dh, bh                 ;dh = Bus
   604 00001988 418A5103            <1>     mov dl, byte [r9 + 3]      ;dl = Device Port
   605 0000198C 4D0FB65102          <1>     movzx r10, byte [r9 + 2]   ;r10b = Host hub address (0 = Root hub)
   606 00001991 6689D8              <1>     mov ax, bx                 ;ax needs a copy for RemoveDevFromTables
   607 00001994 E8D5290000          <1>     call USB.ehciRemoveDevFromTables    ;Removes device from USB tables
   608 00001999 87EA                <1>     xchg ebp, edx                       ;device number -><- bus/dev pair
   609 0000199B E8E4000000          <1>     call .i33removeFromTable            ;Removes device from Int 33h table
   610 000019A0 87EA                <1>     xchg ebp, edx                       ;bus/dev pair -><- device number
   611                              <1> ;Devices enumerated, time to reenumerate!
   612 000019A2 B903000000          <1>     mov ecx, 3
   613 000019A7 85F6                <1>     test esi, esi   ;Is device on root hub?
   614 000019A9 7502                <1>     jnz .bsr0
   615 000019AB FECA                <1>     dec dl  ;Recall that device port must be device port - 1 for Root hub enum
   616                              <1> .bsr0:
   617 000019AD 41FFD0              <1>     call r8
   618 000019B0 7410                <1>     jz .bsr1
   619 000019B2 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;General Controller Failure?
   620 000019BA 7439                <1>     je .bsrFail
   621 000019BC FFC9                <1>     dec ecx
   622 000019BE 75ED                <1>     jnz .bsr0
   623 000019C0 EB33                <1>     jmp short .bsrFail
   624                              <1> .bsr1:
   625 000019C2 4C87CE              <1>     xchg r9, rsi    ;MSD parameter blk -><- Hub parameter blk (or 0 if root)
   626 000019C5 E83F300000          <1>     call USB.ehciMsdInitialise
   627 000019CA 84C0                <1>     test al, al
   628 000019CC 7527                <1>     jnz .bsrFail    ;Exit if the device failed to initialise
   629                              <1> ;Multiply dl by i33DevTblEntry_size to get the address to write Int33h table
   630 000019CE 89EA                <1>     mov edx, ebp    ;Move the device number into edx (dl)
   631 000019D0 B810000000          <1>     mov eax, i33DevTblEntry_size  ;Zeros the upper bytes
   632 000019D5 F6E2                <1>     mul dl  ;Multiply dl by al. ax has offset into i33DevTbl table
   633 000019D7 4805[C4030000]      <1>     add rax, i33DevTbl
   634 000019DD 4889C7              <1>     mov rdi, rax    ;Put the offset into the table into rdi
   635 000019E0 E820000000          <1>     call .deviceInit
   636 000019E5 84C0                <1>     test al, al
   637 000019E7 0F84EBFEFFFF        <1>     jz .bsexit  ;Successful, exit!
   638 000019ED 3C03                <1>     cmp al, 3
   639 000019EF 0F84E3FEFFFF        <1>     je .bsexit  ;Invalid device type, but ignore for now
   640                              <1> .bsrFail:
   641 000019F5 49BB20000000000000- <1>     mov r11, 20h ;Change the msdStatus byte to Gen. Ctrlr Failure
   641 000019FE 00                  <1>
   642 000019FF F9                  <1>     stc
   643 00001A00 E9D3FEFFFF          <1>     jmp .bsexit
   644                              <1> .deviceInit:    
   645                              <1> ;Further initialises an MSD device for use with the int33h interface.
   646                              <1> ;Adds device data to the allocated int33h data table.
   647                              <1> ;Input: rdi = device diskDevice ptr (given by device number*i33DevTblEntry_size)
   648                              <1> ;       rsi = device MSDDevTbl entry (USB address into getDevPtr)
   649                              <1> ;Output: al = 0 : Device added successfully
   650                              <1> ;        al = 1 : Bus error
   651                              <1> ;        al = 2 : Read Capacities/Reset recovary failed after 10 attempts
   652                              <1> ;        al = 3 : Invalid device type (Endpoint size too small, temporary)
   653                              <1> ;   rax destroyed
   654                              <1> ;IF DEVICE HAS MAX ENDPOINT SIZE 64, DO NOT WRITE IT TO INT 33H TABLES
   655 00001A05 51                  <1>     push rcx
   656 00001A06 B003                <1>     mov al, 3   ;Invalid EP size error code
   657 00001A08 66817E090002        <1>     cmp word [rsi + 9], 200h  ;Check IN max EP packet size
   658 00001A0E 7572                <1>     jne .deviceInitExit
   659 00001A10 66817E0C0002        <1>     cmp word [rsi + 12], 200h ;Check OUT max EP packet size
   660 00001A16 756A                <1>     jne .deviceInitExit
   661                              <1> 
   662 00001A18 8A4601              <1>     mov al, byte [rsi + 1]  ;Get bus number
   663 00001A1B E8F2210000          <1>     call USB.ehciAdjustAsyncSchedCtrlr
   664 00001A20 B001                <1>     mov al, 1       ;Bus error exit
   665 00001A22 725E                <1>     jc .deviceInitExit
   666 00001A24 B90A000000          <1>     mov ecx, 10
   667                              <1> .deviceInitReadCaps:
   668 00001A29 E82B360000          <1>     call USB.ehciMsdBOTReadCapacity10   ;Preserve al error code
   669 00001A2E 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;General Controller Failure
   670 00001A36 744A                <1>     je .deviceInitExit
   671 00001A38 E836320000          <1>     call USB.ehciMsdBOTCheckTransaction
   672 00001A3D 84E4                <1>     test ah, ah     ;Clears CF
   673 00001A3F 7418                <1>     jz .deviceInitWriteTableEntry   ;Success, write table entry
   674 00001A41 E858310000          <1>     call USB.ehciMsdBOTResetRecovery    ;Just force a device reset
   675 00001A46 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;General Controller Failure
   676 00001A4E 7432                <1>     je .deviceInitExit
   677 00001A50 FFC9                <1>     dec ecx
   678 00001A52 75D5                <1>     jnz .deviceInitReadCaps
   679 00001A54 B002                <1>     mov al, 2   ;Non bus error exit
   680 00001A56 F9                  <1>     stc ;Set carry, device failed to initialise properly
   681 00001A57 EB29                <1>     jmp short .deviceInitExit
   682                              <1> .deviceInitWriteTableEntry:
   683 00001A59 C60701              <1>     mov byte [rdi], 1   ;MSD USB device signature
   684                              <1> 
   685 00001A5C 668B06              <1>     mov ax, word [rsi]  ;Get address and bus into ax
   686 00001A5F 66894701            <1>     mov word [rdi + 1], ax  ;Store in Int 33h table
   687                              <1> 
   688 00001A63 8B0425[C4030000]    <1>     mov eax, dword [ehciDataIn + 4] ;Get LBA block size
   689 00001A6A 0FC8                <1>     bswap eax
   690 00001A6C 894703              <1>     mov dword [rdi + 3], eax
   691                              <1> 
   692 00001A6F 8B0425[C0030000]    <1>     mov eax, dword [ehciDataIn] ;Get zx qword LastLBA
   693 00001A76 0FC8                <1>     bswap eax
   694 00001A78 48894707            <1>     mov qword [rdi + 7], rax
   695                              <1> 
   696 00001A7C C6470F02            <1>     mov byte [rdi + 15], 2  ;Temporary, only accept devices with 200h EP sizes
   697 00001A80 30C0                <1>     xor al, al 
   698                              <1> .deviceInitExit:
   699 00001A82 59                  <1>     pop rcx
   700 00001A83 C3                  <1>     ret
   701                              <1> .i33removeFromTable:
   702                              <1> ;Uses Int 33h device number to invalidate the device table entry
   703                              <1> ;Input: dl = Device number
   704                              <1> ;Output: Nothing, device entry invalidated
   705 00001A84 50                  <1>     push rax
   706 00001A85 52                  <1>     push rdx
   707 00001A86 B010                <1>     mov al, i33DevTblEntry_size
   708 00001A88 F6E2                <1>     mul dl  ;Multiply tbl entry size by device number, offset in ax
   709 00001A8A 480FB7C0            <1>     movzx rax, ax
   710 00001A8E C680[C4030000]00    <1>     mov byte [i33DevTbl + rax], 0 ;Invalidate entry
   711 00001A95 5A                  <1>     pop rdx
   712 00001A96 58                  <1>     pop rax
   713 00001A97 C3                  <1>     ret
   714                              <1> 
   715                              <1> diskdpt:   ;Imaginary floppy disk parameter table with disk geometry. 
   716                              <1> ;For more information on layout, see Page 3-26 of IBM BIOS ref
   717                              <1> ;Assume 2 head geometry due to emulating a floppy drive
   718 00001A98 00                  <1> .fsb:   db 0    ;First specify byte
   719 00001A99 00                  <1> .ssb:   db 0    ;Second specify byte
   720 00001A9A 00                  <1> .tto:   db 0    ;Number of timer ticks to wait before turning off drive motors
   721 00001A9B 02                  <1> .bps:   db 2    ;Number of bytes per sector in multiples of 128 bytes, editable.
   722                              <1>                 ; 0 = 128 bytes, 1 = 256 bytes, 2 = 512 bytes etc
   723                              <1>                 ;Left shift 128 by bps to get the real bytes per sector
   724 00001A9C 09                  <1> .spt:   db 9    ;Sectors per track
   725 00001A9D 00                  <1> .gpl:   db 0    ;Gap length
   726 00001A9E 00                  <1> .dtl:   db 0    ;Data length
   727 00001A9F 00                  <1> .glf:   db 0    ;Gap length for format
   728 00001AA0 FF                  <1> .fbf:   db 0FFh ;Fill byte for format
   729 00001AA1 00                  <1> .hst:   db 0    ;Head settle time in ms
   730 00001AA2 01                  <1> .mst:   db 1    ;Motor startup time in multiples of 1/8 of a second.
   731                              <1> 
   732                              <1> fdiskdpt: ;Fixed drive table, only cyl, nhd and spt are valid. 
   733                              <1> ;           This schema gives roughly 8.42Gb of storage.
   734                              <1> ;           All fields with 0 in the comments are reserved post XT class BIOS.
   735 00001AA3 0004                <1> .cyl:   dw  1024    ;1024 cylinders
   736 00001AA5 FF                  <1> .nhd:   db  255     ;255 heads
   737 00001AA6 0000                <1> .rwc:   dw  0       ;Reduced write current cylinder, 0
   738 00001AA8 FFFF                <1> .wpc:   dw  -1      ;Write precompensation number (-1=none)
   739 00001AAA 00                  <1> .ecc:   db  0       ;Max ECC burst length, 0
   740 00001AAB 08                  <1> .ctl:   db  08h     ;Control byte (more than 8 heads)
   741 00001AAC 00                  <1> .sto:   db  0       ;Standard timeout, 0
   742 00001AAD 00                  <1> .fto:   db  0       ;Formatting timeout, 0
   743 00001AAE 00                  <1> .tcd:   db  0       ;Timeout for checking drive, 0
   744 00001AAF FF03                <1> .clz:   dw  1023    ;Cylinder for landing zone
   745 00001AB1 3F                  <1> .spt:   db  63      ;Sectors per track
   746 00001AB2 00                  <1> .res:   db  0       ;Reserved byte
   747                              <1> 
   748                              <1> ;----------------------Fixed Disk Int 33h Ext-------------------
   749                              <1> ; Subfunctions in ah
   750                              <1> ;Input:  dl = Drive number, 
   751                              <1> ;        dh = Head number,
   752                              <1> ;        rbx = Address of buffer, 
   753                              <1> ;        al = number of sectors, 
   754                              <1> ;        ch = Cylinder number (low 8 bits), 
   755                              <1> ;        cl[7:6] = Cylinder number (upper 2 bits), 
   756                              <1> ;        cl[5:0] = Sector number
   757                              <1> ;Input LBA: dl = Drive Number, rbx = Address of Buffer, 
   758                              <1> ;           al = number of sectors, rcx = LBA number
   759                              <1> ;
   760                              <1> ;All registers not mentioned above, preserved.
   761                              <1> ;Still use msdStatus as the error byte dumping ground. For now, 
   762                              <1> ; do not use the ata specific status bytes. 
   763                              <1> ; Fixed disk BIOS does NOT return how many sectors were 
   764                              <1> ; successfully transferred!
   765                              <1> ;----------------------------------------------------------------
   766                              <1> fdisk_io:
   767 00001AB3 55                  <1>     push rbp
   768 00001AB4 50                  <1>     push rax
   769 00001AB5 53                  <1>     push rbx
   770 00001AB6 51                  <1>     push rcx
   771 00001AB7 52                  <1>     push rdx
   772                              <1> ;Cherry pick status to avoid resetting status
   773 00001AB8 80FC01              <1>     cmp ah, 01h
   774 00001ABB 0F84C2000000        <1>     je .fdiskStatus
   775                              <1> 
   776 00001AC1 C60425[A9010000]00  <1>     mov byte [msdStatus], 0 ;Reset the status
   777 00001AC9 E8031B0000          <1>     call ATA.getTablePointer    ;Get table pointer in rbp for all functions
   778 00001ACE 7267                <1>     jc .badFunctionRequest  ;If the device doenst exist, bad bad bad!
   779                              <1> 
   780 00001AD0 84E4                <1>     test ah, ah
   781 00001AD2 0F848E000000        <1>     jz .fdiskReset
   782 00001AD8 80FC02              <1>     cmp ah, 02h
   783 00001ADB 0F84B7000000        <1>     je .fdiskReadCHS
   784 00001AE1 80FC03              <1>     cmp ah, 03h
   785 00001AE4 0F84C0000000        <1>     je .fdiskWriteCHS
   786 00001AEA 80FC04              <1>     cmp ah, 04h
   787 00001AED 0F84C9000000        <1>     je .fdiskVerifyCHS
   788 00001AF3 80FC05              <1>     cmp ah, 05h
   789 00001AF6 0F84D0000000        <1>     je .fdiskFormat
   790 00001AFC 80FC08              <1>     cmp ah, 08h
   791 00001AFF 0F84D7000000        <1>     je .fdiskParametersCHS
   792 00001B05 80FC16              <1>     cmp ah, 16h 
   793 00001B08 7449                <1>     je .okExit    ;Pseudo return changeline, always return ok (ah = 0), CF=NC
   794 00001B0A 80FC82              <1>     cmp ah, 82h
   795 00001B0D 0F84FB000000        <1>     je .fdiskReadLBA
   796 00001B13 80FC83              <1>     cmp ah, 83h
   797 00001B16 0F841B010000        <1>     je .fdiskWriteLBA
   798 00001B1C 80FC84              <1>     cmp ah, 84h
   799 00001B1F 0F8437010000        <1>     je .fdiskVerifyLBA
   800 00001B25 80FC85              <1>     cmp ah, 85h
   801 00001B28 0F8453010000        <1>     je .fdiskFormatSector
   802 00001B2E 80FC88              <1>     cmp ah, 88h 
   803 00001B31 0F846F010000        <1>     je .fdiskParametersLBA
   804                              <1> 
   805                              <1> .badFunctionRequest:
   806 00001B37 B401                <1>     mov ah, 01h
   807 00001B39 882425[A9010000]    <1>     mov byte [msdStatus], ah   ;Invalid function requested signature
   808                              <1> .badExit:
   809 00001B40 5A                  <1>     pop rdx
   810 00001B41 59                  <1>     pop rcx
   811 00001B42 5B                  <1>     pop rbx
   812 00001B43 58                  <1>     pop rax
   813 00001B44 5D                  <1>     pop rbp
   814 00001B45 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   815 00001B4C 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag
   816 00001B51 48CF                <1>     iretq 
   817                              <1> .okExit:
   818 00001B53 5A                  <1>     pop rdx
   819 00001B54 59                  <1>     pop rcx
   820 00001B55 5B                  <1>     pop rbx
   821                              <1> .paramExit:
   822 00001B56 58                  <1>     pop rax
   823 00001B57 5D                  <1>     pop rbp
   824 00001B58 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
   825 00001B5F 80642410FE          <1>     and byte [rsp + 2*8h], 0FEh ;Clear Carry flag    
   826 00001B64 48CF                <1>     iretq
   827                              <1> ;Misc functions
   828                              <1> .fdiskReset:
   829 00001B66 E8921A0000          <1>     call ATA.resetChannel
   830 00001B6B B800000000          <1>     mov eax, 0  ;No issue
   831 00001B70 BB05000000          <1>     mov ebx, 5  ;Reset failed
   832 00001B75 0F42C3              <1>     cmovc eax, ebx  ;Only move if carry set
   833 00001B78 880425[A9010000]    <1>     mov byte [msdStatus], al    ;Save status byte
   834 00001B7F 72BF                <1>     jc .badExit ;Carry is still preserved
   835 00001B81 EBD0                <1>     jmp short .okExit
   836                              <1> 
   837                              <1> .fdiskStatus:
   838 00001B83 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]    ;Save old status
   839 00001B8A C60425[A9010000]00  <1>     mov byte [msdStatus], 0     ;Clear the status
   840 00001B92 84E4                <1>     test ah, ah
   841 00001B94 75AA                <1>     jnz .badExit    ;Set carry flag if status is non-zero
   842 00001B96 EBBB                <1>     jmp short .okExit
   843                              <1> ;CHS functions
   844                              <1> .fdiskReadCHS:
   845 00001B98 57                  <1>     push rdi
   846 00001B99 E8081C0000          <1>     call ATA.readCHS
   847 00001B9E 5F                  <1>     pop rdi
   848 00001B9F 0F8228010000        <1>     jc .fdiskError
   849 00001BA5 E9A9FFFFFF          <1>     jmp .okExit
   850                              <1>     
   851                              <1> .fdiskWriteCHS:
   852 00001BAA 56                  <1>     push rsi
   853 00001BAB E8141C0000          <1>     call ATA.writeCHS
   854 00001BB0 5E                  <1>     pop rsi
   855 00001BB1 0F8216010000        <1>     jc .fdiskError
   856 00001BB7 E997FFFFFF          <1>     jmp .okExit
   857                              <1> 
   858                              <1> .fdiskVerifyCHS:
   859 00001BBC E8211C0000          <1>     call ATA.verifyCHS
   860 00001BC1 0F8206010000        <1>     jc .fdiskError
   861 00001BC7 E987FFFFFF          <1>     jmp .okExit
   862                              <1> 
   863                              <1> ;Format a whole "track" (for now just overwrite)
   864                              <1> .fdiskFormat:
   865 00001BCC E82D1C0000          <1>     call ATA.formatCHS
   866 00001BD1 0F82F6000000        <1>     jc .fdiskError
   867 00001BD7 E977FFFFFF          <1>     jmp .okExit
   868                              <1> 
   869                              <1> .fdiskParametersCHS:
   870                              <1> ;Reads CHS drive parameters for given drive 
   871                              <1> ;Output: dl = Number of fixed disks in system
   872                              <1> ;        dh = Max head number for chosen drive
   873                              <1> ;        ch = Cylinder number
   874                              <1> ;        cl[7:6] = High two bits of Cylinder number
   875                              <1> ;        cl[5:0] = Sectors per track
   876                              <1> ;        ebx = Dword, sector size
   877                              <1> ;        ah = 0
   878 00001BDC 5A                  <1>     pop rdx
   879 00001BDD 59                  <1>     pop rcx
   880 00001BDE 5B                  <1>     pop rbx
   881 00001BDF 0FB74501            <1>     movzx eax, word [rbp + fdiskTblEntry.wHeads]
   882 00001BE3 88C6                <1>     mov dh, al
   883 00001BE5 0FB74503            <1>     movzx eax, word [rbp + fdiskTblEntry.wCylinder]
   884 00001BE9 88C5                <1>     mov ch, al  ;Low 8 bits 
   885 00001BEB 66C1E802            <1>     shr ax, 2   ;Move bits [1:0] of ah to bits [7:6] of al
   886 00001BEF 24C0                <1>     and al, 0C0h    ;Clear lower bits [5:0]
   887 00001BF1 88C1                <1>     mov cl, al
   888 00001BF3 0FB74505            <1>     movzx eax, word [rbp + fdiskTblEntry.wSecTrc]
   889 00001BF7 243F                <1>     and al, 3Fh ;Save only bits [5:0]
   890 00001BF9 08C1                <1>     or cl, al   ;Add the sector per track bits here
   891 00001BFB 8A1425[AA010000]    <1>     mov dl, byte [fdiskNum] ;Get number of fixed disks in dl
   892 00001C02 31DB                <1>     xor ebx, ebx
   893 00001C04 BB00020000          <1>     mov ebx, 200h       ;Currently, hardcode sector size of 512 bytes
   894 00001C09 E948FFFFFF          <1>     jmp .paramExit
   895                              <1> 
   896                              <1> ;LBA functions
   897                              <1> .fdiskReadLBA:
   898 00001C0E 57                  <1>     push rdi
   899 00001C0F 56                  <1>     push rsi
   900 00001C10 488D3425[65380000]  <1>     lea rsi, ATA.readLBA
   901 00001C18 488D3C25[20390000]  <1>     lea rdi, ATA.readLBA48
   902 00001C20 F6450004            <1>     test byte [rbp + fdiskTblEntry.signature], fdeLBA48
   903 00001C24 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
   904 00001C28 FFD7                <1>     call rdi    ;rdi is a free parameter anyway
   905 00001C2A 5E                  <1>     pop rsi
   906 00001C2B 5F                  <1>     pop rdi
   907 00001C2C 0F829B000000        <1>     jc .fdiskError
   908 00001C32 E91CFFFFFF          <1>     jmp .okExit
   909                              <1> 
   910                              <1> .fdiskWriteLBA:
   911 00001C37 57                  <1>     push rdi
   912 00001C38 56                  <1>     push rsi
   913 00001C39 488D3425[83380000]  <1>     lea rsi, ATA.writeLBA
   914 00001C41 488D3C25[3E390000]  <1>     lea rdi, ATA.writeLBA48
   915 00001C49 F6450004            <1>     test byte [rbp + fdiskTblEntry.signature], fdeLBA48
   916 00001C4D 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
   917 00001C51 FFD7                <1>     call rdi    ;rdi is a free parameter anyway
   918 00001C53 5E                  <1>     pop rsi
   919 00001C54 5F                  <1>     pop rdi
   920 00001C55 7276                <1>     jc .fdiskError
   921 00001C57 E9F7FEFFFF          <1>     jmp .okExit
   922                              <1> 
   923                              <1> .fdiskVerifyLBA:
   924 00001C5C 57                  <1>     push rdi
   925 00001C5D 56                  <1>     push rsi
   926 00001C5E 488D3425[A1380000]  <1>     lea rsi, ATA.verifyLBA
   927 00001C66 488D3C25[5C390000]  <1>     lea rdi, ATA.verifyLBA48
   928 00001C6E F6450004            <1>     test byte [rbp + fdiskTblEntry.signature], fdeLBA48
   929 00001C72 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
   930 00001C76 FFD7                <1>     call rdi    ;rdi is a free parameter anyway
   931 00001C78 5E                  <1>     pop rsi
   932 00001C79 5F                  <1>     pop rdi
   933 00001C7A 7251                <1>     jc .fdiskError
   934 00001C7C E9D2FEFFFF          <1>     jmp .okExit
   935                              <1> 
   936                              <1> .fdiskFormatSector:
   937                              <1> ;Format a series of sectors (for now just overwrite with fillbyte)
   938 00001C81 57                  <1>     push rdi
   939 00001C82 56                  <1>     push rsi
   940 00001C83 488D3425[BF380000]  <1>     lea rsi, ATA.formatLBA
   941 00001C8B 488D3C25[7A390000]  <1>     lea rdi, ATA.formatLBA48
   942 00001C93 F6450004            <1>     test byte [rbp + fdiskTblEntry.signature], fdeLBA48
   943 00001C97 480F44FE            <1>     cmovz rdi, rsi  ;If LBA48 not supported, call LBA instead
   944 00001C9B FFD7                <1>     call rdi    ;rdi is a free parameter anyway
   945 00001C9D 5E                  <1>     pop rsi
   946 00001C9E 5F                  <1>     pop rdi
   947 00001C9F 722C                <1>     jc .fdiskError
   948 00001CA1 E9ADFEFFFF          <1>     jmp .okExit
   949                              <1> .fdiskParametersLBA:
   950                              <1> ;Output: 
   951                              <1> ;        ebx = Dword, sector size
   952                              <1> ;        rcx = qLastLBANum (Qword address of last LBA)
   953                              <1> ;        dl = Number of fixed disks in system
   954                              <1> ;        Fixed disks have a fixed sector size of 512 bytes
   955                              <1> ;Recall last LBA value is the first NON-user usable LBA
   956                              <1> ;Will return LBA48 if the device uses LBA48 in rcx
   957 00001CA6 5A                  <1>     pop rdx
   958 00001CA7 59                  <1>     pop rcx
   959 00001CA8 5B                  <1>     pop rbx
   960 00001CA9 31C9                <1>     xor ecx, ecx    ;Zero whole of rcx
   961 00001CAB 8B4D07              <1>     mov ecx, dword [rbp + fdiskTblEntry.lbaMax]
   962 00001CAE 488B450B            <1>     mov rax, qword [rbp + fdiskTblEntry.lbaMax48]
   963 00001CB2 F6450004            <1>     test byte [rbp + fdiskTblEntry.signature], fdeLBA48
   964 00001CB6 480F45C8            <1>     cmovnz rcx, rax ;Move lba48 value into rcx if LBA48 bit set
   965 00001CBA 8A1425[AA010000]    <1>     mov dl, byte [fdiskNum] ;Number of fixed disks
   966 00001CC1 31DB                <1>     xor ebx, ebx
   967 00001CC3 BB00020000          <1>     mov ebx, 200h       ;Currently, hardcode sector size of 512 bytes
   968 00001CC8 E989FEFFFF          <1>     jmp .paramExit
   969                              <1> .fdiskError:
   970                              <1> ;A common error handler that checks the status and error register 
   971                              <1> ; to see what the error may have been. If nothing, then the error
   972                              <1> ; that is in the msdStatus byte is left as is, unless it is 0
   973                              <1> ; where a Undefined Error is placed.
   974 00001CCD 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   975 00001CD1 81C207000000        <1>     add edx, 7  ;Goto status
   976 00001CD7 E8EA180000          <1>     call ATA.wait400ns
   977 00001CDC EC                  <1>     in al, dx   ;Get status byte
   978 00001CDD A880                <1>     test al, 80h    ;If busy is STILL set, controller failure
   979 00001CDF 7578                <1>     jnz .fdiskCtrlrFailed
   980 00001CE1 A820                <1>     test al, 20h    ;Test drive fault error
   981 00001CE3 7567                <1>     jnz .fdiskErrorDriveFault
   982 00001CE5 A801                <1>     test al, 1  ;Test the error bit is set
   983 00001CE7 7454                <1>     jz .fdiskErrorNoBit ;If not set then check if we have an error code 
   984 00001CE9 81EA06000000        <1>     sub edx, 6  ;Goto base + 1, Error register
   985 00001CEF EC                  <1>     in al, dx   ;Get Error register
   986 00001CF0 84C0                <1>     test al, al 
   987 00001CF2 743C                <1>     jz .fdiskNoErrorData
   988 00001CF4 88C4                <1>     mov ah, al
   989 00001CF6 80E484              <1>     and ah, 84h ;Save abort and interface crc
   990 00001CF9 80FC84              <1>     cmp ah, 84h
   991 00001CFC 7425                <1>     je .fdiskCRCError
   992 00001CFE A840                <1>     test al, 40h    ;Test the uncorrectable Error bit
   993 00001D00 7521                <1>     jnz .fdiskCRCError
   994 00001D02 88C4                <1>     mov ah, al
   995 00001D04 80E414              <1>     and ah, 14h ;If either bit is set, then it is a bad sector number
   996 00001D07 750D                <1>     jnz .fdiskBadAddress
   997                              <1> .fdiskErrorUnknown: ;Fallthrough here
   998 00001D09 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh  ;Unknown Error code
   999 00001D11 E92AFEFFFF          <1>     jmp .badExit
  1000                              <1> .fdiskBadAddress:
  1001 00001D16 C60425[A9010000]04  <1>     mov byte [msdStatus], 04h   ;Sector not found
  1002 00001D1E E91DFEFFFF          <1>     jmp .badExit
  1003                              <1> .fdiskCRCError:
  1004 00001D23 C60425[A9010000]10  <1>     mov byte [msdStatus], 10h   ;Uncorrectable CRC error
  1005 00001D2B E910FEFFFF          <1>     jmp .badExit
  1006                              <1> .fdiskNoErrorData:
  1007 00001D30 C60425[A9010000]E0  <1>     mov byte [msdStatus], 0E0h  ;Status error = 0
  1008 00001D38 E903FEFFFF          <1>     jmp .badExit
  1009                              <1> .fdiskErrorNoBit:
  1010 00001D3D 8A2425[A9010000]    <1>     mov ah, byte [msdStatus]
  1011 00001D44 84E4                <1>     test ah, ah
  1012 00001D46 0F85F4FDFFFF        <1>     jnz .badExit    ;If there is a code, leave it in situ and exit service
  1013                              <1> 
  1014                              <1> .fdiskErrorDriveFault:
  1015 00001D4C C60425[A9010000]07  <1>     mov byte [msdStatus], 07h  ;Drive parameter activity failed
  1016 00001D54 E9E7FDFFFF          <1>     jmp .badExit
  1017                              <1> .fdiskCtrlrFailed:
  1018 00001D59 C60425[A9010000]20  <1>     mov byte [msdStatus], 020h  ;Controller failure code
  1019 00001D61 E9DAFDFFFF          <1>     jmp .badExit
  1020                              <1> ;------------------------End of Interrupt------------------------
    97                                  %include "./Source/Resident/Services/Int34h.asm"
     1                              <1> ;------------------Serial IO Interrupts Int 34h------------------
     2                              <1> serial_baud_table:    ;DLAB devisor values
     3 00001D66 1704                <1>     dw    0417h    ;110 baud,     00
     4 00001D68 0003                <1>     dw    0300h    ;150 baud,     01
     5 00001D6A 8001                <1>     dw    0180h    ;300 baud,     02
     6 00001D6C C000                <1>     dw    00C0h    ;600 baud,     03
     7 00001D6E 6000                <1>     dw    0060h    ;1200 baud,    04
     8 00001D70 3000                <1>     dw    0030h    ;2400 baud,    05 
     9 00001D72 1800                <1>     dw    0018h    ;4800 baud,    06
    10 00001D74 0C00                <1>     dw    000Ch    ;9600 baud,    07
    11 00001D76 0600                <1>     dw    0006h    ;19200 baud,   08
    12 00001D78 0300                <1>     dw    0003h    ;38400 baud,   09
    13 00001D7A 0200                <1>     dw    0002h    ;57600 baud,   0A
    14 00001D7C 0100                <1>     dw    0001h    ;115200 baud,  0B
    15                              <1> serial_abt: ;serial port address base table. List of supported addresses!
    16 00001D7E F803                <1>     dw com1_base
    17 00001D80 F802                <1>     dw com2_base
    18 00001D82 E803                <1>     dw com3_base
    19 00001D84 E802                <1>     dw com4_base
    20                              <1> serial_io:
    21 00001D86 52                  <1>     push rdx        ;Save upper 7 bytes
    22 00001D87 80FA04              <1>     cmp dl, 4        ;Check to see if the selected com port is within range
    23 00001D8A 7D56                <1>     jge .sbadexit1    ;Bad dx value
    24 00001D8C 480FB6D2            <1>     movzx rdx, dl    ;zero the upper 6 bytes of rdx
    25 00001D90 668B9412[67000000]  <1>     mov dx, word [com_addresses + rdx*2]    ;get serial port base addr into dx
    26 00001D98 6685D2              <1>     test dx, dx        ;is the address zero?
    27 00001D9B 7449                <1>     jz .sbadexit2    ;com port doesnt exist
    28 00001D9D 50                  <1>     push rax        ;Saves upper 6 bytes
    29 00001D9E 52                  <1>     push rdx        ;Save base for exit algorithm
    30                              <1> 
    31 00001D9F 84E4                <1>     test ah, ah
    32 00001DA1 744D                <1>     jz .userinit
    33 00001DA3 FECC                <1>     dec ah 
    34 00001DA5 7477                <1>     jz .transmit
    35 00001DA7 FECC                <1>     dec ah
    36 00001DA9 0F84A2000000        <1>     jz .recieve
    37 00001DAF FECC                <1>     dec ah
    38 00001DB1 741E                <1>     jz .sioexit    ;since this puts the status into ax
    39 00001DB3 FECC                <1>     dec ah
    40 00001DB5 0F8415010000        <1>     jz .extinit
    41 00001DBB FECC                <1>     dec ah
    42 00001DBD 0F840D010000        <1>     jz .extstatus
    43 00001DC3 FECC                <1>     dec ah
    44 00001DC5 0F8405010000        <1>     jz .custombaud
    45                              <1> 
    46                              <1> .badin:
    47 00001DCB 5A                  <1>     pop rdx
    48 00001DCC 58                  <1>     pop rax
    49 00001DCD B480                <1>     mov ah, 80h    ;Invalid Function
    50 00001DCF EB17                <1>     jmp short .sbadcommon
    51                              <1> .sioexit:
    52 00001DD1 5A                  <1>     pop rdx   ;Get base back, to know exact offset
    53 00001DD2 58                  <1>     pop rax        ;Return the upper bytes of rax into rax
    54 00001DD3 6681C20500          <1>     add dx, 5    ;point to the line status register
    55 00001DD8 EC                  <1>     in al, dx    ;get status
    56 00001DD9 88C4                <1>     mov ah, al    ;save line status in ah
    57 00001DDB 66FFC2              <1>     inc dx        ;point to the modem status register
    58 00001DDE EC                  <1>     in al, dx    ;save modem status in al
    59 00001DDF 5A                  <1>     pop rdx
    60 00001DE0 48CF                <1>     iretq
    61                              <1> 
    62                              <1> .sbadexit1:    
    63 00001DE2 B0FF                <1>     mov al, 0FFh    ;dx was too large
    64 00001DE4 EB02                <1>     jmp short .sbadcommon
    65                              <1> .sbadexit2:
    66 00001DE6 B0FE                <1>     mov al, 0FEh    ;COM port doesnt exist
    67                              <1> .sbadcommon:
    68 00001DE8 5A                  <1>     pop rdx        ;return original rdx value
    69 00001DE9 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
    70 00001DEE 48CF                <1>     iretq
    71                              <1> 
    72                              <1> .userinit:
    73 00001DF0 88C4                <1>     mov ah, al    ;save the data in ah for the baud rate
    74 00001DF2 6681C20300          <1>     add dx, 3    ;Point to the line control register
    75 00001DF7 241F                <1>     and al, 00011111b   ;Zero out the upper three bits
    76 00001DF9 0C80                <1>     or al, 10000000b    ;Set the DLAB bit
    77 00001DFB EE                  <1>     out dx, al 
    78                              <1> 
    79 00001DFC 6681EA0300          <1>     sub dx, 3    ;return point to base
    80 00001E01 66C1E80D            <1>     shr ax, 0Dh  ;0Dh=move hi bits of hi word into low bits of low word
    81 00001E05 480FB6C0            <1>     movzx rax, al    ;zero upper 7 bytes of rax
    82                              <1> 
    83 00001E09 668B8400[661D0000]  <1>     mov ax, word [serial_baud_table + 2*rax]    ;rax is the offset into the table
    84 00001E11 66EF                <1>     out dx, ax    ;dx points to base with dlab on, set divisor! (word out)
    85                              <1> ;Disable DLAB bit now
    86 00001E13 6681C20300          <1>     add dx, 3
    87 00001E18 EC                  <1>     in al, dx    ;Get the Line Control Register (preserving the written data)
    88 00001E19 247F                <1>     and al, 01111111b    ;Clear the DLAB bit, preserve the other bits
    89 00001E1B EE                  <1>     out dx, al    ;Clear the bit
    90                              <1> 
    91 00001E1C EBB3                <1>     jmp short .sioexit    ;exit!
    92                              <1> 
    93                              <1> .transmit:
    94 00001E1E 6681C20500          <1>     add dx, 5    ;dx contains base address, point to Line status register
    95 00001E23 88C4                <1>     mov ah, al   ;temp save char to send in ah
    96 00001E25 51                  <1>     push rcx
    97 00001E26 31C9                <1>     xor ecx, ecx
    98                              <1> .t1:
    99 00001E28 FFC9                <1>     dec ecx
   100 00001E2A 7410                <1>     jz .t2       ;timeout
   101 00001E2C EC                  <1>     in al, dx    ;get the LSR byte in
   102 00001E2D 2420                <1>     and al, 00100000b    ;Check the transmit holding register empty bit
   103 00001E2F 74F7                <1>     jz .t1    ;if this is zero, keep looping until it is 1 (aka empty)
   104                              <1> 
   105 00001E31 59                  <1>     pop rcx
   106 00001E32 88E0                <1>     mov al, ah   ;return data byte down to al
   107 00001E34 6681EA0500          <1>     sub dx, 5    ;reaim to the IO port
   108 00001E39 EE                  <1>     out dx, al   ;output the data byte to the serial line!!
   109 00001E3A EB95                <1>     jmp short .sioexit
   110                              <1> .t2:
   111 00001E3C 59                  <1>     pop rcx
   112 00001E3D 5A                  <1>     pop rdx      ;Get base back, to know exact offset
   113 00001E3E 58                  <1>     pop rax      ;Return the upper bytes of rax into rax
   114 00001E3F 6681C20500          <1>     add dx, 5    ;point to the line status register
   115 00001E44 EC                  <1>     in al, dx    ;get status
   116 00001E45 88C4                <1>     mov ah, al   ;save line status in ah
   117 00001E47 80E480              <1>     and ah, 80h  ;Set error bit (bit 7)
   118 00001E4A 66FFC2              <1>     inc dx       ;point to the modem status register
   119 00001E4D EC                  <1>     in al, dx    ;save modem status in al
   120 00001E4E 5A                  <1>     pop rdx
   121 00001E4F 48CF                <1>     iretq
   122                              <1> .recieve:
   123                              <1>     ;Gets byte out of appropriate buffer head and places it in al
   124 00001E51 5A                  <1>     pop rdx
   125 00001E52 58                  <1>     pop rax        
   126 00001E53 5A                  <1>     pop rdx    ;Undoes the address entry and returns COM port number into dx    
   127 00001E54 52                  <1>     push rdx   ;Save it once more
   128 00001E55 53                  <1>     push rbx
   129 00001E56 480FB7D2            <1>     movzx rdx, dx
   130                              <1> 
   131 00001E5A FA                  <1>     cli    ;Entering a critical area, interrupts off
   132 00001E5B 488B1CD5[AF000000]  <1>     mov rbx, qword [comX_buf_head + rdx*8]
   133 00001E63 483B1CD5[CF000000]  <1>     cmp rbx, qword [comX_buf_tail + rdx*8]
   134 00001E6B 7426                <1>     je .r1    ;We are at the head of the buffer, signal error, no char to get.
   135 00001E6D 8A03                <1>     mov al, byte [rbx]    ;store byte into al
   136 00001E6F 88C4                <1>     mov ah, al ;temp save al in ah
   137 00001E71 48FFC3              <1>     inc rbx    ;move buffer head
   138 00001E74 483B1CD5[0F010000]  <1>     cmp rbx, qword [comX_buf_end + rdx*8]    ;are we at the end of the buffer
   139 00001E7C 7508                <1>     jne .r0    ;no, save new position
   140 00001E7E 488B1CD5[EF000000]  <1>     mov rbx, qword [comX_buf_start + rdx*8]  ;yes, wrap around
   141                              <1> .r0:
   142 00001E86 48891CD5[AF000000]  <1>     mov qword [comX_buf_head + rdx*8], rbx   ;save new buffer position
   143 00001E8E FB                  <1>     sti
   144 00001E8F 5B                  <1>     pop rbx
   145 00001E90 5A                  <1>     pop rdx
   146 00001E91 EB07                <1>     jmp short .rexit
   147                              <1> .r1:
   148 00001E93 FB                  <1>     sti
   149 00001E94 B480                <1>     mov ah, 80h    ;Equivalent to a timeout error.
   150 00001E96 5B                  <1>     pop rbx
   151 00001E97 5A                  <1>     pop rdx
   152 00001E98 48CF                <1>     iretq
   153                              <1> 
   154                              <1> .rexit:    ;Line status in ah. Char was got so ensure DTR is now high again!
   155 00001E9A 668B9412[67000000]  <1>     mov dx, word [com_addresses + rdx*2]    ;Get the base address back into dx
   156 00001EA2 6681C20400          <1>     add dx, 4    ;point to the modem control register
   157 00001EA7 EC                  <1>     in al, dx
   158 00001EA8 A801                <1>     test al, 1   ;Test DTR is clear
   159 00001EAA 740B                <1>     jz .getscratch
   160                              <1> .gsret:
   161 00001EAC 0C01                <1>     or al, 1    ;Set DTR bit on again
   162 00001EAE EE                  <1>     out dx, al
   163 00001EAF 66FFC2              <1>     inc dx      ;point to the line status register
   164 00001EB2 EC                  <1>     in al, dx   ;get status
   165 00001EB3 86E0                <1>     xchg ah, al ;swap them around
   166 00001EB5 48CF                <1>     iretq
   167                              <1> .getscratch:
   168 00001EB7 0C10                <1>     or al, 00010000b    ;Enable loopback mode with DTR on
   169 00001EB9 EE                  <1>     out dx, al
   170 00001EBA 6681C20300          <1>     add dx, 3    ;Point to scratch register
   171 00001EBF EC                  <1>     in al, dx    ;Get overrun char
   172 00001EC0 6681EA0700          <1>     sub dx, 7    ;transmit register
   173 00001EC5 EE                  <1>     out dx, al   ;send the char (no need to play with DTR, we sending to 
   174                              <1>                  ; ourselves, generating an INT)
   175 00001EC6 6681C20400          <1>     add dx, 4    ;point back to modem control register again!
   176 00001ECB EC                  <1>     in al, dx
   177 00001ECC 24EF                <1>     and al, 11101111b    ;Clear loopback mode, DTR bit gets set in main proc
   178 00001ECE EBDC                <1>     jmp short .gsret    
   179                              <1> 
   180                              <1> .extinit:
   181                              <1> .extstatus:
   182                              <1> .custombaud:
   183 00001ED0 5A                  <1>     pop rdx
   184 00001ED1 58                  <1>     pop rax
   185 00001ED2 B486                <1>     mov ah, 86h
   186 00001ED4 E90FFFFFFF          <1>     jmp .sbadcommon
   187                              <1> ;------------------------End of Interrupt------------------------
    98                                  %include "./Source/Resident/Services/Int35h.asm"
     1                              <1> ;-------------------Misc IO Interrupts Int 35h-------------------
     2                              <1> ;Misc features int that can be used for a variety of things.
     3                              <1> ;This will break compatibility with BIOS, since hopefully more 
     4                              <1> ; advanced features will be present.
     5                              <1> ;
     6                              <1> ; ah = 0 - 82h System Reserved
     7                              <1> ; ah = 83h -> Reserved, Event wait
     8                              <1> ; ah = 86h -> Delay rcx = # of milliseconds to wait
     9                              <1> ; ah = 88h -> Basic High Mem Map 1 (First 16MB only)
    10                              <1> ; ah = 89h to C4h - System Reserved
    11                              <1> ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    12                              <1> ; ah = C5h - FFh BIOS device class dispatcher extensions
    13                              <1> ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    14                              <1> ; ah = C5h -> Misc sys function dispatcher      (3 funct)
    15                              <1> ; ah = E8h -> Adv mem management sys dispatcher (4 funct)
    16                              <1> ; ah = F0h -> Sys data table dispatcher         (15 funct)
    17                              <1> ; ah = F1h -> EHCI system dispatcher            (4 funct)
    18                              <1> ;----------------------------------------------------------------
    19                              <1> misc_io:
    20 00001ED9 80FC86              <1>     cmp ah, 86h
    21 00001EDC 722F                <1>     jb .badFunction
    22 00001EDE 7436                <1>     jz .delay
    23 00001EE0 80FC88              <1>     cmp ah, 88h
    24 00001EE3 0F84B0000000        <1>     jz .memory16MB
    25                              <1> 
    26 00001EE9 80FCC5              <1>     cmp ah, 0C5h    ;Miscellaneous function dispatcher
    27 00001EEC 0F84B1000000        <1>     jz .miscDispatcher 
    28 00001EF2 80FCE8              <1>     cmp ah, 0E8h    ;Advanced memory management system dispatcher
    29 00001EF5 0F847E010000        <1>     jz .advSysMemDispatcher
    30 00001EFB 80FCF0              <1>     cmp ah, 0F0h    ;System table dispatcher
    31 00001EFE 0F84F3010000        <1>     jz .sysDataTableDispatcher
    32 00001F04 80FCF1              <1>     cmp ah, 0F1h    ;EHCI function dispatcher
    33 00001F07 0F843E030000        <1>     jz .ehciFunctionDispatcher
    34                              <1> .badFunction:
    35 00001F0D B480                <1>     mov ah, 80h    ;Invalid Function
    36                              <1> .badout:
    37 00001F0F 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
    38 00001F14 48CF                <1>     iretq
    39                              <1> 
    40                              <1> .delay:
    41                              <1> ;Input: rcx = milliseconds to wait (rcx < 7FFFFFFFFFFFFFFFh)
    42                              <1> ;Init IRQ 8, wait for loop to end, deactivate
    43 00001F16 FA                  <1>     cli    ;NO INTERRUPTS
    44 00001F17 4885C9              <1>     test rcx, rcx
    45 00001F1A 747B                <1>     jz .return  ;Can avoid sti since we return caller flags
    46 00001F1C 50                  <1>     push rax
    47                              <1> ;Ensure PIC is saved
    48 00001F1D E421                <1>     in al, pic1data
    49 00001F1F 50                  <1>     push rax    ;Save unaltered pic1 value
    50 00001F20 24FB                <1>     and al, 0FBh ;Ensure Cascading pic1 line unmasked
    51 00001F22 E621                <1>     out pic1data, al
    52                              <1> 
    53 00001F24 E4A1                <1>     in al, pic2data
    54 00001F26 50                  <1>     push rax    ;Save unaltered pic2 value
    55 00001F27 24FE                <1>     and al, 0FEh ;Ensure line 0 of pic2 unmasked 
    56 00001F29 E6A1                <1>     out pic2data, al
    57                              <1> 
    58 00001F2B 48890C25[3B010000]  <1>     mov qword [rtc_ticks], rcx
    59 00001F33 66B88B8B            <1>     mov ax, 8B8Bh       
    60 00001F37 E670                <1>     out cmos_base, al   ;NMI disabled
    61 00001F39 E680                <1>     out waitp, al
    62 00001F3B EB00                <1>     jmp short $+2
    63 00001F3D E471                <1>     in al, cmos_data
    64 00001F3F 247F                <1>     and al, 7Fh    ;Clear upper bit
    65 00001F41 0C40                <1>     or al, 40h    ;Set periodic interrupt bit
    66 00001F43 86E0                <1>     xchg ah, al
    67 00001F45 E670                <1>     out cmos_base, al
    68 00001F47 E680                <1>     out waitp, al
    69 00001F49 EB00                <1>     jmp short $+2
    70 00001F4B 86C4                <1>     xchg al, ah
    71 00001F4D E671                <1>     out cmos_data, al
    72 00001F4F B00D                <1>     mov al, 0Dh     ;Read Register D and reenable NMI
    73 00001F51 E670                <1>     out cmos_base, al
    74 00001F53 E680                <1>     out waitp, al    ;allow one io cycle to run
    75 00001F55 EB00                <1>     jmp short $+2
    76 00001F57 E471                <1>     in al, cmos_data  
    77 00001F59 FB                  <1>     sti        ;Reenable interrupts
    78                              <1> .loopdelay:
    79 00001F5A F390                <1>     pause ;allow an interrupt to occur
    80 00001F5C 48813C25[3B010000]- <1>     cmp qword [rtc_ticks], 0        ;See if we at 0 yet
    80 00001F64 00000000            <1>
    81 00001F68 7FF0                <1>     jg .loopdelay    ;If not, keep looping
    82                              <1> ;Return CMOS to default state
    83 00001F6A FA                  <1>     cli
    84 00001F6B 66B88B8B            <1>     mov ax, 8B8Bh   ;NMI disabled
    85 00001F6F E670                <1>     out cmos_base, al
    86 00001F71 E680                <1>     out waitp, al
    87 00001F73 EB00                <1>     jmp short $+2
    88 00001F75 E471                <1>     in al, cmos_data
    89 00001F77 240F                <1>     and al, 0Fh    ;Clear all upper 4 bits
    90 00001F79 86E0                <1>     xchg ah, al
    91 00001F7B E670                <1>     out cmos_base, al
    92 00001F7D E680                <1>     out waitp, al
    93 00001F7F EB00                <1>     jmp short $+2
    94 00001F81 86E0                <1>     xchg ah, al
    95 00001F83 E671                <1>     out cmos_data, al
    96 00001F85 B00D                <1>     mov al, 0Dh     ;Read Register D and reenable NMI
    97 00001F87 E670                <1>     out cmos_base, al
    98 00001F89 E680                <1>     out waitp, al    ;allow one io cycle to run
    99 00001F8B EB00                <1>     jmp short $+2
   100 00001F8D E471                <1>     in al, cmos_data  
   101                              <1> 
   102 00001F8F 58                  <1>     pop rax ;Return pic2 value
   103 00001F90 E6A1                <1>     out pic2data, al
   104 00001F92 58                  <1>     pop rax    ;Return pic1 value
   105 00001F93 E621                <1>     out pic1data, al
   106                              <1> 
   107 00001F95 58                  <1>     pop rax    ;Return rax value
   108 00001F96 FB                  <1>     sti
   109                              <1> .return:
   110 00001F97 48CF                <1>     iretq
   111                              <1> .memory16MB:    ;ah=88 function
   112 00001F99 668B0425[DE010000]  <1>     mov ax, word [srData1]
   113 00001FA1 48CF                <1>     iretq
   114                              <1> 
   115                              <1> .miscDispatcher:
   116                              <1> ; ax = C500h -> Beep PC speaker
   117                              <1> ; ax = C501h -> Connect Debugger 
   118                              <1> ; ax = C502h -> Disconnect Debugger
   119 00001FA3 84C0                <1>     test al, al     ;Play a tone using PC speaker
   120 00001FA5 0F84C7000000        <1>     jz .mdBeeper
   121 00001FAB 3C01                <1>     cmp al, 01h     ;Connect Debugger
   122 00001FAD 7409                <1>     jz .mdConnectDebugger
   123 00001FAF 3C02                <1>     cmp al, 02h     ;Disconnect Debugger
   124 00001FB1 7460                <1>     jz .mdDisconnectDebugger
   125 00001FB3 E955FFFFFF          <1>     jmp .badFunction
   126                              <1> .mdConnectDebugger:
   127 00001FB8 50                  <1>     push rax
   128 00001FB9 53                  <1>     push rbx
   129 00001FBA 52                  <1>     push rdx
   130 00001FBB 56                  <1>     push rsi
   131 00001FBC BA008F0000          <1>     mov edx, 8F00h
   132 00001FC1 BB08000000          <1>     mov ebx, codedescriptor
   133 00001FC6 48B8-               <1>     mov rax, MCP_int.singleStepsEP  ;Pointer
   133 00001FC8 [2024000000000000]  <1>
   134 00001FD0 48BE01000000000000- <1>     mov rsi, 01 ;Interrupt number, Single Step
   134 00001FD9 00                  <1>
   135 00001FDA E8ECE0FFFF          <1>     call idtWriteEntry
   136 00001FDF 48B8-               <1>     mov rax, MCP_int.debugEp  ;Pointer
   136 00001FE1 [7524000000000000]  <1>
   137 00001FE9 48BE03000000000000- <1>     mov rsi, 03 ;Interrupt number, Software Breakpoint
   137 00001FF2 00                  <1>
   138 00001FF3 E8D3E0FFFF          <1>     call idtWriteEntry
   139 00001FF8 48B8-               <1>     mov rax, MCP_int.debugEpHardware  ;Pointer
   139 00001FFA [5524000000000000]  <1>
   140 00002002 48BE3B000000000000- <1>     mov rsi, 3Bh ;Interrupt number, Invoke debugger through hardware CTRL+BREAK
   140 0000200B 00                  <1>
   141 0000200C E8BAE0FFFF          <1>     call idtWriteEntry
   142 00002011 EB59                <1>     jmp short .mdDebugExit
   143                              <1> .mdDisconnectDebugger:
   144 00002013 50                  <1>     push rax
   145 00002014 53                  <1>     push rbx
   146 00002015 52                  <1>     push rdx
   147 00002016 56                  <1>     push rsi
   148 00002017 BA008F0000          <1>     mov edx, 8F00h
   149 0000201C BB08000000          <1>     mov ebx, codedescriptor
   150 00002021 48B8-               <1>     mov rax, i1  ;Pointer
   150 00002023 [1C54000000000000]  <1>
   151 0000202B 48BE01000000000000- <1>     mov rsi, 01 ;Interrupt number, Single Step
   151 00002034 00                  <1>
   152 00002035 E891E0FFFF          <1>     call idtWriteEntry
   153 0000203A 48B8-               <1>     mov rax, i3  ;Pointer
   153 0000203C [3A54000000000000]  <1>
   154 00002044 48BE03000000000000- <1>     mov rsi, 03 ;Interrupt number, Software Breakpoint
   154 0000204D 00                  <1>
   155 0000204E E878E0FFFF          <1>     call idtWriteEntry
   156 00002053 48B8-               <1>     mov rax, ctrlbreak_io  ;Pointer
   156 00002055 [A934000000000000]  <1>
   157 0000205D 48BE3B000000000000- <1>     mov rsi, 3Bh ;Interrupt number, CTRL+Break
   157 00002066 00                  <1>
   158 00002067 E85FE0FFFF          <1>     call idtWriteEntry
   159                              <1> .mdDebugExit:
   160 0000206C 5E                  <1>     pop rsi
   161 0000206D 5A                  <1>     pop rdx
   162 0000206E 5B                  <1>     pop rbx
   163 0000206F 58                  <1>     pop rax
   164 00002070 48CF                <1>     iretq
   165                              <1> 
   166                              <1> .mdBeeper:
   167                              <1> ;Input: 
   168                              <1> ;   bx = Frequency divisor to use for tone
   169                              <1> ;   rcx = # of ms to beep for
   170                              <1> ; All registers including ax preserved
   171 00002072 E81FE0FFFF          <1>     call beep
   172 00002077 48CF                <1>     iretq
   173                              <1> 
   174                              <1> .advSysMemDispatcher:
   175                              <1> ; ax = E800h -> Return userBase pointer
   176                              <1> ; ax = E801h -> Give RAM count, minus the size of SCPBIOS, in ax, bx, cx, dx.
   177                              <1> ; ax = E802h -> Total RAM count (without SCP/BIOS)
   178                              <1> ; ax = E820h -> Full Memory Map, including entry for SCPBIOS
   179 00002079 84C0                <1>     test al, al
   180 0000207B 7411                <1>     jz .retUserBase
   181 0000207D 3C01                <1>     cmp al, 01h
   182 0000207F 7417                <1>     je .memory64MB
   183 00002081 3C02                <1>     cmp al, 02h
   184 00002083 7435                <1>     je .memoryBIOSseg
   185 00002085 3C20                <1>     cmp al, 20h
   186 00002087 7451                <1>     je .fullMemoryMap
   187 00002089 E97FFEFFFF          <1>     jmp .badFunction
   188                              <1> 
   189                              <1> .retUserBase:
   190 0000208E 488B0425[CD010000]  <1>     mov rax, qword [userBase]
   191 00002096 48CF                <1>     iretq
   192                              <1> .memory64MB:
   193 00002098 668B0425[D6010000]  <1>     mov ax, word [srData]
   194 000020A0 668B1C25[D8010000]  <1>     mov bx, word [srData + 2]
   195 000020A8 668B0C25[DA010000]  <1>     mov cx, word [srData + 4]
   196 000020B0 668B1425[DC010000]  <1>     mov dx, word [srData + 6]
   197 000020B8 48CF                <1>     iretq    
   198                              <1> .memoryBIOSseg:
   199                              <1> ;This gives information about the SCP/BIOS segment
   200 000020BA 48B800001100000000- <1>     mov rax, BIOSStartAddr  ;Start address of BIOS
   200 000020C3 00                  <1>
   201 000020C4 31DB                <1>     xor ebx, ebx
   202 000020C6 8B1C25[E8010000]    <1>     mov ebx, dword [scpSize]    ;Total sum of segment sizes
   203 000020CD 488B1425[E0010000]  <1>     mov rdx, qword [sysMem]     ;Get total usable memory count
   204 000020D5 4829DA              <1>     sub rdx, rbx    ;Remove SCP/BIOS allocation from the size
   205 000020D8 48CF                <1>     iretq
   206                              <1> 
   207                              <1> .fullMemoryMap:
   208 000020DA 488B0425[CD010000]  <1>     mov rax, qword [userBase]    ;Start space, returns userbase in r8
   209 000020E2 48BE-               <1>     mov rsi, bigmapptr
   209 000020E4 [F005000000000000]  <1>
   210 000020EC 8A0C25[D5010000]    <1>     mov cl, byte [bigmapSize]   ;Get the number of 24 byte entries
   211 000020F3 30ED                <1>     xor ch, ch                  ;Reserve the upper byte
   212 000020F5 48CF                <1>     iretq
   213                              <1> 
   214                              <1> .sysDataTableDispatcher:
   215                              <1> ; ax = F000h, Register new GDT ptr
   216                              <1> ; ax = F001h, Register new IDT ptr
   217                              <1> ; ax = F002h, Get Current GDT ptr
   218                              <1> ; ax = F003h, Get Current IDT ptr
   219                              <1> ; ax = F004h, Register New Page Tables
   220                              <1> ; ax = F005h, Get physical address of PTables
   221                              <1> ; ax = F006h, Get pointer to BIOS Data Area
   222                              <1> ; ax = F007h, Read IDT entry
   223                              <1> ; ax = F008h, Write IDT entry
   224                              <1> ; ax = F009h, Register new Disk Parameter Table
   225                              <1> ; ax = F00Ah, Get current DPT
   226                              <1> ; ax = F00Bh, Register new Fixed Disk Parameter Table
   227                              <1> ; ax = F00Ch, Get current fDPT
   228                              <1> ; ax = F00Dh, Register new SysInit parameters 
   229                              <1> ; ax = F00Eh, Get current SysInit parameters
   230 000020F7 3C04                <1>     cmp al, 4h          
   231 000020F9 725D                <1>     jb .sdtDT           ;al = 00 - 03, goto sdtDT
   232 000020FB 3C04                <1>     cmp al, 4           
   233 000020FD 0F8493000000        <1>     jz .sdtRegisterPage ;al = 04
   234 00002103 3C05                <1>     cmp al, 5
   235 00002105 0F8495000000        <1>     jz .sdtGetPagePtr   ;al = 05
   236 0000210B 3C06                <1>     cmp al, 6
   237 0000210D 0F8497000000        <1>     jz .sdtDataptr      ;al = 06
   238 00002113 3C07                <1>     cmp al, 7
   239 00002115 0F849B000000        <1>     jz .sdtReadIDTEntry ;al = 07
   240 0000211B 3C08                <1>     cmp al, 8
   241 0000211D 0F84C4000000        <1>     jz .sdtWriteIDTEntry    ;al = 08
   242 00002123 3C09                <1>     cmp al, 9
   243 00002125 0F84D4000000        <1>     jz .sdtNewDDP       ;al = 09
   244 0000212B 3C0A                <1>     cmp al, 0Ah
   245 0000212D 0F84E0000000        <1>     jz .sdtReadDDP      ;al = 0A
   246 00002133 3C0B                <1>     cmp al, 0Bh         
   247 00002135 0F84CE000000        <1>     jz .sdtNewfDDP      ;al = 0Bh
   248 0000213B 3C0C                <1>     cmp al, 0Ch
   249 0000213D 0F84DA000000        <1>     jz .sdtReadfDDP     ;al = 0Ch
   250 00002143 3C0D                <1>     cmp al, 0Dh
   251 00002145 0F84DC000000        <1>     jz .sdtNewSysInit   ;al = 0Dh
   252 0000214B 3C0E                <1>     cmp al, 0Eh
   253 0000214D 0F84E6000000        <1>     jz .sdtReadSysInit  ;al = 0Eh
   254 00002153 E9B5FDFFFF          <1>     jmp .badFunction
   255                              <1> 
   256                              <1> .sdtDT:
   257                              <1> ;sys data tables Descriptor Table dispatcher
   258                              <1> ;rbx has/will have I/GDT base pointer (qword)
   259                              <1> ;ecx has/will have I/GDT limit (word)
   260                              <1> ;edx has/will have Number of entries in I/GDT (word)
   261 00002158 57                  <1>     push rdi
   262 00002159 56                  <1>     push rsi
   263 0000215A 48BF-               <1>     mov rdi, GDTlength
   263 0000215C [0C00000000000000]  <1>
   264 00002164 48BE-               <1>     mov rsi, IDTlength
   264 00002166 [0000000000000000]  <1>
   265 0000216E A801                <1>     test al, 1  ;If al[0] = 1, want rdi to point to IDT area
   266 00002170 480F45FE            <1>     cmovnz rdi, rsi ;If al[0] = 0, rdi will keep pointing to GDT
   267 00002174 A802                <1>     test al, 2  ;If bit 2 is set, Get pointers
   268 00002176 750F                <1>     jnz .sdtGet
   269 00002178 668917              <1>     mov word [rdi], dx
   270 0000217B 66894F02            <1>     mov word [rdi + 2], cx
   271 0000217F 48895F04            <1>     mov qword [rdi + 4], rbx
   272 00002183 56                  <1>     push rsi
   273 00002184 5F                  <1>     pop rdi
   274 00002185 48CF                <1>     iretq
   275                              <1> .sdtGet:
   276 00002187 0FB717              <1>     movzx edx, word [rdi]
   277 0000218A 0FB74F02            <1>     movzx ecx, word [rdi + 2]
   278 0000218E 488B5F04            <1>     mov rbx, qword [rdi + 4]
   279 00002192 56                  <1>     push rsi
   280 00002193 5F                  <1>     pop rdi
   281 00002194 48CF                <1>     iretq
   282                              <1> .sdtRegisterPage:
   283 00002196 48891C25[18000000]  <1>     mov qword [pageTablePtr], rbx   ;Registers pointer as new table space
   284 0000219E 48CF                <1>     iretq
   285                              <1> .sdtGetPagePtr:
   286 000021A0 488B1C25[18000000]  <1>     mov rbx, qword [pageTablePtr]  ;Return BIOS Page Table ptr
   287 000021A8 48CF                <1>     iretq
   288                              <1> .sdtDataptr:
   289 000021AA 48BB-               <1>     mov rbx, section.data.start        ;Get BIOS Data area ptr into rax
   289 000021AC [0000000000000000]  <1>
   290 000021B4 48CF                <1>     iretq
   291                              <1> .sdtReadIDTEntry:
   292                              <1> ;bx = Number of interrupt handler (00h-0FFFFh), uses only bl
   293                              <1> ;Returns pointer in rbx, 
   294                              <1> ;Segment selector in ax,
   295                              <1> ;Attribute word in dx
   296 000021B6 480FB6DB            <1>     movzx rbx, bl
   297 000021BA 488B1425[04000000]  <1>     mov rdx, qword [IDTpointer.Base]    ;Get base address
   298 000021C2 48C1E304            <1>     shl rbx, 4h         ;Multiply address number by 16
   299 000021C6 4801DA              <1>     add rdx, rbx        ;rdx point to IDT entry
   300 000021C9 8B4208              <1>     mov eax, dword [rdx + 8]
   301 000021CC 48C1E020            <1>     shl rax, 20h        ;Shift dword into upper dword
   302 000021D0 668B5A06            <1>     mov bx, word [rdx + 6]
   303 000021D4 C1E310              <1>     shl ebx, 10h        ;Shift word into upper word
   304 000021D7 668B1A              <1>     mov bx, word [rdx]  ;Get final word
   305 000021DA 4809C3              <1>     or rbx, rax         ;Add upper dword to rbx
   306 000021DD 668B4202            <1>     mov ax, word [rdx + 2]  ;Get Segment selector in ax
   307 000021E1 668B5204            <1>     mov dx, word [rdx + 4]  ;Get attributes word
   308 000021E5 48CF                <1>     iretq
   309                              <1> .sdtWriteIDTEntry:
   310                              <1> ;rbx = Pointer to new routine
   311                              <1> ;cx = Number of the interrupt handler (00h-0FFFFh), uses only cl
   312                              <1> ;dx = IDT entry attributes
   313                              <1> ;si = Segment selector
   314 000021E7 50                  <1>     push rax
   315 000021E8 51                  <1>     push rcx
   316 000021E9 56                  <1>     push rsi
   317 000021EA 53                  <1>     push rbx
   318 000021EB 4889D8              <1>     mov rax, rbx    ;Move pointer to new routine to rax
   319 000021EE 89F3                <1>     mov ebx, esi    ;Move Segment selector from si to bx 
   320 000021F0 480FB6F1            <1>     movzx rsi, cl   ;Movzx low byte of interrupt number into rsi
   321 000021F4 E8D2DEFFFF          <1>     call idtWriteEntry
   322 000021F9 5B                  <1>     pop rbx
   323 000021FA 5E                  <1>     pop rsi
   324 000021FB 59                  <1>     pop rcx
   325 000021FC 58                  <1>     pop rax
   326 000021FD 48CF                <1>     iretq
   327                              <1> .sdtNewDDP:
   328 000021FF 48891C25[AF010000]  <1>     mov qword [diskDptPtr], rbx
   329 00002207 48CF                <1>     iretq
   330                              <1> .sdtNewfDDP:
   331 00002209 48891C25[B7010000]  <1>     mov qword [fdiskDptPtr], rbx
   332 00002211 48CF                <1>     iretq
   333                              <1> .sdtReadDDP:
   334 00002213 488B1C25[AF010000]  <1>     mov rbx, qword [diskDptPtr]
   335 0000221B 48CF                <1>     iretq
   336                              <1> .sdtReadfDDP:
   337 0000221D 488B1C25[B7010000]  <1>     mov rbx, qword [fdiskDptPtr]
   338 00002225 48CF                <1>     iretq
   339                              <1> .sdtNewSysInit:
   340 00002227 48891C25[BF010000]  <1>     mov qword [nextFilePtr], rbx
   341 0000222F 66891425[C7010000]  <1>     mov word [numSectors], dx
   342 00002237 48CF                <1>     iretq
   343                              <1> .sdtReadSysInit:
   344 00002239 488B1C25[BF010000]  <1>     mov rbx, qword [nextFilePtr]
   345 00002241 668B1425[C7010000]  <1>     mov dx, word [numSectors]
   346 00002249 48CF                <1>     iretq
   347                              <1> .ehciFunctionDispatcher:
   348                              <1> ;EHCI function dispatcher 0F1h
   349                              <1> ; al = 00h -> EHCI get crit error handler
   350                              <1> ; al = 01h -> EHCI set crit error handler
   351                              <1> ; al = 02h -> Reserved, reset selected EHCI controller
   352                              <1> ; al = 03h -> Reserved, re-enumerate devices downstream of EHCI Root hub
   353 0000224B 84C0                <1>     test al, al
   354 0000224D 7411                <1>     jz .ehciDispGetCritPtr
   355 0000224F FEC8                <1>     dec al
   356 00002251 7417                <1>     jz .ehciDispSetCritPtr
   357 00002253 FEC8                <1>     dec al
   358 00002255 741D                <1>     jz .ehciDispResetCtrlr
   359 00002257 FEC8                <1>     dec al
   360 00002259 7419                <1>     jz .echiDispReEnumDevices
   361 0000225B E9ADFCFFFF          <1>     jmp .badFunction
   362                              <1> 
   363                              <1> .ehciDispGetCritPtr:
   364                              <1> ;Gets the address of the current EHCI critical error handler into rbx
   365 00002260 488B1C25[37020000]  <1>     mov rbx, qword [eHCErrorHandler]
   366 00002268 48CF                <1>     iretq
   367                              <1> .ehciDispSetCritPtr:
   368                              <1> ;Sets the address of the EHCI critical error handler to the ptr in rbx
   369 0000226A 48891C25[37020000]  <1>     mov qword [eHCErrorHandler], rbx
   370 00002272 48CF                <1>     iretq
   371                              <1> .ehciDispResetCtrlr:
   372                              <1> .echiDispReEnumDevices:
   373 00002274 B486                <1>     mov ah, 86h     ;Unsupported function call
   374 00002276 E994FCFFFF          <1>     jmp .badout  
   375                              <1> ;------------------------End of Interrupt------------------------
    99                                  %include "./Source/Resident/Services/Int36h.asm"
     1                              <1> ;-------------------Keyboard Interrupt Int 36h-------------------
     2                              <1> ; Software keyboard interrupt. 
     3                              <1> ; ah = 0 -> Read the next scancode/ASCII struck from the keyboard
     4                              <1> ; ah = 1 -> Clear zero flag if there is a new char ready to be 
     5                              <1> ;           read.
     6                              <1> ; ah = 2 -> Returns the current shift status in the al register
     7                              <1> ; ax and flags changed.
     8                              <1> ;----------------------------------------------------------------
     9                              <1> kb_io:
    10 0000227B 53                  <1>     push rbx
    11 0000227C FA                  <1>     cli            ;Interrupts off
    12 0000227D 84E4                <1>     test ah, ah
    13 0000227F 7411                <1>     jz .k0
    14 00002281 FECC                <1>     dec ah
    15 00002283 7436                <1>     jz .k1
    16 00002285 FECC                <1>     dec ah
    17 00002287 7450                <1>     jz .k2
    18 00002289 804C241801          <1>     or byte [rsp + 3*8h], 1    ;Set CF, invalid function, skip rbx on stack
    19 0000228E B480                <1>     mov ah, 80h    ;Invalid Function
    20 00002290 EB4E                <1>     jmp short .kexit ;ah > 2, not a valid function
    21                              <1>     
    22                              <1> .k0:    
    23                              <1> ;This one moves the head to catch up with the tail.
    24 00002292 FB                  <1>     sti
    25 00002293 F390                <1>     pause    ;Allow a keyboard interrupt to occur
    26 00002295 FA                  <1>     cli
    27 00002296 488B1C25[42000000]  <1>     mov rbx, qword [kb_buf_head]
    28 0000229E 483B1C25[4A000000]  <1>     cmp rbx, qword [kb_buf_tail]    ;Are we at the head of the buffer?
    29 000022A6 74EA                <1>     je .k0    ;If we are, then the buffer is empty, await a keystroke
    30 000022A8 66678B03            <1>     mov ax, word [ebx]        ;move the word pointed at by rbx to ax
    31 000022AC E833000000          <1>     call .kb_ptr_adv    ;Advance the buffer pointer
    32                              <1>     
    33 000022B1 48891C25[42000000]  <1>     mov qword [kb_buf_head], rbx    ;Move rbx into the buffer head variable
    34 000022B9 EB25                <1>     jmp short .kexit
    35                              <1> 
    36                              <1> .k1:
    37 000022BB 488B1C25[42000000]  <1>     mov rbx, qword [kb_buf_head]
    38 000022C3 483B1C25[4A000000]  <1>     cmp rbx, qword [kb_buf_tail] ;sets flags, Z is set if equal 
    39 000022CB 660F4503            <1>     cmovnz ax, word [rbx]    ;move head of buffer into ax, IF Z clear
    40 000022CF FB                  <1>     sti     ;renable interrupts 
    41 000022D0 9C                  <1>     pushfq    ;push flags onto stack
    42 000022D1 5B                  <1>     pop rbx    ;pop them into rbx
    43 000022D2 48895C2418          <1>     mov [rsp + 3*8h], qword rbx    ;Replace with new flags, skip pushed rbx
    44 000022D7 EB07                <1>     jmp short .kexit
    45                              <1>     
    46                              <1> .k2:
    47 000022D9 8A0425[62000000]    <1>     mov al, byte [kb_flags]
    48                              <1> .kexit:
    49 000022E0 FB                  <1>     sti
    50 000022E1 5B                  <1>     pop rbx
    51 000022E2 48CF                <1>     iretq
    52                              <1> 
    53                              <1> .kb_ptr_adv:
    54                              <1> ;Advance the pointer passed by rbx safely and return pointer!
    55 000022E4 48FFC3              <1>     inc rbx
    56 000022E7 48FFC3              <1>     inc rbx
    57 000022EA 483B1C25[5A000000]  <1>     cmp rbx, qword [kb_buf_end]     ;Are we at the end of the buffer space
    58 000022F2 7508                <1>     jne .kbpa1                      ;If not exit, if we are, wrap around space!
    59 000022F4 488B1C25[52000000]  <1>     mov rbx, qword [kb_buf_start]
    60                              <1> .kbpa1:
    61 000022FC C3                  <1>     ret
    62                              <1> ;------------------------End of Interrupt------------------------
   100                                  %include "./Source/Resident/Services/Int37h.asm"
     1                              <1> ;------------------------Printer Int 37h-------------------------
     2                              <1> ; Reserved for printer specific functions. Both USB and Parallel.
     3                              <1> ; Not currently supported
     4                              <1> ;----------------------------------------------------------------
     5                              <1> printer_io:
     6 000022FD B486                <1>     mov ah, 86h    ;Function not supported
     7 000022FF 804C241001          <1>     or byte [rsp+ 2*8h], 1    ;Set carry
     8 00002304 48CF                <1>     iretq
     9                              <1> ;------------------------End of Interrupt------------------------
   101                                  %include "./Source/Sysdebug/sysdeb.asm"
     1                              <1> ;---------------------MCP Interrupt Int 38h----------------------
     2                              <1> ;This interrupt superceeds the IBM BASIC routine caller. 
     3                              <1> ;This is a 64 bit port of my 16 bit MCP monitor program, 
     4                              <1> ; allowing users to "interactively" get sectors from devices 
     5                              <1> ; and run them. I might add some nicities to this version of MCP 
     6                              <1> ; such as a function to list all devices.
     7                              <1> ;----------------------------------------------------------------
     8                              <1> MCPjmptbl:  ;Function jump table
     9 00002306 [402C000000000000]  <1>     dq MCP_int.dumpMemory      ;Dump
    10 0000230E [412E000000000000]  <1>     dq MCP_int.editMemory      ;Edit
    11 00002316 [FD2E000000000000]  <1>     dq MCP_int.singleStep      ;Single step
    12 0000231E [B12E000000000000]  <1>     dq MCP_int.jumpProc        ;Go
    13 00002326 [0C2F000000000000]  <1>     dq MCP_int.proceedDefault  ;Proceed
    14 0000232E [1F2F000000000000]  <1>     dq MCP_int.storageRead     ;Load
    15 00002336 [272F000000000000]  <1>     dq MCP_int.storageWrite    ;Write
    16 0000233E [B12F000000000000]  <1>     dq MCP_int.restartMcp      ;Quit   <- To call Int 40h for DOS compatibility
    17 00002346 [B32F000000000000]  <1>     dq MCP_int.clearscreen     ;Clear screen
    18 0000234E [1B27000000000000]  <1>     dq MCP_int.xchangeReg      ;Registers
    19 00002356 [7E25000000000000]  <1>     dq MCP_int.debugRegs       ;Breakpoints
    20 0000235E [EF28000000000000]  <1>     dq MCP_int.hexCalc         ;Hex
    21 00002366 [3328000000000000]  <1>     dq MCP_int.inport          ;In
    22 0000236E [8628000000000000]  <1>     dq MCP_int.outport         ;Out
    23 00002376 [3925000000000000]  <1>     dq MCP_int.version         ;Version
    24 0000237E [FD2E000000000000]  <1>     dq MCP_int.singleStep      ;Single Step (Alt), temp
    25 00002386 [0A24000000000000]  <1>     dq MCP_int.memoryMap       ;Print memory map
    26 0000238E [D224000000000000]  <1>     dq MCP_int.connect         ;Connect Debugger
    27 00002396 [0425000000000000]  <1>     dq MCP_int.disconnect      ;Disconnect Debugger
    28                              <1> MCP_int:
    29                              <1>     ;Entry point from external programs
    30 0000239E 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
    31 000023A6 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
    32 000023AE 48896008            <1>     mov qword [rax + 08h], rsp
    33 000023B2 E8080C0000          <1>     call .storeMainRegisters    ;Save main registers
    34                              <1> .z11:
    35 000023B7 488B2425[0C020000]  <1>     mov rsp, qword [mcpStackPtr]  ;Point sp to new stack
    36 000023BF B804130000          <1>     mov eax, 1304h    ;Zero extends to rax
    37 000023C4 48BD-               <1>     mov rbp, .prompt
    37 000023C6 [9C31000000000000]  <1>
    38 000023CE 30FF                <1>     xor bh, bh
    39 000023D0 CD30                <1>     int 30h
    40                              <1> .z2:
    41 000023D2 6631C0              <1>     xor ax, ax 
    42 000023D5 CD36                <1>     int 36h
    43 000023D7 3C08                <1>     cmp al, 08h        ;If backspace, ignore
    44 000023D9 74F7                <1>     je .z2
    45 000023DB E8910D0000          <1>     call .print        ;Print input char
    46 000023E0 FD                  <1>     std
    47 000023E1 48BF-               <1>     mov rdi, .prompt    ;end of lst is prompt
    47 000023E3 [9C31000000000000]  <1>
    48 000023EB 48B914000000000000- <1>     mov rcx, .lstl + 1
    48 000023F4 00                  <1>
    49 000023F5 F2AE                <1>     repne scasb
    50 000023F7 FC                  <1>     cld
    51 000023F8 0F85AC000000        <1>     jne .bad_command    ;Char not found!
    52                              <1> .prog_sel:    ;Choose program
    53 000023FE 68[B7230000]        <1>     push MCP_int.z11    ;to allow RETurning to application
    54 00002403 FF24CD[06230000]    <1>     jmp qword [MCPjmptbl + 8*rcx]    ;Jump to chosen function         
    55                              <1> .memoryMap:
    56 0000240A 66B80A0E            <1>     mov ax,0E0Ah
    57 0000240E CD30                <1>     int 30h
    58 00002410 66B80D0E            <1>     mov ax, 0E0Dh
    59 00002414 CD30                <1>     int 30h
    60 00002416 E8E5DBFFFF          <1>     call e820print  ;Print memory map
    61 0000241B E997FFFFFF          <1>     jmp .z11
    62                              <1> .singleStepsEP:
    63 00002420 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
    64 00002428 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
    65 00002430 48896008            <1>     mov qword [rax + 08h], rsp
    66 00002434 E8860B0000          <1>     call .storeMainRegisters
    67 00002439 488B0424            <1>     mov rax, qword [rsp]    ;Get next instruction address
    68 0000243D 48890425[F4010000]  <1>     mov qword [mcpUserRip], rax
    69 00002445 E875050000          <1>     call .dumpReg    ;Show register state
    70 0000244A E802020000          <1>     call .dumpDebugRegs
    71 0000244F FB                  <1>     sti ;Restore interrupts
    72 00002450 E962FFFFFF          <1>     jmp .z11
    73                              <1> .debugEpHardware:
    74 00002455 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
    75 0000245D 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
    76 00002465 48896008            <1>     mov qword [rax + 08h], rsp
    77 00002469 E8510B0000          <1>     call .storeMainRegisters
    78 0000246E FB                  <1>     sti ;Restore interrupts
    79 0000246F B020                <1>     mov al, EOI
    80 00002471 E620                <1>     out pic1command, al
    81 00002473 EB1A                <1>     jmp short .dep1
    82                              <1> .debugEp:    
    83                              <1> ;Return here after a single step or int 3. 
    84                              <1> ;Support Int 3h thru manual encoding only, not via the debugger
    85 00002475 48890425[04020000]  <1>     mov qword [mcpUserRaxStore], rax
    86 0000247D 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
    87 00002485 48896008            <1>     mov qword [rax + 08h], rsp
    88 00002489 E8310B0000          <1>     call .storeMainRegisters
    89 0000248E FB                  <1>     sti ;Restore interrupts
    90                              <1> .dep1:
    91 0000248F 488B0424            <1>     mov rax, qword [rsp]    ;Get next instruction address
    92 00002493 48890425[F4010000]  <1>     mov qword [mcpUserRip], rax
    93 0000249B E81F050000          <1>     call .dumpReg    ;Show register state
    94 000024A0 E8AC010000          <1>     call .dumpDebugRegs
    95 000024A5 E90DFFFFFF          <1>     jmp .z11
    96                              <1> .bad_command:
    97 000024AA 48B804130000000000- <1>     mov rax, 1304h
    97 000024B3 00                  <1>
    98 000024B4 30FF                <1>     xor bh, bh
    99 000024B6 48BD-               <1>     mov rbp, .bc1
    99 000024B8 [C724000000000000]  <1>
   100 000024C0 CD30                <1>     int 30h
   101 000024C2 E9F0FEFFFF          <1>     jmp MCP_int.z11
   102 000024C7 0A0D205E204572726F- <1> .bc1: db 0Ah,0Dh," ^ Error",0
   102 000024D0 7200                <1>
   103                              <1> ;><><><><><><><-Internal Commands Begin Here-><><><><><><><
   104                              <1> .connect:
   105 000024D2 50                  <1>     push rax
   106 000024D3 55                  <1>     push rbp
   107 000024D4 B801C50000          <1>     mov eax, 0C501h ;Connect Debugger
   108 000024D9 CD35                <1>     int 35h
   109 000024DB B804130000          <1>     mov eax, 1304h
   110 000024E0 48BD-               <1>     mov rbp, .connectString
   110 000024E2 [EF24000000000000]  <1>
   111 000024EA CD30                <1>     int 30h
   112 000024EC 5D                  <1>     pop rbp
   113 000024ED 58                  <1>     pop rax
   114 000024EE C3                  <1>     ret
   115 000024EF 0A0D53595344454255- <1> .connectString db 0Ah,0Dh,"SYSDEBUG Connected",0
   115 000024F8 4720436F6E6E656374- <1>
   115 00002501 656400              <1>
   116                              <1> .disconnect:
   117 00002504 50                  <1>     push rax
   118 00002505 55                  <1>     push rbp
   119 00002506 B802C50000          <1>     mov eax, 0C502h ;Disconnect Debugger
   120 0000250B CD35                <1>     int 35h
   121 0000250D B804130000          <1>     mov eax, 1304h
   122 00002512 48BD-               <1>     mov rbp, .disconnectString
   122 00002514 [2125000000000000]  <1>
   123 0000251C CD30                <1>     int 30h
   124 0000251E 5D                  <1>     pop rbp
   125 0000251F 58                  <1>     pop rax
   126 00002520 C3                  <1>     ret
   127 00002521 0A0D53595344454255- <1> .disconnectString db 0Ah,0Dh,"SYSDEBUG Disconnected",0
   127 0000252A 4720446973636F6E6E- <1>
   127 00002533 656374656400        <1>
   128                              <1> .version:
   129 00002539 66B80413            <1>     mov ax, 1304h
   130 0000253D 30FF                <1>     xor bh, bh
   131 0000253F 48BD-               <1>     mov rbp, .vstring
   131 00002541 [6125000000000000]  <1>
   132 00002549 CD30                <1>     int 30h
   133 0000254B 48BE-               <1>     mov rsi, signature + 1    ;Point to BIOS signature string (skip the v char)
   133 0000254D [3658000000000000]  <1>
   134                              <1> .v1:
   135 00002555 AC                  <1>     lodsb
   136 00002556 3C20                <1>     cmp al, 20h            ;Check space
   137 00002558 7406                <1>     je .v2
   138 0000255A B40E                <1>     mov ah, 0Eh
   139                              <1>     ;xor bh, bh
   140 0000255C CD30                <1>     int 30h
   141 0000255E EBF5                <1>     jmp short .v1
   142                              <1> .v2:
   143 00002560 C3                  <1>     ret
   144 00002561 0A0D5343502F42494F- <1> .vstring:    db 0Ah, 0Dh,"SCP/BIOS SYSDEBUG Version ",0
   144 0000256A 532053595344454255- <1>
   144 00002573 472056657273696F6E- <1>
   144 0000257C 2000                <1>
   145                              <1> .debugRegs:
   146 0000257E E8CE000000          <1>     call .dumpDebugRegs
   147 00002583 66B80413            <1>     mov ax, 1304h
   148 00002587 48BD-               <1>     mov rbp, .crlf    ;Newline
   148 00002589 [A231000000000000]  <1>
   149 00002591 CD30                <1>     int 30h
   150                              <1> 
   151 00002593 66B82E0E            <1>     mov ax, 0E2Eh    ;Print dot byte
   152 00002597 CD30                <1>     int 30h
   153                              <1> 
   154 00002599 66B80101            <1>     mov ax, 0101h    ;Process one byte
   155 0000259D E82E0B0000          <1>     call .keyb
   156 000025A2 4885ED              <1>     test rbp, rbp
   157 000025A5 0F840CFEFFFF        <1>     jz .z11    ;If enter pressed, return to command line
   158 000025AB E8C00A0000          <1>     call .arg
   159 000025B0 3C01                <1>     cmp al, 1
   160 000025B2 0F85DA070000        <1>     jne .dmbadexit
   161                              <1> 
   162 000025B8 488B7D00            <1>     mov rdi, qword [rbp]
   163 000025BC 4881FF04000000      <1>     cmp rdi, 4
   164 000025C3 7213                <1>     jb .xr11    ;Cant edit dr4, or 5. dr6 is read only
   165 000025C5 4881FF07000000      <1>     cmp rdi, 7  ;Can only edit 7
   166 000025CC 0F85D8FEFFFF        <1>     jne .bad_command
   167 000025D2 48FFCF              <1>     dec rdi     ;Is the fifth entry in the table
   168 000025D5 48FFCF              <1>     dec rdi
   169                              <1> .xr11:
   170 000025D8 48BD-               <1>     mov rbp, .crlf
   170 000025DA [A231000000000000]  <1>
   171 000025E2 66B80413            <1>     mov ax, 1304h
   172 000025E6 30FF                <1>     xor bh, bh
   173 000025E8 CD30                <1>     int 30h
   174                              <1> 
   175 000025EA 57                  <1>     push rdi    ;Save rdi
   176 000025EB 48C1E702            <1>     shl rdi, 2    ;Multiply by 4
   177 000025EF 66B90400            <1>     mov cx, 4    ;4 chars to print
   178                              <1> .xr1:   ;Print register name
   179 000025F3 8A87[03270000]      <1>     mov al, byte [.dregtbl + rdi]
   180 000025F9 B40E                <1>     mov ah, 0Eh
   181 000025FB CD30                <1>     int 30h
   182 000025FD 66FFC7              <1>     inc di
   183 00002600 66FFC9              <1>     dec cx
   184 00002603 75EE                <1>     jnz .xr1
   185                              <1> ;Get the qword into the keybuffer
   186 00002605 5F                  <1>     pop rdi
   187 00002606 66B80104            <1>     mov ax, 0401h    ;Process one qword
   188 0000260A E8C10A0000          <1>     call .keyb
   189 0000260F 4885ED              <1>     test rbp, rbp
   190 00002612 0F84C6010000        <1>     jz .xcnoexit
   191 00002618 E8530A0000          <1>     call .arg
   192 0000261D 3C01                <1>     cmp al, 1
   193 0000261F 0F856D070000        <1>     jne .dmbadexit
   194                              <1> 
   195 00002625 488B4500            <1>     mov rax, qword [rbp]    ;rax has the replacement value
   196 00002629 4885FF              <1>     test rdi, rdi
   197 0000262C 7504                <1>     jnz .xr2
   198 0000262E 0F23C0              <1>     mov dr0, rax
   199 00002631 C3                  <1>     ret
   200                              <1> .xr2:
   201 00002632 48FFCF              <1>     dec rdi
   202 00002635 7504                <1>     jnz .xr3
   203 00002637 0F23C8              <1>     mov dr1, rax
   204 0000263A C3                  <1>     ret
   205                              <1> .xr3:
   206 0000263B 48FFCF              <1>     dec rdi
   207 0000263E 7504                <1>     jnz .xr4
   208 00002640 0F23D0              <1>     mov dr2, rax
   209 00002643 C3                  <1>     ret
   210                              <1> .xr4:
   211 00002644 48FFCF              <1>     dec rdi
   212 00002647 7504                <1>     jnz .xr5
   213 00002649 0F23D8              <1>     mov dr3, rax
   214 0000264C C3                  <1>     ret
   215                              <1> .xr5:
   216 0000264D 0F23F8              <1>     mov dr7, rax
   217 00002650 C3                  <1>     ret
   218                              <1> 
   219                              <1> .dumpDebugRegs:
   220 00002651 48BD-               <1>     mov rbp, .crlf
   220 00002653 [A231000000000000]  <1>
   221 0000265B 66B80413            <1>     mov ax, 1304h
   222 0000265F 30FF                <1>     xor bh, bh
   223 00002661 CD30                <1>     int 30h
   224 00002663 4831ED              <1>     xor rbp, rbp
   225 00002666 4831FF              <1>     xor rdi, rdi
   226                              <1> 
   227 00002669 0F21F8              <1>     mov rax, dr7
   228 0000266C 50                  <1>     push rax
   229 0000266D 0F21F0              <1>     mov rax, dr6
   230 00002670 50                  <1>     push rax
   231 00002671 0F21D8              <1>     mov rax, dr3
   232 00002674 50                  <1>     push rax
   233 00002675 0F21D0              <1>     mov rax, dr2
   234 00002678 50                  <1>     push rax
   235 00002679 0F21C8              <1>     mov rax, dr1
   236 0000267C 50                  <1>     push rax
   237 0000267D 0F21C0              <1>     mov rax, dr0
   238 00002680 50                  <1>     push rax
   239                              <1> 
   240                              <1> .ddr1:
   241 00002681 4831C9              <1>     xor rcx, rcx
   242 00002684 4881FF03000000      <1>     cmp rdi, 3      ;3 registers per row
   243 0000268B 7450                <1>     je .dregcrlf
   244                              <1> .ddr11:
   245 0000268D 8A840D[03270000]    <1>     mov al, byte [.dregtbl + rbp + rcx]
   246 00002694 B40E                <1>     mov ah, 0Eh
   247 00002696 CD30                <1>     int 30h
   248 00002698 66FFC1              <1>     inc cx
   249 0000269B 6681F90400          <1>     cmp cx, 4
   250 000026A0 75EB                <1>     jnz .ddr11
   251                              <1> 
   252 000026A2 48B908000000000000- <1>     mov rcx, 8
   252 000026AB 00                  <1>
   253                              <1> .ddr2:
   254 000026AC 5B                  <1>     pop rbx    ;Get debug register
   255 000026AD 480FCB              <1>     bswap rbx
   256                              <1> .ddr21:
   257 000026B0 B404                <1>     mov ah, 04h
   258 000026B2 88D8                <1>     mov al, bl
   259 000026B4 CD30                <1>     int 30h
   260 000026B6 48C1EB08            <1>     shr rbx, 8h
   261 000026BA FEC9                <1>     dec cl
   262 000026BC 75F2                <1>     jnz .ddr21
   263 000026BE 48FFC7              <1>     inc rdi
   264                              <1> 
   265 000026C1 B403                <1>     mov ah, 3
   266 000026C3 CD30                <1>     int 30h
   267 000026C5 80C203              <1>     add dl, 3
   268 000026C8 B402                <1>     mov ah, 2
   269 000026CA CD30                <1>     int 30h
   270 000026CC 4881C504000000      <1>     add rbp, 4
   271 000026D3 4881FD18000000      <1>     cmp rbp, 24 ;number of chars in the below typed string
   272 000026DA 72A5                <1>     jb .ddr1
   273                              <1> 
   274 000026DC C3                  <1>     ret
   275                              <1> .dregcrlf:
   276 000026DD 4831FF              <1>     xor rdi, rdi
   277 000026E0 55                  <1>     push rbp
   278 000026E1 50                  <1>     push rax
   279 000026E2 53                  <1>     push rbx
   280 000026E3 48BD-               <1>     mov rbp, .crlf
   280 000026E5 [A231000000000000]  <1>
   281 000026ED 48B804130000000000- <1>     mov rax, 1304h
   281 000026F6 00                  <1>
   282 000026F7 30FF                <1>     xor bh, bh
   283 000026F9 CD30                <1>     int 30h
   284 000026FB 5B                  <1>     pop rbx
   285 000026FC 58                  <1>     pop rax
   286 000026FD 5D                  <1>     pop rbp
   287 000026FE E98AFFFFFF          <1>     jmp .ddr11
   288 00002703 4452303D4452313D44- <1> .dregtbl db "DR0=", "DR1=", "DR2=", "DR3=", "DR6=", "DR7="
   288 0000270C 52323D4452333D4452- <1>
   288 00002715 363D4452373D        <1>
   289                              <1> 
   290                              <1> .xchangeReg:
   291 0000271B E89F020000          <1>     call .dumpReg
   292 00002720 66B80413            <1>     mov ax, 1304h
   293 00002724 48BD-               <1>     mov rbp, .crlf    ;Newline
   293 00002726 [A231000000000000]  <1>
   294 0000272E CD30                <1>     int 30h
   295                              <1> 
   296 00002730 66B82E0E            <1>     mov ax, 0E2Eh    ;Print dot byte
   297 00002734 CD30                <1>     int 30h
   298                              <1> 
   299 00002736 66B80101            <1>     mov ax, 0101h    ;Process one byte
   300 0000273A E891090000          <1>     call .keyb
   301 0000273F 4885ED              <1>     test rbp, rbp
   302 00002742 0F846FFCFFFF        <1>     jz .z11    ;If enter pressed, return to command line
   303 00002748 E823090000          <1>     call .arg
   304 0000274D 3C01                <1>     cmp al, 1
   305 0000274F 0F853D060000        <1>     jne .dmbadexit
   306                              <1> 
   307 00002755 488B7D00            <1>     mov rdi, qword [rbp]    ;move this byte into rdi
   308 00002759 4881FF11000000      <1>     cmp rdi, 11h
   309 00002760 0F8744FDFFFF        <1>     ja .bad_command    ;If the user chooses a value greater than 11, exit!
   310                              <1> 
   311 00002766 48BD-               <1>     mov rbp, .crlf
   311 00002768 [A231000000000000]  <1>
   312 00002770 66B80413            <1>     mov ax, 1304h
   313 00002774 30FF                <1>     xor bh, bh
   314 00002776 CD30                <1>     int 30h
   315                              <1> 
   316 00002778 4881FF11000000      <1>     cmp rdi, 11h
   317 0000277F 7467                <1>     je .xcflags ;If the user typed 10, then xchange flags
   318                              <1> 
   319 00002781 57                  <1>     push rdi    ;Save rdi
   320 00002782 48C1E702            <1>     shl rdi, 2    ;Multiply by 4
   321 00002786 66B90400            <1>     mov cx, 4    ;4 chars to print
   322                              <1> .xcr1:
   323 0000278A 8A87[DA2B0000]      <1>     mov al, byte [.regtbl + rdi]
   324 00002790 B40E                <1>     mov ah, 0Eh
   325 00002792 CD30                <1>     int 30h
   326 00002794 66FFC7              <1>     inc di
   327 00002797 66FFC9              <1>     dec cx
   328 0000279A 75EE                <1>     jnz .xcr1
   329                              <1> 
   330 0000279C 5F                  <1>     pop rdi
   331 0000279D 66B80104            <1>     mov ax, 0401h    ;Process one qword
   332 000027A1 E82A090000          <1>     call .keyb
   333 000027A6 4885ED              <1>     test rbp, rbp
   334 000027A9 7433                <1>     jz .xcnoexit
   335 000027AB E8C0080000          <1>     call .arg
   336 000027B0 3C01                <1>     cmp al, 1
   337 000027B2 0F85DA050000        <1>     jne .dmbadexit
   338                              <1> 
   339 000027B8 488B4500            <1>     mov rax, qword [rbp]
   340 000027BC 4881FF10000000      <1>     cmp rdi, 10h
   341 000027C3 741A                <1>     je .xcipchange
   342 000027C5 488B1C25[EC010000]  <1>     mov rbx, qword [mcpUserBase]
   343 000027CD 4881C380000000      <1>     add rbx, 80h
   344 000027D4 48C1E703            <1>     shl rdi, 3  ;Multiply by 8
   345 000027D8 4829FB              <1>     sub rbx, rdi
   346 000027DB 488903              <1>     mov qword [rbx], rax    ;Replace element with rax
   347                              <1> .xcnoexit:
   348 000027DE C3                  <1>     ret
   349                              <1> .xcipchange:
   350 000027DF 48890425[F4010000]  <1>     mov qword [mcpUserRip], rax
   351 000027E7 C3                  <1>     ret
   352                              <1> .xcflags:
   353 000027E8 48B907000000000000- <1>     mov rcx, 7
   353 000027F1 00                  <1>
   354 000027F2 4831FF              <1>     xor rdi, rdi
   355                              <1> .xcf1:
   356 000027F5 8A87[302C0000]      <1>     mov al, byte [.rflgs + rdi]
   357 000027FB B40E                <1>     mov ah, 0Eh
   358 000027FD CD30                <1>     int 30h
   359 000027FF 66FFC7              <1>     inc di
   360 00002802 66FFC9              <1>     dec cx
   361 00002805 75EE                <1>     jnz .xcf1
   362                              <1> 
   363 00002807 66B80104            <1>     mov ax, 0401h    ;Process one qword
   364 0000280B E8C0080000          <1>     call .keyb
   365 00002810 4885ED              <1>     test rbp, rbp
   366 00002813 74C9                <1>     jz .xcnoexit
   367 00002815 E856080000          <1>     call .arg
   368 0000281A 3C01                <1>     cmp al, 1
   369 0000281C 0F8570050000        <1>     jne .dmbadexit
   370 00002822 488B4500            <1>     mov rax, qword [rbp]
   371 00002826 488B2C25[EC010000]  <1>     mov rbp, qword [mcpUserBase]
   372 0000282E 48894500            <1>     mov qword [rbp], rax
   373 00002832 C3                  <1>     ret
   374                              <1> .inport:
   375 00002833 66B80413            <1>     mov ax, 1304h
   376 00002837 30FF                <1>     xor bh, bh
   377 00002839 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   377 0000283B [A031000000000000]  <1>
   378 00002843 CD30                <1>     int 30h
   379                              <1> 
   380 00002845 66B80101            <1>     mov ax, 0101h    ;Get 1 byte
   381 00002849 E882080000          <1>     call .keyb
   382 0000284E 4885ED              <1>     test rbp, rbp
   383 00002851 0F8453FCFFFF        <1>     jz .bad_command
   384 00002857 E814080000          <1>     call .arg
   385 0000285C 3C01                <1>     cmp al, 1
   386 0000285E 0F852E050000        <1>     jne .dmbadexit
   387 00002864 488B5500            <1>     mov rdx, qword [rbp]    ;First arg, word io addr
   388 00002868 48BD-               <1>     mov rbp, .crlf
   388 0000286A [A231000000000000]  <1>
   389 00002872 48B804130000000000- <1>     mov rax, 1304h
   389 0000287B 00                  <1>
   390 0000287C 30FF                <1>     xor bh, bh
   391 0000287E CD30                <1>     int 30h
   392 00002880 EC                  <1>     in al, dx
   393 00002881 B404                <1>     mov ah, 04h
   394 00002883 CD30                <1>     int 30h
   395 00002885 C3                  <1>     ret
   396                              <1> 
   397                              <1> .outport:
   398 00002886 66B80413            <1>     mov ax, 1304h
   399 0000288A 48BB07000000000000- <1>     mov rbx, 7h
   399 00002893 00                  <1>
   400 00002894 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   400 00002896 [A031000000000000]  <1>
   401 0000289E CD30                <1>     int 30h
   402 000028A0 66B80102            <1>     mov ax, 0201h    ;Get 1 word
   403 000028A4 E827080000          <1>     call .keyb
   404 000028A9 4885ED              <1>     test rbp, rbp
   405 000028AC 0F84F8FBFFFF        <1>     jz .bad_command
   406 000028B2 E8B9070000          <1>     call .arg
   407 000028B7 3C01                <1>     cmp al, 1
   408 000028B9 0F85D3040000        <1>     jne .dmbadexit
   409 000028BF 488B5500            <1>     mov rdx, qword [rbp]    ;First arg, word io addr
   410 000028C3 B02E                <1>     mov al, "."
   411 000028C5 E8A7080000          <1>     call .print
   412 000028CA 66B80101            <1>     mov ax, 0101h    ;Get 1 byte
   413 000028CE E8FD070000          <1>     call .keyb
   414 000028D3 4885ED              <1>     test rbp, rbp
   415 000028D6 0F84CEFBFFFF        <1>     jz .bad_command
   416 000028DC E88F070000          <1>     call .arg
   417 000028E1 3C01                <1>     cmp al, 1
   418 000028E3 0F85A9040000        <1>     jne .dmbadexit
   419 000028E9 488B4500            <1>     mov rax, qword [rbp]
   420 000028ED EE                  <1>     out dx, al
   421 000028EE C3                  <1>     ret
   422                              <1> 
   423                              <1> .hexCalc:
   424 000028EF 66B80413            <1>     mov ax, 1304h
   425 000028F3 30FF                <1>     xor bh, bh
   426 000028F5 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   426 000028F7 [A031000000000000]  <1>
   427 000028FF CD30                <1>     int 30h
   428 00002901 66B80204            <1>     mov ax, 0402h    ;Get 2 qwords
   429 00002905 E8C6070000          <1>     call .keyb
   430 0000290A 4885ED              <1>     test rbp, rbp
   431 0000290D 0F8497FBFFFF        <1>     jz .bad_command
   432 00002913 E858070000          <1>     call .arg
   433                              <1> 
   434 00002918 3C02                <1>     cmp al, 2
   435 0000291A 0F8572040000        <1>     jne .dmbadexit
   436                              <1> 
   437 00002920 4C8B4508            <1>     mov r8, qword [rbp + 8] ;First number 
   438 00002924 4C8B4D00            <1>     mov r9, qword [rbp]        ;Second number
   439 00002928 4F8D1408            <1>     lea r10, qword [r8+r9]
   440                              <1> 
   441 0000292C 48BD-               <1>     mov rbp, .crlf
   441 0000292E [A231000000000000]  <1>
   442 00002936 48B804130000000000- <1>     mov rax, 1304h
   442 0000293F 00                  <1>
   443 00002940 30FF                <1>     xor bh, bh
   444 00002942 CD30                <1>     int 30h
   445                              <1> 
   446 00002944 4C89C2              <1>     mov rdx, r8
   447 00002947 E856000000          <1>     call .hcprintquad
   448 0000294C B02B                <1>     mov al, "+"
   449 0000294E E81E080000          <1>     call .print
   450 00002953 4C89CA              <1>     mov rdx, r9
   451 00002956 E847000000          <1>     call .hcprintquad
   452 0000295B B03D                <1>     mov al, "="
   453 0000295D E80F080000          <1>     call .print
   454 00002962 4C89D2              <1>     mov rdx, r10
   455 00002965 E838000000          <1>     call .hcprintquad
   456                              <1> 
   457 0000296A 48B804130000000000- <1>     mov rax, 1304h
   457 00002973 00                  <1>
   458 00002974 30FF                <1>     xor bh, bh
   459 00002976 CD30                <1>     int 30h
   460                              <1> 
   461 00002978 4C89C2              <1>     mov rdx, r8
   462 0000297B E822000000          <1>     call .hcprintquad
   463 00002980 B02D                <1>     mov al, "-"
   464 00002982 E8EA070000          <1>     call .print
   465 00002987 4C89CA              <1>     mov rdx, r9
   466 0000298A E813000000          <1>     call .hcprintquad
   467 0000298F B03D                <1>     mov al, "="
   468 00002991 E8DB070000          <1>     call .print
   469 00002996 4D29C8              <1>     sub r8, r9
   470 00002999 4C89C2              <1>     mov rdx, r8
   471 0000299C E801000000          <1>     call .hcprintquad
   472 000029A1 C3                  <1>     ret
   473                              <1> 
   474                              <1> .hcprintquad:
   475                              <1> ;Takes whats in rdx, and prints it
   476 000029A2 480FCA              <1>     bswap rdx
   477 000029A5 48B908000000000000- <1>     mov rcx, 8
   477 000029AE 00                  <1>
   478                              <1> .hcpq1:
   479 000029AF 88D0                <1>     mov al, dl
   480 000029B1 B404                <1>     mov ah, 04h
   481 000029B3 CD30                <1>     int 30h
   482 000029B5 48C1EA08            <1>     shr rdx, 8
   483 000029B9 66FFC9              <1>     dec cx
   484 000029BC 75F1                <1>     jnz .hcpq1
   485 000029BE C3                  <1>     ret
   486                              <1> 
   487                              <1> .dumpReg:
   488 000029BF 48BD-               <1>     mov rbp, .crlf
   488 000029C1 [A231000000000000]  <1>
   489 000029C9 66B80413            <1>     mov ax, 1304h
   490 000029CD 30FF                <1>     xor bh, bh
   491 000029CF CD30                <1>     int 30h
   492 000029D1 4831ED              <1>     xor rbp, rbp
   493 000029D4 4831FF              <1>     xor rdi, rdi
   494 000029D7 4831F6              <1>     xor rsi, rsi
   495 000029DA 488B3425[EC010000]  <1>     mov rsi, qword [mcpUserBase]
   496 000029E2 4881C680000000      <1>     add rsi, 80h
   497                              <1> .dreg1:
   498 000029E9 4831C9              <1>     xor rcx, rcx
   499 000029EC 4881FF03000000      <1>     cmp rdi, 3
   500 000029F3 0F84BB010000        <1>     je .regcrlf
   501                              <1> .dreg11:    ;Print register name
   502 000029F9 8A840D[DA2B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   503 00002A00 B40E                <1>     mov ah, 0Eh
   504 00002A02 CD30                <1>     int 30h
   505 00002A04 66FFC1              <1>     inc cx
   506 00002A07 6681F90400          <1>     cmp cx, 4h
   507 00002A0C 75EB                <1>     jnz .dreg11
   508                              <1> .dreg2:
   509 00002A0E 48B908000000000000- <1>     mov rcx, 8h
   509 00002A17 00                  <1>
   510                              <1> ;Now print register value
   511 00002A18 488B1E              <1>     mov rbx, qword [rsi]    ;Get qword from storage
   512 00002A1B 81EE08000000        <1>     sub esi, 8
   513 00002A21 480FCB              <1>     bswap rbx    ;Change endianness
   514                              <1> .dreg21:
   515 00002A24 B404                <1>     mov ah, 04h
   516 00002A26 88D8                <1>     mov al, bl
   517 00002A28 CD30                <1>     int 30h
   518 00002A2A 48C1EB08            <1>     shr rbx, 8h    ;Shift down by a byte
   519 00002A2E FEC9                <1>     dec cl
   520 00002A30 75F2                <1>     jnz .dreg21
   521 00002A32 48FFC7              <1>     inc rdi
   522                              <1> 
   523 00002A35 B403                <1>     mov ah, 3
   524 00002A37 CD30                <1>     int 30h
   525 00002A39 80C203              <1>     add dl, 3
   526 00002A3C B402                <1>     mov ah, 2
   527 00002A3E CD30                <1>     int 30h
   528 00002A40 4881C504000000      <1>     add rbp, 4
   529 00002A47 4881FD40000000      <1>     cmp rbp, 40h
   530 00002A4E 7299                <1>     jb .dreg1
   531                              <1> 
   532                              <1> ;Print RIP
   533                              <1> .drip0:
   534 00002A50 4831C9              <1>     xor rcx, rcx
   535                              <1> .drip1:
   536                              <1> ;Print name
   537 00002A53 8A840D[DA2B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   538 00002A5A B40E                <1>     mov ah, 0Eh
   539 00002A5C CD30                <1>     int 30h
   540 00002A5E 66FFC1              <1>     inc cx
   541 00002A61 6681F90400          <1>     cmp cx, 4h
   542 00002A66 75EB                <1>     jne .drip1
   543                              <1> 
   544 00002A68 48B908000000000000- <1>     mov rcx, 8
   544 00002A71 00                  <1>
   545 00002A72 488B3425[F4010000]  <1>     mov rsi, qword [mcpUserRip]
   546 00002A7A 480FCE              <1>     bswap rsi
   547                              <1> .drip2:
   548                              <1> ;Print value
   549 00002A7D B404                <1>     mov ah, 04h
   550 00002A7F 4088F0              <1>     mov al, sil
   551 00002A82 CD30                <1>     int 30h
   552 00002A84 48C1EE08            <1>     shr rsi, 8h    ;Shift down by a byte
   553 00002A88 FEC9                <1>     dec cl
   554 00002A8A 75F1                <1>     jnz .drip2
   555 00002A8C 4881C504000000      <1>     add rbp, 4    ;Offset into table
   556                              <1> 
   557 00002A93 55                  <1>     push rbp
   558 00002A94 48BD-               <1>     mov rbp, .ipstrg
   558 00002A96 [372C000000000000]  <1>
   559 00002A9E 66B80413            <1>     mov ax, 1304h
   560 00002AA2 CD30                <1>     int 30h    
   561 00002AA4 B107                <1>     mov cl, 7
   562 00002AA6 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   563 00002AAE 488B4008            <1>     mov rax, qword [rax + 08h]  ;Get the old stack pointer
   564 00002AB2 488B18              <1>     mov rbx, qword [rax]    ;Get the address of 8 bytes at that instruction
   565 00002AB5 488B1B              <1>     mov rbx, qword [rbx]    ;Get the bytes
   566 00002AB8 88D8                <1>     mov al, bl
   567 00002ABA B404                <1>     mov ah, 04h
   568 00002ABC CD30                <1>     int 30h
   569 00002ABE 48C1EB08            <1>     shr rbx, 8
   570 00002AC2 B40E                <1>     mov ah, 0Eh   ;Add a space to indicate mod r/m + optionals
   571 00002AC4 B02D                <1>     mov al, '-'
   572 00002AC6 CD30                <1>     int 30h
   573                              <1> .ssep0:
   574 00002AC8 88D8                <1>     mov al, bl
   575 00002ACA B404                <1>     mov ah, 04h
   576 00002ACC CD30                <1>     int 30h
   577 00002ACE 48C1EB08            <1>     shr rbx, 8
   578 00002AD2 FEC9                <1>     dec cl
   579 00002AD4 75F2                <1>     jnz .ssep0
   580                              <1> 
   581 00002AD6 48BD-               <1>     mov rbp, .crlf
   581 00002AD8 [A231000000000000]  <1>
   582 00002AE0 48B804130000000000- <1>     mov rax, 1304h
   582 00002AE9 00                  <1>
   583 00002AEA 48BB07000000000000- <1>     mov rbx, 7h
   583 00002AF3 00                  <1>
   584 00002AF4 CD30                <1>     int 30h
   585 00002AF6 5D                  <1>     pop rbp
   586                              <1> 
   587 00002AF7 668CC8              <1>     mov ax, cs
   588 00002AFA E87D000000          <1>     call .dsegregwrite
   589 00002AFF 668CD8              <1>     mov ax, ds
   590 00002B02 E875000000          <1>     call .dsegregwrite
   591 00002B07 668CC0              <1>     mov ax, es
   592 00002B0A E86D000000          <1>     call .dsegregwrite
   593 00002B0F 668CD0              <1>     mov ax, ss
   594 00002B12 E865000000          <1>     call .dsegregwrite
   595 00002B17 668CE0              <1>     mov ax, fs
   596 00002B1A E85D000000          <1>     call .dsegregwrite
   597 00002B1F 668CE8              <1>     mov ax, gs
   598 00002B22 E855000000          <1>     call .dsegregwrite
   599                              <1> 
   600 00002B27 55                  <1>     push rbp
   601 00002B28 48BD-               <1>     mov rbp, .crlf
   601 00002B2A [A231000000000000]  <1>
   602 00002B32 48B804130000000000- <1>     mov rax, 1304h
   602 00002B3B 00                  <1>
   603 00002B3C 30FF                <1>     xor bh, bh
   604 00002B3E CD30                <1>     int 30h
   605 00002B40 5D                  <1>     pop rbp
   606                              <1> .drflagwrite:
   607 00002B41 4831C9              <1>     xor rcx, rcx
   608                              <1> .drflg1:    ;Print register name
   609 00002B44 8A840D[DA2B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   610 00002B4B B40E                <1>     mov ah, 0Eh
   611 00002B4D CD30                <1>     int 30h
   612 00002B4F 48FFC1              <1>     inc rcx
   613 00002B52 4881F907000000      <1>     cmp rcx, 7
   614 00002B59 75E9                <1>     jnz .drflg1
   615                              <1> 
   616 00002B5B 48FFC1              <1>     inc rcx
   617 00002B5E 488B1425[EC010000]  <1>     mov rdx, qword [mcpUserBase]    ;Get flags into rdx
   618 00002B66 488B12              <1>     mov rdx, qword [rdx]
   619 00002B69 480FCA              <1>     bswap rdx
   620                              <1> .drflg2:
   621 00002B6C B404                <1>     mov ah, 04h
   622 00002B6E 88D0                <1>     mov al, dl
   623 00002B70 CD30                <1>     int 30h
   624 00002B72 48C1EA08            <1>     shr rdx, 8
   625 00002B76 48FFC9              <1>     dec rcx
   626 00002B79 75F1                <1>     jnz .drflg2
   627                              <1> 
   628                              <1> .dregexit:
   629 00002B7B C3                  <1>     ret
   630                              <1> .dsegregwrite:
   631 00002B7C 4831C9              <1>     xor rcx, rcx
   632 00002B7F 6689C2              <1>     mov dx, ax    ;save
   633                              <1> .dsegreg1:    ;Print register name
   634 00002B82 8A840D[DA2B0000]    <1>     mov al, byte [.regtbl+rbp+rcx]
   635                              <1>     ;xor bh, bh
   636 00002B89 B40E                <1>     mov ah, 0Eh
   637 00002B8B CD30                <1>     int 30h
   638 00002B8D 48FFC1              <1>     inc rcx
   639 00002B90 4881F903000000      <1>     cmp rcx, 3
   640 00002B97 75E9                <1>     jnz .dsegreg1
   641                              <1> 
   642 00002B99 88F0                <1>     mov al, dh
   643 00002B9B B404                <1>     mov ah, 04h
   644 00002B9D CD30                <1>     int 30h
   645 00002B9F 88D0                <1>     mov al, dl
   646 00002BA1 B404                <1>     mov ah, 04h
   647 00002BA3 CD30                <1>     int 30h
   648                              <1> 
   649 00002BA5 4801CD              <1>     add rbp, rcx
   650 00002BA8 B403                <1>     mov ah, 3
   651 00002BAA CD30                <1>     int 30h
   652 00002BAC 80C202              <1>     add dl, 2
   653 00002BAF B402                <1>     mov ah, 2
   654 00002BB1 CD30                <1>     int 30h
   655 00002BB3 C3                  <1>     ret
   656                              <1> 
   657                              <1> .regcrlf:
   658 00002BB4 4831FF              <1>     xor rdi, rdi
   659 00002BB7 55                  <1>     push rbp
   660 00002BB8 50                  <1>     push rax
   661 00002BB9 53                  <1>     push rbx
   662 00002BBA 48BD-               <1>     mov rbp, .crlf
   662 00002BBC [A231000000000000]  <1>
   663 00002BC4 48B804130000000000- <1>     mov rax, 1304h
   663 00002BCD 00                  <1>
   664 00002BCE 30FF                <1>     xor bh, bh
   665 00002BD0 CD30                <1>     int 30h
   666 00002BD2 5B                  <1>     pop rbx
   667 00002BD3 58                  <1>     pop rax
   668 00002BD4 5D                  <1>     pop rbp
   669 00002BD5 E91FFEFFFF          <1>     jmp .dreg11
   670                              <1> 
   671 00002BDA 5241583D5242583D52- <1> .regtbl  db "RAX=", "RBX=", "RCX=", "RDX=", "RSI=", "RDI=", "R8 =",
   671 00002BE3 43583D5244583D5253- <1>
   671 00002BEC 493D5244493D523820- <1>
   671 00002BF5 3D                  <1>
   672 00002BF6 5239203D5231303D52- <1>          db "R9 =", "R10=", "R11=", "R12=", "R13=", "R14=", "R15=",
   672 00002BFF 31313D5231323D5231- <1>
   672 00002C08 333D5231343D523135- <1>
   672 00002C11 3D                  <1>
   673 00002C12 5242503D5253503D52- <1>          db "RBP=", "RSP=", "RIP=","CS=", "DS=", "ES=", "SS=", "FS=", 
   673 00002C1B 49503D43533D44533D- <1>
   673 00002C24 45533D53533D46533D  <1>
   674 00002C2D 47533D              <1>          db "GS="
   675 00002C30 52464C4147533D      <1> .rflgs   db "RFLAGS="
   676 00002C37 20205B5249505D3D00  <1> .ipstrg: db "  [RIP]=",0
   677                              <1> .dumpMemory:
   678 00002C40 50                  <1>     push rax
   679 00002C41 53                  <1>     push rbx
   680 00002C42 51                  <1>     push rcx
   681 00002C43 52                  <1>     push rdx
   682 00002C44 57                  <1>     push rdi
   683 00002C45 56                  <1>     push rsi
   684 00002C46 55                  <1>     push rbp
   685 00002C47 4150                <1>     push r8
   686 00002C49 4151                <1>     push r9
   687                              <1> 
   688 00002C4B 66B80413            <1>     mov ax, 1304h
   689 00002C4F 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   689 00002C51 [A031000000000000]  <1>
   690 00002C59 CD30                <1>     int 30h
   691 00002C5B 66B80204            <1>     mov ax, 0402h    ;Get 2 dwords
   692 00002C5F E86C040000          <1>     call .keyb
   693 00002C64 4885ED              <1>     test rbp, rbp
   694 00002C67 0F8442010000        <1>     jz .dmnoargs
   695 00002C6D B002                <1>     mov al, 2    ;Number of user inputs to convert
   696 00002C6F E8FC030000          <1>     call .arg
   697 00002C74 FEC8                <1>     dec al
   698 00002C76 0F843D010000        <1>     jz .dmnoargs1
   699 00002C7C FEC8                <1>     dec al    ;More than 2 args, error
   700 00002C7E 0F850E010000        <1>     jnz .dmbadexit
   701 00002C84 4C8B4508            <1>     mov r8, qword [rbp + 8]    ;First argument, #Base
   702 00002C88 4C8B4D00            <1>     mov r9, qword [rbp]    ;Second argument, #Number of bytes
   703                              <1> .dmmain00:
   704 00002C8C 4D85C9              <1>     test r9, r9
   705 00002C8F 0F84FD000000        <1>     jz .dmbadexit
   706 00002C95 66B80413            <1>     mov ax, 1304h
   707 00002C99 48BD-               <1>     mov rbp, .crlf
   707 00002C9B [A231000000000000]  <1>
   708 00002CA3 CD30                <1>     int 30h
   709 00002CA5 4C89C2              <1>     mov rdx, r8
   710 00002CA8 E85C010000          <1>     call .dmcsaddrprint
   711 00002CAD 30FF                <1>     xor bh, bh
   712 00002CAF B403                <1>     mov ah, 03h
   713 00002CB1 CD30                <1>     int 30h
   714 00002CB3 B219                <1>     mov dl, 25
   715 00002CB5 B402                <1>     mov ah, 02h
   716 00002CB7 CD30                <1>     int 30h
   717 00002CB9 4C89C6              <1>     mov rsi, r8    ;point rsi at r8
   718 00002CBC 48F7C608000000      <1>     test rsi, 08h    ;If it starts between a qword and para
   719                              <1> 
   720 00002CC3 48F7C60F000000      <1>     test rsi, 0Fh
   721 00002CCA 7430                <1>     jz .dmmain0    ;If it starts on paragraph bndry, continue as normal
   722 00002CCC 56                  <1>     push rsi
   723 00002CCD 4881E60F000000      <1>     and rsi, 0Fh
   724 00002CD4 4881FE08000000      <1>     cmp rsi, 8
   725 00002CDB 720F                <1>     jb .dmmain01
   726 00002CDD 48B901000000000000- <1>     mov rcx, 1
   726 00002CE6 00                  <1>
   727 00002CE7 E8F9000000          <1>     call .dmal1    ;Print one space
   728                              <1> .dmmain01:
   729 00002CEC 5E                  <1>     pop rsi
   730 00002CED 48B801000000000000- <1>     mov rax, 1
   730 00002CF6 00                  <1>
   731 00002CF7 E8D0000000          <1>     call .dmalign
   732                              <1> 
   733                              <1> .dmmain0:
   734 00002CFC 4889F7              <1>     mov rdi, rsi    ;Save start point at rdi
   735 00002CFF 4151                <1>     push r9
   736                              <1> .dmmain1:    ;This loop prints a line
   737 00002D01 AC                  <1>     lodsb
   738 00002D02 B404                <1>     mov ah, 4h
   739 00002D04 CD30                <1>     int 30h
   740 00002D06 49FFC9              <1>     dec r9
   741 00002D09 7416                <1>     jz .dmmain2
   742 00002D0B 48F7C608000000      <1>     test rsi, 08h    ;This is zero iff rsi has bit 4 set
   743 00002D12 0F85D9000000        <1>     jnz .dmhyphen1
   744 00002D18 48F7C60F000000      <1>     test rsi, 0Fh    ;This is zero iff lower nybble is zero
   745 00002D1F 75E0                <1>     jnz .dmmain1
   746                              <1> .dmmain2:
   747                              <1> ;Now the numbers have been printed, get the ascii row too
   748                              <1> ;First check if numbers have stopped short of 16
   749 00002D21 4D85C9              <1>     test r9, r9
   750 00002D24 7500                <1>     jnz .dmmain21    ;end of row
   751                              <1> 
   752                              <1> .dmmain21:
   753 00002D26 4159                <1>     pop r9
   754 00002D28 30FF                <1>     xor bh, bh
   755 00002D2A B403                <1>     mov ah, 03h
   756 00002D2C CD30                <1>     int 30h
   757 00002D2E B23E                <1>     mov dl, 62
   758 00002D30 B402                <1>     mov ah, 02h
   759 00002D32 CD30                <1>     int 30h
   760 00002D34 4889FE              <1>     mov rsi, rdi    ;Reload value
   761 00002D37 48F7C60F000000      <1>     test rsi, 0Fh
   762 00002D3E 7408                <1>     jz .dmmain3    ;If it starts on paragraph bndry, continue as normal
   763 00002D40 4831C0              <1>     xor rax, rax    ;no shift
   764 00002D43 E884000000          <1>     call .dmalign
   765                              <1> 
   766                              <1> .dmmain3:
   767 00002D48 AC                  <1>     lodsb
   768 00002D49 49FFC9              <1>     dec r9
   769 00002D4C 3C30                <1>     cmp al, 30h
   770 00002D4E 660F420425-         <1>     cmovb ax, word [.dmdot]    ;bring the dot to ax
   770 00002D53 [302E0000]          <1>
   771 00002D57 B40E                <1>     mov ah, 0Eh
   772 00002D59 CD30                <1>     int 30h
   773 00002D5B 4D85C9              <1>     test r9, r9
   774 00002D5E 7443                <1>     jz .dmexit
   775 00002D60 48F7C60F000000      <1>     test rsi, 0Fh    ;Check if lower nybble is 0
   776 00002D67 75DF                <1>     jnz .dmmain3
   777                              <1> 
   778 00002D69 48BD-               <1>     mov rbp, .crlf
   778 00002D6B [A231000000000000]  <1>
   779 00002D73 66B80413            <1>     mov ax, 1304h
   780 00002D77 CD30                <1>     int 30h
   781                              <1> 
   782 00002D79 4889F2              <1>     mov rdx, rsi
   783 00002D7C E888000000          <1>     call .dmcsaddrprint
   784                              <1> 
   785 00002D81 B403                <1>     mov ah, 03h
   786 00002D83 30FF                <1>     xor bh, bh
   787 00002D85 CD30                <1>     int 30h
   788 00002D87 B219                <1>     mov dl, 25
   789 00002D89 B402                <1>     mov ah, 02h
   790 00002D8B CD30                <1>     int 30h
   791 00002D8D E96AFFFFFF          <1>     jmp .dmmain0
   792                              <1> 
   793                              <1> .dmbadexit:
   794 00002D92 48BD-               <1>     mov rbp, .dmbadargs
   794 00002D94 [322E000000000000]  <1>
   795 00002D9C 66B80413            <1>     mov ax, 1304h
   796 00002DA0 CD30                <1>     int 30h
   797 00002DA2 C3                  <1>     ret;Reload program, error!
   798                              <1> .dmexit:
   799 00002DA3 4159                <1>     pop r9
   800 00002DA5 4158                <1>     pop r8
   801 00002DA7 5D                  <1>     pop rbp
   802 00002DA8 5E                  <1>     pop rsi
   803 00002DA9 5F                  <1>     pop rdi
   804 00002DAA 5A                  <1>     pop rdx
   805 00002DAB 59                  <1>     pop rcx
   806 00002DAC 5B                  <1>     pop rbx
   807 00002DAD 58                  <1>     pop rax
   808 00002DAE C3                  <1>     ret
   809                              <1> .dmnoargs:
   810 00002DAF 4C8B0425[F4010000]  <1>     mov r8, qword [mcpUserRip]
   811                              <1>     ;add r8, 180h    ;Add 180 bytes, to bypass internal work areas
   812 00002DB7 EB04                <1>     jmp short .dmnoargscommon
   813                              <1> .dmnoargs1:
   814 00002DB9 4C8B4500            <1>     mov r8, qword [rbp]
   815                              <1> .dmnoargscommon:
   816 00002DBD 49B980000000000000- <1>     mov r9, 80h
   816 00002DC6 00                  <1>
   817 00002DC7 E9C0FEFFFF          <1>     jmp .dmmain00
   818                              <1> 
   819                              <1> .dmalign:    ;Print blank chars for offset
   820                              <1> ;Works out from rsi
   821                              <1> ;rax contains value for shl
   822 00002DCC 56                  <1>     push rsi
   823 00002DCD 4889F1              <1>     mov rcx, rsi
   824 00002DD0 4881E1F0FFFFFF      <1>     and rcx, 0FFFFFFFFFFFFFFF0h    ;Round down
   825 00002DD7 4829CE              <1>     sub rsi, rcx
   826 00002DDA 4887CE              <1>     xchg rcx, rsi
   827 00002DDD 5E                  <1>     pop rsi
   828 00002DDE 4891                <1>     xchg rcx, rax
   829 00002DE0 48D3E0              <1>     shl rax, cl
   830 00002DE3 4891                <1>     xchg rcx, rax
   831                              <1> .dmal1:
   832 00002DE5 66B8200E            <1>     mov ax, 0E20h
   833 00002DE9 CD30                <1>     int 30h
   834 00002DEB 48FFC9              <1>     dec rcx
   835 00002DEE 75F5                <1>     jnz .dmal1
   836 00002DF0 C3                  <1>     ret
   837                              <1> 
   838                              <1> .dmhyphen1:
   839 00002DF1 48F7C607000000      <1>     test rsi, 07h    ;If the rest of the bits are set, go away
   840 00002DF8 0F8503FFFFFF        <1>     jnz .dmmain1
   841 00002DFE 66B82D0E            <1>     mov ax, 0E2Dh    ;2dh="-"
   842 00002E02 CD30                <1>     int 30h
   843 00002E04 E9F8FEFFFF          <1>     jmp .dmmain1
   844                              <1> .dmcsaddrprint:
   845 00002E09 668CC8              <1>     mov ax, cs    ;Get current code segment into ax
   846 00002E0C 88E0                <1>     mov al, ah
   847 00002E0E B404                <1>     mov ah, 04h    ;print upper byte
   848 00002E10 CD30                <1>     int 30h
   849 00002E12 668CC8              <1>     mov ax, cs
   850 00002E15 B404                <1>     mov ah, 04h
   851 00002E17 CD30                <1>     int 30h        ;print lower byte
   852 00002E19 66B83A0E            <1>     mov ax, 0E3Ah
   853                              <1> 
   854 00002E1D B108                <1>     mov cl, 8
   855 00002E1F CD30                <1>     int 30h
   856                              <1> 
   857                              <1> .dmrollprint:
   858                              <1> ;Takes whats in rdx, rols left by one byte, prints al
   859                              <1> ;repeats, cl times.
   860 00002E21 48C1C208            <1>     rol rdx, 8
   861 00002E25 88D0                <1>     mov al, dl
   862 00002E27 B404                <1>     mov ah, 04h
   863 00002E29 CD30                <1>     int 30h
   864 00002E2B FEC9                <1>     dec cl
   865 00002E2D 75F2                <1>     jnz .dmrollprint
   866 00002E2F C3                  <1>     ret
   867 00002E30 2E00                <1> .dmdot:    db    ".",0
   868 00002E32 0A0D53796E74617820- <1> .dmbadargs:    db 0Ah, 0Dh,"Syntax error",0
   868 00002E3B 6572726F7200        <1>
   869                              <1> 
   870                              <1> .editMemory:
   871 00002E41 66B80413            <1>     mov ax, 1304h
   872 00002E45 30FF                <1>     xor bh, bh
   873 00002E47 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   873 00002E49 [A031000000000000]  <1>
   874 00002E51 CD30                <1>     int 30h
   875                              <1> 
   876 00002E53 66B80104            <1>     mov ax, 0401h    ;Get up to one qword
   877 00002E57 E874020000          <1>     call .keyb
   878 00002E5C 4885ED              <1>     test rbp, rbp        ;No chars entered?
   879 00002E5F 0F8445F6FFFF        <1>     jz .bad_command
   880 00002E65 E806020000          <1>     call .arg
   881 00002E6A 488B7D00            <1>     mov rdi, qword [rbp]    ;First arg, Dword Address 
   882                              <1> 
   883 00002E6E 48BD-               <1>     mov rbp, .crlf
   883 00002E70 [A231000000000000]  <1>
   884 00002E78 30FF                <1>     xor bh, bh
   885 00002E7A 48B804130000000000- <1>     mov rax, 1304h
   885 00002E83 00                  <1>
   886 00002E84 CD30                <1>     int 30h
   887                              <1>     
   888 00002E86 4889FE              <1>     mov rsi, rdi
   889 00002E89 AC                  <1>     lodsb    ;Get byte into al
   890 00002E8A B404                <1>     mov ah, 04
   891 00002E8C CD30                <1>     int 30h
   892 00002E8E B02E                <1>     mov al, "."
   893 00002E90 E8DC020000          <1>     call .print
   894 00002E95 66B80101            <1>     mov ax, 0101h    ;Get 1 byte
   895 00002E99 E832020000          <1>     call .keyb
   896 00002E9E 4885ED              <1>     test rbp, rbp        ;No chars entered?
   897 00002EA1 0F84EBFEFFFF        <1>     jz .dmbadexit
   898 00002EA7 E8C4010000          <1>     call .arg
   899 00002EAC 4889EE              <1>     mov rsi, rbp    ;Point rsi to the stack
   900 00002EAF A4                  <1>     movsb            ;Move byte from rsi to rdi
   901                              <1> 
   902 00002EB0 C3                  <1>     ret
   903                              <1> 
   904                              <1> .jumpProc:
   905 00002EB1 66B80413            <1>     mov ax, 1304h
   906 00002EB5 30FF                <1>     xor bh, bh
   907 00002EB7 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   907 00002EB9 [A031000000000000]  <1>
   908 00002EC1 CD30                <1>     int 30h
   909 00002EC3 66B80104            <1>     mov ax, 0401h    ;Get 1 dword (forbit going too high eh?)
   910 00002EC7 E804020000          <1>     call .keyb
   911 00002ECC 4885ED              <1>     test rbp, rbp        ;No chars entered?
   912 00002ECF 743B                <1>     jz .proceedDefault
   913 00002ED1 E89A010000          <1>     call .arg
   914 00002ED6 FEC8                <1>     dec al
   915 00002ED8 0F85B4FEFFFF        <1>     jnz .dmbadexit
   916 00002EDE 488B6D00            <1>     mov rbp, qword [rbp]    ;First argument, Address of procedure
   917 00002EE2 48892C25[F4010000]  <1>     mov qword [mcpUserRip], rbp   ;Move first argument into new Rip  
   918 00002EEA E81B010000          <1>     call .loadMainRegisters
   919 00002EEF 488B6008            <1>     mov rsp, qword [rax + 08h]
   920 00002EF3 488B0425[04020000]  <1>     mov rax, qword [mcpUserRaxStore]
   921 00002EFB 48CF                <1>     iretq
   922                              <1> .singleStep:
   923                              <1> ;When s is pressed, the program proceeds by a single step.
   924                              <1> ;Sets trap flag on
   925 00002EFD 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
   926 00002F05 48810800010000      <1>     or qword [rax + 00h], 100h  ;Set trap flag on
   927                              <1> .proceedDefault:
   928 00002F0C E8F9000000          <1>     call .loadMainRegisters
   929 00002F11 488B6008            <1>     mov rsp, qword [rax + 08h]
   930 00002F15 488B0425[04020000]  <1>     mov rax, qword [mcpUserRaxStore]
   931 00002F1D 48CF                <1>     iretq
   932                              <1> 
   933                              <1> .storageRead:
   934 00002F1F 50                  <1>     push rax
   935 00002F20 B800820000          <1>     mov eax, 8200h ;LBA Read function
   936 00002F25 EB06                <1>     jmp short .storageCommon
   937                              <1> .storageWrite:
   938 00002F27 50                  <1>     push rax
   939 00002F28 B800830000          <1>     mov eax, 8300h ;LBA Write function
   940                              <1> .storageCommon:
   941                              <1> ;l/w [Address Buffer] [Drive] [Sector] [Count]
   942 00002F2D 53                  <1>     push rbx
   943 00002F2E 51                  <1>     push rcx
   944 00002F2F 52                  <1>     push rdx
   945 00002F30 56                  <1>     push rsi
   946 00002F31 57                  <1>     push rdi
   947 00002F32 55                  <1>     push rbp
   948                              <1> 
   949 00002F33 89C6                <1>     mov esi, eax        ;Save LBA r/w function number in esi
   950 00002F35 66B80413            <1>     mov ax, 1304h
   951 00002F39 48BD-               <1>     mov rbp, .prompt2    ;Give the user the prompt
   951 00002F3B [A031000000000000]  <1>
   952 00002F43 CD30                <1>     int 30h
   953                              <1> 
   954 00002F45 66B80404            <1>     mov ax, 0404h    ;Get 4 qwords
   955 00002F49 E882010000          <1>     call .keyb
   956 00002F4E 4885ED              <1>     test rbp, rbp
   957 00002F51 7452                <1>     jz .storageError
   958 00002F53 B004                <1>     mov al, 4    ;Number of user inputs to convert
   959 00002F55 E816010000          <1>     call .arg
   960 00002F5A 3C04                <1>     cmp al, 4   ;If not 4 arguments, fail
   961 00002F5C 7547                <1>     jne .storageError
   962 00002F5E BF05000000          <1>     mov edi, 5
   963                              <1> .sc0:
   964 00002F63 89F0                <1>     mov eax, esi                ;Get back LBA r/w function number into eax
   965 00002F65 488B5D18            <1>     mov rbx, qword [rbp + 24]   ;First argument, Address buffer
   966 00002F69 488B5510            <1>     mov rdx, qword [rbp + 16]   ;dl ONLY, Second argument
   967 00002F6D 4881E2FF000000      <1>     and rdx, 0FFh
   968 00002F74 488B4D08            <1>     mov rcx, qword [rbp + 08]   ;LBA starting sector, third argument
   969 00002F78 488B7500            <1>     mov rsi, qword [rbp]        ;Sector count into rsi
   970 00002F7C 4881E6FF000000      <1>     and rsi, 0FFh               ;Sector count can be at most 255
   971 00002F83 09F0                <1>     or eax, esi                 ;Add the sector count to eax
   972 00002F85 89C6                <1>     mov esi, eax                ;Copy the function number into esi for failures
   973 00002F87 81E600FF0000        <1>     and esi, 0FF00h             ;Save only byte two of esi, the function number
   974 00002F8D CD33                <1>     int 33h
   975 00002F8F 7308                <1>     jnc .storageExit
   976                              <1> 
   977 00002F91 31C0                <1>     xor eax, eax
   978 00002F93 CD33                <1>     int 33h
   979 00002F95 FFCF                <1>     dec edi
   980 00002F97 75CA                <1>     jnz .sc0
   981                              <1> .storageExit:
   982 00002F99 5D                  <1>     pop rbp
   983 00002F9A 5F                  <1>     pop rdi
   984 00002F9B 5E                  <1>     pop rsi
   985 00002F9C 5A                  <1>     pop rdx
   986 00002F9D 59                  <1>     pop rcx
   987 00002F9E 5B                  <1>     pop rbx
   988 00002F9F 58                  <1>     pop rax   
   989 00002FA0 E912F4FFFF          <1>     jmp MCP_int.z11
   990                              <1> .storageError: 
   991 00002FA5 5D                  <1>     pop rbp
   992 00002FA6 5F                  <1>     pop rdi
   993 00002FA7 5E                  <1>     pop rsi
   994 00002FA8 5A                  <1>     pop rdx
   995 00002FA9 59                  <1>     pop rcx
   996 00002FAA 5B                  <1>     pop rbx
   997 00002FAB 58                  <1>     pop rax
   998 00002FAC E9F9F4FFFF          <1>     jmp .bad_command
   999                              <1> .restartMcp:
  1000 00002FB1 CD40                <1>     int 40h     ;To allow returning to DOS
  1001                              <1> .clearscreen:
  1002 00002FB3 B307                <1>     mov bl, 07h
  1003 00002FB5 E83DD1FFFF          <1>     call cls
  1004 00002FBA E9F8F3FFFF          <1>     jmp MCP_int.z11
  1005                              <1> .storeMainRegisters:
  1006 00002FBF 9C                  <1>     pushfq
  1007 00002FC0 8F00                <1>     pop qword [rax + 00h]      ;Flags
  1008                              <1>     ;mov qword [rax + 08h], rsp
  1009 00002FC2 48896810            <1>     mov qword [rax + 10h], rbp
  1010 00002FC6 4C897818            <1>     mov qword [rax + 18h], r15
  1011 00002FCA 4C897020            <1>     mov qword [rax + 20h], r14
  1012 00002FCE 4C896828            <1>     mov qword [rax + 28h], r13
  1013 00002FD2 4C896030            <1>     mov qword [rax + 30h], r12
  1014 00002FD6 4C895838            <1>     mov qword [rax + 38h], r11
  1015 00002FDA 4C895040            <1>     mov qword [rax + 40h], r10
  1016 00002FDE 4C894848            <1>     mov qword [rax + 48h], r9
  1017 00002FE2 4C894050            <1>     mov qword [rax + 50h], r8
  1018 00002FE6 48897858            <1>     mov qword [rax + 58h], rdi
  1019 00002FEA 48897060            <1>     mov qword [rax + 60h], rsi
  1020 00002FEE 48895068            <1>     mov qword [rax + 68h], rdx
  1021 00002FF2 48894870            <1>     mov qword [rax + 70h], rcx
  1022 00002FF6 48895878            <1>     mov qword [rax + 78h], rbx
  1023 00002FFA 488B1C25[04020000]  <1>     mov rbx, qword [mcpUserRaxStore]
  1024 00003002 48899880000000      <1>     mov qword [rax + 80h], rbx  ;Store rax
  1025 00003009 C3                  <1>     ret
  1026                              <1> .loadMainRegisters:
  1027 0000300A 488B0425[EC010000]  <1>     mov rax, qword [mcpUserBase]
  1028 00003012 488B5008            <1>     mov rdx, qword [rax + 08h]  ;Get old stack pointer into rdx
  1029 00003016 488B1C25[F4010000]  <1>     mov rbx, qword [mcpUserRip]
  1030 0000301E 48891A              <1>     mov qword [rdx], rbx    ;Move the userRip into rdx
  1031 00003021 488B18              <1>     mov rbx, qword [rax + 00h]
  1032 00003024 48895A10            <1>     mov qword [rdx + 10h], rbx  ;Move new flags into position on stack
  1033 00003028 488B9880000000      <1>     mov rbx, qword [rax + 80h]  ;Get rax
  1034 0000302F 48891C25[04020000]  <1>     mov qword [mcpUserRaxStore], rbx
  1035 00003037 488B5878            <1>     mov rbx, qword [rax + 78h]
  1036 0000303B 488B4870            <1>     mov rcx, qword [rax + 70h]
  1037 0000303F 488B5068            <1>     mov rdx, qword [rax + 68h]
  1038 00003043 488B7060            <1>     mov rsi, qword [rax + 60h]
  1039 00003047 488B7858            <1>     mov rdi, qword [rax + 58h]
  1040 0000304B 4C8B4050            <1>     mov r8,  qword [rax + 50h]
  1041 0000304F 4C8B4848            <1>     mov r9,  qword [rax + 48h]
  1042 00003053 4C8B5040            <1>     mov r10, qword [rax + 40h]
  1043 00003057 4C8B5838            <1>     mov r11, qword [rax + 38h]
  1044 0000305B 4C8B6030            <1>     mov r12, qword [rax + 30h]
  1045 0000305F 4C8B6828            <1>     mov r13, qword [rax + 28h]
  1046 00003063 4C8B7020            <1>     mov r14, qword [rax + 20h]
  1047 00003067 4C8B7818            <1>     mov r15, qword [rax + 18h]
  1048 0000306B 488B6810            <1>     mov rbp, qword [rax + 10h]
  1049 0000306F C3                  <1>     ret
  1050                              <1> ;ARG    PROC    NEAR
  1051                              <1> .arg:
  1052                              <1> ;Number of arguments expected in buffer in al (could early terminate due to 
  1053                              <1> ; enter)
  1054                              <1> ;Converted qwords stored on stack with al indicating how many processed
  1055                              <1> ;rbp returns the base of the stack of stored arguments
  1056                              <1> ;rdx is our scratch register
  1057 00003070 53                  <1>     push rbx
  1058 00003071 51                  <1>     push rcx
  1059 00003072 52                  <1>     push rdx
  1060 00003073 56                  <1>     push rsi
  1061 00003074 4889E5              <1>     mov rbp, rsp    ;Preserve stack pointer
  1062 00003077 488B3425[FC010000]  <1>     mov rsi, qword [mcpUserkeybf]
  1063 0000307F 30C9                <1>     xor cl, cl        ;Keep track of how many arguments processed
  1064                              <1> .a01:
  1065 00003081 4831D2              <1>     xor rdx, rdx    ;Clean rdx
  1066                              <1> .a1:
  1067 00003084 AC                  <1>     lodsb        ;Get the first byte into al
  1068 00003085 3C11                <1>     cmp al, 11h    ;Offset 11h is the space key
  1069 00003087 740E                <1>     jz .a2
  1070 00003089 3C12                <1>     cmp al, 12h    ;Offset 12h is the enter key
  1071 0000308B 740F                <1>     jz .aexit        ;Anyway, enter is exit!
  1072 0000308D 48C1E204            <1>     shl rdx, 4    ;Go to next sig fig
  1073 00003091 08C2                <1>     or dl, al    ;Put this byte into dl
  1074 00003093 7013                <1>     jo .error
  1075 00003095 EBED                <1>     jmp short .a1
  1076                              <1> .a2:
  1077 00003097 52                  <1>     push rdx    ;Store argument on stack
  1078 00003098 FEC1                <1>     inc cl        ;One more argument processed
  1079 0000309A EBE5                <1>     jmp short .a01
  1080                              <1> .aexit:
  1081 0000309C 480FB6C1            <1>     movzx rax, cl    ;Return #of args processed
  1082 000030A0 4887E5              <1>     xchg rsp, rbp    ;rbp points to bottom of argument stack 
  1083 000030A3 5E                  <1>     pop rsi
  1084 000030A4 5A                  <1>     pop rdx
  1085 000030A5 59                  <1>     pop rcx
  1086 000030A6 5B                  <1>     pop rbx
  1087 000030A7 C3                  <1>     ret
  1088                              <1> .error:
  1089 000030A8 48BD-               <1>     mov rbp, .emsg
  1089 000030AA [BF30000000000000]  <1>
  1090 000030B2 30FF                <1>     xor bh, bh
  1091 000030B4 66B80413            <1>     mov ax, 1304h
  1092 000030B8 CD30                <1>     int 30h
  1093 000030BA 5E                  <1>     pop rsi
  1094 000030BB 5A                  <1>     pop rdx
  1095 000030BC 59                  <1>     pop rcx
  1096 000030BD 5B                  <1>     pop rbx
  1097 000030BE C3                  <1>     ret
  1098 000030BF 0A0D417267756D656E- <1> .emsg:    db 0Ah, 0Dh,"Argument error",0
  1098 000030C8 74206572726F7200    <1>
  1099                              <1> ;ARG    ENDP
  1100                              <1> 
  1101                              <1> ;KEYB     PROC     NEAR
  1102                              <1> .keyb:
  1103                              <1> ;Number of arguments to accept is passed in al, in units of ah
  1104                              <1> ;ah=4 => Qwords, ah=3 => dwords... ah=2 => word, ah=1 => bytes
  1105                              <1> ;Arguments are stored in buffer, after USB area, of size 2*al qwords
  1106                              <1> ;All arguments CAN be up to qword in size, though not all subprogs,
  1107                              <1> ;    may use the full qword.
  1108                              <1> ;ch returns number of chars not processed
  1109 000030D0 50                  <1>     push rax
  1110 000030D1 53                  <1>     push rbx
  1111                              <1>     ;push rcx
  1112 000030D2 57                  <1>     push rdi
  1113 000030D3 52                  <1>     push rdx
  1114                              <1> 
  1115 000030D4 4831C9              <1>     xor rcx, rcx
  1116 000030D7 88C1                <1>     mov cl, al
  1117 000030D9 51                  <1>     push rcx
  1118 000030DA 88E1                <1>     mov cl, ah
  1119 000030DC D2E0                <1>     shl al, cl  ;Multiply by 16 to get the number of bytes needed w/o spaces
  1120 000030DE 59                  <1>     pop rcx
  1121 000030DF 00C8                <1>     add al, cl  ;Add space for spaces
  1122 000030E1 FEC8                <1>     dec al      ;We reserve one space for a "non-user accessible" EOL at the end
  1123                              <1> 
  1124 000030E3 488B3C25[FC010000]  <1>     mov rdi, qword [mcpUserkeybf]    ;Data area in command tail
  1125 000030EB 50                  <1>     push rax
  1126 000030EC 48B810000000000000- <1>     mov rax, 10h
  1126 000030F5 00                  <1>
  1127 000030F6 57                  <1>     push rdi
  1128 000030F7 F348AB              <1>     rep stosq    ;Clear buffer space for al qwords (max 8)
  1129 000030FA 5F                  <1>     pop rdi
  1130 000030FB 58                  <1>     pop rax
  1131                              <1> 
  1132 000030FC 88C5                <1>     mov ch, al    ;Rememebr 1 Qword is 16 ASCII chars
  1133 000030FE 88C2                <1>     mov dl, al    ;Let dl save this number
  1134 00003100 4831ED              <1>     xor rbp, rbp    ;Cheap cop out char counter
  1135                              <1> 
  1136                              <1> .k1:
  1137 00003103 6631C0              <1>     xor ax, ax
  1138 00003106 CD36                <1>     int 36h
  1139 00003108 3C71                <1>     cmp al, "q"    ;Quit option
  1140 0000310A 0F84A7F2FFFF        <1>     je .z11
  1141 00003110 3C08                <1>     cmp al, 08h    ;Backspace
  1142 00003112 7447                <1>     je .kb2
  1143 00003114 3C0D                <1>     cmp al, 0Dh    ;Enter key pressed, we done
  1144 00003116 7438                <1>     je .kend
  1145                              <1> 
  1146 00003118 84ED                <1>     test ch, ch    ;Have we filled a 16 char buffer?
  1147 0000311A 74E7                <1>     jz .k1        ;Yes, await control key
  1148                              <1> 
  1149 0000311C 4889FB              <1>     mov rbx, rdi    ;Save current offset into bbuffer
  1150 0000311F 51                  <1>     push rcx
  1151 00003120 48BF-               <1>     mov rdi, .ascii
  1151 00003122 [7631000000000000]  <1>
  1152 0000312A 48B913000000000000- <1>     mov rcx, .asciil
  1152 00003133 00                  <1>
  1153 00003134 F2AE                <1>     repne scasb        ;Find the offset of the char in al in the table
  1154 00003136 59                  <1>     pop rcx            ;Doesnt affect flags
  1155 00003137 4887FB              <1>     xchg rdi, rbx    ;Return value back to rdi 
  1156 0000313A 75C7                <1>     jne .k1            ;Not a key from our buffer, loop again
  1157 0000313C 48FFC5              <1>     inc rbp
  1158 0000313F E82D000000          <1>     call .print        ;Print typed char
  1159                              <1> 
  1160 00003144 488D83(89CEFFFF)    <1>     lea rax, qword [rbx - .ascii -1]    ;Work out difference
  1161                              <1> 
  1162 0000314B AA                  <1>     stosb            ;Store the value in storage buffer, inc rdi
  1163 0000314C FECD                <1>     dec ch            ;Decrement the number of typable chars
  1164 0000314E EBB3                <1>     jmp short .k1    ;Get next char
  1165                              <1> .kend:
  1166 00003150 66B81112            <1>     mov ax, 1211h    ;Store a space and EOF at the end (little endian!)
  1167 00003154 66AB                <1>     stosw
  1168                              <1> 
  1169 00003156 5A                  <1>     pop rdx
  1170 00003157 5F                  <1>     pop rdi
  1171                              <1>     ;pop rcx    ;Return in cl the number of processed chars
  1172 00003158 5B                  <1>     pop rbx
  1173 00003159 58                  <1>     pop rax
  1174                              <1> .kb1:        
  1175 0000315A C3                  <1>     ret
  1176                              <1> .kb2:
  1177                              <1> ;When a backspace is entered, DONT MOVE THIS PROC!
  1178 0000315B 68[03310000]        <1>     push .k1
  1179 00003160 38D5                <1>     cmp ch, dl    ;If bbuf is empty, ignore backspace 
  1180 00003162 74F6                <1>     jz .kb1
  1181 00003164 48FFCF              <1>     dec rdi        ;Decrement pointer and print the bspace char
  1182 00003167 FEC5                <1>     inc ch        ;Increment the number of typable chars
  1183 00003169 4885ED              <1>     test rbp, rbp
  1184 0000316C 7403                <1>     jz .print    ;Dont decrement if rbp is zero
  1185 0000316E 48FFCD              <1>     dec rbp
  1186                              <1> ;KEYB    ENDP
  1187                              <1> .print:    ;Print char in al
  1188 00003171 B40E                <1>     mov ah, 0Eh
  1189                              <1>     ;xor bh, bh
  1190 00003173 CD30                <1>     int 30h
  1191 00003175 C3                  <1>     ret
  1192 00003176 303132333435363738- <1> .ascii       db    "0123456789abcdef", 08h, 20h, 0Dh ;b/space, enter
  1192 0000317F 396162636465660820- <1>
  1192 00003188 0D                  <1>
  1193                              <1> .asciil       equ    $ - .ascii
  1194 00003189 64657367706C777163- <1> .lst       db    'desgplwqcrbhiovamkx';dump,edit,go,single step,read,write,quit,
  1194 00003192 726268696F76616D6B- <1>
  1194 0000319B 78                  <1>
  1195                              <1> ;clearscreen,registers,deBug regs,hex,in,out,version,Single Step alt, memory map
  1196                              <1> ; (k)connect, dixonnect
  1197                              <1> .lstl    equ    $ - .lst
  1198 0000319C 0A0D2D00            <1> .prompt       db    0Ah, 0Dh, "-", 0    ;3Eh = >
  1199 000031A0 2000                <1> .prompt2    db 20h,0
  1200 000031A2 0A0D00              <1> .crlf       db    0Ah, 0Dh, 0
  1201                              <1> ;------------------------End of Interrupt------------------------
   102                                  %include "./Source/Resident/Services/Int39h.asm"
     1                              <1> ;-------------------Restart Interrupt Int 39h--------------------
     2                              <1> ;This interrupt allows the user to soft reboot
     3                              <1> ;----------------------------------------------------------------
     4                              <1> bootstrapInt:
     5                              <1> ;Bootstrap loader, loads user programmed sector into memory, first from
     6                              <1> ; device 00h and then from device 80h. If device 00h doesnt exist OR the 
     7                              <1> ; loadsector doesn't begin with the SCP/BIOS boot signature then the 
     8                              <1> ; same sector is read from of device 80h. If this also fails due to device 80h
     9                              <1> ; not existing or the sector not being bootable, the boot loader will return
    10                              <1> ; to the caller with the carry flag set.
    11                              <1> 
    12 000031A5 50                  <1>     push rax
    13 000031A6 53                  <1>     push rbx
    14 000031A7 51                  <1>     push rcx
    15 000031A8 52                  <1>     push rdx
    16 000031A9 56                  <1>     push rsi
    17                              <1> 
    18 000031AA B9000100C0          <1>     mov ecx, 0C0000100h    ;Select fs register to load base addr
    19 000031AF 488B0425[CD010000]  <1>     mov rax, qword [userBase]    ;Load address to fs
    20 000031B7 31D2                <1>     xor edx, edx        ;Zero upper bytes
    21 000031B9 0F30                <1>     wrmsr                ;Write msr to load fs base
    22                              <1> 
    23 000031BB BE0A000000          <1>     mov esi, 10
    24                              <1> ;Now load one sector of second prog from device 00h or 80h
    25 000031C0 803C25[4C020000]00  <1>     cmp byte [numMSD], 0    ;If we have no removable devices, skip checking rem dev
    26 000031C8 7447                <1>     jz .e3
    27 000031CA 6631D2              <1>     xor dx, dx  ;This also clears carry flag so no checking ah
    28                              <1> .e0:
    29 000031CD 48BB007C0000000000- <1>     mov rbx, 7c00h
    29 000031D6 00                  <1>
    30 000031D7 488B0C25[BF010000]  <1>     mov rcx, qword [nextFilePtr]
    31 000031DF 668B0425[C7010000]  <1>     mov ax, word [numSectors]   ;Max 42 sectors, upper byte is always 0
    32 000031E7 B482                <1>     mov ah, 82h ;LBA Sector Read, dl has device number
    33 000031E9 CD33                <1>     int 33h     ;Read one sector, device number is preserved
    34 000031EB 730A                <1>     jnc .e1
    35                              <1> 
    36 000031ED FFCE                <1>     dec esi
    37 000031EF 7412                <1>     jz .e2  ;Try again for fixed disk or if on fixed disk, exit
    38                              <1> 
    39 000031F1 30E4                <1>     xor ah, ah  ;Reset the device in dl
    40 000031F3 CD33                <1>     int 33h
    41 000031F5 EBD6                <1>     jmp short .e0
    42                              <1> .e1:
    43 000031F7 66813C25007C000055- <1>     cmp word [7c00h], 0AA55h ;The Boot signature
    43 00003200 AA                  <1>
    44 00003201 7418                <1>     je .leaveBIOS
    45                              <1> ;If we dont goto leaveBIOS, then we try again with device number 80h if it exists
    46                              <1> ;If already at device 80h, fail.
    47                              <1> .e2:
    48 00003203 80FA80              <1>     cmp dl, 80h
    49 00003206 742A                <1>     je .efail
    50 00003208 381425[AA010000]    <1>     cmp byte [fdiskNum], dl ;Recall, dl is zero here
    51 0000320F 7421                <1>     je .efail   ;Don't waste time if there are no fixed disks
    52                              <1> .e3:
    53 00003211 B280                <1>     mov dl, 80h ;Try first fixed disk now
    54 00003213 BE0A000000          <1>     mov esi, 10 ;Reload repeat count
    55 00003218 F8                  <1>     clc
    56 00003219 EBB2                <1>     jmp short .e0
    57                              <1> .leaveBIOS:
    58                              <1> ;State when system transferred:
    59                              <1> ; RSP = DFF8h, 1FFh qword stack from DFFFh to 7C00H + 42*200h sectors = D000h
    60                              <1> ; FS MSR = userbase pointer, can be used for segment override.
    61                              <1> ; DX = Int 33h boot device number
    62                              <1> ; RBX = LBA of first Logical Block after SCP/BIOS
    63                              <1> ; BDA and BIOS ready to go
    64 0000321B 48BCF8DF0000000000- <1>     mov rsp, 0DFF8h ;Move Stack pointer to default init stack position
    64 00003224 00                  <1>
    65 00003225 488B1C25[BF010000]  <1>     mov rbx, qword [nextFilePtr]     ;First sector on device after SCP/BIOS
    66 0000322D E9(027C0000)        <1>     jmp 7C02h       ;New sector entry point
    67                              <1> .efail:
    68 00003232 5E                  <1>     pop rsi
    69 00003233 5A                  <1>     pop rdx
    70 00003234 59                  <1>     pop rcx
    71 00003235 5B                  <1>     pop rbx
    72 00003236 58                  <1>     pop rax
    73 00003237 804C241001          <1>     or byte [rsp + 2*8h], 1 ;Set carry flag
    74 0000323C 48CF                <1>     iretq
    75                              <1> ;------------------------End of Interrupt------------------------
   103                                  %include "./Source/Resident/Services/Int3Ah.asm"
     1                              <1> ;-----------------System Timer Interrupt Int 3Ah-----------------
     2                              <1> ;System Timer functions:
     3                              <1> ; ah=0 -> Get tick count
     4                              <1> ; ah=1 -> Set tick count
     5                              <1> ; ah=2 -> Read RTC time
     6                              <1> ; ah=3 -> Set RTC time
     7                              <1> ; ah=4 -> Read RTC date
     8                              <1> ; ah=5 -> Set RTC date
     9                              <1> ; ah=6 -> Set RTC alarm
    10                              <1> ; ah=7 -> Reset RTC alarm
    11                              <1> ; ah=80h -> Get PIT divisor
    12                              <1> ; ah=81h -> Set PIT divisor
    13                              <1> ;----------------------------------------------------------------
    14                              <1> timerInt:
    15 0000323E 80FC80              <1>     cmp ah, 80h
    16 00003241 737B                <1>     jae .tiext
    17 00003243 84E4                <1>     test ah, ah
    18 00003245 7444                <1>     jz .gett
    19 00003247 80FC01              <1>     cmp ah, 1
    20 0000324A 745E                <1>     jz .sett
    21 0000324C 80FC02              <1>     cmp ah, 2
    22 0000324F 0F8497000000        <1>     jz .readRTCtime
    23 00003255 80FC03              <1>     cmp ah, 3
    24 00003258 0F84D8000000        <1>     jz .setRTCtime
    25 0000325E 80FC04              <1>     cmp ah, 4
    26 00003261 0F8431010000        <1>     jz .readRTCdate
    27 00003267 80FC05              <1>     cmp ah, 5
    28 0000326A 0F845C010000        <1>     jz .setRTCdate
    29 00003270 80FC06              <1>     cmp ah, 6
    30 00003273 0F84B4010000        <1>     jz .setRTCalarm
    31 00003279 80FC07              <1>     cmp ah, 7
    32 0000327C 0F84F6010000        <1>     jz .resetRTCalarm
    33                              <1> .bad:
    34 00003282 804C241001          <1>     or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
    35 00003287 B480                <1>     mov ah, 80h
    36                              <1> .exit:
    37 00003289 48CF                <1>     iretq
    38                              <1> .gett:
    39                              <1> ;Returns:
    40                              <1> ; al=Rolled over flag (0=not rolled)
    41                              <1> ; cx=Hi count
    42                              <1> ; dx=Lo count
    43 0000328B 8B0425[37010000]    <1>     mov eax, dword [pit_ticks]
    44 00003292 6689C2              <1>     mov dx, ax    ;Lo count
    45 00003295 C1E810              <1>     shr eax, 10h    ;Bring high word down
    46 00003298 30ED                <1>     xor ch, ch
    47 0000329A 88C1                <1>     mov cl, al
    48 0000329C 88E0                <1>     mov al, ah
    49 0000329E 0FB6C0              <1>     movzx eax, al    ;Zero upper bytes
    50 000032A1 882425[3A010000]    <1>     mov byte [pit_ticks + 3], ah    ;Move 0 into day OF counter
    51 000032A8 48CF                <1>     iretq
    52                              <1> .sett:
    53                              <1> ;Called with:
    54                              <1> ; cx=Hi count (bzw. cl)
    55                              <1> ; dx=Lo count
    56                              <1> ;Returns: Nothing
    57 000032AA 66891425[37010000]  <1>     mov word [pit_ticks], dx
    58 000032B2 30ED                <1>     xor ch, ch    ;Reset the OF counter
    59 000032B4 66890C25[39010000]  <1>     mov word [pit_ticks + 2], cx
    60 000032BC 48CF                <1>     iretq
    61                              <1> 
    62                              <1> .tiext:    ;Extended Timer functions
    63 000032BE 80EC80              <1>     sub ah, 80h
    64 000032C1 7406                <1>     jz .getpitdiv
    65 000032C3 FECC                <1>     dec ah
    66 000032C5 740C                <1>     jz .setpitdiv
    67 000032C7 EBB9                <1>     jmp short .bad
    68                              <1> .getpitdiv:
    69                              <1> ;Returns:
    70                              <1> ; ax=PIT divisor
    71 000032C9 668B0425[35010000]  <1>     mov ax, word [pit_divisor]
    72 000032D1 48CF                <1>     iretq
    73                              <1> .setpitdiv:
    74                              <1> ;Called with:
    75                              <1> ; dx=divsor
    76                              <1> ;Returns: Nothing
    77 000032D3 66891425[35010000]  <1>     mov word [pit_divisor], dx
    78 000032DB 50                  <1>     push rax
    79 000032DC B036                <1>     mov al, 36h ;Bitmap for frequency write to channel 0 of PIT
    80 000032DE E643                <1>     out PITcommand, al
    81 000032E0 6689D0              <1>     mov ax, dx
    82 000032E3 E640                <1>     out PIT0, al    ;Send low byte of new divisor
    83 000032E5 88E0                <1>     mov al, ah
    84 000032E7 E640                <1>     out PIT0, al    ;Send high byte of new divisor
    85 000032E9 58                  <1>     pop rax
    86 000032EA 48CF                <1>     iretq
    87                              <1> 
    88                              <1> .readRTCtime:
    89                              <1> ; dh = Seconds
    90                              <1> ; cl = Minutes
    91                              <1> ; ch = Hours
    92                              <1> ; dl = Daylight Savings   
    93 000032EC 50                  <1>     push rax
    94 000032ED 51                  <1>     push rcx
    95 000032EE 31C9                <1>     xor ecx, ecx    ;Long counter
    96                              <1> .rrt0:
    97 000032F0 FFC9                <1>     dec ecx
    98 000032F2 743C                <1>     jz .rrtbad
    99 000032F4 B08A                <1>     mov al, 8Ah ;Disable NMI and and read bit 7. When 0, read
   100 000032F6 E89A010000          <1>     call .readRTC
   101 000032FB A880                <1>     test al, 80h    ;Check bit 7 is zero
   102 000032FD 75F1                <1>     jnz .rrt0   ;If zero, fall and read RTC registers
   103                              <1> 
   104 000032FF 59                  <1>     pop rcx         ;Pop upper word of ecx back
   105 00003300 B080                <1>     mov al, 80h     ;Get seconds
   106 00003302 E88E010000          <1>     call .readRTC
   107 00003307 88C6                <1>     mov dh, al      ;Pack seconds in dh
   108 00003309 B082                <1>     mov al, 82h     ;Get minutes
   109 0000330B E885010000          <1>     call .readRTC
   110 00003310 88C1                <1>     mov cl, al      ;Pack minutes in cl
   111 00003312 B084                <1>     mov al, 84h     ;Get Hours
   112 00003314 E87C010000          <1>     call .readRTC
   113 00003319 88C5                <1>     mov ch, al      ;Pack Hours in ch
   114 0000331B B08B                <1>     mov al, 8Bh     ;Get Status B for Daylight Savings
   115 0000331D E873010000          <1>     call .readRTC
   116 00003322 2401                <1>     and al, 1       ;Isolate bit 0
   117 00003324 88C2                <1>     mov dl, al      ;Pack Daylight Savings bit in dl
   118 00003326 B00D                <1>     mov al, 0Dh     ;Enable NMI
   119 00003328 E868010000          <1>     call .readRTC
   120 0000332D 58                  <1>     pop rax
   121 0000332E 48CF                <1>     iretq
   122                              <1> .rrtbad:
   123 00003330 59                  <1>     pop rcx
   124 00003331 58                  <1>     pop rax
   125 00003332 F9                  <1>     stc
   126 00003333 C20800              <1>     ret 8   ;Set carry and return
   127                              <1> 
   128                              <1> .setRTCtime:
   129                              <1> ; dh = Seconds
   130                              <1> ; cl = Minutes
   131                              <1> ; ch = Hours
   132                              <1> ; dl = Daylight Savings 
   133 00003336 50                  <1>     push rax
   134 00003337 51                  <1>     push rcx
   135 00003338 31C9                <1>     xor ecx, ecx
   136                              <1> .srt0:
   137 0000333A FFC9                <1>     dec ecx
   138 0000333C 74F2                <1>     jz .rrtbad
   139 0000333E B08A                <1>     mov al, 8Ah ;Disable NMI and and read bit 7. When 0, write
   140 00003340 E850010000          <1>     call .readRTC
   141 00003345 A880                <1>     test al, 80h    ;Check bit 7 is zero
   142 00003347 75F1                <1>     jnz .srt0   ;If zero, fall and write RTC registers
   143                              <1> 
   144 00003349 59                  <1>     pop rcx
   145 0000334A B08B                <1>     mov al, 8Bh
   146 0000334C E844010000          <1>     call .readRTC
   147 00003351 80E201              <1>     and dl, 1   ;Ensure we only have the low bit of dl
   148 00003354 08D0                <1>     or al, dl   ;Set the daylight savings bit of Status B
   149 00003356 0C80                <1>     or al, 80h  ;Stop RTC updates
   150 00003358 88C4                <1>     mov ah, al
   151 0000335A B08B                <1>     mov al, 8Bh ;Reset Status B Register, and daylight savings
   152 0000335C E83D010000          <1>     call .writeRTC
   153                              <1> 
   154 00003361 88F4                <1>     mov ah, dh  ;Pack seconds
   155 00003363 B080                <1>     mov al, 80h
   156 00003365 E834010000          <1>     call .writeRTC
   157 0000336A 88CC                <1>     mov ah, cl  ;Pack minutes
   158 0000336C B082                <1>     mov al, 82h
   159 0000336E E82B010000          <1>     call .writeRTC
   160 00003373 88EC                <1>     mov ah, ch  ;Pack hours
   161 00003375 B084                <1>     mov al, 84h
   162 00003377 E822010000          <1>     call .writeRTC
   163                              <1> 
   164 0000337C B08B                <1>     mov al, 8Bh
   165 0000337E E812010000          <1>     call .readRTC
   166 00003383 247F                <1>     and al, 7Fh ;Clear the top bit
   167 00003385 88C4                <1>     mov ah, al  ;Pack byte to send in ah
   168 00003387 B08B                <1>     mov al, 8Bh
   169 00003389 E810010000          <1>     call .writeRTC  ;Restart RTC
   170                              <1> 
   171 0000338E B00D                <1>     mov al, 0Dh   ;Enable NMI
   172 00003390 E800010000          <1>     call .readRTC
   173                              <1> 
   174 00003395 58                  <1>     pop rax
   175 00003396 48CF                <1>     iretq
   176                              <1>     
   177                              <1> .readRTCdate:
   178                              <1> ; ch = Reserved, Century (19/20/21...), fixed 20h for now
   179                              <1> ; cl = Year
   180                              <1> ; dh = Month
   181                              <1> ; dl = Day
   182 00003398 50                  <1>     push rax
   183 00003399 51                  <1>     push rcx
   184 0000339A 31C9                <1>     xor ecx, ecx
   185                              <1> .rrd0:
   186 0000339C FFC9                <1>     dec ecx
   187 0000339E 7490                <1>     jz .rrtbad
   188 000033A0 B08A                <1>     mov al, 8Ah     ;Disable NMI and and read bit 7. When 0, write
   189 000033A2 E8EE000000          <1>     call .readRTC
   190 000033A7 A880                <1>     test al, 80h    ;Check bit 7 is zero
   191 000033A9 75F1                <1>     jnz .rrd0       ;If zero, fall and read RTC registers
   192                              <1> 
   193 000033AB 59                  <1>     pop rcx
   194 000033AC B087                <1>     mov al, 87h     ;Get Day of the Month
   195 000033AE E8E2000000          <1>     call .readRTC
   196 000033B3 88C2                <1>     mov dl, al      ;Pack Day of the Month
   197 000033B5 B088                <1>     mov al, 88h     ;Get Month of the Year
   198 000033B7 E8D9000000          <1>     call .readRTC
   199 000033BC 88C6                <1>     mov dh, al      ;Pack Month of the Year
   200 000033BE B089                <1>     mov al, 89h     ;Get bottom two digits of year
   201 000033C0 E8D0000000          <1>     call .readRTC
   202 000033C5 88C1                <1>     mov cl, al      ;Pack Year
   203 000033C7 B514                <1>     mov ch, 20      ;BCD value for 20
   204                              <1> 
   205 000033C9 58                  <1>     pop rax
   206 000033CA 48CF                <1>     iretq
   207                              <1> 
   208                              <1> .setRTCdate:
   209                              <1> ; ch = Reserved, Century (19/20/21...), fixed 20h for now
   210                              <1> ; cl = Year
   211                              <1> ; dh = Month
   212                              <1> ; dl = Day
   213 000033CC 50                  <1>     push rax
   214 000033CD 51                  <1>     push rcx
   215 000033CE 31C9                <1>     xor ecx, ecx
   216                              <1> .srd0:
   217 000033D0 FFC9                <1>     dec ecx
   218 000033D2 0F8458FFFFFF        <1>     jz .rrtbad
   219 000033D8 B08A                <1>     mov al, 8Ah     ;Disable NMI and and read bit 7. When 0, write
   220 000033DA E8B6000000          <1>     call .readRTC
   221 000033DF A880                <1>     test al, 80h    ;Check bit 7 is zero
   222 000033E1 75ED                <1>     jnz .srd0       ;If zero, fall and write RTC registers
   223                              <1> 
   224 000033E3 59                  <1>     pop rcx
   225 000033E4 B08B                <1>     mov al, 8Bh
   226 000033E6 E8AA000000          <1>     call .readRTC
   227 000033EB 0C80                <1>     or al, 80h      ;Stop RTC updates
   228 000033ED 88C4                <1>     mov ah, al
   229 000033EF B08B                <1>     mov al, 8Bh
   230 000033F1 E8A8000000          <1>     call .writeRTC
   231 000033F6 88D4                <1>     mov ah, dl      ;Pack Day of the Month
   232 000033F8 B087                <1>     mov al, 87h
   233 000033FA E89F000000          <1>     call .writeRTC
   234 000033FF 88F4                <1>     mov ah, dh      ;Pack Month of the Year
   235 00003401 B088                <1>     mov al, 88h
   236 00003403 E896000000          <1>     call .writeRTC
   237 00003408 88CC                <1>     mov ah, cl      ;Pack Year
   238 0000340A B089                <1>     mov al, 89h
   239 0000340C E88D000000          <1>     call .writeRTC
   240                              <1> 
   241 00003411 B08B                <1>     mov al, 8Bh
   242 00003413 E87D000000          <1>     call .readRTC
   243 00003418 247F                <1>     and al, 7Fh ;Clear the top bit
   244 0000341A 88C4                <1>     mov ah, al  ;Pack byte to send in ah
   245 0000341C B08B                <1>     mov al, 8Bh
   246 0000341E E87B000000          <1>     call .writeRTC  ;Restart RTC
   247                              <1> 
   248 00003423 B00D                <1>     mov al, 0Dh   ;Enable NMI
   249 00003425 E86B000000          <1>     call .readRTC
   250                              <1> 
   251 0000342A 58                  <1>     pop rax
   252 0000342B 48CF                <1>     iretq
   253                              <1> 
   254                              <1> .setRTCalarm:
   255                              <1> ; dh = Seconds for alarm
   256                              <1> ; cl = Minutes for alarm
   257                              <1> ; ch = Hours for alarm
   258 0000342D 50                  <1>     push rax
   259 0000342E B08B                <1>     mov al, 8BH ;Get status B
   260 00003430 E860000000          <1>     call .readRTC
   261 00003435 A820                <1>     test al, 20h
   262 00003437 7537                <1>     jnz .srabad ;If The alarm bit is already set, exit CF=CY
   263                              <1> 
   264 00003439 88F4                <1>     mov ah, dh      ;Pack Seconds for alarm
   265 0000343B B081                <1>     mov al, 81h     
   266 0000343D E85C000000          <1>     call .writeRTC
   267 00003442 88CC                <1>     mov ah, cl      ;Pack Minutes for alarm
   268 00003444 B083                <1>     mov al, 83h
   269 00003446 E853000000          <1>     call .writeRTC
   270 0000344B 88EC                <1>     mov ah, ch      ;Pack Hours for alarm
   271 0000344D B085                <1>     mov al, 85h
   272 0000344F E84A000000          <1>     call .writeRTC
   273                              <1> 
   274 00003454 B08B                <1>     mov al, 8Bh     ;Get Status B
   275 00003456 E83A000000          <1>     call .readRTC
   276 0000345B 0C20                <1>     or al, 20h      ;Set Bit 5 - Alarm Interrupt Enable
   277 0000345D 88C4                <1>     mov ah, al      ;Pack new Status B
   278 0000345F B08B                <1>     mov al, 8Bh
   279 00003461 E838000000          <1>     call .writeRTC 
   280                              <1> 
   281 00003466 B00D                <1>     mov al, 0Dh     ;Enable NMI
   282 00003468 E828000000          <1>     call .readRTC
   283                              <1> 
   284 0000346D 58                  <1>     pop rax
   285 0000346E 48CF                <1>     iretq
   286                              <1> .srabad:
   287 00003470 58                  <1>     pop rax
   288 00003471 804C241001          <1>     or byte [rsp + 2*8], 1 ;Set Carry Flag
   289 00003476 48CF                <1>     iretq  
   290                              <1> .resetRTCalarm:
   291 00003478 50                  <1>     push rax
   292 00003479 B08B                <1>     mov al, 8Bh     ;Get Status B
   293 0000347B E815000000          <1>     call .readRTC
   294 00003480 24DF                <1>     and al, 0DFh    ;Clear Alarm Interrupt Enable
   295 00003482 88C4                <1>     mov ah, al
   296 00003484 B08B                <1>     mov al, 8Bh
   297 00003486 E813000000          <1>     call .writeRTC
   298                              <1> 
   299 0000348B B00D                <1>     mov al, 0Dh     ;Enable NMI
   300 0000348D E803000000          <1>     call .readRTC 
   301 00003492 58                  <1>     pop rax
   302 00003493 48CF                <1>     iretq
   303                              <1> 
   304                              <1> .readRTC:
   305                              <1> ;Reads an RTC port, interrupts disabled throughout
   306                              <1> ;Input: al = I/O port to read
   307                              <1> ;Output: al = I/O data
   308 00003495 FA                  <1>     cli
   309 00003496 E670                <1>     out cmos_base, al
   310 00003498 E680                <1>     out waitp, al
   311 0000349A E471                <1>     in al, cmos_data
   312 0000349C FB                  <1>     sti
   313 0000349D C3                  <1>     ret
   314                              <1> .writeRTC:
   315                              <1> ;Writes to an RTC port, interrupts disabled throughout 
   316                              <1> ;Input: al = I/O port to read, ah = Data byte to send
   317 0000349E FA                  <1>     cli
   318 0000349F E670                <1>     out cmos_base, al
   319 000034A1 E680                <1>     out waitp, al
   320 000034A3 88E0                <1>     mov al, ah
   321 000034A5 E671                <1>     out cmos_data, al
   322 000034A7 FB                  <1>     sti
   323 000034A8 C3                  <1>     ret
   324                              <1> ;------------------------End of Interrupt------------------------
   104                                  %include "./Source/Resident/Services/Int3Bh.asm"
     1                              <1> ;-----------------CTRL+BREAK Interrupt Int 3Bh-------------------
     2                              <1> ;CTRL+Break will call this!
     3                              <1> ;----------------------------------------------------------------
     4                              <1> ctrlbreak_io:
     5 000034A9 48CF                <1>     iretq
     6                              <1> ;------------------------End of Interrupt-------------------------
   105                                  %include "./Source/Resident/Services/Int3Dh.asm"
     1                              <1> ;------------Screen Mode Parameters Interrupt Int 3Dh-------------
     2                              <1> ;This Interrupt returns in r8 the pointer to screen mode 
     3                              <1> ; parameters. It replaces the nice pointers in the IVT of yore.
     4                              <1> ;Returns in r8 to not conflict with ported apps
     5                              <1> ;----------------------------------------------------------------
     6                              <1> scr_params_io:
     7 000034AB 49B8-               <1>     mov r8, scr_mode_params
     7 000034AD [6001000000000000]  <1>
     8 000034B5 48CF                <1>     iretq
     9                              <1> ;------------------------End of Interrupt------------------------
   106                                  %include "./Source/Resident/Services/Int3Eh.asm"
     1                              <1> ;-----------------Disk Params Interrupt Int 3Eh------------------
     2                              <1> disk_params_io:
     3 000034B7 4C8B0425[AF010000]  <1>     mov r8, qword [diskDptPtr]    
     4 000034BF 4C8B0C25[B7010000]  <1>     mov r9, qword [fdiskDptPtr]
     5 000034C7 48CF                <1>     iretq
     6                              <1> ;------------------------End of Interrupt------------------------
   107                                  %include "./Source/Resident/Services/Int3Fh.asm"
     1                              <1> ;------------------CGA font Interrupt Int 3Fh--------------------
     2                              <1> ;This Interrupt returns in r8 the pointer to the CGA font.
     3                              <1> ;It replaces the nice pointers in the IVT of yore.
     4                              <1> ;Returns in r8 to not conflict with ported apps
     5                              <1> ;----------------------------------------------------------------
     6                              <1> cga_ret_io: ;Get first pointer in list
     7 000034C9 4C0FB70425-         <1>     movzx r8, word [scr_vga_ptrs]
     7 000034CE [68010000]          <1>
     8 000034D2 49C1E004            <1>     shl r8, 4
     9 000034D6 6644030425-         <1>     add r8w, word [scr_vga_ptrs + 2]
     9 000034DB [6A010000]          <1>
    10 000034DF 48CF                <1>     iretq
    11                              <1> ;------------------------End of Interrupt------------------------
   108                                  ;========================RESIDENT DRIVERS=====================
   109                                  %include "./Source/Resident/Hardware/ATA/ataDrv.asm"
     1                              <1> ;ATA driver!
     2                              <1> ATA:
     3                              <1> .identifyDevice:
     4                              <1> ;Drive to be identified should be selected already
     5                              <1> ;dx should contain the base register
     6                              <1> ;rdi points to the buffer
     7                              <1> ;Carry set if failed.
     8                              <1> 
     9 000034E1 50                  <1>     push rax
    10 000034E2 53                  <1>     push rbx
    11                              <1> 
    12 000034E3 30C0                <1>     xor al, al
    13 000034E5 81C202000000        <1>     add edx, 2            ;dx at base + 2
    14 000034EB EE                  <1>     out dx, al
    15 000034EC FFC2                <1>     inc edx               ;dx at base + 3
    16 000034EE EE                  <1>     out dx, al
    17 000034EF FFC2                <1>     inc edx               ;dx at base + 4
    18 000034F1 EE                  <1>     out dx, al
    19 000034F2 FFC2                <1>     inc edx               ;dx at base + 5
    20 000034F4 EE                  <1>     out dx, al
    21 000034F5 81C202000000        <1>     add edx, 2           ;dx at base + 7
    22 000034FB B0EC                <1>     mov al, 0ECh         ;ECh = Identify drive command
    23 000034FD EE                  <1>     out dx, al
    24                              <1> 
    25 000034FE EB00                <1>     jmp short $ + 2      ;IO cycle kill
    26 00003500 B30A                <1>     mov bl, 10           ;10 retries ok
    27                              <1> .l2:
    28 00003502 EC                  <1>     in al, dx            ;get status byte
    29 00003503 A808                <1>     test al, 00001000b   ;Check DRQ, to be set for data ready
    30 00003505 7511                <1>     jnz .l3 ;If set we good to go
    31                              <1>     ;Else timeout, wait for 1 ms before reading again
    32 00003507 FECB                <1>     dec bl
    33 00003509 741E                <1>     jz .exitfail
    34 0000350B 51                  <1>     push rcx
    35 0000350C B901000000          <1>     mov ecx, 1
    36 00003511 B486                <1>     mov ah, 86h
    37 00003513 CD35                <1>     int 35h
    38 00003515 59                  <1>     pop rcx
    39 00003516 EBEA                <1>     jmp short .l2
    40                              <1> .l3:
    41 00003518 81EA07000000        <1>     sub edx, 7            ;dx at base + 0
    42 0000351E B900010000          <1>     mov ecx, 100h         ;100h words to be copied
    43 00003523 F3666D              <1>     rep insw
    44 00003526 F8                  <1>     clc
    45 00003527 EB01                <1>     jmp short .exit
    46                              <1> 
    47                              <1> .exitfail:
    48 00003529 F9                  <1>     stc
    49                              <1> .exit:
    50 0000352A 5B                  <1>     pop rbx
    51 0000352B 58                  <1>     pop rax
    52 0000352C C3                  <1>     ret
    53                              <1> .selectDriveFromTable:
    54                              <1> ;Selects the drive pointed to by the table entry in rbp
    55                              <1> ;Input: rbp = Pointer to drive table entry
    56                              <1> ;Output: CF=NC -> All ok, can proceed with writing data
    57                              <1> ;        CF=CY -> drive not set
    58 0000352D 52                  <1>     push rdx
    59 0000352E 50                  <1>     push rax
    60 0000352F 8A4515              <1>     mov al, byte [rbp + fdiskTblEntry.msBit]
    61 00003532 668B5513            <1>     mov dx, word [rbp + fdiskTblEntry.ioBase]
    62 00003536 E803000000          <1>     call .selectDrive
    63 0000353B 58                  <1>     pop rax
    64 0000353C 5A                  <1>     pop rdx
    65 0000353D C3                  <1>     ret
    66                              <1> .selectDrive:
    67                              <1> ;Selects either master or slave drive
    68                              <1> ;Sets/clears bit 7 of ataXCmdByte 
    69                              <1> ;Bit 7 ataX Clear => Master
    70                              <1> ;Input: dx = ataXbase, 
    71                              <1> ;       ah = al = A0h/B0h (or E0h/F0h for LBA) for master/slave
    72                              <1> ;
    73                              <1> ;Return: If CF=NC, al = the status of the selected drive after selection
    74                              <1> ;        If CF=CY drive not set
    75                              <1> ;ah is preserved
    76                              <1> ;First check if this is the presently active device
    77 0000353E 53                  <1>     push rbx
    78 0000353F 51                  <1>     push rcx
    79                              <1>     ;First find if ata0CmdByte or ata1CmdByte
    80 00003540 8D0C25[AB010000]    <1>     lea ecx, ata0CmdByte
    81 00003547 8D1C25[AD010000]    <1>     lea ebx, ata1CmdByte
    82 0000354E 81FAF0010000        <1>     cmp edx, ata0_base
    83 00003554 0F45CB              <1>     cmovne ecx, ebx    ;Move ata1CmdByte to ecx
    84                              <1>     ;Now isolate master/slave bit
    85 00003557 88C3                <1>     mov bl, al  ;Save master/slave byte in bl
    86 00003559 C0EB04              <1>     shr bl, 4   ;Bring nybble low
    87 0000355C 80E301              <1>     and bl, 1   ;Save only bottom bit, if set it is slave
    88 0000355F 8A39                <1>     mov bh, byte [rcx]  ;Now get ataXCmdByte
    89 00003561 80E701              <1>     and bh, 1   ;Only care for the bottom bit
    90                              <1>     ;bh has in memory bit, bl has device bit
    91 00003564 38DF                <1>     cmp bh, bl
    92 00003566 743A                <1>     je .skipSelection   ;If bh and bl are equal, the drive we want is selected
    93                              <1>     ;Now set master/slave on host
    94 00003568 B70B                <1>     mov bh, 11     ;Up to 10 tries to set a device
    95                              <1> .sd0:      
    96 0000356A FECF                <1>     dec bh
    97 0000356C 7437                <1>     jz .driveNotSelected
    98 0000356E 88E0                <1>     mov al, ah     ;Return A0h/B0h to al from ah
    99 00003570 88C3                <1>     mov bl, al     ;Save shifted-up drive select bit in bl
   100 00003572 81C206000000        <1>     add edx, 6     ;dx at base + 6, drive select register
   101 00003578 EE                  <1>     out dx, al     ;Select here
   102 00003579 81EA06000000        <1>     sub edx, 6     ;dx back at base + 0
   103                              <1>     ;Now wait 400ns for value to settle
   104 0000357F E824000000          <1>     call .driveSelectWait
   105 00003584 81C207000000        <1>     add edx, 7     ;Go to Status Register
   106 0000358A EC                  <1>     in al, dx      ;Get status
   107 0000358B 81EA07000000        <1>     sub edx, 7     ;Go back to ataXbase
   108 00003591 A888                <1>     test al, 88h   ;Test if either BSY and DRQ bits set.
   109 00003593 75D5                <1>     jnz .sd0       ;If either is set, drive setting failed, try set again!
   110                              <1>     ;Here set the bit in ataXCmdByte to confirm drive as selected
   111                              <1>     ;ecx still has the value of the ataXCmdbyte
   112 00003595 8021FE              <1>     and byte [rcx], 0FEh    ;Clear the bottom bit
   113 00003598 88E3                <1>     mov bl, ah              ;Bring A0h/B0h to bl
   114 0000359A C0EB04              <1>     shr bl, 4               ;Shift it down to bl[0]
   115 0000359D 80E301              <1>     and bl, 1   ;Save only bottom bit, if set it is slave
   116 000035A0 0819                <1>     or byte [rcx], bl       ;Set the bit if bl[0] is set
   117                              <1> .skipSelection:
   118 000035A2 59                  <1>     pop rcx
   119 000035A3 5B                  <1>     pop rbx
   120 000035A4 C3                  <1>     ret
   121                              <1> .driveNotSelected:
   122 000035A5 F9                  <1>     stc
   123 000035A6 EBFA                <1>     jmp short .skipSelection
   124                              <1> 
   125                              <1> .driveSelectWait:
   126                              <1> ; Called with dx = ataXbase
   127                              <1> ; Reads the alternate status register 14 times
   128                              <1> ; Returns the alternate status after a 15th read
   129 000035A8 51                  <1>     push rcx
   130 000035A9 81C206020000        <1>     add edx, 206h   ;Move to alt base
   131 000035AF B90E000000          <1>     mov ecx, 14     ;14 iterations for 420ns wait
   132                              <1> .dsw0:
   133 000035B4 EC                  <1>     in al, dx
   134 000035B5 E2FD                <1>     loop .dsw0
   135 000035B7 81EAFF010000        <1>     sub edx, 1FFh   ;Return to ataXbase + 7
   136 000035BD EC                  <1>     in al, dx       ;Get status and clear pending Interrupt
   137 000035BE 81EA07000000        <1>     sub edx, 7      ;Return to ataXbase
   138 000035C4 59                  <1>     pop rcx
   139 000035C5 C3                  <1>     ret
   140                              <1> 
   141                              <1> .wait400ns:
   142                              <1> ;Called with dx pointing to a port to read 14 times
   143 000035C6 51                  <1>     push rcx
   144 000035C7 B90E000000          <1>     mov ecx, 14     ;14 iterations for 420ns wait
   145                              <1> .wns:
   146 000035CC EC                  <1>     in al, dx
   147 000035CD E2FD                <1>     loop .wns
   148 000035CF 59                  <1>     pop rcx
   149 000035D0 C3                  <1>     ret
   150                              <1> 
   151                              <1> .getTablePointer:
   152                              <1> ;Given a drive number in dl, put the table pointer in rbp
   153                              <1> ;If entry not valid OR greater than 4, fail with CF=CY
   154 000035D1 52                  <1>     push rdx
   155 000035D2 80E27F              <1>     and dl, 7Fh ;Clear top bit
   156 000035D5 80FA03              <1>     cmp dl, 3   ;Only 4 fixed disks allowed!
   157 000035D8 7720                <1>     ja .gtpBad
   158 000035DA 488D2C25[6C030000]  <1>     lea rbp, fdiskTbl ;Point to the fdiskTbl
   159                              <1> .gtpSearch:
   160 000035E2 84D2                <1>     test dl, dl
   161 000035E4 740B                <1>     jz .gtpVerifyOk
   162 000035E6 FECA                <1>     dec dl
   163 000035E8 4881C516000000      <1>     add rbp, fdiskTblEntry_size    ;Goto next entry
   164 000035EF EBF1                <1>     jmp short .gtpSearch
   165                              <1> .gtpVerifyOk:
   166 000035F1 807D0001            <1>     cmp byte [rbp + fdiskTblEntry.signature], 1    ;Configured bit must be set
   167 000035F5 7403                <1>     jz .gtpBad 
   168 000035F7 5A                  <1>     pop rdx
   169 000035F8 F8                  <1>     clc
   170 000035F9 C3                  <1>     ret
   171                              <1> .gtpBad:
   172 000035FA F9                  <1>     stc 
   173 000035FB 5A                  <1>     pop rdx
   174 000035FC C3                  <1>     ret
   175                              <1> ;==============================:
   176                              <1> ;    ATA primitive functions
   177                              <1> ;==============================:
   178                              <1> .resetChannel:
   179                              <1>     ;Resets a selected ATA channel
   180                              <1>     ;Input: rbp = Fixed Disk Table entry pointer for chosen device
   181                              <1>     ;Output: CF=CY -> Channel did not reset.
   182                              <1>     ;        CF=NC -> Channel reset
   183                              <1>     ;If the channel doesnt reset, the caller will establish an error code
   184                              <1>     ;
   185 000035FD 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   186 00003601 81C206020000        <1>     add edx, 206h   ;Go to alternate base
   187 00003607 B004                <1>     mov al, 4h      ;Set the SoftwareReSeT (SRST) bit
   188 00003609 EE                  <1>     out dx, al      ;Set the bit
   189 0000360A B90A000000          <1>     mov ecx, 10     ;Wait 10 milliseconds
   190 0000360F B486                <1>     mov ah, 86h
   191 00003611 CD35                <1>     int 35h
   192 00003613 30C0                <1>     xor al, al
   193 00003615 EE                  <1>     out dx, al      ;Clear the SRST bit
   194 00003616 B90A000000          <1>     mov ecx, 10     ;Wait 10 milliseconds
   195 0000361B B486                <1>     mov ah, 86h
   196 0000361D CD35                <1>     int 35h
   197 0000361F EC                  <1>     in al, dx       ;Get one more read
   198 00003620 81EA06020000        <1>     sub edx, 206h   ;Return to base
   199 00003626 24C0                <1> 	and al, 0xc0    ;Get only BSY and DRDY
   200 00003628 3C40                <1> 	cmp al, 0x40	;Check that BSY is clear and that DRDY is set
   201 0000362A 751F                <1>     jne .rcBad
   202                              <1>     ;Here clear the master/slave bit in ataXCmdByte
   203 0000362C 488D1C25[AB010000]  <1>     lea rbx, ata0CmdByte
   204 00003634 488D0C25[AD010000]  <1>     lea rcx, ata1CmdByte
   205 0000363C 66817D13F001        <1>     cmp word [rbp + fdiskTblEntry.ioBase], ata0_base
   206 00003642 480F45D9            <1>     cmovne rbx, rcx
   207 00003646 8023FE              <1>     and byte [rbx], 0FEh    ;Clear low bit
   208                              <1> 
   209 00003649 F8                  <1>     clc             ;Clear carry
   210 0000364A C3                  <1>     ret
   211                              <1> .rcBad:
   212 0000364B F9                  <1>     stc             ;Set carry
   213 0000364C C3                  <1>     ret
   214                              <1> ;Common functions:
   215                              <1> ;Jumped to with: 
   216                              <1> ; al = Primary function number
   217                              <1> ; cl = Sector count
   218                              <1> ; dx = Command register for drive
   219                              <1> .read:
   220 0000364D EE                  <1>     out dx, al  ;Output the command byte!
   221 0000364E 88C8                <1>     mov al, cl  ;Return sector count into al
   222                              <1> 
   223                              <1>     ;Now we wait for the DRQ bit in the status register to set
   224 00003650 4889DF              <1>     mov rdi, rbx    ;Move the read buffer pointer to rdi
   225 00003653 88C3                <1>     mov bl, al      ;Save sector count in bl
   226                              <1> .rWait:
   227 00003655 B9FFFFFFFF          <1>     mov ecx, -1  ;Data should be ready within ~67 miliseconds
   228 0000365A 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   229 0000365E 81C207000000        <1>     add edx, 7  ;Dummy read on status register
   230                              <1> .rWaitLoop:
   231 00003664 FFC9                <1>     dec ecx
   232 00003666 7440                <1>     jz .rTimeout
   233 00003668 EC                  <1>     in al, dx
   234 00003669 A880                <1>     test al, 80h     ;Is BSY set?
   235 0000366B 75F7                <1>     jnz .rWaitLoop   ;If so, keep looping
   236 0000366D A821                <1>     test al, 21h     ;Are error bits set?  
   237 0000366F 753F                <1>     jnz .errorExit   ;If not, must be ok to go
   238 00003671 A808                <1>     test al, 8h      ;Check DRQ, data ready bit is set
   239 00003673 74EF                <1>     jz .rWaitLoop
   240                              <1> ;Now we can read the data
   241 00003675 81EA07000000        <1>     sub edx, 7   ;Point to base=data register
   242 0000367B B900010000          <1>     mov ecx, 256    ;Number of words in a sector
   243                              <1> .r0:
   244 00003680 666D                <1>     insw    ;Read that many words!
   245 00003682 EB00                <1>     jmp short $ + 2
   246 00003684 E2FA                <1>     loop .r0    ;Read the sector, one word at a time
   247 00003686 FECB                <1>     dec bl      ;Reduce the number of sectors read by 1
   248 00003688 75CB                <1>     jnz .rWait
   249                              <1>     ;Here check status register to ensure error isnt set
   250 0000368A 81C207000000        <1>     add edx, 7
   251 00003690 B9FFFFFFFF          <1>     mov ecx, -1
   252                              <1> .readExitloop:
   253 00003695 FFC9                <1>     dec ecx
   254 00003697 7417                <1>     jz .errorExit
   255 00003699 EC                  <1>     in al, dx
   256 0000369A A880                <1>     test al, 80h        ;Check if BSY bit still set (i.e not ready yet)
   257 0000369C 75F7                <1>     jnz .readExitloop   ;If BSY still set keep looping
   258 0000369E A861                <1>     test al, 61h        ;Check if DSDY bit or Error bits are set
   259 000036A0 74F3                <1>     jz .readExitloop    ;If DSDY not set, wait
   260 000036A2 A821                <1>     test al, 21h    ;Check status bits 0 and 5 (error and drive fault)
   261 000036A4 750A                <1>     jnz .errorExit
   262                              <1> .rExit:
   263 000036A6 F8                  <1>     clc
   264 000036A7 C3                  <1>     ret
   265                              <1> .rTimeout:
   266 000036A8 C60425[A9010000]80  <1>     mov byte [msdStatus], 80h   ;Timeout occured
   267                              <1> .errorExit:
   268 000036B0 F9                  <1>     stc
   269 000036B1 C3                  <1>     ret
   270                              <1> 
   271                              <1> .write:
   272 000036B2 EE                  <1>     out dx, al  ;Output the command byte!
   273 000036B3 88C8                <1>     mov al, cl  ;Return sector count into al
   274                              <1> 
   275                              <1>     ;Now we wait for the DRQ bit in the status register to set
   276 000036B5 4889DE              <1>     mov rsi, rbx    ;Move the write buffer pointer to rsi
   277 000036B8 88C3                <1>     mov bl, al      ;Save sector count in bl
   278                              <1> .writeWait:
   279 000036BA B9FFFFFFFF          <1>     mov ecx, -1  ;Data should be ready within ~67 miliseconds
   280 000036BF 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   281 000036C3 81C207000000        <1>     add edx, 7  ;Dummy read on Alt status register
   282                              <1> .writeWaitLoop:
   283 000036C9 FFC9                <1>     dec ecx
   284 000036CB 74DB                <1>     jz .rTimeout
   285 000036CD EC                  <1>     in al, dx
   286 000036CE A880                <1>     test al, 80h     ;Is BSY set?
   287 000036D0 75F7                <1>     jnz .writeWaitLoop   ;If so, keep looping
   288 000036D2 A821                <1>     test al, 21h     ;Are error bits set?  
   289 000036D4 75DA                <1>     jnz .errorExit   ;If not, must be ok to go
   290 000036D6 A808                <1>     test al, 8h      ;Check DRQ, data ready bit is set
   291 000036D8 74EF                <1>     jz .writeWaitLoop
   292                              <1> ;Now we can write the data
   293 000036DA 81EA07000000        <1>     sub edx, 7   ;Point to base=data register
   294 000036E0 B900010000          <1>     mov ecx, 256    ;Number of words in a sector
   295                              <1> .w1:
   296 000036E5 666F                <1>     outsw    ;Write that many words!
   297 000036E7 EB00                <1>     jmp short $ + 2
   298 000036E9 E2FA                <1>     loop .w1 ;Write one sector, one word at a time
   299 000036EB FECB                <1>     dec bl
   300 000036ED 75CB                <1>     jnz .writeWait  ;Keep going up by a sector
   301                              <1>     ;Here wait for device to stop being busy. 
   302                              <1>     ;If it doesnt after ~4 seconds, declare an error
   303                              <1> .formatEP:  ;Where the format routine enters the write routine
   304 000036EF B9FFFFFFFF          <1>     mov ecx, -1 ;About 4 seconds
   305 000036F4 81C207000000        <1>     add edx, 7  ;Goto status register
   306                              <1> .wBSYcheck:
   307 000036FA FFC9                <1>     dec ecx
   308 000036FC 74B2                <1>     jz .errorExit   ;If after 4 seconds the device is still BSY, consider it failing
   309 000036FE EC                  <1>     in al, dx   ;Read status reg
   310 000036FF A880                <1>     test al, 80h    ;Check BSY
   311 00003701 75F7                <1>     jnz .wBSYcheck   ;If it is no longer BSY, check error status
   312 00003703 A861                <1>     test al, 61h        ;Check if DSDY bit or Error bits are set
   313 00003705 74F3                <1>     jz .wBSYcheck    ;If not set, do not send next command
   314                              <1> ;NOW FLUSH THE DISK BUFFERS TO DISK
   315                              <1>     ;Here check status register to ensure error isnt set
   316 00003707 A821                <1>     test al, 21h    ;Test bits 0 and 5 (error and drive fault)
   317 00003709 75A5                <1>     jnz .errorExit
   318                              <1>     ;Now we must flush cache on the device
   319 0000370B B0E7                <1>     mov al, 0E7h    ;FLUSH CACHE COMMAND
   320 0000370D EE                  <1>     out dx, al
   321                              <1>     ;This command can take 30 seconds to complete so we check status 
   322                              <1>     ; every ms to see if BSY is clear yet.
   323 0000370E BB30750000          <1>     mov ebx, 30000   ;30,000 miliseconds in 30 seconds
   324                              <1> .wFlushCheck:
   325 00003713 FFCB                <1>     dec ebx
   326 00003715 7499                <1>     jz .errorExit
   327 00003717 B901000000          <1>     mov ecx, 1
   328 0000371C B486                <1>     mov ah, 86h
   329 0000371E CD35                <1>     int 35h
   330 00003720 EC                  <1>     in al, dx   ;Read the status byte
   331 00003721 A880                <1>     test al, 80h    ;Are we still busy?
   332 00003723 75EE                <1>     jnz .wFlushCheck ;IF yes, loop again
   333 00003725 A861                <1>     test al, 61h    ;Check if DSDY bit or Error bits are set
   334 00003727 74EA                <1>     jz .wFlushCheck  ;Whilst it is not set, keep looping
   335 00003729 A821                <1>     test al, 21h    ;Test bits 0 and 5 (error and drive fault)
   336 0000372B 7583                <1>     jnz .errorExit   ;If either are set, return fail
   337 0000372D F8                  <1>     clc
   338 0000372E C3                  <1>     ret
   339                              <1> 
   340                              <1> .verify:
   341 0000372F EE                  <1>     out dx, al  ;Output the command byte!
   342                              <1>     ;Now we wait for BSY to go low and DRDY to go high
   343 00003730 66B9FFFF            <1>     mov cx, -1  ;Data should be ready within ~67 miliseconds
   344 00003734 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   345 00003738 81C207000000        <1>     add edx, 7  ;Goto status register
   346                              <1> .vLoop:
   347 0000373E 66FFC9              <1>     dec cx
   348 00003741 0F8469FFFFFF        <1>     jz .errorExit
   349 00003747 EC                  <1>     in al, dx   ;Get status
   350 00003748 A880                <1>     test al, 80h    ;BSY bit set
   351 0000374A 75F2                <1>     jnz .vLoop
   352                              <1>     ;Once it clears come here
   353 0000374C A861                <1>     test al, 61h    ;Check if DSDY bit or Error bits are set
   354 0000374E 74EE                <1>     jz .vLoop    ;Whilst it is not set, keep looping
   355 00003750 A821                <1>     test al, 21h    ;Test bits 0 and 5 (error and drive fault)
   356 00003752 0F8558FFFFFF        <1>     jnz .errorExit   ;If either are set, return fail
   357 00003758 F8                  <1>     clc
   358 00003759 C3                  <1>     ret
   359                              <1> 
   360                              <1> .format:
   361                              <1>     ;A write which writes a byte to disk (0E5h for classical reasons)
   362 0000375A EE                  <1>     out dx, al  ;Output the command byte!
   363 0000375B 88C8                <1>     mov al, cl  ;Return sector count into al
   364                              <1> 
   365                              <1>     ;Now we wait for the DRQ bit in the status register to set
   366 0000375D 88C3                <1>     mov bl, al     ;Save sector count in bl to use as counter
   367                              <1> .formatWait:
   368 0000375F B9FFFFFFFF          <1>     mov ecx, -1  ;Data should be ready within ~67 miliseconds
   369 00003764 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   370 00003768 81C207000000        <1>     add edx, 7  ;Dummy read on Alt status register
   371                              <1> .formatWaitLoop:
   372 0000376E FFC9                <1>     dec ecx
   373 00003770 0F8432FFFFFF        <1>     jz .rTimeout
   374 00003776 EC                  <1>     in al, dx
   375 00003777 A880                <1>     test al, 80h     ;Is BSY set?
   376 00003779 75F3                <1>     jnz .formatWaitLoop   ;If so, keep looping
   377 0000377B A821                <1>     test al, 21h     ;Are error bits set?  
   378 0000377D 0F852DFFFFFF        <1>     jnz .errorExit   ;If not, must be ok to go
   379 00003783 A808                <1>     test al, 8h      ;Check DRQ, data ready bit is set
   380 00003785 74E7                <1>     jz .formatWaitLoop
   381                              <1> ;Now we can write the format data
   382 00003787 81EA07000000        <1>     sub edx, 7
   383 0000378D B900010000          <1>     mov ecx, 256    ;Number of words in a sector
   384 00003792 B8E5E50000          <1>     mov eax, 0E5E5h ;Format Signature Word
   385                              <1> .f1:
   386 00003797 66EF                <1>     out dx, ax  ;Write E5h to the disk!!
   387 00003799 EB00                <1>     jmp short $ + 2
   388 0000379B E2FA                <1>     loop .f1 ;Write one sector, one word at a time
   389 0000379D FECB                <1>     dec bl
   390 0000379F 75BE                <1>     jnz .formatWait  ;Keep going up by a sector
   391 000037A1 E949FFFFFF          <1>     jmp .formatEP   ;Goto the format entry point
   392                              <1> 
   393                              <1> ;CHS functions
   394                              <1> .readCHS:
   395                              <1> ;Called with rdi as a free register to use
   396                              <1> ;All other registers have parameters as in Int 33h function ah=02h
   397 000037A6 E87B000000          <1>     call .setupCHS
   398 000037AB 0F82FFFEFFFF        <1>     jc .errorExit
   399                              <1>     ;Send command
   400 000037B1 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   401 000037B5 81C207000000        <1>     add edx, 7  ;Goto command register
   402 000037BB 88C1                <1>     mov cl, al  ;Save sector count in cl
   403 000037BD B020                <1>     mov al, 20h ;ATA READ COMMAND!
   404 000037BF E989FEFFFF          <1>     jmp .read
   405                              <1> 
   406                              <1> .writeCHS:
   407                              <1> ;Called with rsi as a free register to use
   408                              <1> ;All other registers have parameters as in Int 33h function ah=02h
   409 000037C4 E85D000000          <1>     call .setupCHS
   410 000037C9 0F82E1FEFFFF        <1>     jc .errorExit
   411                              <1>     ;Send command
   412 000037CF 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   413 000037D3 81C207000000        <1>     add edx, 7  ;Goto command register
   414 000037D9 88C1                <1>     mov cl, al  ;Save sector count in cl
   415 000037DB B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   416 000037DD E9D0FEFFFF          <1>     jmp .write
   417                              <1> 
   418                              <1> .verifyCHS:
   419 000037E2 E83F000000          <1>     call .setupCHS
   420 000037E7 0F82C3FEFFFF        <1>     jc .errorExit
   421                              <1>     ;Send command
   422 000037ED 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   423 000037F1 81C207000000        <1>     add edx, 7  ;Goto command register
   424 000037F7 B040                <1>     mov al, 40h ;ATA VERIFY COMMAND!
   425 000037F9 E931FFFFFF          <1>     jmp .verify
   426                              <1> 
   427                              <1> .formatCHS:
   428                              <1> ;Ignore al (number of sectors) and cl[5:0] (Starting sector number)
   429 000037FE 668B4505            <1>     mov ax, word [rbp + fdiskTblEntry.wSecTrc] ;Get sectors in a track to clear
   430                              <1>     ;Sectors per track is always less than 256 so byte is ok!
   431 00003802 80E1C0              <1>     and cl, 0C0h    ;Clear bottom 6 bits. 
   432 00003805 80C901              <1>     or cl, 1        ;All tracks start at sector 1
   433 00003808 E819000000          <1>     call .setupCHS
   434 0000380D 0F829DFEFFFF        <1>     jc .errorExit
   435 00003813 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   436 00003817 81C207000000        <1>     add edx, 7  ;Goto command register
   437 0000381D 88C1                <1>     mov cl, al  ;Save sector count in cl
   438 0000381F B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   439 00003821 E934FFFFFF          <1>     jmp .format
   440                              <1> 
   441                              <1> .setupCHS:
   442                              <1>     ;First sets the chosen device, then sets all the registers
   443                              <1>     ; except for the command and then returns
   444 00003826 E802FDFFFF          <1>     call .selectDriveFromTable
   445 0000382B 722F                <1>     jc .sCHSFailed
   446                              <1>     ;Now the drive has been selected, we can write to it
   447 0000382D 50                  <1>     push rax    ;Only sector count needs to be preserved
   448 0000382E 52                  <1>     push rdx    ;Temporarily save drive head bits to use later
   449 0000382F 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   450 00003833 81C202000000        <1>     add edx, 2  ;Goto base + 2, Sector count
   451 00003839 EE                  <1>     out dx, al
   452 0000383A FFC2                <1>     inc edx     ;Goto base + 3, Starting sector number
   453 0000383C 88C8                <1>     mov al, cl  ;Bits [5:0] have starting sector number
   454 0000383E 243F                <1>     and al, 3Fh ;Clear upper two bits
   455 00003840 EE                  <1>     out dx, al
   456 00003841 FFC2                <1>     inc edx     ;Goto base + 4, Cylinder low bits
   457 00003843 88E8                <1>     mov al, ch  ;Get the low 8 bits of the cylinder number
   458 00003845 EE                  <1>     out dx, al
   459 00003846 FFC2                <1>     inc edx     ;Goto base + 5, Cylinder high bits
   460 00003848 88C8                <1>     mov al, cl  ;Bits [7:6] have top two bits of cylinder number
   461 0000384A C0E806              <1>     shr al, 6   ;Shift them down to clear bottom 6 bits
   462 0000384D EE                  <1>     out dx, al  
   463 0000384E FFC2                <1>     inc edx     ;Goto base + 6, Drive/Head controller register
   464 00003850 58                  <1>     pop rax     ;Get back the drive head number from dh into ah
   465 00003851 88E0                <1>     mov al, ah  
   466 00003853 240F                <1>     and al, 0Fh ;Save only bottom nybble
   467 00003855 0A4515              <1>     or al, byte [rbp + fdiskTblEntry.msBit]    ;Add the MS bits to al
   468 00003858 EE                  <1>     out dx, al
   469 00003859 58                  <1>     pop rax
   470 0000385A F8                  <1>     clc
   471 0000385B C3                  <1>     ret
   472                              <1> .sCHSFailed:
   473 0000385C C60425[A9010000]20  <1>     mov byte [msdStatus], 20h   ;General controller failure
   474 00003864 C3                  <1>     ret ;Carry flag propagated
   475                              <1> 
   476                              <1> ;LBA functions
   477                              <1> .readLBA:
   478 00003865 E873000000          <1>     call .setupLBA
   479 0000386A 0F8240FEFFFF        <1>     jc .errorExit
   480                              <1>     ;Send command
   481 00003870 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   482 00003874 81C207000000        <1>     add edx, 7  ;Goto command register
   483 0000387A 88C1                <1>     mov cl, al  ;Save sector count in cl
   484 0000387C B020                <1>     mov al, 20h ;ATA READ COMMAND!
   485 0000387E E9CAFDFFFF          <1>     jmp .read
   486                              <1> 
   487                              <1> .writeLBA:
   488 00003883 E855000000          <1>     call .setupLBA
   489 00003888 0F8222FEFFFF        <1>     jc .errorExit
   490                              <1>     ;Send command
   491 0000388E 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   492 00003892 81C207000000        <1>     add edx, 7  ;Goto command register
   493 00003898 88C1                <1>     mov cl, al  ;Save sector count in cl
   494 0000389A B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   495 0000389C E911FEFFFF          <1>     jmp .write
   496                              <1> 
   497                              <1> .verifyLBA:
   498 000038A1 E837000000          <1>     call .setupLBA
   499 000038A6 0F8204FEFFFF        <1>     jc .errorExit
   500                              <1>     ;Send command
   501 000038AC 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   502 000038B0 81C207000000        <1>     add edx, 7  ;Goto command register
   503 000038B6 88C1                <1>     mov cl, al  ;Save sector count in cl
   504 000038B8 B040                <1>     mov al, 40h ;ATA VERIFY COMMAND!
   505 000038BA E970FEFFFF          <1>     jmp .verify
   506                              <1> 
   507                              <1> .formatLBA:
   508 000038BF E819000000          <1>     call .setupLBA
   509 000038C4 0F82E6FDFFFF        <1>     jc .errorExit
   510                              <1>     ;Send command
   511 000038CA 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   512 000038CE 81C207000000        <1>     add edx, 7  ;Goto command register
   513 000038D4 88C1                <1>     mov cl, al  ;Save sector count in cl
   514 000038D6 B030                <1>     mov al, 30h ;ATA WRITE COMMAND!
   515 000038D8 E97DFEFFFF          <1>     jmp .format
   516                              <1> 
   517                              <1> .setupLBA:
   518                              <1>     ;First sets the chosen device, then sets all the registers
   519                              <1>     ; except for the command and then returns
   520 000038DD E84BFCFFFF          <1>     call .selectDriveFromTable
   521 000038E2 7233                <1>     jc .sLBAFailed
   522 000038E4 50                  <1>     push rax        ;Save sector count on stack
   523 000038E5 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   524 000038E9 81C202000000        <1>     add edx, 2      ;Goto base + 2, Sector count
   525 000038EF EE                  <1>     out dx, al      ;Output sector number
   526 000038F0 FFC2                <1>     inc edx         ;Goto base + 3, LBA low
   527 000038F2 88C8                <1>     mov al, cl      ;Get LBA low address
   528 000038F4 C1E908              <1>     shr ecx, 8      ;Get second byte low
   529 000038F7 EE                  <1>     out dx, al      
   530                              <1> 
   531 000038F8 FFC2                <1>     inc edx         ;Goto base + 4, LBA mid
   532 000038FA 88C8                <1>     mov al, cl      ;Get LBA second byte
   533 000038FC C1E908              <1>     shr ecx, 8      ;Get third byte low
   534 000038FF EE                  <1>     out dx, al
   535                              <1> 
   536 00003900 FFC2                <1>     inc edx         ;Goto base + 5, LBA high
   537 00003902 88C8                <1>     mov al, cl      ;Get LBA third byte
   538 00003904 C1E908              <1>     shr ecx, 8      ;Get final nybble into cl
   539 00003907 EE                  <1>     out dx, al
   540                              <1> 
   541 00003908 FFC2                <1>     inc edx         ;Goto base + 6, LBA upper bits and drive select
   542 0000390A 88C8                <1>     mov al, cl      ;Get final nybble into al
   543 0000390C 240F                <1>     and al, 0Fh     ;Clear extra bits
   544 0000390E 0A4515              <1>     or al, byte [rbp + fdiskTblEntry.msBit]    ;Add the master/slave bit and fixed bits
   545 00003911 0C40                <1>     or al, 40h      ;Set LBA bit
   546 00003913 EE                  <1>     out dx, al
   547 00003914 58                  <1>     pop rax  ;Return sector count into al
   548 00003915 F8                  <1>     clc
   549 00003916 C3                  <1>     ret
   550                              <1> .sLBAFailed:
   551 00003917 C60425[A9010000]20  <1>     mov byte [msdStatus], 20h   ;General controller failure
   552 0000391F C3                  <1>     ret ;Carry flag propagated
   553                              <1> 
   554                              <1> ;LBA48 functions
   555                              <1> .readLBA48:
   556 00003920 E873000000          <1>     call .setupLBA48
   557 00003925 0F8285FDFFFF        <1>     jc .errorExit
   558                              <1>     ;Send command
   559 0000392B 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   560 0000392F 81C207000000        <1>     add edx, 7  ;Goto command register
   561 00003935 88C1                <1>     mov cl, al  ;Save sector count in cl
   562 00003937 B024                <1>     mov al, 24h ;ATA READ EXT COMMAND!
   563 00003939 E90FFDFFFF          <1>     jmp .read
   564                              <1> 
   565                              <1> .writeLBA48:
   566 0000393E E855000000          <1>     call .setupLBA48
   567 00003943 0F8267FDFFFF        <1>     jc .errorExit
   568                              <1>     ;Send command
   569 00003949 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   570 0000394D 81C207000000        <1>     add edx, 7  ;Goto command register
   571 00003953 88C1                <1>     mov cl, al  ;Save sector count in cl
   572 00003955 B034                <1>     mov al, 34h ;ATA WRITE EXT COMMAND!
   573 00003957 E956FDFFFF          <1>     jmp .write
   574                              <1> 
   575                              <1> .verifyLBA48:
   576 0000395C E837000000          <1>     call .setupLBA48
   577 00003961 0F8249FDFFFF        <1>     jc .errorExit
   578                              <1>     ;Send command
   579 00003967 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   580 0000396B 81C207000000        <1>     add edx, 7  ;Goto command register
   581 00003971 88C1                <1>     mov cl, al  ;Save sector count in cl
   582 00003973 B042                <1>     mov al, 42h ;ATA VERIFY EXT COMMAND!
   583 00003975 E9B5FDFFFF          <1>     jmp .verify
   584                              <1> 
   585                              <1> .formatLBA48:
   586 0000397A E819000000          <1>     call .setupLBA48
   587 0000397F 0F822BFDFFFF        <1>     jc .errorExit
   588                              <1>     ;Send command
   589 00003985 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   590 00003989 81C207000000        <1>     add edx, 7  ;Goto command register
   591 0000398F 88C1                <1>     mov cl, al  ;Save sector count in cl
   592 00003991 B034                <1>     mov al, 34h ;ATA WRITE EXT COMMAND!
   593 00003993 E9C2FDFFFF          <1>     jmp .format
   594                              <1> 
   595                              <1> .setupLBA48:
   596                              <1> ;First sets the chosen device, then sets all the registers
   597                              <1>     ; except for the command and then returns
   598 00003998 E890FBFFFF          <1>     call .selectDriveFromTable
   599 0000399D 0F8274FFFFFF        <1>     jc .sLBAFailed
   600 000039A3 50                  <1>     push rax        ;Save sector count on stack
   601 000039A4 0FB75513            <1>     movzx edx, word [rbp + fdiskTblEntry.ioBase]
   602 000039A8 81C202000000        <1>     add edx, 2      ;Goto base + 2, Sector count
   603 000039AE 48C1C918            <1>     ror rcx, 24     ;Move the upper three bytes low
   604 000039B2 30C0                <1>     xor al, al      ;High byte of sector count is always 0
   605 000039B4 EE                  <1>     out dx, al
   606                              <1> 
   607 000039B5 FFC2                <1>     inc edx         ;Goto base + 3, Write LBA byte 4
   608 000039B7 88C8                <1>     mov al, cl      ;Get LBA byte 4 into al
   609 000039B9 EE                  <1>     out dx, al
   610 000039BA 48C1E908            <1>     shr rcx, 8      ;Shift bytes down by 1
   611                              <1> 
   612 000039BE FFC2                <1>     inc edx         ;Goto base + 4, Write LBA byte 5
   613 000039C0 88C8                <1>     mov al, cl      ;Get LBA byte 5 into al
   614 000039C2 EE                  <1>     out dx, al
   615 000039C3 48C1E908            <1>     shr rcx, 8      ;Shift bytes down by 1
   616                              <1> 
   617 000039C7 FFC2                <1>     inc edx         ;Goto base + 5, Write LBA byte 6
   618 000039C9 88C8                <1>     mov al, cl      ;Get LBA byte 6 into al
   619 000039CB EE                  <1>     out dx, al
   620                              <1> 
   621 000039CC 48C1E918            <1>     shr rcx, 24     ;Shift down by an extra two to eliminate two dummy bytes
   622                              <1> ;cl now has LBA byte 1 again
   623 000039D0 81EA03000000        <1>     sub edx, 3      ;Goto base + 2, Write low byte of sector count
   624 000039D6 58                  <1>     pop rax         ;Get back sector count from stack
   625 000039D7 50                  <1>     push rax        ;Push it back onto the stack
   626 000039D8 EE                  <1>     out dx, al
   627                              <1> 
   628 000039D9 FFC2                <1>     inc edx         ;Goto base + 3, Write LBA byte 1
   629 000039DB 88C8                <1>     mov al, cl      ;Get LBA byte 1 into al
   630 000039DD EE                  <1>     out dx, al
   631 000039DE 48C1E908            <1>     shr rcx, 8      ;Shift bytes down by 1
   632                              <1> 
   633 000039E2 FFC2                <1>     inc edx         ;Goto base + 4, Write LBA byte 2
   634 000039E4 88C8                <1>     mov al, cl      ;Get LBA byte 2 into al
   635 000039E6 EE                  <1>     out dx, al
   636 000039E7 48C1E908            <1>     shr rcx, 8
   637                              <1> 
   638 000039EB FFC2                <1>     inc edx         ;Goto base + 5, Write LBA byte 3
   639 000039ED 88C8                <1>     mov al, cl      ;Get LBA byte 3 into al
   640 000039EF EE                  <1>     out dx, al
   641                              <1> 
   642 000039F0 FFC2                <1>     inc edx         ;Goto base + 6, write drive select
   643 000039F2 8A4515              <1>     mov al, byte [rbp + fdiskTblEntry.msBit]    ;Add the master/slave bit and fixed bits
   644 000039F5 0C40                <1>     or al, 40h      ;Set LBA bit
   645 000039F7 EE                  <1>     out dx, al
   646                              <1> 
   647 000039F8 58                  <1>     pop rax  ;Return sector count into al
   648 000039F9 F8                  <1>     clc
   649 000039FA C3                  <1>     ret
   110                                  %include "./Source/Resident/Hardware/USB/EHCI/ehciDriv.asm"
     1                              <1> ;--------------------USB Driver and data area--------------------
     2                              <1> ;Note, this needs to be updated.
     3                              <1> ;All SCSI, MSD and HUB related functions are grouped in this file
     4                              <1> ;SCSI functions need to be moved into their own folder
     5                              <1> USB:
     6                              <1> ;------------------------EHCI functions--------------------------
     7                              <1> ;eActiveCtrlr must be set with the offset of the controller
     8                              <1> ; IFF the controller is about to enter a state in which it could
     9                              <1> ; fire an interrupt. These functions must safeguard against it by
    10                              <1> ; checking that this byte is -1 first and then setting the byte
    11                              <1> ; with the selected controller index, ending by resetting this 
    12                              <1> ; byte to -1 (even on fail). 
    13                              <1> ;
    14                              <1> ;Certain functions may be called to act upon the CURRENT ACTIVE
    15                              <1> ; controller, these functions dont need these safeguards, though
    16                              <1> ; they may need to ensure that there is a valid controller number 
    17                              <1> ; in the eActiveCtrlr byte.
    18                              <1> ;----------------------------------------------------------------
    19                              <1> .ehciCriticalErrorWrapper:
    20                              <1> ;Currently just jumps to the installed address.
    21                              <1> ;Conditional error calls MUST call this wrapper to allow for
    22                              <1> ; host operating systems to install their own USB error handlers
    23                              <1> ; and have the system continue working.
    24 000039FB FF2425[37020000]    <1>     jmp qword [eHCErrorHandler]
    25                              <1> .ehciCriticalErrorHandler:
    26                              <1> ;Currently just halts the system
    27 00003A02 BB07000000          <1>     mov ebx, 07h
    28 00003A07 E8EBC6FFFF          <1>     call cls
    29 00003A0C 48BD-               <1>     mov rbp, .ecehmsg
    29 00003A0E [293A000000000000]  <1>
    30 00003A16 66B80413            <1>     mov ax, 1304h
    31 00003A1A CD30                <1>     int 30h
    32 00003A1C B0FF                <1>     mov al, 0FFh
    33 00003A1E E621                <1>     out pic1data, al
    34 00003A20 E6A1                <1>     out pic2data, al
    35 00003A22 FA                  <1>     cli
    36 00003A23 F4                  <1>     hlt
    37 00003A24 E9F9FFFFFF          <1>     jmp $ - 2
    38 00003A29 454843492043686563- <1> .ecehmsg db "EHCI Check 1", 0
    38 00003A32 6B203100            <1>
    39                              <1> .setupEHCIcontroller:
    40                              <1> ;Resets, initialises variables to default
    41                              <1> ;Input: al = Controller to setup (0 based)
    42                              <1> ;Output: CF=CY - Controller failed to reset
    43                              <1> ;        CF=NC - No problems
    44                              <1> ; al = Controller that was reset
    45 00003A36 51                  <1>     push rcx
    46 00003A37 53                  <1>     push rbx
    47 00003A38 55                  <1>     push rbp
    48 00003A39 E80F010000          <1>     call .ehciResetCtrlr    ;Reset the controller
    49 00003A3E 7215                <1>     jc .secexit
    50 00003A40 6631DB              <1>     xor bx, bx ;No schedule, no interrupts
    51 00003A43 31C9                <1>     xor ecx, ecx
    52 00003A45 48BD-               <1>     mov rbp, ehciAschedule
    52 00003A47 [0000000000000000]  <1>
    53 00003A4F E8EB010000          <1>     call .ehciInitCtrlrRegs    ;Initialise controller registers
    54 00003A54 F8                  <1>     clc
    55                              <1> .secexit:
    56 00003A55 5D                  <1>     pop rbp
    57 00003A56 5B                  <1>     pop rbx
    58 00003A57 59                  <1>     pop rcx
    59 00003A58 C3                  <1>     ret
    60                              <1> 
    61                              <1> .ehciResetControllerPort:
    62                              <1> ;A function that enacts an EHCI reset on a port.
    63                              <1> ;Works ONLY on the current active controller.
    64                              <1> ;Input:
    65                              <1> ; al = Port number [0,N-1] (Checked against ctrlr struc params entry)
    66                              <1> ;Returns:
    67                              <1> ; CF set if failed, clear if success
    68                              <1> ; ax=Error code, 0h=No active controller
    69                              <1> ;             1h=Invalid port number
    70                              <1> ;             2h=No device on port
    71                              <1> ;             3h=Port not enabled (Low speed device)
    72                              <1> ;             4h=Device not entering reset
    73                              <1> ;             5h=Device not clearing reset
    74                              <1> ;             6h=Port not enabled (Full speed device)
    75                              <1> ; rax destroyed
    76 00003A59 53                  <1>     push rbx
    77 00003A5A 51                  <1>     push rcx
    78 00003A5B 52                  <1>     push rdx
    79 00003A5C 55                  <1>     push rbp
    80                              <1> 
    81 00003A5D 6631ED              <1>     xor bp, bp
    82 00003A60 0FB6D0              <1>     movzx edx, al    ;Save port number into dl (edx)
    83 00003A63 0FB61C25[48020000]  <1>     movzx ebx, byte [eActiveCtrlr]
    84 00003A6B 80FBFF              <1>     cmp bl, -1
    85 00003A6E 0F84D3000000        <1>     je .ercperr    ;Error, No active controller (ec=0)
    86 00003A74 66FFC5              <1>     inc bp        ;Inc error counter
    87 00003A77 8B1CDD[1A020000]    <1>     mov ebx, dword [eControllerList + 4 + 8*rbx]    ;get mmiobase into ebx
    88 00003A7E 678B4304            <1>     mov eax, dword [ebx+ehcistrucparams]    ;Get # of ports in al
    89 00003A82 247F                <1>     and al, 7Fh    ;al contains port number, clear upper bit
    90 00003A84 FEC8                <1>     dec al        ;Zero based port number
    91 00003A86 0FB6C0              <1>     movzx eax, al
    92 00003A89 38C2                <1>     cmp dl, al    ;dl contains called port number
    93 00003A8B 0F87B6000000        <1>     ja .ercperr    ;Error, invalid port number (ec=1)
    94 00003A91 66FFC5              <1>     inc bp        ;Inc error counter
    95                              <1> 
    96                              <1> 
    97 00003A94 670FB603            <1>     movzx eax, byte [ebx]    ;Byte access for caplength!
    98 00003A98 01C3                <1>     add ebx, eax    ;eax now points to opregs    
    99 00003A9A 66B90A00            <1>     mov cx, 10
   100                              <1> .erclp0:    ;Remember ebx=opregs, edx=port number    
   101 00003A9E 67814C934400100000  <1>     or dword [ebx+4*edx+ehciportsc], 1000h ;Set power bit
   102                              <1> 
   103 00003AA7 51                  <1>     push rcx
   104 00003AA8 B90A000000          <1>     mov ecx, 10
   105 00003AAD B486                <1>     mov ah, 86h
   106 00003AAF CD35                <1>     int 35h        ;Wait for 10 ms
   107 00003AB1 59                  <1>     pop rcx
   108                              <1> 
   109                              <1> .erclp1:
   110 00003AB2 66FFC9              <1>     dec cx
   111 00003AB5 0F848C000000        <1>     jz .ercperr ;Error, No device on port (ec=2)
   112 00003ABB 67F744934401000000  <1>     test dword [ebx+4*edx+ehciportsc], 1h    ;Test device on port
   113 00003AC4 74D8                <1>     jz .erclp0
   114 00003AC6 66FFC5              <1>     inc bp        ;Inc error counter
   115                              <1> 
   116 00003AC9 678B449344          <1>     mov eax, dword [ebx+4*edx+ehciportsc]
   117 00003ACE 6625000C            <1>     and ax, 0C00h
   118 00003AD2 662D0004            <1>     sub ax, 400h
   119 00003AD6 66FFC8              <1>     dec ax
   120 00003AD9 746C                <1>     jz .ercperr    ;Error, Low speed device (ec=3)
   121 00003ADB 66FFC5              <1>     inc bp        ;Inc error counter
   122                              <1> 
   123 00003ADE 66B90A00            <1>     mov cx, 10
   124                              <1> .erclp2:
   125 00003AE2 66FFC9              <1>     dec cx
   126 00003AE5 7460                <1>     jz .ercperr ;Error, Device not entering reset (ec=4)
   127 00003AE7 67814C934400010000  <1>     or dword [ebx+4*edx+ehciportsc], 100h    ;Set bit 8, port reset bit
   128                              <1>     
   129 00003AF0 51                  <1>     push rcx
   130 00003AF1 B90A000000          <1>     mov ecx, 10
   131 00003AF6 B486                <1>     mov ah, 86h
   132 00003AF8 CD35                <1>     int 35h        ;Wait for 10 ms
   133 00003AFA 59                  <1>     pop rcx
   134                              <1> 
   135 00003AFB 67F744934400010000  <1>     test dword [ebx+4*edx+ehciportsc], 100h    ;Check if entered reset
   136 00003B04 74DC                <1>     jz .erclp2
   137                              <1> 
   138 00003B06 66FFC5              <1>     inc bp        ;Inc error counter
   139 00003B09 66B90A00            <1>     mov cx, 10
   140 00003B0D 6781649344FFFEFFFF  <1>     and dword [ebx+4*edx+ehciportsc], 0FFFFFEFFh    ;Clear reset bit
   141                              <1> .erclp3:
   142 00003B16 FFC9                <1>     dec ecx
   143 00003B18 742D                <1>     jz .ercperr ;Error, Device not leaving reset (ec=5)
   144                              <1> 
   145 00003B1A 51                  <1>     push rcx
   146 00003B1B B90A000000          <1>     mov ecx, 10
   147 00003B20 B486                <1>     mov ah, 86h
   148 00003B22 CD35                <1>     int 35h        ;Wait for 10 ms
   149 00003B24 59                  <1>     pop rcx
   150                              <1> 
   151 00003B25 67F744934400010000  <1>     test dword [ebx+4*edx+ehciportsc], 100h
   152 00003B2E 75E6                <1>     jnz .erclp3
   153 00003B30 66FFC5              <1>     inc bp        ;Inc error counter
   154                              <1> 
   155 00003B33 67F744934404000000  <1>     test dword [ebx+4*edx+ehciportsc], 4h    ;Bit 2 is the port enabled bit
   156 00003B3C 7409                <1>     jz .ercperr    ;Error, Full speed device (ec=6)
   157                              <1> ;We get here IFF device on port is high speed
   158                              <1>     
   159                              <1> ;High Speed Device successfully reset. Now print message or whatever
   160 00003B3E 4831C0              <1>     xor rax, rax
   161 00003B41 F8                  <1>     clc
   162                              <1> .ercpexit:
   163 00003B42 5D                  <1>     pop rbp
   164 00003B43 5A                  <1>     pop rdx
   165 00003B44 59                  <1>     pop rcx
   166 00003B45 5B                  <1>     pop rbx
   167 00003B46 C3                  <1>     ret
   168                              <1> .ercperr:
   169 00003B47 6689E8              <1>     mov ax, bp    ;Get error code in ax
   170 00003B4A F9                  <1>     stc
   171 00003B4B EBF5                <1>     jmp short .ercpexit
   172                              <1> 
   173                              <1> .ehciResetCtrlr:
   174                              <1> ;A function that resets a controller. 
   175                              <1> ;No other controllers may be running during a ctrlr reset
   176                              <1> ;Input:
   177                              <1> ; al = Offset into the ehci controller table
   178                              <1> ;Returns:
   179                              <1> ; CF=CY if failed, CF=NC if reset
   180                              <1> ;All registers preserved
   181 00003B4D 50                  <1>     push rax
   182 00003B4E 51                  <1>     push rcx
   183                              <1>     ;cmp byte [eActiveCtrlr], -1
   184                              <1>     ;jne .erc2    ;A controller already active, exit fail (ec=0)
   185                              <1>     ;mov byte [eActiveCtrlr], al    ;For added security (may be removed later)
   186 00003B4F E8A5180000          <1>     call .ehciGetOpBase
   187 00003B54 67C7400800000000    <1>     mov dword [eax + ehciintr], 0h    ;No interrupts
   188 00003B5C 67C740043F000000    <1>     mov dword [eax + ehcists], 3Fh    ;Clear any outstanding interrupts
   189                              <1>     ;Set the reset bit, check to see if run bit has cleared first!
   190 00003B64 31C9                <1>     xor ecx, ecx
   191                              <1> .erc0:
   192 00003B66 678120FEFFFFFF      <1>     and dword [eax + ehcicmd], 0FFFFFFFEh    ;Force stop the controller
   193 00003B6D FFC9                <1>     dec ecx
   194 00003B6F 743D                <1>     jz .erc2    ;Controller not resetting, exit fail  (ec=1)
   195                              <1> 
   196 00003B71 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;Test if bit 12 has been set
   197 00003B79 74EB                <1>     jz .erc0
   198 00003B7B 67810802000000      <1>     or dword [eax + ehcicmd], 02h ;Set bit 1, reset HC
   199                              <1>     ;Spin and wait to give device time to respond and reset.
   200 00003B82 6631C9              <1>     xor cx, cx
   201                              <1> .erc1:
   202 00003B85 66FFC9              <1>     dec cx        ;Wait for reset to happen
   203 00003B88 7424                <1>     jz .erc2    ;Not resetting, exit fail (ec=2)
   204                              <1> 
   205 00003B8A 50                  <1>     push rax
   206 00003B8B 51                  <1>     push rcx
   207 00003B8C B486                <1>     mov ah, 86h
   208 00003B8E B905000000          <1>     mov ecx, 5    ;5ms wait
   209 00003B93 CD35                <1>     int 35h
   210 00003B95 59                  <1>     pop rcx
   211 00003B96 58                  <1>     pop rax
   212                              <1> 
   213 00003B97 67F70002000000      <1>     test dword [eax + ehcicmd], 2h    ;Whilst this bit is set, keep looping
   214 00003B9E 75E5                <1>     jnz .erc1
   215 00003BA0 31C0                <1>     xor eax, eax
   216 00003BA2 F8                  <1>     clc
   217                              <1> .ercexit:
   218 00003BA3 C60425[48020000]FF  <1>     mov byte [eActiveCtrlr], -1    ;No controllers active
   219 00003BAB 59                  <1>     pop rcx
   220 00003BAC 58                  <1>     pop rax
   221 00003BAD C3                  <1>     ret
   222                              <1> .erc2:
   223 00003BAE F9                  <1>     stc
   224 00003BAF EBF2                <1>     jmp short .ercexit
   225                              <1> 
   226                              <1> .ehciRunCtrlr:
   227                              <1> ;A function that runs a controller to process set schedules
   228                              <1> ;Input:
   229                              <1> ;   al = Offset into the controller table
   230                              <1> ;Returns:
   231                              <1> ; CF = CY if failed, CF = NC if success
   232 00003BB1 50                  <1>     push rax
   233 00003BB2 51                  <1>     push rcx
   234 00003BB3 E841180000          <1>     call .ehciGetOpBase
   235 00003BB8 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;bit 12 must be set to write 1 in cmd
   236 00003BC0 741E                <1>     jz .esc2
   237 00003BC2 67810801000000      <1>     or dword [eax + ehcicmd], 1h ;Set bit 0 to run
   238 00003BC9 31C9                <1>     xor ecx, ecx
   239                              <1> .esc0:
   240 00003BCB 66FFC9              <1>     dec cx
   241 00003BCE 7410                <1>     jz .esc2
   242 00003BD0 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;bit 12 must be clear
   243 00003BD8 75F1                <1>     jnz .esc0
   244 00003BDA 31C0                <1>     xor eax, eax
   245 00003BDC F8                  <1>     clc
   246                              <1> .esc1:
   247 00003BDD 59                  <1>     pop rcx
   248 00003BDE 58                  <1>     pop rax
   249 00003BDF C3                  <1>     ret
   250                              <1> .esc2:    ;Bad exit
   251 00003BE0 F9                  <1>     stc
   252 00003BE1 EBFA                <1>     jmp short .esc1
   253                              <1> 
   254                              <1> .ehciStopCtrlr:
   255                              <1> ;A function that stops current active controller from running
   256                              <1> ;Input:
   257                              <1> ; al=Controller to stop processing
   258                              <1> ;Returns:
   259                              <1> ; CF set if failed to stop, clear if success
   260 00003BE3 50                  <1>     push rax
   261 00003BE4 51                  <1>     push rcx
   262 00003BE5 480FB60425-         <1>     movzx rax, byte [eActiveCtrlr]
   262 00003BEA [48020000]          <1>
   263 00003BEE E806180000          <1>     call .ehciGetOpBase
   264 00003BF3 678120FEFFFFFF      <1>     and dword [eax + ehcicmd], 0FFFFFFFEh    ;Stop controller
   265 00003BFA 31C9                <1>     xor ecx, ecx
   266                              <1> .estc0:
   267 00003BFC 66FFC9              <1>     dec cx
   268 00003BFF 740E                <1>     jz .estc1
   269 00003C01 67F7400400100000    <1>     test dword [eax + ehcists], 1000h    ;test hchalted until set
   270 00003C09 74F1                <1>     jz .estc0
   271 00003C0B F8                  <1>     clc
   272                              <1> .estcexit:
   273 00003C0C 59                  <1>     pop rcx
   274 00003C0D 58                  <1>     pop rax
   275 00003C0E C3                  <1>     ret
   276                              <1> .estc1:
   277 00003C0F F9                  <1>     stc
   278 00003C10 EBFA                <1>     jmp short .estcexit
   279                              <1> .ehciAdjustAsyncSchedCtrlr:
   280                              <1> ;This function checks the currently online controller and compares it to
   281                              <1> ; the value provided in al. 
   282                              <1> ;If they are equal, do nothing.
   283                              <1> ;If not, turn off controller, update active ctrlr byte and indicate a new bus 
   284                              <1> ; was activated.
   285                              <1> ;If no controller active, update active ctrlr byte and indicate which bus 
   286                              <1> ; has been activated.
   287                              <1> ;
   288                              <1> ; Input: al = Controller to activate, preserved.
   289                              <1> ; Output: CF=CY: Error, turn off all controllers
   290                              <1> ;         CF=NC: All ok, proceed
   291 00003C12 3A0425[48020000]    <1>     cmp al, byte [eActiveCtrlr]
   292 00003C19 7420                <1>     je .eacOkExit
   293 00003C1B 803C25[48020000]FF  <1>     cmp byte [eActiveCtrlr], -1
   294 00003C23 7407                <1>     je .eacStart
   295 00003C25 E8D8020000          <1>     call .ehciStopAsyncSchedule ;Stop currently transacting controller
   296 00003C2A 7211                <1>     jc .eacBad
   297                              <1> .eacStart:
   298 00003C2C 880425[48020000]    <1>     mov byte [eActiveCtrlr], al ;Set new active controller
   299 00003C33 C60425[47020000]01  <1>     mov byte [eNewBus], 1   ;Set flag that a new bus has been selected
   300                              <1> .eacOkExit:
   301 00003C3B F8                  <1>     clc
   302 00003C3C C3                  <1>     ret
   303                              <1> .eacBad:
   304 00003C3D F9                  <1>     stc
   305 00003C3E C3                  <1>     ret
   306                              <1> .ehciInitCtrlrRegs:
   307                              <1> ;A function that initialises a given controllers registers as needed.
   308                              <1> ;Controller is left ready to process data start schedules
   309                              <1> ;MUST NOT BE CALLED ON A RUNNING CONTROLLER
   310                              <1> ;Input:
   311                              <1> ; al = Offset into the ehci controller table
   312                              <1> ; bl = ehciintr mask
   313                              <1> ; bh = Schedule mask, bits [7:2] reserved
   314                              <1> ;        00b = No schedule, 01b=Periodic, 10b=Async, 11b=Both
   315                              <1> ; ecx = Frame Index
   316                              <1> ; rbp = Schedule address
   317                              <1> ;Returns:
   318                              <1> ; Nothing
   319 00003C3F 50                  <1>     push rax
   320 00003C40 53                  <1>     push rbx
   321 00003C41 51                  <1>     push rcx
   322 00003C42 53                  <1>     push rbx
   323 00003C43 E8B1170000          <1>     call .ehciGetOpBase    ;Get opbase 
   324 00003C48 0FB7DB              <1>     movzx ebx, bx
   325 00003C4B 67C7400800000000    <1>     mov dword [eax + ehciintr], 0
   326 00003C53 6789480C            <1>     mov dword [eax + ehcifrindex], ecx
   327 00003C57 67896818            <1>     mov dword [eax + ehciasyncaddr], ebp
   328 00003C5B 48C1CD20            <1>     ror rbp, 20h    ;Get upper dword low
   329 00003C5F 67896810            <1>     mov dword [eax + ehcictrlseg], ebp
   330 00003C63 5B                  <1>     pop rbx    ;Get back bh
   331 00003C64 30DB                <1>     xor bl, bl    ;Zero lo byte
   332 00003C66 66C1EB04            <1>     shr bx, 4    ;Shift to hi nybble of lo byte
   333 00003C6A 678120CF000000      <1>     and dword [eax + ehcicmd], 0CFh    ;Clear schedule enable bits
   334 00003C71 670B18              <1>     or ebx, dword [eax + ehcicmd]    ;Add ehcicmd to schedule mask
   335 00003C74 81E3F3FF00FF        <1>     and ebx, 0FF00FFF3h    ;Clear the Int Threshold and Frame List bits
   336 00003C7A 81CB00000800        <1>     or ebx, 000080000h ;Set 8 microframes (1 ms) per interrupt
   337 00003C80 678918              <1>     mov dword [eax + ehcicmd], ebx    ;Write back
   338 00003C83 67C7404001000000    <1>     mov dword [eax + ehciconfigflag], 1h    ;Route all ports to EHCI ctrlr
   339 00003C8B 59                  <1>     pop rcx
   340 00003C8C 5B                  <1>     pop rbx
   341 00003C8D 58                  <1>     pop rax
   342 00003C8E C3                  <1>     ret
   343                              <1> .ehciCtrlrGetNumberOfPorts:
   344                              <1> ;Gets the number of ports on a Host Controller.
   345                              <1> ;Ports are zero addressed so ports numbers are 0 to NUMBER_OF_PORTS - 1
   346                              <1> ;Input:  al = Offset into the controller table
   347                              <1> ;Output: rax = Number of ports on controller.
   348                              <1> ;Warning, input NOT bounds checked.
   349 00003C8F 0FB6C0              <1>     movzx eax, al
   350 00003C92 8B04C5[1A020000]    <1>     mov eax, dword [eControllerList + 4 + 8*rax]
   351 00003C99 678B4004            <1>     mov eax, dword [eax + ehcistrucparams]
   352 00003C9D 257F000000          <1>     and eax, 7Fh    ;Clear upper bits
   353 00003CA2 C3                  <1>     ret
   354                              <1> .ehciGetNewQHeadAddr:
   355                              <1> ;Picks which QHead position to put the new Qhead into
   356                              <1> ;Input: Nothing
   357                              <1> ;Output: rdi = Position in RAM for QHead
   358                              <1> ;        r8  = Link to next QHead
   359                              <1> ;           r8 NEEDS to be or'ed with 2 when used as a QHead pointer
   360 00003CA3 49B8-               <1>     mov r8, ehciQHead1
   360 00003CA5 [8000000000000000]  <1>
   361 00003CAD 48BF-               <1>     mov rdi, ehciQHead0
   361 00003CAF [0000000000000000]  <1>
   362 00003CB7 483B3C25[3F020000]  <1>     cmp rdi, qword [eCurrAsyncHead]   ;Compare head to start of buffer
   363 00003CBF 7503                <1>     jne .egnqaexit
   364 00003CC1 4987F8              <1>     xchg rdi, r8
   365                              <1> .egnqaexit:
   366 00003CC4 C3                  <1>     ret
   367                              <1> 
   368                              <1> .ehciToggleTransactingQHead:
   369                              <1> ;Toggles the transacting Qhead position
   370                              <1> ;This is called AFTER the old Qhead has been delinked from the AsynchSchedule
   371 00003CC5 48813C25[3F020000]- <1>     cmp qword [eCurrAsyncHead], ehciQHead0
   371 00003CCD [00000000]          <1>
   372 00003CD1 750D                <1>     jne .ettqh0
   373 00003CD3 48C70425[3F020000]- <1>     mov qword [eCurrAsyncHead], ehciQHead1
   373 00003CDB [80000000]          <1>
   374 00003CDF C3                  <1>     ret
   375                              <1> .ettqh0:
   376 00003CE0 48C70425[3F020000]- <1>     mov qword [eCurrAsyncHead], ehciQHead0
   376 00003CE8 [00000000]          <1>
   377 00003CEC C3                  <1>     ret
   378                              <1> 
   379                              <1> .ehciDelinkOldQHead:
   380                              <1> ;Delinks the old Qhead from the list async list
   381 00003CED 57                  <1>     push rdi
   382 00003CEE 4150                <1>     push r8
   383 00003CF0 E8AEFFFFFF          <1>     call .ehciGetNewQHeadAddr
   384 00003CF5 4989F8              <1>     mov r8, rdi
   385 00003CF8 4981C802000000      <1>     or r8, 2
   386 00003CFF 448907              <1>     mov dword [rdi], r8d    ;Point the new qhead to itself
   387 00003D02 814F0400800000      <1>     or dword [rdi + 4], 8000h   ;Toggle H-bit in the current transacting QHead
   388 00003D09 4158                <1>     pop r8
   389 00003D0B 5F                  <1>     pop rdi
   390 00003D0C C3                  <1>     ret
   391                              <1> 
   392                              <1> .ehciLinkNewQHead:
   393                              <1> ;Links the inserted qhead into the async list
   394 00003D0D 57                  <1>     push rdi
   395 00003D0E 4150                <1>     push r8
   396 00003D10 E88EFFFFFF          <1>     call .ehciGetNewQHeadAddr   ;Get bus addresses
   397 00003D15 803C25[47020000]01  <1>     cmp byte [eNewBus], 1
   398 00003D1D 740F                <1>     je .elnqadjusted   ;If equal, exit
   399 00003D1F 4881CF02000000      <1>     or rdi, 2
   400 00003D26 418938              <1>     mov dword [r8], edi
   401                              <1> .elnqhexit:
   402 00003D29 F8                  <1>     clc
   403 00003D2A 4158                <1>     pop r8
   404 00003D2C 5F                  <1>     pop rdi
   405 00003D2D C3                  <1>     ret
   406                              <1> ;Only here if a new bus was Adjusted
   407                              <1> .elnqadjusted:
   408                              <1> ;The first qhead in a new queue must always point to itself and be
   409                              <1> ; the head of the reclaim list.
   410                              <1> ;The same address is provided to the function which writes the qhead
   411                              <1> ; and in the above function call into rdi, thus allowing us to point
   412                              <1> ; the new qhead to itself and set the H-bit on, in ALL instances 
   413 00003D2E 4989F8              <1>     mov r8, rdi
   414 00003D31 4981C802000000      <1>     or r8, 2
   415 00003D38 448907              <1>     mov dword [rdi], r8d    ;Point the QHead to itself
   416 00003D3B 814F0400800000      <1>     or dword [rdi + 4], 8000h   ;Set H bit on
   417 00003D42 50                  <1>     push rax
   418 00003D43 8A0425[48020000]    <1>     mov al, byte [eActiveCtrlr]
   419 00003D4A E8AA160000          <1>     call .ehciGetOpBase
   420 00003D4F 67897818            <1>     mov dword [eax + ehciasyncaddr], edi ;Set the address in the ctrlr register
   421 00003D53 58                  <1>     pop rax
   422 00003D54 E87D010000          <1>     call .ehciStartAsyncSchedule    ;Start schedule
   423 00003D59 7209                <1>     jc .elnqhbad
   424 00003D5B FE0C25[47020000]    <1>     dec byte [eNewBus]  ;Reset back to zero if successfully onlined
   425 00003D62 EBC5                <1>     jmp short .elnqhexit
   426                              <1> .elnqhbad:  ;If Async fails to start, exit
   427 00003D64 4158                <1>     pop r8
   428 00003D66 5F                  <1>     pop rdi
   429 00003D67 F9                  <1>     stc
   430 00003D68 C3                  <1>     ret
   431                              <1> 
   432                              <1> .ehciSetNoData:
   433                              <1> ;A function that does a set request with no data phase to the device
   434                              <1> ;at address al.
   435                              <1> ;Input:
   436                              <1> ; al = Address number (7 bit value)
   437                              <1> ; rbx = Setup packet
   438                              <1> ; cx = Max Packet Length 
   439                              <1> ;Returns:
   440                              <1> ; CF = NC if no Host error, CF = CY if Host error
   441                              <1> ; Caller MUST check the schedule to ensure that the transfer was successful,
   442                              <1> ; and without transaction errors as these dont constitute Host system errors.
   443                              <1> ;
   444                              <1> ; All registers except for CF preserved
   445 00003D69 57                  <1>     push rdi
   446 00003D6A 4150                <1>     push r8
   447 00003D6C 4151                <1>     push r9
   448 00003D6E 4152                <1>     push r10
   449 00003D70 4153                <1>     push r11
   450 00003D72 51                  <1>     push rcx
   451 00003D73 52                  <1>     push rdx
   452 00003D74 FC                  <1>     cld    ;Set right direction for string ops
   453                              <1>     
   454                              <1>     ;Write setup packet
   455 00003D75 48891C25[80030000]  <1>     mov qword [ehciDataOut], rbx
   456 00003D7D E821FFFFFF          <1>     call .ehciGetNewQHeadAddr
   457 00003D82 4981C802000000      <1>     or r8, 2    ;Process qH TDs
   458 00003D89 41B900600080        <1>     mov r9d, 80006000h  ;Bit 15 not set here!!!!! Important
   459 00003D8F 0FB7C9              <1>     movzx ecx, cx
   460 00003D92 C1E110              <1>     shl ecx, 8*2
   461 00003D95 4109C9              <1>     or r9d, ecx
   462 00003D98 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
   463 00003D9A 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
   464 00003D9D 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
   465 00003DA3 49BB-               <1>     mov r11, ehciTDSpace  ;First TD is the head of the buffer
   465 00003DA5 [0001000000000000]  <1>
   466                              <1> 
   467 00003DAD E827080000          <1>     call .ehciWriteQHead
   468                              <1> 
   469 00003DB2 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
   470 00003DB5 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]    ;Point to next TD
   471 00003DB9 49B901000000000000- <1>     mov r9, 1
   471 00003DC2 00                  <1>
   472 00003DC3 41BA800E0800        <1>     mov r10d, 00080E80h ;Active TD, SETUP EP, Error ctr = 3, 8 byte transfer
   473 00003DC9 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
   473 00003DCB [8003000000000000]  <1>
   474                              <1> 
   475 00003DD3 E826080000          <1>     call .ehciWriteQHeadTD
   476                              <1> 
   477 00003DD8 4881C740000000      <1>     add rdi, ehciSizeOfTD     ;Go to next TD space
   478 00003DDF 49B801000000000000- <1>     mov r8, 1
   478 00003DE8 00                  <1>
   479 00003DE9 4D89C1              <1>     mov r9, r8
   480 00003DEC 41BA808D0080        <1>     mov r10d, 80008D80h        ;Status stage opposite direction of last transfer
   481 00003DF2 49BB-               <1>     mov r11, msdCSW         ;Nothing should be returned but use this point
   481 00003DF4 [C005000000000000]  <1>
   482                              <1> 
   483 00003DFC E8FD070000          <1>     call .ehciWriteQHeadTD
   484 00003E01 B103                <1>     mov cl, 011b   ;Lock out internal buffer
   485 00003E03 E9BD000000          <1>     jmp .egddproceed
   486                              <1> 
   487                              <1> .ehciGetRequest:
   488                              <1> ;A function which does a standard get request from a device at
   489                              <1> ;address al.
   490                              <1> ;Input:
   491                              <1> ; al = Address number (7 bit value)
   492                              <1> ; rbx = Setup packet
   493                              <1> ; ecx = Max Packet Length 
   494                              <1> ;Returns:
   495                              <1> ; CF = NC if no Host error, CF = CY if Host error
   496                              <1> ; Caller MUST check the schedule to ensure that the transfer was successful,
   497                              <1> ; and without transaction errors as these dont constitute Host system errors.
   498                              <1> ;
   499                              <1> ; All registers except for CF preserved
   500 00003E08 57                  <1>     push rdi
   501 00003E09 4150                <1>     push r8
   502 00003E0B 4151                <1>     push r9
   503 00003E0D 4152                <1>     push r10
   504 00003E0F 4153                <1>     push r11
   505 00003E11 51                  <1>     push rcx
   506 00003E12 52                  <1>     push rdx
   507 00003E13 FC                  <1>     cld    ;Ensure right direction
   508                              <1> 
   509                              <1>     ;Write setup packet
   510 00003E14 48891C25[80030000]  <1>     mov qword [ehciDataOut], rbx
   511 00003E1C E882FEFFFF          <1>     call .ehciGetNewQHeadAddr
   512 00003E21 4981C802000000      <1>     or r8, 2    ;Process qH TDs
   513 00003E28 41B900600080        <1>     mov r9d, 80006000h  ;Bit 15 not set here!!!!! Important
   514 00003E2E 0FB7C9              <1>     movzx ecx, cx
   515 00003E31 C1E110              <1>     shl ecx, 8*2
   516 00003E34 4109C9              <1>     or r9d, ecx
   517 00003E37 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
   518 00003E39 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
   519 00003E3C 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
   520 00003E42 49BB-               <1>     mov r11, ehciTDSpace  ;First TD is the head of the buffer
   520 00003E44 [0001000000000000]  <1>
   521                              <1>     
   522 00003E4C E888070000          <1>     call .ehciWriteQHead
   523                              <1> 
   524 00003E51 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
   525 00003E54 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]    ;Point to next TD
   526 00003E58 49B901000000000000- <1>     mov r9, 1
   526 00003E61 00                  <1>
   527 00003E62 41BA800E0800        <1>     mov r10d, 00080E80h ;Active TD, SETUP EP, Error ctr = 3, 8 byte transfer
   528 00003E68 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
   528 00003E6A [8003000000000000]  <1>
   529                              <1> 
   530 00003E72 E887070000          <1>     call .ehciWriteQHeadTD
   531                              <1> 
   532 00003E77 4881C740000000      <1>     add rdi, ehciSizeOfTD    ;Go to next TD space
   533 00003E7E 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]
   534 00003E82 4D89C1              <1>     mov r9, r8    ;Alt pointer also points to next TD since this is expected!
   535 00003E85 41BA800D4080        <1>     mov r10d, 80400D80h ;Active TD, IN EP, Error ctr = 3, max 64 byte transfer
   536 00003E8B 49BB-               <1>     mov r11, ehciDataIn
   536 00003E8D [C003000000000000]  <1>
   537                              <1> 
   538 00003E95 E864070000          <1>     call .ehciWriteQHeadTD
   539                              <1> 
   540 00003E9A 4881C740000000      <1>     add rdi, ehciSizeOfTD     ;Go to next TD space
   541 00003EA1 49B801000000000000- <1>     mov r8, 1
   541 00003EAA 00                  <1>
   542 00003EAB 4D89C1              <1>     mov r9, r8
   543 00003EAE 41BA808C0080        <1>     mov r10d, 80008C80h
   544 00003EB4 49BB-               <1>     mov r11, msdCSW
   544 00003EB6 [C005000000000000]  <1>
   545                              <1> 
   546 00003EBE E83B070000          <1>     call .ehciWriteQHeadTD
   547                              <1> 
   548 00003EC3 B103                <1>     mov cl, 11b    ;Lock out internal buffer, ignore one interrupt
   549                              <1> ;Now set controller to process the schedule
   550                              <1> .egddproceed:
   551 00003EC5 E867000000          <1>     call .ehciProcessCommand
   552                              <1> ;The carry status of the previous function will propagate
   553                              <1> .egddexit:
   554 00003ECA 5A                  <1>     pop rdx
   555 00003ECB 59                  <1>     pop rcx
   556 00003ECC 415B                <1>     pop r11
   557 00003ECE 415A                <1>     pop r10
   558 00003ED0 4159                <1>     pop r9
   559 00003ED2 4158                <1>     pop r8
   560 00003ED4 5F                  <1>     pop rdi
   561 00003ED5 C3                  <1>     ret
   562                              <1> 
   563                              <1> .ehciStartAsyncSchedule:
   564 00003ED6 50                  <1>     push rax
   565 00003ED7 51                  <1>     push rcx
   566                              <1> 
   567 00003ED8 8A0425[48020000]    <1>     mov al, byte [eActiveCtrlr]    ;Deals with current active controller
   568 00003EDF E815150000          <1>     call .ehciGetOpBase            ;Return opregs ADDRESS in eax
   569 00003EE4 67810820000000      <1>     or dword [eax + ehcicmd], 20h    ;Process asyncschedule
   570 00003EEB 31C9                <1>     xor ecx, ecx
   571                              <1> .esas0:
   572 00003EED FFC9                <1>     dec ecx
   573 00003EEF 740E                <1>     jz .esasfail
   574 00003EF1 67F7400400800000    <1>     test dword [eax + ehcists], 08000h ;Asyncschedule bit should be on
   575 00003EF9 74F2                <1>     jz .esas0
   576                              <1> 
   577 00003EFB F8                  <1>     clc
   578                              <1> .esasok:
   579 00003EFC 59                  <1>     pop rcx
   580 00003EFD 58                  <1>     pop rax
   581 00003EFE C3                  <1>     ret
   582                              <1> .esasfail:
   583 00003EFF F9                  <1>     stc
   584 00003F00 EBFA                <1>     jmp short .esasok
   585                              <1> 
   586                              <1> .ehciStopAsyncSchedule:
   587                              <1> ;This function stops the processing of the current active Async Schedule
   588                              <1> ;Output: CF=CY: Failed to stop Async Schedule CF=NC: Stopped Async Schedule
   589 00003F02 50                  <1>     push rax
   590 00003F03 51                  <1>     push rcx
   591 00003F04 8A0425[48020000]    <1>     mov al, byte [eActiveCtrlr]    ;Deals with current active controller
   592 00003F0B E8E9140000          <1>     call .ehciGetOpBase            ;Return opregs ADDRESS in eax
   593 00003F10 6631C9              <1>     xor cx, cx
   594 00003F13 678120DFFFFFFF      <1>     and dword [eax + ehcicmd], 0FFFFFFDFh ;Stop processing async
   595                              <1> .espc0:
   596 00003F1A 66FFC9              <1>     dec cx
   597 00003F1D 740E                <1>     jz .espcfail
   598 00003F1F 67F7400400800000    <1>     test dword [eax + ehcists], 08000h
   599 00003F27 75F1                <1>     jnz .espc0
   600                              <1> 
   601 00003F29 F8                  <1>     clc
   602 00003F2A 59                  <1>     pop rcx
   603 00003F2B 58                  <1>     pop rax
   604 00003F2C C3                  <1>     ret
   605                              <1> .espcfail:
   606 00003F2D F9                  <1>     stc
   607 00003F2E 59                  <1>     pop rcx
   608 00003F2F 58                  <1>     pop rax
   609 00003F30 C3                  <1>     ret
   610                              <1> 
   611                              <1> .ehciProcessCommand:
   612                              <1> ; Allows EHCI async schedule to process commands.
   613                              <1> ; Preserves all registers except CF
   614                              <1> ; Returns: CF=CY if error detected 
   615                              <1> ;          CF=NC if no error detected
   616                              <1> ;
   617                              <1> ; If returned with CF=CY, caller must read the msdStatus byte
   618 00003F31 50                  <1>     push rax
   619 00003F32 53                  <1>     push rbx
   620 00003F33 51                  <1>     push rcx
   621 00003F34 57                  <1>     push rdi
   622                              <1> 
   623 00003F35 880C25[4A020000]    <1>     mov byte [eAsyncMutex], cl  ;Set mutex
   624 00003F3C 8A0425[48020000]    <1>     mov al, byte [eActiveCtrlr]    ;Deals with current active controller
   625 00003F43 E8B1140000          <1>     call .ehciGetOpBase            ;Return opregs ADDRESS in eax
   626 00003F48 4889C3              <1>     mov rbx, rax
   627 00003F4B 66BF8813            <1>     mov di, 5000
   628 00003F4F E8B9FDFFFF          <1>     call .ehciLinkNewQHead
   629 00003F54 0F82A1000000        <1>     jc .epcfailedstart
   630                              <1> .epc1:
   631 00003F5A 67F7430413000000    <1>     test dword [ebx + ehcists], 13h
   632 00003F62 7516                <1>     jnz .epc2     ;If bits we care about are set, call IRQ proceedure
   633 00003F64 F390                <1>     pause       
   634 00003F66 66FFCF              <1>     dec di
   635 00003F69 0F849F000000        <1>     jz .epcfailtimeout
   636 00003F6F B486                <1>     mov ah, 86h
   637 00003F71 B901000000          <1>     mov ecx, 1    ;Max 5s in 1ms chunks
   638 00003F76 CD35                <1>     int 35h
   639 00003F78 EBE0                <1>     jmp short .epc1
   640                              <1> .epc2:
   641 00003F7A 89D8                <1>     mov eax, ebx    ;Get opreg base into eax before we proceed into IRQ handler
   642 00003F7C E805CCFFFF          <1>     call ehci_IRQ.nonIRQep ;Manually call IRQ
   643 00003F81 F60425[49020000]10  <1>     test byte [eActiveInt], 10h ;HC error bit
   644 00003F89 7578                <1>     jnz .epcHostError   ;HC error detected
   645 00003F8B F60425[4A020000]00  <1>     test byte [eAsyncMutex], 0
   646 00003F93 75C5                <1>     jnz .epc1    ;If the mutex isnt cleared, go back to sts check
   647 00003F95 E853FDFFFF          <1>     call .ehciDelinkOldQHead   ;Perform delink
   648 00003F9A E826FDFFFF          <1>     call .ehciToggleTransactingQHead    ;Toggle the active Qheads
   649                              <1> ;Now set doorbell
   650 00003F9F 67810B40000000      <1>     or dword [ebx + ehcicmd], 40h   ;Ring Doorbell
   651 00003FA6 66BF8813            <1>     mov di, 5000
   652                              <1> .epc3:
   653 00003FAA 67F7430420000000    <1>     test dword [ebx + ehcists], 20h ;Test for doorbell set high
   654 00003FB2 7512                <1>     jnz .epc4
   655 00003FB4 F390                <1>     pause
   656 00003FB6 66FFCF              <1>     dec di
   657 00003FB9 7440                <1>     jz .epcfaildelinked
   658 00003FBB B486                <1>     mov ah, 86h
   659 00003FBD B901000000          <1>     mov ecx, 1    ;Max 5s in 1ms chunks
   660 00003FC2 CD35                <1>     int 35h
   661 00003FC4 EBE4                <1>     jmp short .epc3
   662                              <1> .epc4:
   663                              <1> ;Clear once more to clear the doorbell bit
   664 00003FC6 678B4B04            <1>     mov ecx, dword [ebx + ehcists]  
   665 00003FCA 67094B04            <1>     or dword  [ebx + ehcists], ecx    ;WC high bits
   666                              <1> ;Check if it was a stall
   667 00003FCE F60425[49020000]02  <1>     test byte [eActiveInt], 2h  ;Check USBError bit
   668 00003FD6 7509                <1>     jnz .epcexit
   669 00003FD8 C60425[A9010000]00  <1>     mov byte [msdStatus], 00h   ;No error... yet
   670 00003FE0 F8                  <1>     clc
   671                              <1> .epcexit:
   672 00003FE1 5F                  <1>     pop rdi
   673 00003FE2 59                  <1>     pop rcx
   674 00003FE3 5B                  <1>     pop rbx
   675 00003FE4 58                  <1>     pop rax
   676 00003FE5 C3                  <1>     ret 
   677                              <1> .epcStall:
   678 00003FE6 C60425[A9010000]21  <1>     mov byte [msdStatus], 21h   ;General Controller Failure - Stall
   679 00003FEE F9                  <1>     stc
   680 00003FEF EBF0                <1>     jmp short .epcexit
   681                              <1> .epcfail:
   682 00003FF1 E8F7FCFFFF          <1>     call .ehciDelinkOldQHead   ;Perform delink
   683 00003FF6 E8CAFCFFFF          <1>     call .ehciToggleTransactingQHead    ;Toggle the active Qheads
   684                              <1> .epcfailedstart: ;No need to delink as that data structure is considered garbage
   685                              <1> .epcfaildelinked:
   686 00003FFB 678B4B04            <1>     mov ecx, dword [ebx + ehcists]
   687 00003FFF 67094B04            <1>     or dword  [ebx + ehcists], ecx    ;WC selected bits
   688                              <1> .epcHostError:  ;Host error detected in interrupt register
   689 00004003 C60425[A9010000]20  <1>     mov byte [msdStatus], 20h   ;General Controller Error
   690 0000400B F9                  <1>     stc
   691 0000400C EBD3                <1>     jmp short .epcexit
   692                              <1> .epcfailtimeout:
   693                              <1> ;Called in the event that the schedule fails to process the QHead.
   694                              <1> ;Emergency stops the currently transacting schedule
   695 0000400E E8DAFCFFFF          <1>     call .ehciDelinkOldQHead   ;Perform delink
   696 00004013 E8ADFCFFFF          <1>     call .ehciToggleTransactingQHead    ;Toggle the active Qheads
   697 00004018 678B4B04            <1>     mov ecx, dword [ebx + ehcists]
   698 0000401C 67094B04            <1>     or dword  [ebx + ehcists], ecx    ;WC selected bits
   699 00004020 C60425[A9010000]80  <1>     mov byte [msdStatus], 80h   ;Timeout Error
   700 00004028 F9                  <1>     stc
   701 00004029 EBB6                <1>     jmp short .epcexit  ;Delink
   702                              <1> 
   703                              <1> .ehciEnumerateRootPort:
   704                              <1> ;This function discovers whether a device is of a valid type
   705                              <1> ;or not.
   706                              <1> ;Input: dl=port number - 1 (0 based), dh = bus [0-3]
   707                              <1> ;       r10b = Host hub address (if the device is on a hub, 0 else)
   708                              <1> ;Output:     CF=CY if error, CF=NC if bus transaction occured 
   709                              <1> ;           ZF=ZR if passed enum: ah = bus number, al = Address number
   710                              <1> ;            ZF=NZ if the device failed enumeration: ax=error code
   711                              <1> ;                ah = Enum stage, al = Sub function stage
   712 0000402B 53                  <1>     push rbx
   713 0000402C 51                  <1>     push rcx
   714 0000402D 52                  <1>     push rdx
   715 0000402E 55                  <1>     push rbp
   716 0000402F 4150                <1>     push r8
   717 00004031 4151                <1>     push r9
   718 00004033 4152                <1>     push r10
   719 00004035 4153                <1>     push r11
   720                              <1> 
   721                              <1> .eebinit:
   722 00004037 6631ED              <1>     xor bp, bp    ;Use as error counter    (Stage 0)
   723 0000403A 88D0                <1>     mov al, dl
   724 0000403C E818FAFFFF          <1>     call .ehciResetControllerPort    ;Reset port
   725 00004041 0F828C010000        <1>     jc .ehciedbadnotimeout
   726                              <1> ;Power on debounce!
   727 00004047 B9C8000000          <1>     mov ecx, debounceperiod    ;debounce period
   728 0000404C B486                <1>     mov ah, 86h
   729 0000404E CD35                <1>     int 35h
   730                              <1> 
   731 00004050 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 1)
   732                              <1> .eeb0:
   733 00004053 48BB80060001000008- <1>     mov rbx, 00008000001000680h    ;Pass get minimal device descriptor
   733 0000405C 00                  <1>
   734 0000405D 48891C25[80030000]  <1>     mov qword [ehciDataOut], rbx
   735 00004065 66B94000            <1>     mov cx, 40h    ;Pass default endpoint size
   736 00004069 30C0                <1>     xor al, al
   737 0000406B E898FDFFFF          <1>     call .ehciGetRequest
   738 00004070 0F8245010000        <1>     jc .ehciedexit  ;Fast exit with carry set
   739                              <1> .eeb1:
   740 00004076 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 2)
   741 00004079 30C0                <1>     xor al, al    ;Increment Error subcounter    (Substage 0)
   742 0000407B 48BB-               <1>     mov rbx, ehciDataIn
   742 0000407D [C003000000000000]  <1>
   743 00004085 807B0101            <1>     cmp byte [rbx + 1], 01h    ;Verify this is a valid dev descriptor
   744 00004089 0F8539010000        <1>     jne .ehciedbad
   745 0000408F FEC0                <1>     inc al    ;Increment Error subcounter    (Substage 1)
   746 00004091 66817B020002        <1>     cmp word [rbx + 2], 0200h    ;Verify this is a USB 2.0 device or above
   747 00004097 0F822B010000        <1>     jb .ehciedbad
   748 0000409D FEC0                <1>     inc al    ;Increment Error subcounter    (Substage 2)
   749 0000409F 807B0400            <1>     cmp byte [rbx + 4], 0    ;Check interfaces
   750 000040A3 7410                <1>     je .eeb2
   751 000040A5 807B0408            <1>     cmp byte [rbx + 4], 08h    ;MSD?
   752 000040A9 740A                <1>     je .eeb2
   753 000040AB 807B0409            <1>     cmp byte [rbx + 4], 09h    ;Hub?
   754 000040AF 0F8513010000        <1>     jne .ehciedbad
   755                              <1> .eeb2:
   756 000040B5 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 3)
   757 000040B8 440FB64307          <1>     movzx r8d, byte [rbx + 7]    ;Byte 7 is MaxPacketSize0, save in r8b
   758 000040BD 88D0                <1>     mov al, dl
   759                              <1> 
   760 000040BF E895F9FFFF          <1>     call .ehciResetControllerPort    ;Reset port again
   761 000040C4 0F82FE000000        <1>     jc .ehciedbad
   762 000040CA 49BB0A000000000000- <1>     mov r11, 10
   762 000040D3 00                  <1>
   763                              <1> .ehciEnumCommonEp:
   764 000040D4 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 4)
   765 000040D7 88F0                <1>     mov al, dh    ;Put bus number into al
   766                              <1> 
   767 000040D9 E825030000          <1>     call .ehciGiveValidAddress    ;Get a valid address for device
   768 000040DE 3C80                <1>     cmp al, 80h    
   769 000040E0 0F83E2000000        <1>     jae .ehciedbad    ;Invalid address
   770                              <1> 
   771 000040E6 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 5)
   772 000040E9 4188C1              <1>     mov r9b, al        ;Save the new device address number in r9b
   773                              <1> .eeb3:
   774 000040EC BB00050000          <1>     mov ebx, 0500h    ;Set address function
   775 000040F1 410FB6C9            <1>     movzx ecx, r9b    ;move new address into ecx
   776 000040F5 C1E110              <1>     shl ecx, 8*2
   777 000040F8 09CB                <1>     or ebx, ecx    ;Add address number to ebx
   778 000040FA 664489C1            <1>     mov cx, r8w    ;Move endpoint size into cx
   779 000040FE 30C0                <1>     xor al, al    ;Device still talks on address 0, ax not preserved
   780 00004100 E864FCFFFF          <1>     call .ehciSetNoData    ;Set address
   781 00004105 0F82B0000000        <1>     jc .ehciedexit  ;Fast exit with carry set
   782                              <1> .eeb4:
   783 0000410B B486                <1>     mov ah, 86h
   784 0000410D 4C89D9              <1>     mov rcx, r11
   785 00004110 CD35                <1>     int 35h
   786                              <1> 
   787 00004112 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 6)
   788                              <1> .eeb5:
   789 00004115 48BB80060001000012- <1>     mov rbx, 00012000001000680h    ;Now get full device descriptor
   789 0000411E 00                  <1>
   790 0000411F 4488C8              <1>     mov al, r9b    ;Get address
   791 00004122 664489C1            <1>     mov cx, r8w
   792 00004126 E8DDFCFFFF          <1>     call .ehciGetRequest    ;Get full device descriptor and discard
   793 0000412B 0F828A000000        <1>     jc .ehciedexit  ;Fast exit with carry set
   794 00004131 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 7/0Bh)
   795                              <1> .eeb6:
   796 00004134 48BB80060002000000- <1>     mov rbx, 00000000002000680h ;Get config descriptor
   796 0000413D 00                  <1>
   797 0000413E 4489C1              <1>     mov ecx, r8d    ;Adjust the packet data with bMaxPacketSize0
   798 00004141 48C1E130            <1>     shl rcx, 8*6    ;cx contains bMaxPacketSize0
   799 00004145 4809CB              <1>     or rbx, rcx
   800 00004148 4488C8              <1>     mov al, r9b    ;Get address
   801 0000414B 664489C1            <1>     mov cx, r8w    ;Move endpoint size into cx
   802 0000414F E8B4FCFFFF          <1>     call .ehciGetRequest
   803 00004154 7265                <1>     jc .ehciedexit  ;Fast exit with carry set
   804                              <1> .eeb7:
   805 00004156 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 8/0Ch)
   806                              <1> ;Find a valid interface in this config
   807 00004159 E8CB020000          <1>     call .ehciFindValidInterface
   808 0000415E 7268                <1>     jc .ehciedbad    ;Dont set config, exit bad
   809                              <1> ;If success, ah has device type (0=msd, 1=hub), al = Interface to use
   810                              <1> ;rbx points to interface descriptor
   811 00004160 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 9/0Dh)
   812 00004163 E889000000          <1>     call .ehciAddDeviceToTables
   813 00004168 725E                <1>     jc .ehciedbad    ;Failed to be added to internal tables
   814 0000416A FE0425[36020000]    <1>     inc byte [usbDevices]   ;Device added successfully, inc byte
   815                              <1> ;Set configuration 1 (wie OG Windows, consider upgrading soon)
   816 00004171 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 0Ah/0Ch)
   817                              <1> .eeb8:
   818 00004174 48BB00090100000000- <1>     mov rbx, 00000000000010900h    ;Set configuration 1 (function 09h)
   818 0000417D 00                  <1>
   819 0000417E 4488C8              <1>     mov al, r9b    ;Get address
   820 00004181 664489C1            <1>     mov cx, r8w    ;Move endpoint size into cx
   821 00004185 E8DFFBFFFF          <1>     call .ehciSetNoData
   822 0000418A 722F                <1>     jc .ehciedexit  ;Fast exit with carry set
   823                              <1> .eeb9:
   824 0000418C 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 0Bh/0Dh)
   825                              <1> .eeb10:
   826 0000418F 48BB80080000000001- <1>     mov rbx, 0001000000000880h  ;Get device config (sanity check)
   826 00004198 00                  <1>
   827 00004199 410FB7C8            <1>     movzx ecx, r8w              ;bMaxPacketSize0
   828 0000419D 4488C8              <1>     mov al, r9b                 ;Get device address
   829 000041A0 E863FCFFFF          <1>     call .ehciGetRequest
   830 000041A5 7214                <1>     jc .ehciedexit  ;Fast exit with carry set
   831                              <1> .eeb11:
   832 000041A7 66FFC5              <1>     inc bp    ;Increment Error Counter    (Stage 0Ch/0Eh)
   833 000041AA 803C25[C0030000]01  <1>     cmp byte [ehciDataIn], 01
   834 000041B2 7531                <1>     jne .ehcibadremtables
   835                              <1> ;Device is now configured and ready to go to set/reset
   836 000041B4 88F4                <1>     mov ah, dh  ;Move bus number
   837 000041B6 4488C8              <1>     mov al, r9b ;Move address number
   838 000041B9 31D2                <1>     xor edx, edx  ;This will always set the zero flag
   839                              <1> .ehciedexit:
   840 000041BB 415B                <1>     pop r11
   841 000041BD 415A                <1>     pop r10
   842 000041BF 4159                <1>     pop r9
   843 000041C1 4158                <1>     pop r8
   844 000041C3 5D                  <1>     pop rbp
   845 000041C4 5A                  <1>     pop rdx
   846 000041C5 59                  <1>     pop rcx
   847 000041C6 5B                  <1>     pop rbx
   848 000041C7 C3                  <1>     ret
   849                              <1> .ehciedbad:
   850                              <1> .ehciedbadnoport:
   851 000041C8 50                  <1>     push rax
   852 000041C9 B486                <1>     mov ah, 86h
   853 000041CB B9F4010000          <1>     mov ecx, 500    ;500 ms wait between failed attempts
   854 000041D0 CD35                <1>     int 35h
   855 000041D2 58                  <1>     pop rax
   856                              <1> .ehciedbadnotimeout:
   857 000041D3 88C4                <1>     mov ah, al    ;Save subproc error code
   858 000041D5 30C0                <1>     xor al, al    ;Zero byte
   859 000041D7 6609E8              <1>     or ax, bp    ;Add proc error stage code into al
   860 000041DA 86E0                <1>     xchg ah, al
   861 000041DC 6631ED              <1>     xor bp, bp
   862 000041DF 66FFC5              <1>     inc bp      ;This will always clear the Zero flag
   863 000041E2 F8                  <1>     clc         ;This will force clear the Carry flag
   864 000041E3 EBD6                <1>     jmp short .ehciedexit
   865                              <1> .ehcibadremtables:
   866 000041E5 4488C8              <1>     mov al, r9b ;Get address low
   867 000041E8 88F4                <1>     mov ah, dh  
   868 000041EA E87F010000          <1>     call .ehciRemoveDevFromTables
   869 000041EF EBE2                <1>     jmp short .ehciedbadnotimeout
   870                              <1> 
   871                              <1> .ehciAddDeviceToTables:
   872                              <1> ;This function adds a valid device to the internal tables.
   873                              <1> ;Interrupts are off for this to avoid dead entries
   874                              <1> ;Input: ah = device type (0=msd, 1=hub)
   875                              <1> ;       al = Interface Value to use (USB bInterfaceNumber)
   876                              <1> ;       rbx = Ptr to valid Interface descriptor
   877                              <1> ;       r8b = MaxPacketSize0
   878                              <1> ;       r9b = Device Address
   879                              <1> ;       dh = Bus number
   880                              <1> ;       dl = Physical Port number - 1
   881                              <1> ;       r10b = Host hub address
   882 000041F1 4153                <1>     push r11
   883 000041F3 55                  <1>     push rbp    ;Error counter
   884 000041F4 57                  <1>     push rdi
   885 000041F5 53                  <1>     push rbx
   886 000041F6 52                  <1>     push rdx
   887 000041F7 9C                  <1>     pushfq
   888 000041F8 FEC2                <1>     inc dl      ;Add one to the Physical port number (kludge for root hub enum)
   889 000041FA 6631ED              <1>     xor bp, bp  ;Zero error counter (Stage 0)
   890 000041FD B90A000000          <1>     mov ecx, usbMaxDevices
   891 00004202 380C25[36020000]    <1>     cmp byte [usbDevices], cl   ;Max number of devices, check
   892 00004209 0F8458010000        <1>     je .eadttbad        ;If max, fail
   893 0000420F 66FFC5              <1>     inc bp      ;Increment error counter (Stage 1)
   894 00004212 48BF-               <1>     mov rdi, usbDevTbl
   894 00004214 [4D02000000000000]  <1>
   895 0000421C B10A                <1>     mov cl, usbDevTblSz  ;Within the length of the table
   896                              <1> ;Write Common table first
   897                              <1> .eadtt0:
   898 0000421E 800F00              <1>     or byte [rdi], 0   ;Check if there exists a free entry
   899 00004221 7411                <1>     jz .eadtt1
   900 00004223 4881C703000000      <1>     add rdi, usbDevTblEntry_size ;Go to next entry
   901 0000422A FEC9                <1>     dec cl
   902 0000422C 0F8435010000        <1>     jz .eadttbad
   903 00004232 EBEA                <1>     jmp short .eadtt0
   904                              <1> .eadtt1:
   905 00004234 66FFC5              <1>     inc bp      ;Increment error counter (Stage 2)
   906 00004237 80C408              <1>     add ah, 08h ;hub is 09h
   907                              <1> ;Add device here, rdi points to entry
   908 0000423A 44880F              <1>     mov byte [rdi], r9b
   909 0000423D 887701              <1>     mov byte [rdi + 1], dh
   910 00004240 886702              <1>     mov byte [rdi + 2], ah
   911                              <1> ;Entry written
   912 00004243 66FFC5              <1>     inc bp      ;Increment error counter (Stage 3)
   913                              <1> ;Individual Device table writing
   914 00004246 80FC08              <1>     cmp ah, 08h
   915 00004249 740E                <1>     je .eadttmsd
   916 0000424B 80FC09              <1>     cmp ah, 09h
   917 0000424E 0F84C9000000        <1>     je .eadtthub
   918 00004254 E90E010000          <1>     jmp .eadttbad
   919                              <1> .eadttmsd:
   920 00004259 48BF-               <1>     mov rdi, msdDevTbl
   920 0000425B [BB02000000000000]  <1>
   921 00004263 B10A                <1>     mov cl, msdDevTblSz  ;Max entries possible
   922 00004265 66FFC5              <1>     inc bp      ;Increment error counter (Stage 4)
   923                              <1> .eadttmsd0:
   924 00004268 800F00              <1>     or byte [rdi], 0
   925 0000426B 7411                <1>     jz .eadttmsd1
   926 0000426D 4881C710000000      <1>     add rdi, msdDevTblEntry_size
   927 00004274 FEC9                <1>     dec cl
   928 00004276 0F84EB000000        <1>     jz .eadttbad
   929 0000427C EBEA                <1>     jmp short .eadttmsd0
   930                              <1> .eadttmsd1:
   931                              <1> ;rdi points to correct offset into table
   932                              <1> ;rbx points to interface
   933 0000427E 8A4B04              <1>     mov cl, byte [rbx + 4]   ;Get number of endpoints to check
   934 00004281 88CD                <1>     mov ch, cl
   935 00004283 66FFC5              <1>     inc bp      ;Increment error counter (Stage 5)
   936 00004286 4989DB              <1>     mov r11, rbx    ;Save Interface Pointer in r11
   937 00004289 4881C309000000      <1>     add rbx, 9  ;Go to first IF
   938                              <1> .eadttmsd11:
   939 00004290 50                  <1>     push rax
   940 00004291 668B4302            <1>     mov ax, word [rbx + 2]
   941 00004295 66C1E804            <1>     shr ax, 4   ;Remove low 4 bits
   942 00004299 663D2800            <1>     cmp ax, 28h     ;Bulk/In bits
   943 0000429D 58                  <1>     pop rax         ;Doesnt ruin flags
   944 0000429E 7411                <1>     je .eadttmsd2   ;Not zero only if valid
   945 000042A0 4881C307000000      <1>     add rbx, 7   ;Go to next endpoint
   946 000042A7 FEC9                <1>     dec cl
   947 000042A9 0F84B8000000        <1>     jz .eadttbad
   948 000042AF EBDF                <1>     jmp short .eadttmsd11
   949                              <1> .eadttmsd2:
   950 000042B1 44880F              <1>     mov byte [rdi], r9b      ;Device Address
   951 000042B4 887701              <1>     mov byte [rdi + 1], dh   ;Root hub/bus
   952 000042B7 44885702            <1>     mov byte [rdi + 2], r10b ;Address of parent device if not root
   953 000042BB 885703              <1>     mov byte [rdi + 3], dl   ;Port number we are inserted in
   954 000042BE 884704              <1>     mov byte [rdi + 4], al   ;Save Interface number
   955 000042C1 418A4306            <1>     mov al, byte [r11 + 6]   ;bInterfaceSubclass is +6
   956 000042C5 884705              <1>     mov byte [rdi + 5], al
   957 000042C8 418A4307            <1>     mov al, byte [r11 + 7]   ;Protocol
   958 000042CC 884706              <1>     mov byte [rdi + 6], al
   959 000042CF 44884707            <1>     mov byte [rdi + 7], r8b  ;MaxPacketSize0
   960                              <1> ;Valid In EP found, write table entries
   961 000042D3 8A4302              <1>     mov al, byte [rbx + 2]  ;Get address
   962 000042D6 884708              <1>     mov byte [rdi + 8], al
   963 000042D9 668B4304            <1>     mov ax, word [rbx + 4]  ;Get maxPacketSizeIn
   964 000042DD 66894709            <1>     mov word [rdi + 9], ax
   965                              <1> 
   966 000042E1 498D5B09            <1>     lea rbx, qword [r11 + 9]   ;Return rbx to first IF
   967 000042E5 66FFC5              <1>     inc bp      ;Increment error counter (Stage 6)
   968                              <1> .eadttmsd21:
   969 000042E8 668B4302            <1>     mov ax, word [rbx + 2]  ;Bulk/Out bits
   970 000042EC 66C1E804            <1>     shr ax, 4
   971 000042F0 663D2000            <1>     cmp ax, 20h
   972 000042F4 740D                <1>     je .eadttmsd3   ;Not zero only if valid
   973 000042F6 4881C307000000      <1>     add rbx, 7   ;Go to next endpoint
   974 000042FD FECD                <1>     dec ch
   975 000042FF 7466                <1>     jz .eadttbad
   976 00004301 EBE5                <1>     jmp short .eadttmsd21
   977                              <1> .eadttmsd3:
   978 00004303 8A4302              <1>     mov al, byte [rbx + 2]  ;Get address
   979 00004306 88470B              <1>     mov byte [rdi + 11], al
   980 00004309 668B4304            <1>     mov ax, word [rbx + 4]  ;Get maxPacketSizeIn
   981 0000430D 6689470C            <1>     mov word [rdi + 12], ax
   982 00004311 6631C0              <1>     xor ax, ax  ;Zero ax
   983 00004314 6689470E            <1>     mov word [rdi + 14], ax ;Make dt bits for I/O EPs zero
   984                              <1> ;Table entry written for MSD device
   985 00004318 E93F000000          <1>     jmp .eadttpass
   986                              <1> .eadtthub:
   987 0000431D 48BF-               <1>     mov rdi, hubDevTbl
   987 0000431F [6B02000000000000]  <1>
   988 00004327 B10A                <1>     mov cl,  hubDevTblSz ;Max entries possible
   989 00004329 66BD0700            <1>     mov bp, 7      ;Increment error counter (Stage 7)
   990                              <1> .eadtthub0:
   991 0000432D 800F00              <1>     or byte [rdi], 0
   992 00004330 740D                <1>     jz .eadtthub1
   993 00004332 4881C708000000      <1>     add rdi, hubDevTblEntry_size
   994 00004339 FEC9                <1>     dec cl
   995 0000433B 742A                <1>     jz .eadttbad
   996 0000433D EBEE                <1>     jmp short .eadtthub0
   997                              <1> .eadtthub1:
   998                              <1> ;Valid table space found
   999 0000433F 44880F              <1>     mov byte [rdi], r9b      ;Device Address
  1000 00004342 887701              <1>     mov byte [rdi + 1], dh   ;Root hub/bus
  1001 00004345 44885702            <1>     mov byte [rdi + 2], r10b ;Address of parent device if not root
  1002 00004349 885703              <1>     mov byte [rdi + 3], dl   ;Port number we are inserted in
  1003 0000434C 44884704            <1>     mov byte [rdi + 4], r8b  ;MaxPacketSize0
  1004 00004350 66B800FF            <1>     mov ax, 0FF00h  ;Res byte is 0FFh, Num ports (byte 6) is 0
  1005 00004354 66894705            <1>     mov word [rdi + 5], ax   ;Number of ports and PowerOn2PowerGood
  1006 00004358 C64707FF            <1>     mov byte [rdi + 7], 0FFh    ;EP address, currently reserved
  1007                              <1> .eadttpass:
  1008 0000435C 9D                  <1>     popfq   ;If IF was clear, it will be set clear by popf
  1009 0000435D 6631C0              <1>     xor ax, ax  ;Clear ax and clc
  1010                              <1> .eadttexit:
  1011 00004360 5A                  <1>     pop rdx
  1012 00004361 5B                  <1>     pop rbx
  1013 00004362 5F                  <1>     pop rdi
  1014 00004363 5D                  <1>     pop rbp
  1015 00004364 415B                <1>     pop r11
  1016 00004366 C3                  <1>     ret
  1017                              <1> .eadttbad:
  1018 00004367 9D                  <1>     popfq   ;If IF was clear, it will be set clear by popf
  1019 00004368 F9                  <1>     stc
  1020 00004369 6689E8              <1>     mov ax, bp
  1021 0000436C EBF2                <1>     jmp short .eadttexit
  1022                              <1> .ehciRemoveDevFromTables:
  1023                              <1> ;This function removes a function from internal tables
  1024                              <1> ;Input: al = Address number, ah = Bus number
  1025                              <1> ;Output: Internal tables zeroed out, ax destroyed, Carry clear
  1026                              <1> ;    If invalid argument, Carry set
  1027 0000436E 57                  <1>     push rdi
  1028 0000436F 51                  <1>     push rcx
  1029 00004370 53                  <1>     push rbx
  1030 00004371 48BF-               <1>     mov rdi, usbDevTbl
  1030 00004373 [4D02000000000000]  <1>
  1031 0000437B B10A                <1>     mov cl, usbDevTblSz    ;10 entries possible
  1032                              <1> .erdft0:
  1033 0000437D 66AF                <1>     scasw
  1034 0000437F 7409                <1>     je .erdft1    ;Device signature found
  1035 00004381 48FFC7              <1>     inc rdi
  1036 00004384 FEC9                <1>     dec cl
  1037 00004386 7478                <1>     jz .erdftbad
  1038 00004388 EBF3                <1>     jmp short .erdft0
  1039                              <1> .erdft1:
  1040 0000438A 4881EF02000000      <1>     sub rdi, 2  ;scasw pointers to the next word past the comparison
  1041 00004391 8A6702              <1>     mov ah, byte [rdi + 2]    ;Save class code in ah
  1042 00004394 80FC08              <1>     cmp ah, 08h ;USB MSD Class device
  1043 00004397 7507                <1>     jne .erdft11    ;Skip the dec if it is a hub class device
  1044 00004399 FE0C25[4C020000]    <1>     dec byte [numMSD]   ;Device is being removed from tables, decrement count
  1045                              <1> .erdft11:
  1046                              <1> ;Clear usbDevTbl entry for usb device
  1047 000043A0 50                  <1>     push rax
  1048 000043A1 B903000000          <1>     mov ecx, usbDevTblEntry_size    ;Table entry size
  1049 000043A6 30C0                <1>     xor al, al
  1050 000043A8 F3AA                <1>     rep stosb    ;Store zeros for entry
  1051 000043AA 58                  <1>     pop rax
  1052                              <1> 
  1053 000043AB 48BB-               <1>     mov rbx, hubDevTbl
  1053 000043AD [6B02000000000000]  <1>
  1054 000043B5 48B9-               <1>     mov rcx, msdDevTbl
  1054 000043B7 [BB02000000000000]  <1>
  1055 000043BF 80FC09              <1>     cmp ah, 09h
  1056 000043C2 480F44CB            <1>     cmove rcx, rbx ;If 09h (Hub), change table pointed to by rcx
  1057 000043C6 4889CF              <1>     mov rdi, rcx    ;Point rdi to appropriate table
  1058 000043C9 BB08000000          <1>     mov ebx, hubDevTblEntry_size    ;Size of hub table entry
  1059 000043CE B910000000          <1>     mov ecx, msdDevTblEntry_size    ;Size of msd table entry
  1060 000043D3 80FC09              <1>     cmp ah, 09h
  1061 000043D6 0F44CB              <1>     cmove ecx, ebx    ;If hub, move size into cx
  1062                              <1> ;cx has entry size, rdi points to appropriate table
  1063 000043D9 4889FB              <1>     mov rbx, rdi
  1064 000043DC 31FF                <1>     xor edi, edi
  1065 000043DE 29CF                <1>     sub edi, ecx
  1066 000043E0 B411                <1>     mov ah, 11h
  1067                              <1> .erdft2:
  1068 000043E2 FECC                <1>     dec ah
  1069 000043E4 741A                <1>     jz .erdftbad    ;Somehow, address not found
  1070 000043E6 01CF                <1>     add edi, ecx
  1071 000043E8 3A043B              <1>     cmp al, byte [rbx + rdi]
  1072 000043EB 75F5                <1>     jne .erdft2
  1073 000043ED 4801DF              <1>     add rdi, rbx    ;point rdi to table entry
  1074 000043F0 30C0                <1>     xor al, al
  1075 000043F2 F3AA                <1>     rep stosb    ;ecx contains table entry size in bytes
  1076 000043F4 FE0C25[36020000]    <1>     dec byte [usbDevices]   ;Decrement total usb devices
  1077 000043FB F8                  <1>     clc
  1078                              <1> .erdftexit:
  1079 000043FC 5B                  <1>     pop rbx
  1080 000043FD 59                  <1>     pop rcx
  1081 000043FE 5F                  <1>     pop rdi
  1082 000043FF C3                  <1>     ret
  1083                              <1> .erdftbad:
  1084 00004400 F9                  <1>     stc
  1085 00004401 EBF9                <1>     jmp short .erdftexit 
  1086                              <1> .ehciGiveValidAddress:
  1087                              <1> ;This function will return a valid value to use as an address
  1088                              <1> ;for a new device.
  1089                              <1> ;Input: al = Controller number [0-3]
  1090                              <1> ;Output: al = Address, or 80h => No valid available address
  1091 00004403 57                  <1>     push rdi
  1092 00004404 51                  <1>     push rcx
  1093 00004405 88C4                <1>     mov ah, al    ;Move bus number high
  1094 00004407 B000                <1>     mov al, 0 ;Address 0, start at addr 1
  1095                              <1> .egva0:
  1096 00004409 FEC0                <1>     inc al
  1097 0000440B 3C80                <1>     cmp al, 80h
  1098 0000440D 7317                <1>     jae .egvaexit
  1099 0000440F 48BF-               <1>     mov rdi, usbDevTbl
  1099 00004411 [4D02000000000000]  <1>
  1100 00004419 B10A                <1>     mov cl, usbDevTblSz    ;10 entries possible
  1101                              <1> .egva1:
  1102 0000441B 66AF                <1>     scasw
  1103 0000441D 74EA                <1>     je .egva0
  1104 0000441F 48FFC7              <1>     inc rdi    ;Pass third byte in table entry
  1105 00004422 FEC9                <1>     dec cl
  1106 00004424 75F5                <1>     jnz .egva1    ;Check every entry for any addresses being used
  1107                              <1> .egvaexit:
  1108 00004426 59                  <1>     pop rcx
  1109 00004427 5F                  <1>     pop rdi
  1110 00004428 C3                  <1>     ret 
  1111                              <1> .ehciFindValidInterface:
  1112                              <1> ;A proc to check a valid interface descriptor is present. 
  1113                              <1> ;Input: Nothing [Assumes Get Config was called in standard buffer]
  1114                              <1> ;Output: Carry set if invalid. Carry clear if valid.
  1115                              <1> ;    On success: ah = device type (0 is msd, 1 is hub)
  1116                              <1> ;                al = interface number to set
  1117                              <1> ;               rbx = Pointer to Interface Descriptor
  1118                              <1> ;   On fail: al contains error code, registers rbx, cx, dx destroyed
  1119 00004429 56                  <1>     push rsi
  1120 0000442A 57                  <1>     push rdi
  1121 0000442B 51                  <1>     push rcx
  1122 0000442C 52                  <1>     push rdx
  1123                              <1> 
  1124 0000442D 48BE-               <1>     mov rsi, ehciDataIn    ;Shift to buffer
  1124 0000442F [C003000000000000]  <1>
  1125 00004437 30D2                <1>     xor dl, dl    ;Error code counter
  1126 00004439 807E0102            <1>     cmp byte [rsi + 1], 02h    ;Check if valid config descriptor
  1127 0000443D 753F                <1>     jne .ecvifail
  1128 0000443F FEC2                <1>     inc dl
  1129                              <1> ;cl counts ep's per interface, ch counts possible interfaces
  1130 00004441 8A6E05              <1>     mov ch, byte [rsi + 5]        ;Get number of interfaces
  1131                              <1> .ecvi0:
  1132 00004444 84ED                <1>     test ch, ch
  1133 00004446 7436                <1>     jz .ecvifail    ;Zero interfaces is invalid for us
  1134 00004448 FEC2                <1>     inc dl
  1135                              <1> 
  1136 0000444A 4889F3              <1>     mov rbx, rsi    ;Save this descriptor in rbx
  1137 0000444D 480FB633            <1>     movzx rsi, byte [rbx]    ;get the size of the config to skip
  1138 00004451 4801DE              <1>     add rsi, rbx    ;point rsi to head of first interface descriptor
  1139 00004454 807E0104            <1>     cmp byte [rsi + 1], 04h    ;Check if valid interface descriptor
  1140 00004458 7524                <1>     jne .ecvifail
  1141 0000445A FEC2                <1>     inc dl
  1142 0000445C 8A4E04              <1>     mov cl, byte [rsi + 4]
  1143                              <1> ;Cmp IF has valid class/prototcol
  1144 0000445F 4831C0              <1>     xor rax, rax    ;Device signature, 0 is msd, 1 is hub
  1145 00004462 E859000000          <1>     call .ehciCheckMsdIf
  1146 00004467 7309                <1>     jnc    .ecviif    ;Not clear => valid interface
  1147 00004469 FEC4                <1>     inc ah    ;Device signature, 0 is msd, 1 is hub
  1148 0000446B E831000000          <1>     call .ehciCheckHubIf
  1149 00004470 7213                <1>     jc    .ecvibadif    ;Clear => bad interface
  1150                              <1> .ecviif:    ;Valid interface found
  1151 00004472 8A4602              <1>     mov al, byte [rsi + 2]    ;Get interface number into al
  1152 00004475 4889F3              <1>     mov rbx, rsi    ;Save pointer in rbx for return
  1153 00004478 F8                  <1>     clc ;Clear carry
  1154                              <1> .ecviexit:
  1155 00004479 5A                  <1>     pop rdx
  1156 0000447A 59                  <1>     pop rcx
  1157 0000447B 5F                  <1>     pop rdi
  1158 0000447C 5E                  <1>     pop rsi
  1159 0000447D C3                  <1>     ret
  1160                              <1> .ecvifail:
  1161 0000447E 31DB                <1>     xor ebx, ebx    ;Zero rbx for bad returns
  1162 00004480 F9                  <1>     stc
  1163 00004481 88D0                <1>     mov al, dl    ;Move error code
  1164 00004483 EBF4                <1>     jmp short .ecviexit
  1165                              <1> .ecvibadif:    ;Bad interface, goto next interface
  1166 00004485 84C9                <1>     test cl, cl
  1167 00004487 740B                <1>     jz .ecvibadif1
  1168 00004489 FEC9                <1>     dec cl
  1169 0000448B 4881C607000000      <1>     add rsi, 7
  1170 00004492 EBF1                <1>     jmp short .ecvibadif
  1171                              <1> .ecvibadif1:
  1172 00004494 4881C609000000      <1>     add rsi, 9
  1173 0000449B FECD                <1>     dec ch
  1174 0000449D B201                <1>     mov dl, 1
  1175 0000449F EBA3                <1>     jmp short .ecvi0
  1176                              <1> .ehciCheckHubIf:
  1177                              <1> ;Input: rsi points to interface descriptor
  1178                              <1> ;Output: All registers preserved, carry set if NOT valid hub
  1179 000044A1 56                  <1>     push rsi
  1180 000044A2 807E0509            <1>     cmp byte [rsi + 5], 09h
  1181 000044A6 7515                <1>     jne .ecdhfail
  1182 000044A8 807E0600            <1>     cmp byte [rsi + 6], 0
  1183 000044AC 750F                <1>     jne .ecdhfail
  1184 000044AE 807E0702            <1>     cmp byte [rsi + 7], 2
  1185 000044B2 7709                <1>     ja .ecdhfail
  1186 000044B4 807E0401            <1>     cmp byte [rsi + 4], 1    ;One endpoint to rule them all
  1187 000044B8 7503                <1>     jne .ecdhfail
  1188 000044BA F8                  <1>     clc 
  1189                              <1> .ecdhexit:
  1190 000044BB 5E                  <1>     pop rsi
  1191 000044BC C3                  <1>     ret
  1192                              <1> .ecdhfail:
  1193 000044BD F9                  <1>     stc
  1194 000044BE EBFB                <1>     jmp short .ecdhexit
  1195                              <1> .ehciCheckMsdIf:
  1196                              <1> ;Input: rsi points to interface descriptor
  1197                              <1> ;Output: Carry set if fail, ax destroyed
  1198                              <1> ;    rsi points to good descriptor if all ok
  1199                              <1> ;Note we only accept 09/00/50 and 09/06/50
  1200 000044C0 56                  <1>     push rsi
  1201 000044C1 53                  <1>     push rbx
  1202 000044C2 51                  <1>     push rcx
  1203 000044C3 807E0508            <1>     cmp byte [rsi + 5], 08h    ;MSD class
  1204 000044C7 7517                <1>     jne .ecdmfail
  1205                              <1> ;Subclass check
  1206 000044C9 807E0606            <1>     cmp byte [rsi + 6], 06h    ;SCSI actual
  1207 000044CD 7406                <1>     je .ecdmprot
  1208 000044CF 807E0600            <1>     cmp byte [rsi + 6], 00h    ;SCSI defacto
  1209 000044D3 750B                <1>     jne .ecdmfail
  1210                              <1> .ecdmprot:
  1211 000044D5 807E0750            <1>     cmp byte [rsi + 7], 50h    ;BBB
  1212 000044D9 7505                <1>     jne .ecdmfail
  1213                              <1> .ecdmprotUAF:   ;Dummy label to find where to add this later
  1214                              <1> .ecdmpass:
  1215 000044DB F8                  <1>     clc
  1216                              <1> .ecdmexit:
  1217 000044DC 59                  <1>     pop rcx
  1218 000044DD 5B                  <1>     pop rbx
  1219 000044DE 5E                  <1>     pop rsi
  1220 000044DF C3                  <1>     ret
  1221                              <1> .ecdmfail:
  1222 000044E0 F9                  <1>     stc
  1223 000044E1 EBF9                <1>     jmp short .ecdmexit
  1224                              <1> .ehciGetDevicePtr:
  1225                              <1> ;Gets address/bus pair and returns in rax a pointer to the data
  1226                              <1> ;structure of the device, in the data table.
  1227                              <1> ;Input: ah = bus number, al = Address number
  1228                              <1> ;Output: ax = Preserved, rsi = Pointer to table structure, bl = USB Class Code
  1229 000044E3 51                  <1>     push rcx
  1230 000044E4 52                  <1>     push rdx
  1231 000044E5 55                  <1>     push rbp
  1232 000044E6 B90A000000          <1>     mov ecx, usbMaxDevices
  1233 000044EB 48BE-               <1>     mov rsi, usbDevTbl
  1233 000044ED [4D02000000000000]  <1>
  1234                              <1> .egdp0:
  1235 000044F5 663B06              <1>     cmp ax, word [rsi]
  1236 000044F8 740E                <1>     je .egdp1   ;Device found
  1237 000044FA 4881C603000000      <1>     add rsi, usbDevTblEntry_size
  1238 00004501 66FFC9              <1>     dec cx
  1239 00004504 7447                <1>     jz .egdpfail    ;Got to the end with no dev found, exit
  1240 00004506 EBED                <1>     jmp short .egdp0
  1241                              <1> .egdp1:
  1242 00004508 48BD-               <1>     mov rbp, hubDevTbl
  1242 0000450A [6B02000000000000]  <1>
  1243 00004512 B908000000          <1>     mov ecx, hubDevTblEntry_size
  1244 00004517 0FB65E02            <1>     movzx ebx, byte [rsi + 2]  ;Return bl for device type
  1245 0000451B 80FB09              <1>     cmp bl, 09h ;Are we hub?
  1246 0000451E 48BE-               <1>     mov rsi, msdDevTbl  ;Set to msd
  1246 00004520 [BB02000000000000]  <1>
  1247 00004528 BA10000000          <1>     mov edx, msdDevTblEntry_size
  1248 0000452D 480F44F5            <1>     cmove rsi, rbp  ;If hub, reload rsi pointer to hub table
  1249 00004531 0F44D1              <1>     cmove edx, ecx    ;If hub, reload dx with hub table size
  1250 00004534 B90A000000          <1>     mov ecx, usbMaxDevices
  1251                              <1> .egdp2:
  1252 00004539 663B06              <1>     cmp ax, word [rsi]
  1253 0000453C 740A                <1>     je .egdp3
  1254 0000453E 4801D6              <1>     add rsi, rdx    ;rdx contains size of entry for either table
  1255 00004541 66FFC9              <1>     dec cx
  1256 00004544 7407                <1>     jz .egdpfail
  1257 00004546 EBF1                <1>     jmp short .egdp2
  1258                              <1> .egdp3:
  1259 00004548 F8                  <1>     clc
  1260                              <1> .egdpexit:
  1261 00004549 5D                  <1>     pop rbp
  1262 0000454A 5A                  <1>     pop rdx
  1263 0000454B 59                  <1>     pop rcx
  1264 0000454C C3                  <1>     ret
  1265                              <1> .egdpfail:
  1266 0000454D 6631DB              <1>     xor bx, bx
  1267 00004550 F9                  <1>     stc
  1268 00004551 EBF6                <1>     jmp short .egdpexit
  1269                              <1> 
  1270                              <1> .ehciProbeQhead:
  1271                              <1> ;A proc that returns a Queue Heads' status byte in bl.
  1272                              <1> ;Input:
  1273                              <1> ;   rbx = Address of QHead to probe
  1274                              <1> ;Output: 
  1275                              <1> ;   bl = Status byte, if 0, successful transfer!
  1276 00004553 8A5B18              <1>     mov bl, byte [rbx + 18h]  ;08h is offset in qTD
  1277 00004556 C3                  <1>     ret
  1278                              <1> .ehciStandardErrorHandler:
  1279                              <1> ;Attempts to verify if something went wrong in previous transaction.
  1280                              <1> ;May only be called if eActiveInt has bit USBSTS bit set
  1281                              <1> ;Input:  al = Device Address
  1282                              <1> ;        cx = Default Endpoint Size
  1283                              <1> ;Output: CF=CY: Host error, Reset host system
  1284                              <1> ;        CF=NC: Proceed with below
  1285                              <1> ;        al = 0 => Benign error, Make request again/Verify data.
  1286                              <1> ;        al = 1 => Stall, Transaction error or Handshake error, corrected.
  1287                              <1> ;        al = 80h => Fatal error, EPClear errored out, but no clear reason why
  1288                              <1> ;        al > 80h => Bits 6-0 give the status byte for the error on EP Clear.
  1289                              <1> ;                  Bit 7 is the fatal error bit. 
  1290                              <1> ;                  If set, recommend device is port reset.
  1291                              <1> ;All other registers preserved
  1292 00004557 53                  <1>     push rbx
  1293 00004558 4150                <1>     push r8
  1294 0000455A 4151                <1>     push r9
  1295                              <1> 
  1296 0000455C 4989C0              <1>     mov r8, rax
  1297 0000455F 4989C9              <1>     mov r9, rcx
  1298 00004562 30C0                <1>     xor al, al                  ;Set error counter and clear CF
  1299 00004564 F60425[49020000]02  <1>     test byte [eActiveInt], 2   ;Error Interrupt
  1300 0000456C 744B                <1>     jz .esehexit                ;No error found, should not have been called
  1301 0000456E 488B1C25[3F020000]  <1>     mov rbx, qword [eCurrAsyncHead] ;Get the current transacting QHead address
  1302 00004576 E8D8FFFFFF          <1>     call .ehciProbeQhead    ;Ret in bl status byte
  1303 0000457B 80E378              <1>     and bl, 01111000b       ;Check if it is something we should clear EP for
  1304 0000457E 7439                <1>     jz .esehexit            ;If it is not, benign error. al = 0
  1305                              <1> 
  1306 00004580 488B1C25[3F020000]  <1>     mov rbx, qword [eCurrAsyncHead] ;Get current AsyncHead again
  1307 00004588 4488C0              <1>     mov al, r8b        ;Device Address
  1308 0000458B 664489C9            <1>     mov cx, r9w        ;EP size
  1309 0000458F 8A5B05              <1>     mov bl, byte [rbx + 05h]  ;Get Endpoint to reset
  1310 00004592 80E30F              <1>     and bl, 0Fh ;Lo nybble only
  1311 00004595 E828000000          <1>     call .ehciClearEpStallHalt
  1312 0000459A 721D                <1>     jc .esehexit        ;HC error!
  1313 0000459C B001                <1>     mov al, 1           ;Stall cleared
  1314 0000459E F60425[49020000]02  <1>     test byte [eActiveInt], 2   ;Check if interrupt returned an error
  1315 000045A6 7411                <1>     jz .esehexit                ;No error found, return al=1, stall cleared
  1316 000045A8 B080                <1>     mov al, 80h                 ;Fatal error indication
  1317 000045AA 488B1C25[3F020000]  <1>     mov rbx, qword [eCurrAsyncHead] ;Get the current transacting QHead address
  1318 000045B2 E89CFFFFFF          <1>     call .ehciProbeQhead   
  1319 000045B7 08D8                <1>     or al, bl          ;Add error bits to al for Fatal error indication.
  1320                              <1> .esehexit:
  1321 000045B9 4C89C9              <1>     mov rcx, r9
  1322 000045BC 4159                <1>     pop r9
  1323 000045BE 4158                <1>     pop r8
  1324 000045C0 5B                  <1>     pop rbx
  1325 000045C1 C3                  <1>     ret
  1326                              <1> 
  1327                              <1> .ehciClearEpStallHalt:
  1328                              <1> ;Clears a halt or stall on an endpoint.
  1329                              <1> ;Input: bl=Endpoint (0 for control)
  1330                              <1> ;       al=Device Address
  1331                              <1> ;       cx=Ctrl Endpoint Size
  1332                              <1> ;Output:
  1333                              <1> ;   CF=CY: Host error, Reset host system
  1334                              <1> ;   CF=NC: Transaction succeeded, check interrupt error bit for confirmation
  1335 000045C2 53                  <1>     push rbx
  1336 000045C3 480FB6DB            <1>     movzx rbx, bl
  1337 000045C7 48C1E320            <1>     shl rbx, 2*10h  ;Shift wIndex by two words
  1338 000045CB 4881CB02010000      <1>     or rbx, 0102h   ;01=bRequest(CLEAR_FEATURE) 02h=bmRequestType (Endpoint)
  1339 000045D2 E892F7FFFF          <1>     call .ehciSetNoData
  1340 000045D7 5B                  <1>     pop rbx ;Get original bx
  1341 000045D8 C3                  <1>     ret
  1342                              <1> 
  1343                              <1> .ehciWriteQHead:
  1344                              <1> ;Writes a Queue head at rdi, and clears the space for the transfer descriptor
  1345                              <1> ;rdi points at the head of the qhead on return
  1346                              <1> ;All non argument registers preserved
  1347                              <1> ;r8d=Horizontal Ptr + Typ + T
  1348                              <1> ;r9d=Endpoint Characteristics
  1349                              <1> ;r10d=Endpoint Capabilities
  1350                              <1> ;r11d=Next qTD Pointer
  1351 000045D9 50                  <1>     push rax
  1352 000045DA 51                  <1>     push rcx
  1353 000045DB 57                  <1>     push rdi
  1354 000045DC 31C0                <1>     xor eax, eax
  1355 000045DE 4489C0              <1>     mov eax, r8d
  1356 000045E1 AB                  <1>     stosd
  1357 000045E2 4489C8              <1>     mov eax, r9d
  1358 000045E5 AB                  <1>     stosd
  1359 000045E6 4489D0              <1>     mov eax, r10d
  1360 000045E9 AB                  <1>     stosd
  1361 000045EA 31C0                <1>     xor eax, eax
  1362 000045EC AB                  <1>     stosd            ;Enter 0 for the current qTD pointer entry
  1363 000045ED 4489D8              <1>     mov eax, r11d
  1364 000045F0 AB                  <1>     stosd
  1365 000045F1 B90A000000          <1>     mov ecx, 10
  1366 000045F6 31C0                <1>     xor eax, eax
  1367 000045F8 F3AB                <1>     rep stosd
  1368 000045FA 5F                  <1>     pop rdi
  1369 000045FB 59                  <1>     pop rcx
  1370 000045FC 58                  <1>     pop rax
  1371 000045FD C3                  <1>     ret
  1372                              <1> .ehciWriteQHeadTD:
  1373                              <1> ;Writes a transfer descriptor at the location pointed at by rdi
  1374                              <1> ;rdi points at the head of the qheadTD on return
  1375                              <1> ;All registers except passed arguments, preserved
  1376                              <1> ;rdi=location for current linked list element
  1377                              <1> ;r8d=Next qTD ptr
  1378                              <1> ;r9d=Alternate Next qTD ptr
  1379                              <1> ;r10d=Transfer Descriptor Token
  1380                              <1> ;r11=Buffer Ptr 0 + Current Offset
  1381 000045FE 50                  <1>     push rax
  1382 000045FF 57                  <1>     push rdi
  1383 00004600 4489C0              <1>     mov eax, r8d
  1384 00004603 AB                  <1>     stosd
  1385 00004604 4489C8              <1>     mov eax, r9d
  1386 00004607 AB                  <1>     stosd
  1387 00004608 4489D0              <1>     mov eax, r10d
  1388 0000460B AB                  <1>     stosd
  1389 0000460C 4489D8              <1>     mov eax, r11d
  1390 0000460F AB                  <1>     stosd
  1391 00004610 2500F0FFFF          <1>     and eax, 0FFFFF000h
  1392 00004615 0500100000          <1>     add eax, 1000h
  1393 0000461A AB                  <1>     stosd
  1394 0000461B 0500100000          <1>     add eax, 1000h
  1395 00004620 AB                  <1>     stosd
  1396 00004621 0500100000          <1>     add eax, 1000h
  1397 00004626 AB                  <1>     stosd
  1398 00004627 0500100000          <1>     add eax, 1000h
  1399 0000462C AB                  <1>     stosd
  1400                              <1> 
  1401 0000462D 4C89D8              <1>     mov rax, r11
  1402 00004630 48C1C820            <1>     ror rax, 20h
  1403 00004634 AB                  <1>     stosd
  1404 00004635 48C1C820            <1>     ror rax, 20h
  1405 00004639 482500F0FFFF        <1>     and rax, 0FFFFFFFFFFFFF000h
  1406 0000463F 480500100000        <1>     add rax, 1000h
  1407 00004645 48C1C820            <1>     ror rax, 20h
  1408 00004649 AB                  <1>     stosd
  1409 0000464A 48C1C820            <1>     ror rax, 20h
  1410 0000464E 480500100000        <1>     add rax, 1000h
  1411 00004654 48C1C820            <1>     ror rax, 20h
  1412 00004658 AB                  <1>     stosd  
  1413 00004659 48C1C820            <1>     ror rax, 20h
  1414 0000465D 480500100000        <1>     add rax, 1000h
  1415 00004663 48C1C820            <1>     ror rax, 20h
  1416 00004667 AB                  <1>     stosd
  1417 00004668 48C1C820            <1>     ror rax, 20h
  1418 0000466C 480500100000        <1>     add rax, 1000h
  1419 00004672 48C1C820            <1>     ror rax, 20h
  1420 00004676 AB                  <1>     stosd
  1421 00004677 5F                  <1>     pop rdi
  1422 00004678 58                  <1>     pop rax
  1423 00004679 C3                  <1>     ret
  1424                              <1> 
  1425                              <1> 
  1426                              <1> .ehciDevSetupHub:
  1427                              <1> ;Device specific setup. Takes rsi as a ptr to the 
  1428                              <1> ; specific device parameter block.
  1429 0000467A 53                  <1>     push rbx
  1430 0000467B 51                  <1>     push rcx
  1431 0000467C 56                  <1>     push rsi
  1432 0000467D 55                  <1>     push rbp
  1433 0000467E 6631ED              <1>     xor bp, bp    ;Error Stage 0
  1434                              <1> .edshub:
  1435 00004681 E839030000          <1>     call .ehciHubClassDescriptor
  1436 00004686 0F82DA000000        <1>     jc .edsfail
  1437 0000468C 66FFC5              <1>     inc bp  ;Error Stage 1
  1438 0000468F 8A4E05              <1>     mov cl, byte [rsi + 5] ;Get number of ports here
  1439 00004692 B201                <1>     mov dl, 1   ;Start port number to begin enum on (hub ports start at 1)
  1440                              <1> .edshub1:
  1441 00004694 49BC03000000000000- <1>     mov r12, 3
  1441 0000469D 00                  <1>
  1442                              <1> .edshub11:
  1443 0000469E E8CB000000          <1>     call .ehciEnumerateHubPort    ;dl for port to scan/enumerate
  1444 000046A3 7413                <1>     jz .edshub13    ;If ZF=ZR, valid device found!
  1445 000046A5 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h  ;General Controller Failure
  1446 000046AD 0F8448F3FFFF        <1>     je USB.ehciCriticalErrorWrapper
  1447 000046B3 49FFCC              <1>     dec r12
  1448 000046B6 75E6                <1>     jnz .edshub11   ;Still not zero but failed, try again.
  1449                              <1> .edshub13:
  1450 000046B8 FEC2                <1>     inc dl  ;Start with port 1
  1451 000046BA 38D1                <1>     cmp cl, dl
  1452 000046BC 73D6                <1>     jae .edshub1
  1453                              <1> .edshub2:
  1454                              <1> ;Need to write bHostHub for any detected devices here
  1455 000046BE F8                  <1>     clc    ;Common success exit
  1456 000046BF 5D                  <1>     pop rbp
  1457 000046C0 5E                  <1>     pop rsi
  1458 000046C1 59                  <1>     pop rcx
  1459 000046C2 5B                  <1>     pop rbx
  1460 000046C3 C3                  <1>     ret
  1461                              <1> 
  1462                              <1> .ehciDeviceSetupMsd:
  1463                              <1> ; Input:  rsi = MSD Device Parameter Block
  1464                              <1> ; Output: CF=CY if catastrophic host error.
  1465                              <1> ;         CF=NC then ax = Return code
  1466                              <1> ;         ax = 0 if successful setup
  1467                              <1> ;         ax = 1 if device did not reset the first time
  1468                              <1> ;         ax = 2 if device did not return a valid LUN
  1469                              <1> ;         ax = 3 if device did not reset the second time
  1470                              <1> ;         Device must me removed from tables and port reset if ax != 0
  1471 000046C4 51                  <1>     push rcx
  1472 000046C5 55                  <1>     push rbp
  1473 000046C6 4150                <1>     push r8
  1474 000046C8 6631ED              <1>     xor bp, bp    ;Error Stage 0
  1475                              <1> .edsmsd:
  1476 000046CB 49B810000000000000- <1>     mov r8, 10h ;Loop counter setup
  1476 000046D4 00                  <1>
  1477                              <1> .edsm1:
  1478 000046D5 E870040000          <1>     call .ehciMsdDeviceReset
  1479 000046DA 0F8281000000        <1>     jc .edsexit
  1480                              <1> ;Check eActiveInterrupt for confirmation if we need to handle error
  1481 000046E0 F60425[49020000]02  <1>     test byte [eActiveInt], 2   ;If this is set, handle error
  1482 000046E8 7416                <1>     jz .edsms2
  1483 000046EA 668B4E07            <1>     mov cx, word [rsi + 7]    ;Pass endpoint size
  1484 000046EE 8A06                <1>     mov al, byte [rsi]  ;Device address
  1485 000046F0 E862FEFFFF          <1>     call .ehciStandardErrorHandler
  1486 000046F5 A880                <1>     test al, 80h 
  1487 000046F7 756D                <1>     jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  1488 000046F9 49FFC8              <1>     dec r8                ;Dec loop counter
  1489 000046FC 7468                <1>     jz .edsfail           ;Fatal error if after 16 goes nothing was resolved
  1490 000046FE EBD5                <1>     jmp short .edsm1
  1491                              <1> .edsms2:
  1492 00004700 66FFC5              <1>     inc bp  ;Error Stage 1
  1493                              <1> .edsms3:
  1494 00004703 E86C040000          <1>     call .ehciMsdGetMaxLun  ;If stall, clear endpoint and proceed. No loop
  1495 00004708 7257                <1>     jc .edsexit
  1496 0000470A F60425[49020000]02  <1>     test byte [eActiveInt], 2   ;If this is set, handle error
  1497 00004712 740F                <1>     jz .edsms4
  1498                              <1> 
  1499 00004714 668B4E07            <1>     mov cx, word [rsi + 7]    ;Pass endpoint size
  1500 00004718 8A06                <1>     mov al, byte [rsi]  ;Device address
  1501 0000471A E838FEFFFF          <1>     call .ehciStandardErrorHandler
  1502 0000471F A880                <1>     test al, 80h 
  1503 00004721 7543                <1>     jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  1504                              <1> .edsms4:
  1505 00004723 66FFC5              <1>     inc bp  ;Error Stage 2
  1506 00004726 49B810000000000000- <1>     mov r8, 10h ;Loop counter setup
  1506 0000472F 00                  <1>
  1507                              <1> .edsms5:
  1508 00004730 E815040000          <1>     call .ehciMsdDeviceReset  ;Reset once again to clear issues
  1509 00004735 722A                <1>     jc .edsexit
  1510 00004737 F60425[49020000]02  <1>     test byte [eActiveInt], 2   ;If this is set, handle error
  1511 0000473F 7416                <1>     jz .edsms6
  1512                              <1> 
  1513 00004741 668B4E07            <1>     mov cx, word [rsi + 7]    ;Pass endpoint size
  1514 00004745 8A06                <1>     mov al, byte [rsi]  ;Device address
  1515 00004747 E80BFEFFFF          <1>     call .ehciStandardErrorHandler
  1516 0000474C A880                <1>     test al, 80h 
  1517 0000474E 7516                <1>     jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  1518 00004750 49FFC8              <1>     dec r8                 ;Dec loop counter
  1519 00004753 7411                <1>     jz .edsfail           ;Fatal error if after 16 goes nothing was resolved
  1520 00004755 EBD9                <1>     jmp short .edsms5
  1521                              <1> .edsms6:
  1522 00004757 FE0425[4C020000]    <1>     inc byte [numMSD] 
  1523 0000475E 6631C0              <1>     xor ax, ax  ;Note that xor also clears CF
  1524                              <1> .edsexit:
  1525 00004761 4158                <1>     pop r8
  1526 00004763 5D                  <1>     pop rbp
  1527 00004764 59                  <1>     pop rcx
  1528 00004765 C3                  <1>     ret
  1529                              <1> .edsfail:
  1530                              <1> ;If a fail occurs, then the entry needs to be removed from the data tables
  1531 00004766 6689E8              <1>     mov ax, bp
  1532 00004769 E9F3FFFFFF          <1>     jmp .edsexit
  1533                              <1> 
  1534                              <1> .ehciEnumerateHubPort:
  1535                              <1> ;Enumerates devices on an external Hub.
  1536                              <1> ;Use rsi to get device properties
  1537                              <1> ;Input: rsi = ptr to hub device block
  1538                              <1> ;       dl = Port number to reset
  1539                              <1> ;Output: None, CF
  1540                              <1> 
  1541 0000476E 53                  <1>     push rbx
  1542 0000476F 51                  <1>     push rcx
  1543 00004770 52                  <1>     push rdx
  1544 00004771 55                  <1>     push rbp
  1545 00004772 4150                <1>     push r8
  1546 00004774 4151                <1>     push r9
  1547 00004776 4152                <1>     push r10
  1548 00004778 4153                <1>     push r11
  1549                              <1> 
  1550 0000477A 0FB6D2              <1>     movzx edx, dl
  1551 0000477D 48C1E220            <1>     shl rdx, 4*8    ;Shift port number to right bits
  1552                              <1> .eehdeinit:
  1553 00004781 6631ED              <1>     xor bp, bp  ;Error counter
  1554 00004784 4C0FB70E            <1>     movzx r9, word [rsi]        ;Save hub bus/addr in r9w
  1555 00004788 4C0FB64604          <1>     movzx r8, byte [rsi + 4]    ;Get MaxPacketSize0
  1556                              <1> 
  1557                              <1> .eehde0:
  1558 0000478D 48BB23030800000000- <1>     mov rbx, 0000000000080323h  ;Set port power feature
  1558 00004796 00                  <1>
  1559 00004797 4809D3              <1>     or rbx, rdx ;Add port number into descriptor
  1560 0000479A 664489C1            <1>     mov cx, r8w
  1561 0000479E 4488C8              <1>     mov al, r9b
  1562 000047A1 E8C3F5FFFF          <1>     call .ehciSetNoData   ;Turn on power to port on device in addr al
  1563 000047A6 0F829F010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1564                              <1> .eehde1:
  1565                              <1> ;Power on debounce!
  1566 000047AC B486                <1>     mov ah, 86h
  1567 000047AE 0FB64E06            <1>     movzx ecx, byte [rsi + 6]   ;poweron2powergood
  1568 000047B2 D1E1                <1>     shl ecx, 1
  1569 000047B4 CD35                <1>     int 35h
  1570                              <1> 
  1571 000047B6 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 1)
  1572                              <1> .eehde2:
  1573 000047B9 48BB23011000000000- <1>     mov rbx, 0000000000100123h  ;Clear port set connection bit
  1573 000047C2 00                  <1>
  1574 000047C3 4809D3              <1>     or rbx, rdx ;Add port number into descriptor
  1575 000047C6 4488C1              <1>     mov cl, r8b
  1576 000047C9 4488C8              <1>     mov al, r9b
  1577 000047CC E898F5FFFF          <1>     call .ehciSetNoData
  1578 000047D1 0F8274010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1579                              <1> .eehde3:
  1580                              <1> 
  1581 000047D7 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 2)
  1582                              <1> .eehde31:
  1583 000047DA 48BBA3000000000004- <1>     mov rbx, 00040000000000A3h ;Get port status
  1583 000047E3 00                  <1>
  1584 000047E4 4809D3              <1>     or rbx, rdx
  1585 000047E7 4488C1              <1>     mov cl, r8b
  1586 000047EA 4488C8              <1>     mov al, r9b
  1587 000047ED E816F6FFFF          <1>     call .ehciGetRequest
  1588 000047F2 0F8253010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1589                              <1> .eehde4:
  1590 000047F8 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 3)
  1591                              <1> 
  1592 000047FB 8A0C25[C0030000]    <1>     mov cl, byte [ehciDataIn]   ;Get the first byte in into cx
  1593 00004802 F6C101              <1>     test cl, 1  ;Check device in port
  1594 00004805 0F8436010000        <1>     jz .eehdebadnotimeout
  1595                              <1> 
  1596                              <1> .eehde41:   ;EP for first port reset state
  1597 0000480B 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 4)
  1598 0000480E E83D010000          <1>     call .eehdereset    ;First port reset
  1599 00004813 0F8232010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1600                              <1> 
  1601 00004819 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 5)
  1602                              <1> 
  1603 0000481C 49BB10000000000000- <1>     mov r11, 10h
  1603 00004825 00                  <1>
  1604                              <1> .eehde5:
  1605 00004826 48BBA3000000000004- <1>     mov rbx, 00040000000000A3h ;Get port status again
  1605 0000482F 00                  <1>
  1606 00004830 4809D3              <1>     or rbx, rdx
  1607 00004833 4488C1              <1>     mov cl, r8b
  1608 00004836 4488C8              <1>     mov al, r9b
  1609 00004839 E8CAF5FFFF          <1>     call .ehciGetRequest
  1610 0000483E 0F8207010000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1611                              <1> .eehde6:
  1612 00004844 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 6)
  1613                              <1> ;Now check for high speed
  1614                              <1> 
  1615 00004847 668B0C25[C0030000]  <1>     mov cx, word [ehciDataIn]
  1616 0000484F 6681E1FF07          <1>     and cx, 7FFh    ;Zero upper bits
  1617 00004854 66C1E909            <1>     shr cx, 9   ;Bring bits [10:9] low
  1618 00004858 6681F90200          <1>     cmp cx, 2   ;2 is High Speed device
  1619 0000485D 0F85DE000000        <1>     jne .eehdebadnotimeout
  1620 00004863 48C70425[C0030000]- <1>     mov qword [ehciDataIn], 0
  1620 0000486B 00000000            <1>
  1621                              <1> 
  1622 0000486F 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 7)
  1623                              <1> 
  1624 00004872 57                  <1>     push rdi
  1625 00004873 48BF-               <1>     mov rdi, ehciDataIn
  1625 00004875 [C003000000000000]  <1>
  1626 0000487D B908000000          <1>     mov ecx, 8
  1627 00004882 31C0                <1>     xor eax, eax
  1628 00004884 F348AB              <1>     rep stosq
  1629 00004887 5F                  <1>     pop rdi
  1630                              <1> .eehde7:
  1631 00004888 48BB23011200000000- <1>     mov rbx, 0000000000120123h  ;Clear port suspend
  1631 00004891 00                  <1>
  1632 00004892 4809D3              <1>     or rbx, rdx ;Add port number into descriptor
  1633 00004895 4488C1              <1>     mov cl, r8b
  1634 00004898 4488C8              <1>     mov al, r9b
  1635 0000489B E8C9F4FFFF          <1>     call .ehciSetNoData
  1636 000048A0 0F82A5000000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1637                              <1> 
  1638                              <1> .eehde10:
  1639 000048A6 48BB80060001000008- <1>     mov rbx, 00008000001000680h    ;Pass get minimal device descriptor
  1639 000048AF 00                  <1>
  1640 000048B0 66B94000            <1>     mov cx, 40h    ;Pass default endpoint size
  1641 000048B4 30C0                <1>     xor al, al
  1642 000048B6 E84DF5FFFF          <1>     call .ehciGetRequest
  1643 000048BB 0F828A000000        <1>     jc .eehdecritical  ;Fast exit with carry set
  1644                              <1> .eehde101:
  1645 000048C1 66FFC5              <1>     inc bp      ;Increment Error Counter    (Stage 8)
  1646                              <1> 
  1647 000048C4 803C25[C1030000]01  <1>     cmp byte [ehciDataIn + 1], 01h    ;Verify this is a valid dev descriptor
  1648 000048CC 756E                <1>     jne .eehdebad       ;ehciDataIn contains error signature
  1649                              <1> 
  1650                              <1> ;Sanity check the returned descriptor here
  1651                              <1> .eehde11:
  1652 000048CE 66813C25[C2030000]- <1>     cmp word [ehciDataIn + 2], 0200h    ;Verify this is a USB 2.0+ device or
  1652 000048D6 0002                <1>
  1653 000048D8 7262                <1>     jb .eehdebad
  1654 000048DA 803C25[C4030000]00  <1>     cmp byte [ehciDataIn + 4], 0    ;Check interfaces
  1655 000048E2 7414                <1>     je .eehde12
  1656 000048E4 803C25[C4030000]08  <1>     cmp byte [ehciDataIn + 4], 08h    ;MSD?
  1657 000048EC 740A                <1>     je .eehde12
  1658 000048EE 803C25[C4030000]09  <1>     cmp byte [ehciDataIn + 4], 09h    ;Hub?
  1659 000048F6 7544                <1>     jne .eehdebad
  1660                              <1> 
  1661                              <1> .eehde12:    ;Valid device detected
  1662 000048F8 440FB60425-         <1>     movzx r8d, byte [ehciDataIn + 7]   ;Save attached device max ep size
  1662 000048FD [C7030000]          <1>
  1663                              <1> .eehde13: 
  1664 00004901 E84A000000          <1>     call .eehdereset    ;Do second reset
  1665 00004906 7243                <1>     jc .eehdecritical  ;Fast exit with carry set
  1666                              <1> ;Clear the data in buffer
  1667 00004908 57                  <1>     push rdi
  1668 00004909 48BF-               <1>     mov rdi, ehciDataIn
  1668 0000490B [C003000000000000]  <1>
  1669 00004913 B908000000          <1>     mov ecx, 8
  1670 00004918 31C0                <1>     xor eax, eax
  1671 0000491A F348AB              <1>     rep stosq
  1672 0000491D 5F                  <1>     pop rdi
  1673                              <1> 
  1674                              <1> ;Device on port now ready to have an address set to it, and be enumerated
  1675 0000491E 48C1EA20            <1>     shr rdx, 4*8    ;Shift port number back down to dl
  1676 00004922 668B06              <1>     mov ax, word [rsi]  ;Get hub bus/addr pair
  1677 00004925 88E6                <1>     mov dh, ah          ;Move the bus number into dh
  1678 00004927 440FB6D0            <1>     movzx r10d, al      ;Move hub address into r10b
  1679                              <1> ;Ensure dl=port number - 1, dh=Root hub (Bus) number, r10b=Host hub number
  1680                              <1> ;       r8b=Max Control EP endpoint size
  1681 0000492B 49BB64000000000000- <1>     mov r11, 100    ;Address settle time
  1681 00004934 00                  <1>
  1682 00004935 FECA                <1>     dec dl
  1683 00004937 E998F7FFFF          <1>     jmp .ehciEnumCommonEp
  1684                              <1> 
  1685                              <1> .eehdebad:
  1686                              <1> .eehdebadnoport:    ;EP if done without disabling port
  1687 0000493C E987F8FFFF          <1>     jmp .ehciedbadnoport
  1688                              <1> .eehdebadnotimeout:
  1689 00004941 E98DF8FFFF          <1>     jmp .ehciedbadnotimeout
  1690                              <1> .eehdebadremtables:
  1691 00004946 E99AF8FFFF          <1>     jmp .ehcibadremtables
  1692                              <1> .eehdecritical:
  1693 0000494B E96BF8FFFF          <1>     jmp .ehciedexit  ;Fast exit with carry set
  1694                              <1> .eehdereset:
  1695                              <1> ;rsi must point to valid Hub device block
  1696 00004950 48BB23030400000000- <1>     mov rbx, 0000000000040323h  ;Reset port 
  1696 00004959 00                  <1>
  1697 0000495A 4809D3              <1>     or rbx, rdx ;Add device address
  1698 0000495D 4488C1              <1>     mov cl, r8b
  1699 00004960 4488C8              <1>     mov al, r9b
  1700 00004963 E801F4FFFF          <1>     call .ehciSetNoData
  1701 00004968 7254                <1>     jc .eehcritexit
  1702                              <1> 
  1703 0000496A 49BB88130000000000- <1>     mov r11, 5000 ;Just keep trying
  1703 00004973 00                  <1>
  1704                              <1> .eehder1:
  1705 00004974 B486                <1>     mov ah, 86h
  1706 00004976 B914000000          <1>     mov ecx, 20     ;20 ms is max according to USB 2.0 standard
  1707 0000497B CD35                <1>     int 35h
  1708                              <1> 
  1709 0000497D 48BBA3000000000004- <1>     mov rbx, 00040000000000A3h ;Get port status
  1709 00004986 00                  <1>
  1710 00004987 4809D3              <1>     or rbx, rdx
  1711 0000498A 4488C1              <1>     mov cl, r8b
  1712 0000498D 4488C8              <1>     mov al, r9b
  1713 00004990 E873F4FFFF          <1>     call .ehciGetRequest
  1714 00004995 8A0C25[C0030000]    <1>     mov cl, byte [ehciDataIn]   ;Get low byte of in data
  1715 0000499C F6C110              <1>     test cl, 10h    ;If bit not set, reset over, proceed
  1716 0000499F 7405                <1>     jz .eehder2
  1717 000049A1 49FFCB              <1>     dec r11
  1718 000049A4 75CE                <1>     jnz .eehder1
  1719                              <1> .eehder2:
  1720 000049A6 48BB23011400000000- <1>     mov rbx, 0000000000140123h ;Clear port reset bit
  1720 000049AF 00                  <1>
  1721 000049B0 4809D3              <1>     or rbx, rdx
  1722 000049B3 4488C1              <1>     mov cl, r8b
  1723 000049B6 4488C8              <1>     mov al, r9b
  1724 000049B9 E8ABF3FFFF          <1>     call .ehciSetNoData
  1725                              <1> .eehcritexit:
  1726 000049BE C3                  <1>     ret
  1727                              <1> 
  1728                              <1> .ehciHubClassDescriptor:
  1729                              <1> ;Gets the Hub class descriptor
  1730                              <1> ;Get Hub descriptor for device pointed to by rsi
  1731                              <1> ;If invalid data, returns error
  1732                              <1> ;Input: rsi = Ptr to hub data block
  1733                              <1> ;Output:
  1734                              <1> ;   Carry Clear if success
  1735                              <1> ;   Carry Set if fail, al contains error code
  1736 000049BF 53                  <1>     push rbx
  1737 000049C0 51                  <1>     push rcx
  1738 000049C1 55                  <1>     push rbp
  1739 000049C2 66BD0300            <1>     mov bp, 3
  1740                              <1> 
  1741 000049C6 48BBA0060029000007- <1>     mov rbx, 00070000290006A0h  ;Get Hub descriptor (only first 7 bytes)
  1741 000049CF 00                  <1>
  1742 000049D0 0FB64E04            <1>     movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
  1743 000049D4 8A06                <1>     mov al, byte [rsi]      ;Get device address
  1744 000049D6 E82DF4FFFF          <1>     call .ehciGetRequest
  1745 000049DB 7226                <1>     jc .ehcdfail    ;Errors 0-2 live here
  1746                              <1> 
  1747 000049DD 66FFC5              <1>     inc bp
  1748 000049E0 803C25[C1030000]29  <1>     cmp byte [ehciDataIn + 1], 29h  ;Is this a valid hub descriptor
  1749 000049E8 7519                <1>     jne .ehcdfail
  1750                              <1> 
  1751 000049EA 8A0C25[C2030000]    <1>     mov cl, byte [ehciDataIn + 2]   ;Get number of downstream ports
  1752 000049F1 884E05              <1>     mov byte [rsi + 5], cl  ;Store in variable, marking device as configured
  1753                              <1> 
  1754 000049F4 8A0C25[C5030000]    <1>     mov cl, byte [ehciDataIn + 5]   ;Get PowerOn2PowerGood
  1755 000049FB 884E06              <1>     mov byte [rsi + 6], cl  ;Store in variable
  1756 000049FE F8                  <1>     clc
  1757                              <1> .ehcdexit:
  1758 000049FF 5D                  <1>     pop rbp
  1759 00004A00 59                  <1>     pop rcx
  1760 00004A01 5B                  <1>     pop rbx
  1761 00004A02 C3                  <1>     ret
  1762                              <1> .ehcdfail:
  1763 00004A03 4088E8              <1>     mov al, bpl
  1764 00004A06 F9                  <1>     stc
  1765 00004A07 EBF6                <1>     jmp short .ehcdexit
  1766                              <1> ;                        ---------MSD functions---------
  1767                              <1> .ehciMsdInitialise:
  1768                              <1> ;Initialises an MSD device.
  1769                              <1> ;Input: rsi = Valid MSD device block
  1770                              <1> ;Output: CF=CY: Init did not complete
  1771                              <1> ;        al = 0 => Device initialised
  1772                              <1> ;        al = 1 => Host/Schedule error
  1773                              <1> ;        al = 2 => Device failed to initialise
  1774                              <1> ;        CF=NC: Init complete, rsi points to complete USB MSD device block
  1775 00004A09 51                  <1>     push rcx
  1776 00004A0A 8A4601              <1>     mov al, byte [rsi + 1]  ;Get the bus number into al
  1777 00004A0D E800F2FFFF          <1>     call .ehciAdjustAsyncSchedCtrlr
  1778 00004A12 0F82FC000000        <1>     jc .emiAbortHost
  1779 00004A18 E8A7FCFFFF          <1>     call .ehciDeviceSetupMsd
  1780 00004A1D 0F82F1000000        <1>     jc .emiAbortHost
  1781 00004A23 6685C0              <1>     test ax, ax
  1782 00004A26 0F85E8000000        <1>     jnz .emiAbortHost
  1783                              <1> 
  1784                              <1> ;Start of the init new device routine!
  1785                              <1> ;If any host errors here... something is fishy, crash the init.
  1786 00004A2C B905000000          <1>     mov ecx, 5
  1787                              <1> .emiInq1:
  1788 00004A31 E885050000          <1>     call .ehciMsdBOTInquiry
  1789 00004A36 E8F7000000          <1>     call .emiGetXactStatus
  1790 00004A3B 0F82D3000000        <1>     jc .emiAbortHost
  1791 00004A41 7410                <1>     jz .emiInq1RR
  1792 00004A43 E82B020000          <1>     call .ehciMsdBOTCheckTransaction
  1793 00004A48 84E4                <1>     test ah, ah
  1794 00004A4A 7507                <1>     jnz .emiInq1RR
  1795 00004A4C B905000000          <1>     mov ecx, 5  ;Reset count for the next command
  1796 00004A51 EB0F                <1>     jmp short .emiReadFormCap
  1797                              <1> .emiInq1RR:
  1798 00004A53 E846010000          <1>     call .ehciMsdBOTResetRecovery
  1799 00004A58 FFC9                <1>     dec ecx
  1800 00004A5A 0F84BA000000        <1>     jz .emiAbortBOT
  1801 00004A60 EBCF                <1>     jmp short .emiInq1
  1802                              <1> .emiReadFormCap:
  1803                              <1>     ;Since we don't use anything other than LUN0 for BIOS, this is
  1804                              <1>     ; purely for Windows like behaviour. Only halt the init if the
  1805                              <1>     ; host errors
  1806 00004A62 E8A1050000          <1>     call .ehciMsdBOTReadFormatCapacities
  1807 00004A67 E8C6000000          <1>     call .emiGetXactStatus
  1808 00004A6C 0F82A2000000        <1>     jc .emiAbortHost
  1809 00004A72 7414                <1>     jz .emiRFCRR
  1810 00004A74 E8FA010000          <1>     call .ehciMsdBOTCheckTransaction
  1811 00004A79 84E4                <1>     test ah, ah
  1812 00004A7B 741A                <1>     jz .emiRFCProceed
  1813 00004A7D 80FC02              <1>     cmp ah, 02h
  1814 00004A80 7506                <1>     jne .emiRFCRR
  1815 00004A82 240F                <1>     and al, 0Fh ;Save low nybble only
  1816 00004A84 3C02                <1>     cmp al, 2
  1817 00004A86 740F                <1>     je .emiRFCProceed     ;Ignore this issue!
  1818                              <1> .emiRFCRR:
  1819 00004A88 E811010000          <1>     call .ehciMsdBOTResetRecovery
  1820 00004A8D FFC9                <1>     dec ecx
  1821 00004A8F 0F8485000000        <1>     jz .emiAbortBOT
  1822 00004A95 EBCB                <1>     jmp short .emiReadFormCap
  1823                              <1> .emiRFCProceed:
  1824 00004A97 B905000000          <1>     mov ecx, 5  ;Reset count for the next command
  1825                              <1> .emiInq2:
  1826 00004A9C E81A050000          <1>     call .ehciMsdBOTInquiry
  1827 00004AA1 E88C000000          <1>     call .emiGetXactStatus
  1828 00004AA6 726C                <1>     jc .emiAbortHost
  1829 00004AA8 7410                <1>     jz .emiInq2RR
  1830 00004AAA E8C4010000          <1>     call .ehciMsdBOTCheckTransaction
  1831 00004AAF 84E4                <1>     test ah, ah
  1832 00004AB1 7507                <1>     jnz .emiInq2RR
  1833 00004AB3 B905000000          <1>     mov ecx, 5  ;Reset count for the next command
  1834 00004AB8 EB0B                <1>     jmp short .emiReadCap
  1835                              <1> .emiInq2RR:
  1836 00004ABA E8DF000000          <1>     call .ehciMsdBOTResetRecovery
  1837 00004ABF FFC9                <1>     dec ecx
  1838 00004AC1 7457                <1>     jz .emiAbortBOT
  1839 00004AC3 EBD7                <1>     jmp short .emiInq2
  1840                              <1> .emiReadCap:
  1841 00004AC5 E88F050000          <1>     call .ehciMsdBOTReadCapacity10
  1842 00004ACA E863000000          <1>     call .emiGetXactStatus
  1843 00004ACF 7243                <1>     jc .emiAbortHost
  1844 00004AD1 7410                <1>     jz .emiRCRR
  1845 00004AD3 E89B010000          <1>     call .ehciMsdBOTCheckTransaction
  1846 00004AD8 84E4                <1>     test ah, ah
  1847 00004ADA 7507                <1>     jnz .emiRCRR
  1848 00004ADC B905000000          <1>     mov ecx, 5  ;Reset count for the next command
  1849 00004AE1 EB0B                <1>     jmp short .emiModSen
  1850                              <1> .emiRCRR:
  1851 00004AE3 E8B6000000          <1>     call .ehciMsdBOTResetRecovery
  1852 00004AE8 FFC9                <1>     dec ecx
  1853 00004AEA 742E                <1>     jz .emiAbortBOT
  1854 00004AEC EBD7                <1>     jmp short .emiReadCap
  1855                              <1> .emiModSen:
  1856 00004AEE E8F4060000          <1>     call .ehciMsdBOTModeSense6
  1857 00004AF3 E83A000000          <1>     call .emiGetXactStatus
  1858 00004AF8 721A                <1>     jc .emiAbortHost
  1859 00004AFA 7409                <1>     jz .emiInqMSRR
  1860 00004AFC E872010000          <1>     call .ehciMsdBOTCheckTransaction
  1861 00004B01 84E4                <1>     test ah, ah     ;Also clears CF if zero
  1862 00004B03 740B                <1>     jz .emiExit
  1863                              <1> .emiInqMSRR:
  1864 00004B05 E894000000          <1>     call .ehciMsdBOTResetRecovery
  1865 00004B0A FFC9                <1>     dec ecx
  1866 00004B0C 740C                <1>     jz .emiAbortBOT
  1867 00004B0E EBDE                <1>     jmp short .emiModSen
  1868                              <1> .emiExit:
  1869 00004B10 31C0                <1>     xor eax, eax
  1870                              <1> .emiExit1:
  1871 00004B12 59                  <1>     pop rcx
  1872 00004B13 C3                  <1>     ret
  1873                              <1> 
  1874                              <1> ;Error exits
  1875                              <1> .emiAbortHost:
  1876 00004B14 66B80100            <1>     mov ax, 1
  1877 00004B18 EB04                <1>     jmp short .emiAbort
  1878                              <1> .emiAbortBOT:
  1879 00004B1A 66B80200            <1>     mov ax, 2
  1880                              <1> .emiAbort:
  1881 00004B1E 50                  <1>     push rax
  1882 00004B1F 668B06              <1>     mov ax, word [rsi]
  1883 00004B22 E847F8FFFF          <1>     call .ehciRemoveDevFromTables
  1884 00004B27 58                  <1>     pop rax
  1885 00004B28 FE0C25[4C020000]    <1>     dec byte [numMSD]   ;Device was removed from tables, decrement
  1886 00004B2F F9                  <1>     stc
  1887 00004B30 EBE0                <1>     jmp short .emiExit1
  1888                              <1> 
  1889                              <1> .emiGetXactStatus:
  1890                              <1> ;Establishes what to do.
  1891                              <1> ;Output: CF=NC and ZF=NZ -> all is well, proceed.
  1892                              <1> ;        CF=NC and ZF=ZY -> Do reset recovery
  1893                              <1> ;        CF=CY -> Host error, fail!
  1894 00004B32 7214                <1>     jc .emigxsBad ;If entered with CF=CY, means host error, rip  
  1895 00004B34 803C25[A9010000]20  <1>     cmp byte [msdStatus], 20h   ;Host error
  1896 00004B3C 740A                <1>     je .emigxsBad
  1897 00004B3E 803C25[A9010000]21  <1>     cmp byte [msdStatus], 21h   ;EP Stall?
  1898 00004B46 F8                  <1>     clc
  1899 00004B47 C3                  <1>     ret
  1900                              <1> .emigxsBad:
  1901 00004B48 F9                  <1>     stc
  1902 00004B49 C3                  <1>     ret
  1903                              <1> .ehciMsdDeviceReset:
  1904                              <1> ;Reset an MSD device on current active EHCI bus
  1905                              <1> ;Input: rsi = Pointer to table data structure
  1906                              <1> ;Output:
  1907                              <1> ;   CF=CY: Host error, Reset host system
  1908                              <1> ;   CF=NC: Transaction succeeded, check reset occurred successfully 
  1909                              <1> ;          (If eActiveIntr AND 2 != 0, then error in transfer)
  1910 00004B4A 51                  <1>     push rcx
  1911 00004B4B 52                  <1>     push rdx
  1912 00004B4C 53                  <1>     push rbx
  1913 00004B4D 50                  <1>     push rax
  1914                              <1> 
  1915 00004B4E 0FB64E07            <1>     movzx ecx, byte [rsi + 7]  ;Get bMaxPacketSize0
  1916 00004B52 480FB65604          <1>     movzx rdx, byte [rsi + 4]  ;Get Interface Number
  1917 00004B57 48C1E228            <1>     shl rdx, 5*8 ;Send to 5th byte
  1918 00004B5B 48BB21FF0000000000- <1>     mov rbx, 0FF21h            ;MSD Reset
  1918 00004B64 00                  <1>
  1919 00004B65 4809D3              <1>     or rbx, rdx                ;And those bytes
  1920 00004B68 8A06                <1>     mov al, byte [rsi]
  1921 00004B6A E8FAF1FFFF          <1>     call .ehciSetNoData
  1922                              <1> 
  1923 00004B6F 58                  <1>     pop rax
  1924 00004B70 5B                  <1>     pop rbx
  1925 00004B71 5A                  <1>     pop rdx
  1926 00004B72 59                  <1>     pop rcx
  1927 00004B73 C3                  <1>     ret
  1928                              <1> 
  1929                              <1> .ehciMsdGetMaxLun:
  1930                              <1> ;Get max LUN of an MSD device on current active EHCI bus
  1931                              <1> ;Input: rsi = Pointer to table data structure
  1932                              <1> ;       al = Address
  1933                              <1> ;Output:
  1934                              <1> ;   CF=CY: Host error, Reset host system
  1935                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  1936                              <1> ;   Max Lun saved at DataIn Buffer (first byte)
  1937                              <1> ;   Check this was transferred, by checking total data transferred value
  1938 00004B74 51                  <1>     push rcx
  1939 00004B75 52                  <1>     push rdx
  1940 00004B76 53                  <1>     push rbx
  1941 00004B77 50                  <1>     push rax
  1942                              <1> 
  1943 00004B78 0FB64E07            <1>     movzx ecx, byte [rsi + 7]  ;Get bMaxPacketSize0
  1944 00004B7C 480FB65604          <1>     movzx rdx, byte [rsi + 4]  ;Get Interface Number
  1945 00004B81 48C1E228            <1>     shl rdx, 5*8 ;Send to 5th byte
  1946 00004B85 48BBA1FE0000000001- <1>     mov rbx, 000100000000FEA1h            ;MSD Get Max LUN
  1946 00004B8E 00                  <1>
  1947 00004B8F 4809D3              <1>     or rbx, rdx                ;And those bytes
  1948 00004B92 8A06                <1>     mov al, byte [rsi]
  1949 00004B94 E86FF2FFFF          <1>     call .ehciGetRequest
  1950                              <1> 
  1951 00004B99 58                  <1>     pop rax
  1952 00004B9A 5B                  <1>     pop rbx
  1953 00004B9B 5A                  <1>     pop rdx
  1954 00004B9C 59                  <1>     pop rcx
  1955 00004B9D C3                  <1>     ret
  1956                              <1> 
  1957                              <1> .ehciMsdBOTResetRecovery:
  1958                              <1> ;----------------------------------------------------------------
  1959                              <1> ;Calls the reset recovery procedure on a device ptd to by rsi   :
  1960                              <1> ;Input:  rsi = Pointer to MSD device parameter block            :
  1961                              <1> ;Output: CF=CY if something went wrong. Else CF=NC              :
  1962                              <1> ;----------------------------------------------------------------
  1963                              <1> ;Calls an MSDBBB reset then calls StandardErrorHandler AFTER    : 
  1964                              <1> ; writing the Qhead for each Bulk EP.                           :
  1965                              <1> ;----------------------------------------------------------------
  1966 00004B9E 50                  <1>     push rax
  1967 00004B9F 53                  <1>     push rbx
  1968 00004BA0 51                  <1>     push rcx
  1969 00004BA1 66C7460E0000        <1>     mov word [rsi + 14], 00h    ;Reset clear both endpoint dt bits 
  1970                              <1> 
  1971 00004BA7 E89EFFFFFF          <1>     call .ehciMsdDeviceReset    ;Call the device reset
  1972 00004BAC 721E                <1>     jc .embrrexit
  1973                              <1> ;Now clear stall on IN EP
  1974 00004BAE 8A06                <1>     mov al, byte [rsi]          ;Get the address
  1975 00004BB0 8A5E08              <1>     mov bl, byte [rsi + 8]      ;Get the 4 byte EP address
  1976 00004BB3 0FB64E07            <1>     movzx ecx, byte [rsi + 7]   ;Get the Max packet size for the ctrl EP
  1977 00004BB7 E806FAFFFF          <1>     call .ehciClearEpStallHalt
  1978 00004BBC 720E                <1>     jc .embrrexit
  1979                              <1> ;Now clear stall on OUT EP
  1980 00004BBE 8A06                <1>     mov al, byte [rsi]          ;Get the address
  1981 00004BC0 8A5E0B              <1>     mov bl, byte [rsi + 11]     ;Get the 4 byte EP address
  1982 00004BC3 0FB64E07            <1>     movzx ecx, byte [rsi + 7]   ;Get the Max packet size for the ctrl EP
  1983 00004BC7 E8F6F9FFFF          <1>     call .ehciClearEpStallHalt
  1984                              <1> .embrrexit:
  1985 00004BCC 59                  <1>     pop rcx
  1986 00004BCD 5B                  <1>     pop rbx
  1987 00004BCE 58                  <1>     pop rax
  1988 00004BCF C3                  <1>     ret
  1989                              <1> .ehciMsdBOTCheckValidCSW:
  1990                              <1> ; This function checks that the recieved CSW was valid.
  1991                              <1> ; If this function returns a non-zero value in al, 
  1992                              <1> ; a reset recovery of the device is required
  1993                              <1> ; Output: al = 0 : valid CSW
  1994                              <1> ;         If CSW not valid, al contains a bitfield describing what failed
  1995                              <1> ;         al = 1h   : CSW is not 13 bytes in length
  1996                              <1> ;         al = 2h   : dCSWSignature is not equal to 053425355h
  1997                              <1> ;         al = 4h   : dCSWTag does not match the dCBWTag
  1998                              <1> ;         al = 0F8h : Reserved
  1999                              <1> ;   rax destroyed
  2000 00004BD0 53                  <1>     push rbx
  2001 00004BD1 51                  <1>     push rcx
  2002 00004BD2 31C0                <1>     xor eax, eax
  2003 00004BD4 66B90100            <1>     mov cx, 1
  2004 00004BD8 668B1C25[8A010000]  <1>     mov bx, word [ehciTDSpace + 2*ehciSizeOfTD + 0Ah]   
  2005                              <1> ;Get total bytes to transfer from third QHeadTD to see if 13h bytes were 
  2006                              <1> ; transferred
  2007 00004BE0 6681E3FF7F          <1>     and bx, 7FFFh   ;Clear upper bit
  2008 00004BE5 660F45C1            <1>     cmovnz ax, cx   ;If the result for the and is not zero, <>13 bytes were sent
  2009                              <1> 
  2010 00004BE9 66D1E1              <1>     shl cx, 1     
  2011 00004BEC 6609C1              <1>     or cx, ax
  2012 00004BEF 813C25[C0050000]55- <1>     cmp dword [msdCSW], CSWSig
  2012 00004BF7 534253              <1>
  2013 00004BFA 660F45C1            <1>     cmovne ax, cx
  2014                              <1> 
  2015 00004BFE 66B90400            <1>     mov cx, 4h
  2016 00004C02 6609C1              <1>     or cx, ax
  2017 00004C05 0FB61C25[4B020000]  <1>     movzx ebx, byte [cbwTag]
  2018 00004C0D FECB                <1>     dec bl
  2019 00004C0F 3A1C25[C4050000]    <1>     cmp bl, byte [msdCSW + 4h]
  2020 00004C16 660F45C1            <1>     cmovne ax, cx
  2021                              <1> 
  2022 00004C1A 59                  <1>     pop rcx
  2023 00004C1B 5B                  <1>     pop rbx
  2024 00004C1C C3                  <1>     ret
  2025                              <1> 
  2026                              <1> .ehciMsdBOTCheckMeaningfulCSW:
  2027                              <1> ; This function checks if the CSW was meaningful.
  2028                              <1> ; If this function returns a non-zero value in al, it is up to the
  2029                              <1> ; caller to decide what action to take. The possible set of actions that
  2030                              <1> ; can be taken is outlined in Section 6.7 of the USB MSC BOT Revision 1.0 
  2031                              <1> ; specification.
  2032                              <1> ; Output :  al = 0h  : Invalid
  2033                              <1> ;           al = 1h  : bCSWStatus = 0
  2034                              <1> ;           al = 2h  : bCSWStatus = 1
  2035                              <1> ;           al = 4h  : bCSWStatus = 2
  2036                              <1> ;           al = 8h  : bCSWStatus > 2
  2037                              <1> ;           al = 10h : dCSWDataResidue = 0
  2038                              <1> ;           al = 20h : dCSWDataResidue < dCBWDataTransferLength
  2039                              <1> ;           al = 40h : dCSWDataResidue > dCBWDataTransferLength
  2040                              <1> ;           al = 80h : Reserved
  2041                              <1> ;   rax destroyed
  2042 00004C1D 53                  <1>     push rbx
  2043 00004C1E 51                  <1>     push rcx
  2044                              <1> 
  2045 00004C1F 31C0                <1>     xor eax, eax  ;In the event that things go completely wrong
  2046 00004C21 66BB0800            <1>     mov bx, 8h
  2047 00004C25 8A0C25[CC050000]    <1>     mov cl, byte [msdCSW + 0Ch]
  2048                              <1> 
  2049 00004C2C 80F902              <1>     cmp cl, 2
  2050 00004C2F 660F47C3            <1>     cmova ax, bx
  2051 00004C33 7718                <1>     ja .embcmcResidueCheck
  2052                              <1> 
  2053 00004C35 66D1EB              <1>     shr bx, 1       ;Shift it down to 4
  2054 00004C38 660F44C3            <1>     cmove ax, bx    ;If bCSWStatus = 2, move it in
  2055 00004C3C 740F                <1>     je .embcmcResidueCheck
  2056                              <1> 
  2057 00004C3E 66D1EB              <1>     shr bx, 1       ;Shift down to 2
  2058 00004C41 80F901              <1>     cmp cl, 1
  2059 00004C44 660F44C3            <1>     cmove ax, bx    ;If bCSWStatus = 1, move bx into ax
  2060 00004C48 7403                <1>     je .embcmcResidueCheck
  2061                              <1> 
  2062 00004C4A 66FFC0              <1>     inc ax          ;Otherwise bCSWStatus = 0
  2063                              <1> .embcmcResidueCheck:
  2064 00004C4D 8B0C25[C8050000]    <1>     mov ecx, dword [msdCSW + 8] ;Get dCSWDataResidue
  2065 00004C54 85C9                <1>     test ecx, ecx
  2066 00004C56 66BB1000            <1>     mov bx, 10h
  2067 00004C5A 7411                <1>     jz .embcmcExit
  2068 00004C5C 3B0C25[88030000]    <1>     cmp ecx, dword [ehciDataOut + 8]    ;ehciDataOut + 8 = dCBWDataTransferLength
  2069 00004C63 66BB2000            <1>     mov bx, 20h
  2070 00004C67 7204                <1>     jb .embcmcExit
  2071 00004C69 66BB4000            <1>     mov bx, 40h  ;Else, it must be above, fail
  2072                              <1> .embcmcExit:
  2073 00004C6D 6609D8              <1>     or ax, bx   ;Add upper bits to ax
  2074 00004C70 59                  <1>     pop rcx
  2075 00004C71 5B                  <1>     pop rbx
  2076 00004C72 C3                  <1>     ret
  2077                              <1> 
  2078                              <1> .ehciMsdBOTCheckTransaction:
  2079                              <1> ;Check successful return data here
  2080                              <1> ;Output: ah = 0, al = CSW Meaningful bitfield   : CSW Valid and Meaningful
  2081                              <1> ;        ah = 1, al = CSW Validity bitfield     : CSW NOT valid
  2082                              <1> ;        ah = 2, al = CSW Meaningful bitfield   : CSW NOT meaningful
  2083                              <1> ;   rax destroyed
  2084 00004C73 30E4                <1>     xor ah, ah
  2085 00004C75 E856FFFFFF          <1>     call .ehciMsdBOTCheckValidCSW
  2086 00004C7A 84C0                <1>     test al, al
  2087 00004C7C 7407                <1>     jz .embhiehcswmeaningful
  2088 00004C7E B401                <1>     mov ah, 1       ; CSW Not Valid signature
  2089 00004C80 E90F000000          <1>     jmp .embhiehexit
  2090                              <1> .embhiehcswmeaningful:
  2091 00004C85 E893FFFFFF          <1>     call .ehciMsdBOTCheckMeaningfulCSW
  2092 00004C8A A84C                <1>     test al, 4Ch     ;Check bad bits first and bCSWStatus=02 40h|08h|04h
  2093 00004C8C 7404                <1>     jz .embhiehcswmeaningfulOk
  2094 00004C8E B402                <1>     mov ah, 2        ;CSW Not Meaningful signature
  2095 00004C90 EB02                <1>     jmp short .embhiehexit
  2096                              <1> .embhiehcswmeaningfulOk:
  2097 00004C92 30E4                <1>     xor ah, ah      ;Clear the upper bits.
  2098                              <1> .embhiehexit:
  2099 00004C94 C3                  <1>     ret
  2100                              <1> .ehciMsdBOTOO64I:   ;For devices with 64 byte max packet size
  2101                              <1> .ehciMsdBOTOI64I:   ;For devices with 64 byte max packet size
  2102 00004C95 C60425[A9010000]BB  <1>     mov byte [msdStatus], 0BBh   ;Undefined error
  2103 00004C9D C3                  <1>     ret
  2104                              <1> .ehciMsdBOTOOI:     ;Out Out In transfer
  2105                              <1> ;Input - rsi = MSD device parameter block
  2106                              <1> ;        rbx = Input buffer for Data In
  2107                              <1> ;        ecx = Number of milliseconds to wait between Out and In packets
  2108                              <1> ;        r8  = Number of bytes to be transferred (for the DATA phase)
  2109                              <1> ;        r10 = LUN Value
  2110                              <1> ;        r11 = Length of CBW command block
  2111 00004C9E 57                  <1>     push rdi
  2112 00004C9F 4150                <1>     push r8
  2113 00004CA1 4151                <1>     push r9
  2114 00004CA3 4152                <1>     push r10
  2115 00004CA5 4153                <1>     push r11
  2116 00004CA7 4154                <1>     push r12
  2117 00004CA9 51                  <1>     push rcx
  2118 00004CAA FC                  <1>     cld
  2119                              <1> 
  2120 00004CAB 4D89C4              <1>     mov r12, r8     ;Save number of bytes to transfer to MSD device
  2121 00004CAE 51                  <1>     push rcx
  2122                              <1> ;Write QHead for CBW
  2123 00004CAF 49BB-               <1>     mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  2123 00004CB1 [0001000000000000]  <1>
  2124 00004CB9 E840020000          <1>     call .ehciMsdWriteOutQHead
  2125                              <1> ;Write TD for CBW send
  2126 00004CBE 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2127 00004CC1 49B801000000000000- <1>     mov r8, 1
  2127 00004CCA 00                  <1>
  2128 00004CCB 4D89C1              <1>     mov r9, r8
  2129 00004CCE 440FB6560F          <1>     movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  2130 00004CD3 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2131 00004CD7 41D1CA              <1>     ror r10d, 1 ;Roll dt bit to upper bit of dword
  2132 00004CDA 4181CA808C1F00      <1>     or r10d, 001F8C80h 
  2133                              <1> ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  2134 00004CE1 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
  2134 00004CE3 [8003000000000000]  <1>
  2135 00004CEB E80EF9FFFF          <1>     call .ehciWriteQHeadTD
  2136                              <1> 
  2137 00004CF0 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2138 00004CF2 E83AF2FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2139 00004CF7 59                  <1>     pop rcx    ;Wait ecx ms for "motors to spin up"
  2140 00004CF8 0F824B010000        <1>     jc .emboexit    ;If catastrophic Host system error, exit!
  2141                              <1> 
  2142 00004CFE 50                  <1>     push rax
  2143 00004CFF B486                <1>     mov ah, 86h
  2144 00004D01 CD35                <1>     int 35h
  2145 00004D03 58                  <1>     pop rax
  2146                              <1> ;Write Qhead to Send data
  2147 00004D04 49BB80000000000000- <1>     mov r11, ehciSizeOfTD + ehciSizeOfTD
  2147 00004D0D 00                  <1>
  2148 00004D0E E8EB010000          <1>     call .ehciMsdWriteOutQHead
  2149                              <1> ;Write TD for data send
  2150 00004D13 4C89DF              <1>     mov rdi, r11
  2151 00004D16 49B801000000000000- <1>     mov r8, 1
  2151 00004D1F 00                  <1>
  2152 00004D20 4D89C1              <1>     mov r9, r8
  2153 00004D23 4D89E2              <1>     mov r10, r12     ;Get back number of bytes to transfer
  2154 00004D26 49C1E210            <1>     shl r10, 8*2    ;Shift into 3rd byte
  2155 00004D2A 4181CA808C0000      <1>     or r10d, 00008C80h ;Add control bits: Active TD, OUT EP, Error ctr = 3
  2156 00004D31 0FB64E0F            <1>     movzx ecx, byte [rsi + 15]  ;Get Out EP dt bit in r9d
  2157 00004D35 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2158 00004D39 D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2159 00004D3B 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2160 00004D3E 4989DB              <1>     mov r11, rbx    ;Get the address of Data buffer
  2161 00004D41 E8B8F8FFFF          <1>     call .ehciWriteQHeadTD
  2162                              <1> 
  2163 00004D46 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2164 00004D48 E8E4F1FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2165 00004D4D 0F82F6000000        <1>     jc .emboexit    ;If catastrophic Host system error, exit!
  2166                              <1> ;Write Qhead for CSW
  2167 00004D53 49BB-               <1>     mov r11, ehciTDSpace + 2*ehciSizeOfTD ;Third TD
  2167 00004D55 [8001000000000000]  <1>
  2168 00004D5D E8DB010000          <1>     call .ehciMsdWriteInQHead
  2169 00004D62 4C89DF              <1>     mov rdi, r11
  2170 00004D65 E9A9000000          <1>     jmp .emboiicommonep
  2171                              <1> .ehciMsdBOTOII: ;Out In In transfer
  2172                              <1> ;Input - rsi = MSD device parameter block
  2173                              <1> ;        rbx = Input buffer for Data In
  2174                              <1> ;        ecx = Number of milliseconds to wait between Out and In packets
  2175                              <1> ;        r8  = Number of bytes to be transferred (for the DATA phase)
  2176                              <1> ;        r10 = LUN Value
  2177                              <1> ;        r11 = Length of CBW command block
  2178                              <1> 
  2179 00004D6A 57                  <1>     push rdi
  2180 00004D6B 4150                <1>     push r8
  2181 00004D6D 4151                <1>     push r9
  2182 00004D6F 4152                <1>     push r10
  2183 00004D71 4153                <1>     push r11
  2184 00004D73 4154                <1>     push r12
  2185 00004D75 51                  <1>     push rcx
  2186 00004D76 FC                  <1>     cld
  2187                              <1> 
  2188 00004D77 4D89C4              <1>     mov r12, r8 ;Save the number of bytes to be transferred
  2189 00004D7A 51                  <1>     push rcx
  2190                              <1> 
  2191                              <1> ;Write the OUT Queue Head
  2192 00004D7B 49BB-               <1>     mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  2192 00004D7D [0001000000000000]  <1>
  2193 00004D85 E874010000          <1>     call .ehciMsdWriteOutQHead
  2194                              <1> 
  2195 00004D8A 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2196 00004D8D 49B801000000000000- <1>     mov r8, 1
  2196 00004D96 00                  <1>
  2197 00004D97 4D89C1              <1>     mov r9, r8
  2198 00004D9A 440FB6560F          <1>     movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  2199 00004D9F 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2200 00004DA3 41D1CA              <1>     ror r10d, 1 ;Roll dt bit to upper bit of dword
  2201 00004DA6 4181CA808C1F00      <1>     or r10d, 001F8C80h 
  2202                              <1> ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  2203 00004DAD 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
  2203 00004DAF [8003000000000000]  <1>
  2204 00004DB7 E842F8FFFF          <1>     call .ehciWriteQHeadTD
  2205                              <1> 
  2206 00004DBC B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2207 00004DBE E86EF1FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2208 00004DC3 59                  <1>     pop rcx    ;Wait ecx ms for "motors to spin up"
  2209 00004DC4 0F827F000000        <1>     jc .emboexit    ;If catastrophic Host system error, exit!
  2210                              <1>          
  2211 00004DCA 50                  <1>     push rax
  2212 00004DCB B486                <1>     mov ah, 86h
  2213 00004DCD CD35                <1>     int 35h
  2214 00004DCF 58                  <1>     pop rax
  2215                              <1> ;Write the IN Queue Head
  2216 00004DD0 49BB-               <1>     mov r11, ehciTDSpace + ehciSizeOfTD ;Move to position 2 to preserve OUT TD
  2216 00004DD2 [4001000000000000]  <1>
  2217 00004DDA E85E010000          <1>     call .ehciMsdWriteInQHead
  2218                              <1> 
  2219 00004DDF 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2220 00004DE2 4C8D4740            <1>     lea r8, qword [rdi + ehciSizeOfTD]  ;Point to next TD
  2221 00004DE6 4D89C1              <1>     mov r9, r8
  2222 00004DE9 4D89E2              <1>     mov r10, r12     ;Get back number of bytes to transfer from the stack
  2223 00004DEC 49C1E210            <1>     shl r10, 8*2    ;Shift into 3rd byte
  2224 00004DF0 4181CA800D0000      <1>     or r10d, 00000D80h ;Add control bits: Active TD, IN EP, Error ctr = 3
  2225 00004DF7 0FB64E0E            <1>     movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  2226 00004DFB 80760E01            <1>     xor byte [rsi + 14], 1  ;Toggle bit
  2227 00004DFF D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2228 00004E01 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2229 00004E04 4989DB              <1>     mov r11, rbx ; Data out buffer, default ehciDataIn
  2230 00004E07 E8F2F7FFFF          <1>     call .ehciWriteQHeadTD
  2231                              <1> 
  2232 00004E0C 4881C740000000      <1>     add rdi, ehciSizeOfTD     ;Go to next TD space
  2233                              <1> .emboiicommonep:
  2234 00004E13 49B801000000000000- <1>     mov r8, 1
  2234 00004E1C 00                  <1>
  2235 00004E1D 4D89C1              <1>     mov r9, r8
  2236 00004E20 41BA808D0D00        <1>     mov r10d, 000D8D80h     ;Active TD, IN EP, Error ctr = 3, 0Dh = 13 byte CSW
  2237 00004E26 0FB64E0E            <1>     movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  2238 00004E2A 80760E01            <1>     xor byte [rsi + 14], 1  ;Toggle bit
  2239 00004E2E D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2240 00004E30 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2241 00004E33 49BB-               <1>     mov r11, msdCSW
  2241 00004E35 [C005000000000000]  <1>
  2242                              <1> 
  2243 00004E3D E8BCF7FFFF          <1>     call .ehciWriteQHeadTD
  2244                              <1> 
  2245 00004E42 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2246 00004E44 E8E8F0FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2247                              <1> .emboexit:
  2248 00004E49 59                  <1>     pop rcx
  2249 00004E4A 415C                <1>     pop r12
  2250 00004E4C 415B                <1>     pop r11
  2251 00004E4E 415A                <1>     pop r10
  2252 00004E50 4159                <1>     pop r9
  2253 00004E52 4158                <1>     pop r8
  2254 00004E54 5F                  <1>     pop rdi
  2255 00004E55 C3                  <1>     ret
  2256                              <1> .ehciMsdBOTOI: ;Out In transfer
  2257                              <1> ;Input - rsi = MSD device parameter block
  2258                              <1> ;        rbx = Input buffer for Data In
  2259                              <1> ;        ecx = Number of milliseconds to wait between Out and In packets
  2260                              <1> ;        r8  = Number of bytes to be transferred (for the DATA phase)
  2261                              <1> ;        r10 = LUN Value
  2262                              <1> ;        r11 = Length of CBW command block
  2263                              <1> 
  2264 00004E56 57                  <1>     push rdi
  2265 00004E57 4150                <1>     push r8
  2266 00004E59 4151                <1>     push r9
  2267 00004E5B 4152                <1>     push r10
  2268 00004E5D 4153                <1>     push r11
  2269 00004E5F 51                  <1>     push rcx
  2270 00004E60 FC                  <1>     cld
  2271                              <1> 
  2272                              <1> 
  2273                              <1> ;Write the OUT Queue Head
  2274 00004E61 49BB-               <1>     mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  2274 00004E63 [0001000000000000]  <1>
  2275 00004E6B E88E000000          <1>     call .ehciMsdWriteOutQHead
  2276                              <1> 
  2277 00004E70 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2278 00004E73 49B801000000000000- <1>     mov r8, 1
  2278 00004E7C 00                  <1>
  2279 00004E7D 4D89C1              <1>     mov r9, r8
  2280 00004E80 440FB6560F          <1>     movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  2281 00004E85 80760F01            <1>     xor byte [rsi + 15], 1  ;Toggle bit
  2282 00004E89 41D1CA              <1>     ror r10d, 1 ;Roll dt bit to upper bit of dword
  2283 00004E8C 4181CA808C1F00      <1>     or r10d, 001F8C80h 
  2284                              <1> ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  2285 00004E93 49BB-               <1>     mov r11, ehciDataOut ; Data out buffer
  2285 00004E95 [8003000000000000]  <1>
  2286 00004E9D E85CF7FFFF          <1>     call .ehciWriteQHeadTD
  2287                              <1> 
  2288 00004EA2 B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2289 00004EA4 E888F0FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2290 00004EA9 7248                <1>     jc .emboiexit    ;If catastrophic Host system error, exit!
  2291                              <1>          
  2292                              <1> ;Write the IN Queue Head
  2293 00004EAB 49BB-               <1>     mov r11, ehciTDSpace + ehciSizeOfTD ;Move to position 2 to preserve OUT TD
  2293 00004EAD [4001000000000000]  <1>
  2294 00004EB5 E883000000          <1>     call .ehciMsdWriteInQHead
  2295                              <1> 
  2296 00004EBA 4C89DF              <1>     mov rdi, r11    ;Move pointer to TD buffer head
  2297 00004EBD 49B801000000000000- <1>     mov r8, 1
  2297 00004EC6 00                  <1>
  2298 00004EC7 4D89C1              <1>     mov r9, r8
  2299 00004ECA 41BA808D0D00        <1>     mov r10d, 000D8D80h     ;Active TD, IN EP, Error ctr = 3, 0Dh = 13 byte CSW
  2300 00004ED0 0FB64E0E            <1>     movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  2301 00004ED4 80760E01            <1>     xor byte [rsi + 14], 1  ;Toggle bit
  2302 00004ED8 D1C9                <1>     ror ecx, 1 ;Roll dt bit to upper bit of dword
  2303 00004EDA 4109CA              <1>     or r10d, ecx    ;Add dt bit to r10d
  2304 00004EDD 49BB-               <1>     mov r11, msdCSW
  2304 00004EDF [C005000000000000]  <1>
  2305                              <1> 
  2306 00004EE7 E812F7FFFF          <1>     call .ehciWriteQHeadTD
  2307                              <1> 
  2308 00004EEC B103                <1>     mov cl, 11b    ;Lock out internal buffer
  2309 00004EEE E83EF0FFFF          <1>     call .ehciProcessCommand        ;Run controller
  2310                              <1> .emboiexit:
  2311 00004EF3 59                  <1>     pop rcx
  2312 00004EF4 415B                <1>     pop r11
  2313 00004EF6 415A                <1>     pop r10
  2314 00004EF8 4159                <1>     pop r9
  2315 00004EFA 4158                <1>     pop r8
  2316 00004EFC 5F                  <1>     pop rdi
  2317 00004EFD C3                  <1>     ret
  2318                              <1> .ehciMsdWriteOutQHead:
  2319                              <1> ;Input: rsi = Valid MSD device
  2320                              <1> ;       r11 = Ptr to First QHTD
  2321 00004EFE E8A0EDFFFF          <1>     call .ehciGetNewQHeadAddr
  2322 00004F03 4181C802000000      <1>     or r8d, 2    ;Process QHs
  2323 00004F0A 41B900600000        <1>     mov r9d, 00006000h  ;Default mask, no nak counter
  2324 00004F10 0FB74E0C            <1>     movzx ecx, word [rsi + 12]  ;wMaxPacketSizeOut
  2325 00004F14 C1E110              <1>     shl ecx, 8*2
  2326 00004F17 4109C9              <1>     or r9d, ecx
  2327 00004F1A 0FB64E0B            <1>     movzx ecx, byte [rsi + 11]  ;EP address
  2328 00004F1E 81E10F000000        <1>     and ecx, 0Fh
  2329 00004F24 C1E108              <1>     shl ecx, 8  ;Shift to second byte 
  2330 00004F27 4109C9              <1>     or r9d, ecx ;Add bits
  2331 00004F2A 8A06                <1>     mov al, byte [rsi]  ;Get device address
  2332 00004F2C 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
  2333 00004F2E 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
  2334 00004F31 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
  2335 00004F37 E89DF6FFFF          <1>     call .ehciWriteQHead
  2336 00004F3C C3                  <1>     ret
  2337                              <1> .ehciMsdWriteInQHead:
  2338                              <1> ;Input: rsi = Valid MSD device
  2339                              <1> ;       r11 = Ptr to First QHTD
  2340 00004F3D E861EDFFFF          <1>     call .ehciGetNewQHeadAddr
  2341 00004F42 4981C802000000      <1>     or r8, 2
  2342 00004F49 41B900600000        <1>     mov r9d, 00006000h  ;Default mask
  2343 00004F4F 0FB74E09            <1>     movzx ecx, word [rsi + 9]  ;wMaxPacketSizeIn
  2344 00004F53 C1E110              <1>     shl ecx, 8*2
  2345 00004F56 4109C9              <1>     or r9d, ecx
  2346 00004F59 0FB64E08            <1>     movzx ecx, byte [rsi + 8]  ;EP address
  2347 00004F5D 81E10F000000        <1>     and ecx, 0Fh
  2348 00004F63 C1E108              <1>     shl ecx, 8  ;Shift to second byte 
  2349 00004F66 4109C9              <1>     or r9d, ecx ;Add bits
  2350 00004F69 8A06                <1>     mov al, byte [rsi]  ;Get device address
  2351 00004F6B 247F                <1>     and al, 7Fh    ;Force clear upper bit of al
  2352 00004F6D 4108C1              <1>     or r9b, al    ;Set lower 8 bits of r9 correctly
  2353 00004F70 41BA00000040        <1>     mov r10d, 40000000h    ;1 transaction/ms
  2354 00004F76 E85EF6FFFF          <1>     call .ehciWriteQHead
  2355 00004F7B C3                  <1>     ret
  2356                              <1> .ehciMsdBOTRequest:
  2357                              <1> ;Input: ecx = Number of miliseconds to wait between Out and In requests
  2358                              <1> ;       rbx = Data in Buffer
  2359                              <1> ;       r8  = Number of bytes to be returned by command
  2360                              <1> ;       r11 = Length of SCSI command block
  2361                              <1> ;       r14 = Pointer to EHCI(USB) transaction function
  2362                              <1> ;       r15 = Pointer to SCSI command function
  2363                              <1> ;Output:
  2364                              <1> ;   CF=CY: Host error, Reset host system
  2365                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2366 00004F7C 50                  <1>     push rax
  2367 00004F7D 51                  <1>     push rcx
  2368 00004F7E 57                  <1>     push rdi
  2369 00004F7F 4151                <1>     push r9
  2370 00004F81 4152                <1>     push r10
  2371                              <1> ;Clear the previous CSW
  2372 00004F83 48BF-               <1>     mov rdi, msdCSW
  2372 00004F85 [C005000000000000]  <1>
  2373 00004F8D 30C0                <1>     xor al, al
  2374 00004F8F B90D000000          <1>     mov ecx, 13
  2375 00004F94 F3AA                <1>     rep stosb
  2376                              <1> ;Write the CBW
  2377 00004F96 48BF-               <1>     mov rdi, ehciDataOut    ;Write the CBW at the data out point
  2377 00004F98 [8003000000000000]  <1>
  2378                              <1> 
  2379 00004FA0 41B180              <1>     mov r9b, 80h            ;Recieve an IN packet
  2380 00004FA3 4D31D2              <1>     xor r10, r10            ;LUN 0
  2381 00004FA6 E85E030000          <1>     call .msdWriteCBW       ;Write the 15 byte CBW
  2382                              <1> ;Append the Command Block to the CBW
  2383 00004FAB 30C0                <1>     xor al, al              ;LUN 0 device
  2384 00004FAD 41FFD7              <1>     call r15                ;Write the valid CBW Command block
  2385                              <1> ;Enact transaction
  2386 00004FB0 41FFD6              <1>     call r14
  2387                              <1> 
  2388 00004FB3 415A                <1>     pop r10
  2389 00004FB5 4159                <1>     pop r9
  2390 00004FB7 5F                  <1>     pop rdi
  2391 00004FB8 59                  <1>     pop rcx
  2392 00004FB9 58                  <1>     pop rax
  2393 00004FBA C3                  <1>     ret
  2394                              <1> 
  2395                              <1> .ehciMsdBOTInquiry:
  2396                              <1> ;Input: 
  2397                              <1> ; rsi = Pointer to MSD table data structure that we want to Inqure
  2398                              <1> ;Output:
  2399                              <1> ;   CF=CY: Host error, Reset host system
  2400                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2401 00004FBB 53                  <1>     push rbx
  2402 00004FBC 51                  <1>     push rcx
  2403 00004FBD 4150                <1>     push r8
  2404 00004FBF 4153                <1>     push r11
  2405 00004FC1 4156                <1>     push r14
  2406 00004FC3 4157                <1>     push r15
  2407 00004FC5 48BB-               <1>     mov rbx, ehciDataIn
  2407 00004FC7 [C003000000000000]  <1>
  2408 00004FCF B900000000          <1>     mov ecx, 0
  2409 00004FD4 41B824000000        <1>     mov r8d, 024h           ;36 bytes to be returned
  2410 00004FDA 49BB0C000000000000- <1>     mov r11, 0Ch            ;The command block is 12 bytes (As per Bootability)
  2410 00004FE3 00                  <1>
  2411 00004FE4 49BF-               <1>     mov r15, .scsiInquiry
  2411 00004FE6 [3A53000000000000]  <1>
  2412 00004FEE 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2412 00004FF0 [6A4D000000000000]  <1>
  2413 00004FF8 E87FFFFFFF          <1>     call .ehciMsdBOTRequest
  2414 00004FFD 415F                <1>     pop r15
  2415 00004FFF 415E                <1>     pop r14
  2416 00005001 415B                <1>     pop r11
  2417 00005003 4158                <1>     pop r8
  2418 00005005 59                  <1>     pop rcx
  2419 00005006 5B                  <1>     pop rbx
  2420 00005007 C3                  <1>     ret
  2421                              <1> 
  2422                              <1> .ehciMsdBOTReadFormatCapacities:
  2423                              <1> ;Input: 
  2424                              <1> ; rsi = Pointer to MSD table data structure
  2425                              <1> ;Output:
  2426                              <1> ;   CF=CY: Host error, Reset host system
  2427                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2428 00005008 53                  <1>     push rbx
  2429 00005009 51                  <1>     push rcx
  2430 0000500A 4150                <1>     push r8
  2431 0000500C 4153                <1>     push r11
  2432 0000500E 4156                <1>     push r14
  2433 00005010 4157                <1>     push r15
  2434 00005012 48BB-               <1>     mov rbx, ehciDataIn
  2434 00005014 [C003000000000000]  <1>
  2435 0000501C B900000000          <1>     mov ecx, 0
  2436 00005021 49B8FC000000000000- <1>     mov r8, 0FCh            ;Return 252 bytes
  2436 0000502A 00                  <1>
  2437 0000502B 49BB0A000000000000- <1>     mov r11, 0Ah            ;The command block is 10 bytes
  2437 00005034 00                  <1>
  2438 00005035 49BF-               <1>     mov r15, .scsiReadFormatCapacities
  2438 00005037 [9953000000000000]  <1>
  2439 0000503F 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2439 00005041 [6A4D000000000000]  <1>
  2440 00005049 E82EFFFFFF          <1>     call .ehciMsdBOTRequest
  2441 0000504E 415F                <1>     pop r15
  2442 00005050 415E                <1>     pop r14
  2443 00005052 415B                <1>     pop r11
  2444 00005054 4158                <1>     pop r8
  2445 00005056 59                  <1>     pop rcx
  2446 00005057 5B                  <1>     pop rbx
  2447 00005058 C3                  <1>     ret
  2448                              <1> 
  2449                              <1> .ehciMsdBOTReadCapacity10:
  2450                              <1> ;Input: 
  2451                              <1> ; rsi = Pointer to MSD table data structure that we want to Read Capcities
  2452                              <1> ;Output:
  2453                              <1> ;   CF=CY: Host error, Reset host system
  2454                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2455 00005059 53                  <1>     push rbx
  2456 0000505A 51                  <1>     push rcx
  2457 0000505B 4150                <1>     push r8
  2458 0000505D 4153                <1>     push r11
  2459 0000505F 4156                <1>     push r14
  2460 00005061 4157                <1>     push r15
  2461 00005063 48BB-               <1>     mov rbx, ehciDataIn
  2461 00005065 [C003000000000000]  <1>
  2462 0000506D B900000000          <1>     mov ecx, 0
  2463 00005072 49B808000000000000- <1>     mov r8, 8
  2463 0000507B 00                  <1>
  2464 0000507C 49BB0A000000000000- <1>     mov r11, 0Ah
  2464 00005085 00                  <1>
  2465 00005086 49BF-               <1>     mov r15, .scsiReadCap10
  2465 00005088 [A953000000000000]  <1>
  2466 00005090 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2466 00005092 [6A4D000000000000]  <1>
  2467 0000509A E8DDFEFFFF          <1>     call .ehciMsdBOTRequest
  2468 0000509F 415F                <1>     pop r15
  2469 000050A1 415E                <1>     pop r14
  2470 000050A3 415B                <1>     pop r11
  2471 000050A5 4158                <1>     pop r8
  2472 000050A7 59                  <1>     pop rcx
  2473 000050A8 5B                  <1>     pop rbx
  2474 000050A9 C3                  <1>     ret
  2475                              <1> .ehciMsdBOTFormatUnit:
  2476                              <1> ;Input: 
  2477                              <1> ; rsi = Pointer to MSD table data structure that we want to Format
  2478                              <1> ;Output:
  2479                              <1> ;   CF=CY: Host error, Reset host system
  2480                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2481 000050AA 50                  <1>     push rax
  2482 000050AB 4150                <1>     push r8
  2483 000050AD 4153                <1>     push r11
  2484 000050AF 4156                <1>     push r14
  2485 000050B1 4157                <1>     push r15
  2486 000050B3 4D31C0              <1>     xor r8, r8  ;Request no data
  2487 000050B6 49BB06000000000000- <1>     mov r11, 06h  ;Command length is 6 bytes
  2487 000050BF 00                  <1>
  2488 000050C0 49BE-               <1>     mov r14, .ehciMsdBOTOI
  2488 000050C2 [564E000000000000]  <1>
  2489 000050CA 49BF-               <1>     mov r15, .scsiFormatUnit
  2489 000050CC [B353000000000000]  <1>
  2490 000050D4 E8A3FEFFFF          <1>     call .ehciMsdBOTRequest
  2491 000050D9 7233                <1>     jc .embfuerror
  2492 000050DB E893FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2493 000050E0 84E4                <1>     test ah, ah
  2494 000050E2 752A                <1>     jnz .embfuerror
  2495                              <1> .embfu0:
  2496 000050E4 E8C7000000          <1>     call .ehciMsdBOTTestReady
  2497 000050E9 7223                <1>     jc .embfuerror
  2498 000050EB E883FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2499 000050F0 84E4                <1>     test ah, ah
  2500 000050F2 7410                <1>     jz .embfuexit
  2501 000050F4 E866000000          <1>     call .ehciMsdBOTRequestSense
  2502 000050F9 7213                <1>     jc .embfuerror
  2503 000050FB E873FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2504 00005100 84E4                <1>     test ah, ah
  2505 00005102 75E0                <1>     jnz .embfu0
  2506                              <1> .embfuexit:
  2507 00005104 415F                <1>     pop r15
  2508 00005106 415E                <1>     pop r14
  2509 00005108 415B                <1>     pop r11
  2510 0000510A 4158                <1>     pop r8
  2511 0000510C 58                  <1>     pop rax
  2512 0000510D C3                  <1>     ret
  2513                              <1> .embfuerror:
  2514 0000510E F9                  <1>     stc
  2515 0000510F EBF3                <1>     jmp short .embfuexit
  2516                              <1> .ehciMsdBOTVerify:
  2517                              <1> ;Input: 
  2518                              <1> ; rsi = Pointer to MSD table data structure that we want to Verify Sectors
  2519                              <1> ; edx = Starting LBA to verify
  2520                              <1> ;Output:
  2521                              <1> ;   CF=CY: Host error, Reset host system
  2522                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2523 00005111 50                  <1>     push rax
  2524 00005112 4150                <1>     push r8
  2525 00005114 4153                <1>     push r11
  2526 00005116 4154                <1>     push r12
  2527 00005118 4156                <1>     push r14
  2528 0000511A 4157                <1>     push r15
  2529 0000511C 4D31C0              <1>     xor r8, r8  ;Request no data
  2530 0000511F 49BB0A000000000000- <1>     mov r11, 0Ah  ;Command length is 10 bytes
  2530 00005128 00                  <1>
  2531 00005129 4189D4              <1>     mov r12d, edx
  2532 0000512C 49BE-               <1>     mov r14, .ehciMsdBOTOI
  2532 0000512E [564E000000000000]  <1>
  2533 00005136 49BF-               <1>     mov r15, .scsiVerify
  2533 00005138 [C853000000000000]  <1>
  2534 00005140 E837FEFFFF          <1>     call .ehciMsdBOTRequest
  2535 00005145 7215                <1>     jc .embvbad
  2536 00005147 E827FBFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2537 0000514C 84E4                <1>     test ah, ah
  2538 0000514E 750C                <1>     jnz .embvbad
  2539                              <1> .embvexit:
  2540 00005150 415F                <1>     pop r15
  2541 00005152 415E                <1>     pop r14
  2542 00005154 415C                <1>     pop r12
  2543 00005156 415B                <1>     pop r11
  2544 00005158 4158                <1>     pop r8
  2545 0000515A 59                  <1>     pop rcx
  2546 0000515B C3                  <1>     ret
  2547                              <1> .embvbad:
  2548 0000515C F9                  <1>     stc
  2549 0000515D EBF1                <1>     jmp short .embvexit
  2550                              <1> .ehciMsdBOTRequestSense:
  2551                              <1> ;Input: 
  2552                              <1> ; rsi = Pointer to device MSD table data structure
  2553                              <1> ;Output:
  2554                              <1> ;   CF=CY: Host error, Reset host system
  2555                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2556 0000515F 53                  <1>     push rbx
  2557 00005160 51                  <1>     push rcx
  2558 00005161 4150                <1>     push r8
  2559 00005163 4153                <1>     push r11
  2560 00005165 4156                <1>     push r14
  2561 00005167 4157                <1>     push r15
  2562 00005169 48BB-               <1>     mov rbx, ehciDataIn
  2562 0000516B [C003000000000000]  <1>
  2563 00005173 B900000000          <1>     mov ecx, 0
  2564 00005178 49B812000000000000- <1>     mov r8, 12h         ;Request 18 bytes
  2564 00005181 00                  <1>
  2565 00005182 49BB06000000000000- <1>     mov r11, 6          ;Command length is 6
  2565 0000518B 00                  <1>
  2566 0000518C 49BF-               <1>     mov r15, .scsiRequestSense
  2566 0000518E [7C53000000000000]  <1>
  2567 00005196 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2567 00005198 [6A4D000000000000]  <1>
  2568 000051A0 E8D7FDFFFF          <1>     call .ehciMsdBOTRequest
  2569 000051A5 415F                <1>     pop r15
  2570 000051A7 415E                <1>     pop r14
  2571 000051A9 415B                <1>     pop r11
  2572 000051AB 4158                <1>     pop r8
  2573 000051AD 59                  <1>     pop rcx
  2574 000051AE 5B                  <1>     pop rbx
  2575 000051AF C3                  <1>     ret
  2576                              <1> 
  2577                              <1> .ehciMsdBOTTestReady:
  2578                              <1> ;Input: 
  2579                              <1> ; rsi = Pointer to MSD table data structure that we want to Test Ready
  2580                              <1> ;Output:
  2581                              <1> ;   CF=CY: Host error, Reset host system
  2582                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2583 000051B0 4150                <1>     push r8
  2584 000051B2 4153                <1>     push r11
  2585 000051B4 4156                <1>     push r14
  2586 000051B6 4157                <1>     push r15
  2587 000051B8 4D31C0              <1>     xor r8, r8  ;Request no data
  2588 000051BB 49BB06000000000000- <1>     mov r11, 6  ;Command length is 6
  2588 000051C4 00                  <1>
  2589 000051C5 49BE-               <1>     mov r14, .ehciMsdBOTOI
  2589 000051C7 [564E000000000000]  <1>
  2590 000051CF 49BF-               <1>     mov r15, .scsiTestUnitReady
  2590 000051D1 [8F53000000000000]  <1>
  2591 000051D9 E89EFDFFFF          <1>     call .ehciMsdBOTRequest
  2592 000051DE 415F                <1>     pop r15
  2593 000051E0 415E                <1>     pop r14
  2594 000051E2 415B                <1>     pop r11
  2595 000051E4 4158                <1>     pop r8
  2596 000051E6 C3                  <1>     ret
  2597                              <1> .ehciMsdBOTModeSense6:
  2598                              <1> ;Input: 
  2599                              <1> ; rsi = Pointer to MSD table data structure that we want to Test Ready
  2600                              <1> ;Output:
  2601                              <1> ;   CF=CY: Host error, Reset host system
  2602                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2603 000051E7 53                  <1>     push rbx
  2604 000051E8 51                  <1>     push rcx
  2605 000051E9 4150                <1>     push r8
  2606 000051EB 4153                <1>     push r11
  2607 000051ED 4156                <1>     push r14
  2608 000051EF 4157                <1>     push r15
  2609 000051F1 48BB-               <1>     mov rbx, ehciDataIn
  2609 000051F3 [C003000000000000]  <1>
  2610 000051FB B900000000          <1>     mov ecx, 0
  2611 00005200 49B8C0000000000000- <1>     mov r8, 0C0h        ;Request 192 bytes
  2611 00005209 00                  <1>
  2612 0000520A 49BB06000000000000- <1>     mov r11, 6          ;Command length is 6
  2612 00005213 00                  <1>
  2613 00005214 49BF-               <1>     mov r15, .scsiModeSense6
  2613 00005216 [E953000000000000]  <1>
  2614 0000521E 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2614 00005220 [6A4D000000000000]  <1>
  2615 00005228 E84FFDFFFF          <1>     call .ehciMsdBOTRequest
  2616 0000522D 415F                <1>     pop r15
  2617 0000522F 415E                <1>     pop r14
  2618 00005231 415B                <1>     pop r11
  2619 00005233 4158                <1>     pop r8
  2620 00005235 59                  <1>     pop rcx
  2621 00005236 5B                  <1>     pop rbx
  2622 00005237 C3                  <1>     ret
  2623                              <1> 
  2624                              <1> ;.ehciMsdBOTOutSector64:
  2625                              <1> .ehciMsdBOTOutSector512:
  2626                              <1> ;Input: 
  2627                              <1> ; rsi = Pointer to MSD table data structure that we want to read
  2628                              <1> ; rbx = Address of the buffer to read the segment from
  2629                              <1> ; edx = Starting LBA to read to
  2630                              <1> ;Output:
  2631                              <1> ;   CF=CY: Host error, Reset host system
  2632                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2633 00005238 4151                <1>     push r9
  2634 0000523A 4156                <1>     push r14
  2635 0000523C 4157                <1>     push r15
  2636 0000523E 50                  <1>     push rax
  2637 0000523F 4D31C9              <1>     xor r9, r9 ;Send an OUT packet
  2638 00005242 49BE-               <1>     mov r14, .ehciMsdBOTOOI
  2638 00005244 [9E4C000000000000]  <1>
  2639 0000524C 49BF-               <1>     mov r15, .scsiWrite10
  2639 0000524E [5553000000000000]  <1>
  2640 00005256 E85D000000          <1>     call .ehciMsdBOTSector512
  2641 0000525B 7221                <1>     jc .emboseerror
  2642 0000525D E811FAFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2643 00005262 84E4                <1>     test ah, ah
  2644 00005264 7518                <1>     jnz .emboseerror
  2645 00005266 E845FFFFFF          <1>     call .ehciMsdBOTTestReady   ;Seems to flush data onto disk
  2646 0000526B 7211                <1>     jc .emboseerror
  2647 0000526D E801FAFFFF          <1>     call .ehciMsdBOTCheckTransaction
  2648 00005272 84E4                <1>     test ah, ah
  2649 00005274 7508                <1>     jnz .emboseerror
  2650                              <1> .embosexit:
  2651 00005276 58                  <1>     pop rax
  2652 00005277 415F                <1>     pop r15
  2653 00005279 415E                <1>     pop r14
  2654 0000527B 4159                <1>     pop r9
  2655 0000527D C3                  <1>     ret
  2656                              <1> .emboseerror:
  2657 0000527E F9                  <1>     stc
  2658 0000527F EBF5                <1>     jmp short .embosexit
  2659                              <1> ;.ehciMsdBOTInSector64:
  2660                              <1> .ehciMsdBOTInSector512:
  2661                              <1> ;Input: 
  2662                              <1> ; rsi = Pointer to MSD table data structure that we want to read
  2663                              <1> ; rbx = Address of the buffer to read the segment into
  2664                              <1> ; edx = Starting LBA to read from
  2665                              <1> ;Output:
  2666                              <1> ;   CF=CY: Host error, Reset host system
  2667                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2668 00005281 4151                <1>     push r9
  2669 00005283 4156                <1>     push r14
  2670 00005285 4157                <1>     push r15
  2671 00005287 50                  <1>     push rax
  2672 00005288 49B980000000000000- <1>     mov r9, 80h ;Recieve an IN packet
  2672 00005291 00                  <1>
  2673 00005292 49BE-               <1>     mov r14, .ehciMsdBOTOII
  2673 00005294 [6A4D000000000000]  <1>
  2674 0000529C 49BF-               <1>     mov r15, .scsiRead10
  2674 0000529E [5953000000000000]  <1>
  2675 000052A6 E80D000000          <1>     call .ehciMsdBOTSector512
  2676 000052AB 72D1                <1>     jc .emboseerror
  2677 000052AD E8C1F9FFFF          <1>     call .ehciMsdBOTCheckTransaction
  2678 000052B2 84E4                <1>     test ah, ah
  2679 000052B4 75C8                <1>     jnz .emboseerror
  2680 000052B6 EBBE                <1>     jmp short .embosexit
  2681                              <1> .ehciMsdBOTSector512:
  2682                              <1> ;Input: 
  2683                              <1> ; rsi = Pointer to MSD table data structure that we want to read
  2684                              <1> ; rbx = Address of the buffer to read the segment into
  2685                              <1> ; edx = Starting LBA to read to/from
  2686                              <1> ; r9  = CBW flag (IN or OUT transaction)
  2687                              <1> ; r15 = SCSI function
  2688                              <1> ;Output:
  2689                              <1> ;   CF=CY: Host error, Reset host system
  2690                              <1> ;   CF=NC: Transaction succeeded, check data transferred successfully
  2691 000052B8 57                  <1>     push rdi
  2692 000052B9 4150                <1>     push r8
  2693 000052BB 4152                <1>     push r10
  2694 000052BD 4153                <1>     push r11
  2695                              <1> 
  2696 000052BF 48BF-               <1>     mov rdi, ehciDataOut    ;Write the CBW at the data out point
  2696 000052C1 [8003000000000000]  <1>
  2697 000052C9 41B800020000        <1>     mov r8d, 200h           ;512 bytes to be transferred
  2698 000052CF 4D31D2              <1>     xor r10, r10            ;LUN 0
  2699 000052D2 49BB0C000000000000- <1>     mov r11, 0Ch            ;The command block is 10 bytes long
  2699 000052DB 00                  <1>
  2700 000052DC E828000000          <1>     call .msdWriteCBW     ;Write the CBW
  2701                              <1> 
  2702 000052E1 50                  <1>     push rax                ;Temp push ax
  2703 000052E2 4150                <1>     push r8                 ;Temp save # of bytes for transfer
  2704 000052E4 30C0                <1>     xor al, al              ;LUN 0 device
  2705 000052E6 4189D0              <1>     mov r8d, edx            ;Starting LBA to read from
  2706 000052E9 49B901000000000000- <1>     mov r9, 1               ;Number of LBAs to read
  2706 000052F2 00                  <1>
  2707 000052F3 41FFD7              <1>     call r15                ;Write the valid CBW Command block
  2708 000052F6 4158                <1>     pop r8
  2709 000052F8 58                  <1>     pop rax
  2710                              <1> 
  2711 000052F9 B90A000000          <1>     mov ecx, 10              ;Wait for data preparation, 10ms
  2712 000052FE 41FFD6              <1>     call r14
  2713                              <1> 
  2714 00005301 415B                <1>     pop r11
  2715 00005303 415A                <1>     pop r10
  2716 00005305 4158                <1>     pop r8
  2717 00005307 5F                  <1>     pop rdi
  2718 00005308 C3                  <1>     ret
  2719                              <1> .msdWriteCBW:
  2720                              <1> ;Writes a Command Block Wrapper at the location pointed to by rdi
  2721                              <1> ; without a functional command block. Must be appended by user.
  2722                              <1> ; Input:  rdi=Pointer to CBW buffer
  2723                              <1> ;         r8d=Command Block Wrapper Data Transfer Length
  2724                              <1> ;         r9b=Command Block Wrapper Flags
  2725                              <1> ;         r10b=Command Block Wrapper LUN nybble
  2726                              <1> ;         r11b=Command Block Wrapper Command Block Length
  2727                              <1> ; Output: rdi = Pointer to CBW's (SCSI) Command Descriptor Block buffer
  2728 00005309 50                  <1>     push rax
  2729 0000530A B855534243          <1>     mov eax, CBWSig
  2730 0000530F AB                  <1>     stosd
  2731 00005310 0FB60425[4B020000]  <1>     movzx eax, byte [cbwTag]
  2732 00005318 FE0425[4B020000]    <1>     inc byte [cbwTag]
  2733 0000531F AB                  <1>     stosd
  2734 00005320 4489C0              <1>     mov eax, r8d
  2735 00005323 AB                  <1>     stosd
  2736 00005324 4488C8              <1>     mov al, r9b
  2737 00005327 AA                  <1>     stosb
  2738 00005328 4488D0              <1>     mov al, r10b
  2739 0000532B AA                  <1>     stosb
  2740 0000532C 4488D8              <1>     mov al, r11b
  2741 0000532F AA                  <1>     stosb
  2742 00005330 31C0                <1>     xor eax, eax
  2743 00005332 57                  <1>     push rdi
  2744 00005333 48AB                <1>     stosq   ;16 bytes in csw command block
  2745 00005335 48AB                <1>     stosq   ;Clear memory
  2746 00005337 5F                  <1>     pop rdi
  2747 00005338 58                  <1>     pop rax
  2748 00005339 C3                  <1>     ret
  2749                              <1> 
  2750                              <1> ;                        --------SCSI functions---------
  2751                              <1> 
  2752                              <1> .scsiInquiry:
  2753                              <1> ;Writes an inquiry scsi command block to the location pointed to by rdi
  2754                              <1> ;al contains the LUN of the device we are accessing. (lower 3 bits considered)
  2755                              <1> ;al not preserved
  2756 0000533A B412                <1>     mov ah, 12h        ;Move inquiry command value high
  2757 0000533C C0E005              <1>     shl al, 5        ;Shift left by five to align LUN properly
  2758 0000533F 86E0                <1>     xchg ah, al        ;swap ah and al
  2759 00005341 66AB                <1>     stosw            ;Store command and shifted LUN together
  2760 00005343 4831C0              <1>     xor rax, rax
  2761 00005346 66AB                <1>     stosw            ;Store two zeros (reserved fields)
  2762 00005348 48B824000000000000- <1>     mov rax, 24h    ;Allocation length (36 bytes)
  2762 00005351 00                  <1>
  2763 00005352 48AB                <1>     stosq
  2764 00005354 C3                  <1>     ret
  2765                              <1> ;NOTE! Using read/write 10 means can't read beyond the first 4 Gb of Medium.
  2766                              <1> .scsiWrite10:
  2767                              <1> ;Writes a scsi write 10 transfer command to the location pointed at by rdi
  2768                              <1> ;al contains the LUN of the device we are accessing
  2769                              <1> ;r8d contains the LBA start address
  2770                              <1> ;r9w contains the Verification Length
  2771 00005355 B42A                <1>     mov ah, 2Ah        ;Operation code for command
  2772 00005357 EB02                <1>     jmp short .scsirw
  2773                              <1> .scsiRead10:
  2774                              <1> ;Writes a scsi Read 10 command to the location pointed to by rdi
  2775                              <1> ;al contains the LUN of the device we are accessing.
  2776                              <1> ;r8d contains the LBA to read from
  2777                              <1> ;r9w contains the number of contiguous blocks to read (should be 1 for us)
  2778 00005359 B428                <1>     mov ah, 28h        ;Move read(10) command value high
  2779                              <1> .scsirw:
  2780 0000535B C0E005              <1>     shl al, 5        ;Shift left by five to align LUN properly
  2781 0000535E 86E0                <1>     xchg ah, al        ;swap ah and al
  2782 00005360 66AB                <1>     stosw            ;Store command and shifted LUN together
  2783 00005362 410FC8              <1>     bswap r8d        ;swap endianness of r8d
  2784 00005365 4489C0              <1>     mov eax, r8d
  2785 00005368 AB                  <1>     stosd
  2786 00005369 4831C0              <1>     xor rax, rax    ;Clear for a Reserved byte
  2787 0000536C AA                  <1>     stosb
  2788 0000536D 664489C8            <1>     mov ax, r9w        ;move into ax to use xchg on upper and lower bytes
  2789 00005371 86C4                <1>     xchg al, ah        ;MSB first, yuck yuck yuck
  2790 00005373 66AB                <1>     stosw
  2791 00005375 C1E810              <1>     shr eax, 16        ;Bring zeros down onto lower word
  2792 00005378 66AB                <1>     stosw            ;Store one reserved byte and two padding bytes
  2793 0000537A AA                  <1>     stosb            
  2794 0000537B C3                  <1>     ret
  2795                              <1> .scsiRequestSense:
  2796                              <1> ;Writes a scsi Request Sense command to the location pointer to by rdi
  2797                              <1> ;al contains the LUN of the device we are accessing.
  2798 0000537C B403                <1>     mov ah, 03h        ;Move reqsense command value high
  2799 0000537E C0E005              <1>     shl al, 5        ;Shift left by five to align LUN properly
  2800 00005381 86E0                <1>     xchg ah, al        ;swap ah and al
  2801 00005383 66AB                <1>     stosw            ;Store command and shifted LUN together
  2802 00005385 4831C0              <1>     xor rax, rax    
  2803 00005388 66AB                <1>     stosw            ;Reserved word
  2804 0000538A B012                <1>     mov al, 12h    ;Move alloc length byte into al
  2805 0000538C 48AB                <1>     stosq
  2806 0000538E C3                  <1>     ret
  2807                              <1> .scsiTestUnitReady:
  2808                              <1> ;Writes a scsi test unit ready command to the location pointed to by rdi
  2809                              <1> ;al contains the LUN of the device we are accessing.
  2810 0000538F 30E4                <1>     xor ah, ah        ;Operation code zero
  2811 00005391 C0E005              <1>     shl al, 5
  2812 00005394 86E0                <1>     xchg ah, al
  2813 00005396 66AB                <1>     stosw            ;Store shifted LUN and command code
  2814 00005398 C3                  <1>     ret
  2815                              <1> .scsiReadFormatCapacities:
  2816                              <1> ;al contains the LUN of the device
  2817 00005399 88C4                <1>     mov ah, al
  2818 0000539B B023                <1>     mov al, 23h        ;Operation code for command
  2819 0000539D 66AB                <1>     stosw            ;Store shifted LUN and command code
  2820 0000539F 4831C0              <1>     xor rax, rax
  2821 000053A2 AB                  <1>     stosd          ;Reserved dword    
  2822 000053A3 66AB                <1>     stosw           ;Reserved word
  2823 000053A5 B0FC                <1>     mov al, 0FCh    ;Move alloc length byte into al
  2824 000053A7 AA                  <1>     stosb
  2825 000053A8 C3                  <1>     ret
  2826                              <1> .scsiReadCap10:
  2827                              <1> ;Writes a scsi read capacity command to the location pointed to by rdi
  2828                              <1> ;al contains the LUN of the device we are accessing
  2829 000053A9 B425                <1>     mov ah, 25h        ;Operation code for command
  2830 000053AB C0E005              <1>     shl al, 5
  2831 000053AE 86E0                <1>     xchg ah, al
  2832 000053B0 66AB                <1>     stosw            ;Store shifted LUN and command code
  2833 000053B2 C3                  <1>     ret
  2834                              <1> .scsiFormatUnit:
  2835                              <1> ;Writes a scsi format unit command to the location pointed to by rdi
  2836                              <1> ;al contains the LUN of the device we are accessing
  2837 000053B3 B404                <1>     mov ah, 04h        ;Operation code for format command
  2838 000053B5 C0E005              <1>     shl al, 5
  2839 000053B8 0C17                <1>     or al, 17h      ;Set bits [3:0] and 5, keep bit 4 clear
  2840 000053BA 86E0                <1>     xchg ah, al
  2841 000053BC 66AB                <1>     stosw
  2842 000053BE 30C0                <1>     xor al, al
  2843 000053C0 66AB                <1>     stosw            ;Vender specific, set to 0!!
  2844 000053C2 4831C0              <1>     xor rax, rax
  2845 000053C5 48AB                <1>     stosq            ;Store LSB byte and all the 0 padding
  2846 000053C7 C3                  <1>     ret
  2847                              <1> .scsiVerify:
  2848                              <1> ;Writes a scsi verify transfer command to the location pointed at by rdi
  2849                              <1> ;al contains the LUN of the device we are accessing
  2850                              <1> ;r12d contains the LBA for the sector address
  2851                              <1> ;Verifies one sector
  2852 000053C8 B42F                <1>     mov ah, 2Fh        ;Operation code for command
  2853 000053CA C0E005              <1>     shl al, 5        ;Hardcode bytecheck (byte [1]) to 0
  2854 000053CD 86E0                <1>     xchg ah, al
  2855 000053CF 66AB                <1>     stosw            ;Store shifted LUN and command code
  2856 000053D1 410FCC              <1>     bswap r12d        ;swap endianness of r12d
  2857 000053D4 4489E0              <1>     mov eax, r12d
  2858 000053D7 AB                  <1>     stosd
  2859 000053D8 4831C0              <1>     xor rax, rax    ;Clear for a Reserved byte
  2860 000053DB AA                  <1>     stosb
  2861 000053DC 66B80001            <1>     mov ax, 0100h    ;Write the number 1 in Big endian
  2862 000053E0 66AB                <1>     stosw
  2863 000053E2 C1E810              <1>     shr eax, 16        ;Bring zeros down onto lower word
  2864 000053E5 66AB                <1>     stosw            ;Store one reserved byte and two padding bytes
  2865 000053E7 AA                  <1>     stosb        
  2866 000053E8 C3                  <1>     ret
  2867                              <1> .scsiModeSense6:
  2868                              <1> ;al contains the LUN of the device we are accessing
  2869 000053E9 B41A                <1>     mov ah, 1Ah     ;Operation code for Mode Sense 6
  2870 000053EB C0E005              <1>     shl al, 5       ;Move LUN
  2871 000053EE 86E0                <1>     xchg ah, al
  2872 000053F0 66AB                <1>     stosw
  2873 000053F2 B83F00C000          <1>     mov eax, 0C0003Fh    
  2874                              <1>     ;Request all pages, reserve byte, 192 bytes and 0 end byte
  2875 000053F7 AB                  <1>     stosd
  2876 000053F8 C3                  <1>     ret
  2877                              <1> ;                    -------------------------------
  2878                              <1> .ehciGetOpBase:
  2879                              <1> ;Gets opbase from mmio base (aka adds caplength) into eax
  2880                              <1> ;Input:
  2881                              <1> ; al = offset into ehci table
  2882                              <1> ;Return:
  2883                              <1> ; eax = opbase (low 4Gb)
  2884 000053F9 53                  <1>     push rbx
  2885 000053FA 4831DB              <1>     xor rbx, rbx
  2886 000053FD 480FB6C0            <1>     movzx rax, al
  2887 00005401 8B04C5[1A020000]    <1>     mov eax, dword [eControllerList + 4 + 8*rax]    ;get mmiobase into eax
  2888 00005408 85C0                <1>     test eax, eax             ;addrress of 0 means no controller
  2889 0000540A 7406                <1>     jz .egob1
  2890 0000540C 670FB618            <1>     movzx ebx, byte [eax]    ;get the offset to opbase into ebx
  2891 00005410 01D8                <1>     add eax, ebx            ;add this offset to mmiobase to get opbase
  2892                              <1> .egob1:
  2893 00005412 5B                  <1>     pop rbx
  2894 00005413 C3                  <1>     ret
   111                                  %include "./Source/Resident/Hardware/USB/xHCI/xhciDriv.asm"
   112                                  ;====================================CPU Interrupts=============================
   113                                  %include "./Source/Resident/Hardware/CPU/xception.asm"
     1                              <1> i0:
     2 00005414 4831C0              <1>     xor rax, rax
     3 00005417 E936010000          <1>     jmp cpu_2args
     4                              <1> i1:
     5 0000541C 48B801000000000000- <1>     mov rax, 1
     5 00005425 00                  <1>
     6 00005426 E927010000          <1>     jmp cpu_2args
     7                              <1> i2:
     8 0000542B 48B802000000000000- <1>     mov rax, 2
     8 00005434 00                  <1>
     9 00005435 E918010000          <1>     jmp cpu_2args
    10                              <1> i3:
    11 0000543A 48B803000000000000- <1>     mov rax, 3
    11 00005443 00                  <1>
    12 00005444 E909010000          <1>     jmp cpu_2args
    13                              <1> i4:
    14 00005449 48B804000000000000- <1>     mov rax, 4
    14 00005452 00                  <1>
    15 00005453 E9FA000000          <1>     jmp cpu_2args
    16                              <1> i5:
    17 00005458 48B805000000000000- <1>     mov rax, 5
    17 00005461 00                  <1>
    18 00005462 E9EB000000          <1>     jmp cpu_2args
    19                              <1> i6:
    20 00005467 48B806000000000000- <1>     mov rax, 6
    20 00005470 00                  <1>
    21 00005471 E9DC000000          <1>     jmp cpu_2args
    22                              <1> i7:
    23 00005476 48B807000000000000- <1>     mov rax, 7
    23 0000547F 00                  <1>
    24 00005480 E9CD000000          <1>     jmp cpu_2args
    25                              <1> i8:
    26 00005485 48B808000000000000- <1>     mov rax, 8
    26 0000548E 00                  <1>
    27 0000548F E9B2000000          <1>     jmp cpu_3args
    28                              <1> i9:
    29 00005494 48B809000000000000- <1>     mov rax, 9
    29 0000549D 00                  <1>
    30 0000549E E9AF000000          <1>     jmp cpu_2args
    31                              <1> i10:
    32 000054A3 48B80A000000000000- <1>     mov rax, 0Ah
    32 000054AC 00                  <1>
    33 000054AD E994000000          <1>     jmp cpu_3args
    34                              <1> i11:
    35 000054B2 48B80B000000000000- <1>     mov rax, 0Bh
    35 000054BB 00                  <1>
    36 000054BC E985000000          <1>     jmp cpu_3args
    37                              <1> i12:
    38 000054C1 48B80C000000000000- <1>     mov rax, 0Ch
    38 000054CA 00                  <1>
    39 000054CB E976000000          <1>     jmp cpu_3args
    40                              <1> i13:
    41 000054D0 48B80D000000000000- <1>     mov rax, 0Dh
    41 000054D9 00                  <1>
    42 000054DA EB6A                <1>     jmp short cpu_3args
    43                              <1> i14:
    44 000054DC 48B80E000000000000- <1>     mov rax, 0Eh
    44 000054E5 00                  <1>
    45 000054E6 EB52                <1>     jmp short cpu_4args
    46                              <1> i15:
    47 000054E8 48B80F000000000000- <1>     mov rax, 0Fh
    47 000054F1 00                  <1>
    48 000054F2 EB5E                <1>     jmp short cpu_2args
    49                              <1> i16:
    50 000054F4 48B810000000000000- <1>     mov rax, 10h
    50 000054FD 00                  <1>
    51 000054FE EB52                <1>     jmp short cpu_2args
    52                              <1> i17:
    53 00005500 48B811000000000000- <1>     mov rax, 11h
    53 00005509 00                  <1>
    54 0000550A EB3A                <1>     jmp short cpu_3args
    55                              <1> i18:
    56 0000550C 48B812000000000000- <1>     mov rax, 12h
    56 00005515 00                  <1>
    57 00005516 EB3A                <1>     jmp short cpu_2args
    58                              <1> i19:
    59 00005518 48B813000000000000- <1>     mov rax, 13h
    59 00005521 00                  <1>
    60 00005522 EB2E                <1>     jmp short cpu_2args
    61                              <1> i20:
    62 00005524 48B814000000000000- <1>     mov rax, 14h
    62 0000552D 00                  <1>
    63 0000552E EB22                <1>     jmp short cpu_2args
    64                              <1> i21:
    65 00005530 48B815000000000000- <1>     mov rax, 15h
    65 00005539 00                  <1>
    66                              <1> cpu_4args:
    67 0000553A 48B903000000000000- <1>     mov rcx, 3
    67 00005543 00                  <1>
    68 00005544 EB16                <1>     jmp short cpu_exception
    69                              <1> cpu_3args:
    70 00005546 48B902000000000000- <1>     mov rcx, 2
    70 0000554F 00                  <1>
    71 00005550 EB0A                <1>     jmp short cpu_exception
    72                              <1> cpu_2args:
    73 00005552 48B901000000000000- <1>     mov rcx, 1
    73 0000555B 00                  <1>
    74                              <1> cpu_exception:
    75 0000555C 50                  <1>     push rax
    76 0000555D 51                  <1>     push rcx
    77 0000555E 66BB1F00            <1>     mov bx, 001Fh    ;cls attribs
    78 00005562 E890ABFFFF          <1>     call cls
    79                              <1> 
    80 00005567 48B800020000000000- <1>     mov rax, 0200h
    80 00005570 00                  <1>
    81 00005571 4831DB              <1>     xor rbx, rbx
    82 00005574 48BA22070000000000- <1>     mov rdx, 0722h    ;7 Rows down, 24 columns across
    82 0000557D 00                  <1>
    83 0000557E 48BD-               <1>     mov rbp, .fatalt0
    83 00005580 [C956000000000000]  <1>
    84 00005588 66BB7100            <1>     mov bx, 0071h     ;blue grey attribs, page 0
    85 0000558C 66B80113            <1>     mov ax, 1301h     ;print zero 8 chars, with bh attrib
    86 00005590 48B908000000000000- <1>     mov rcx, 8
    86 00005599 00                  <1>
    87 0000559A CD30                <1>     int 30h
    88                              <1> 
    89 0000559C 48B800020000000000- <1>     mov rax, 0200h
    89 000055A5 00                  <1>
    90 000055A6 30FF                <1>     xor bh, bh
    91 000055A8 48BA040A0000000000- <1>     mov rdx, 0A04h    ;11 Rows down, 24 columns across
    91 000055B1 00                  <1>
    92 000055B2 CD30                <1>     int 30h
    93 000055B4 48BD-               <1>     mov rbp, .fatal1
    93 000055B6 [D156000000000000]  <1>
    94 000055BE 30FF                <1>     xor bh, bh        ;blue grey attribs, page 0
    95 000055C0 66B80413            <1>     mov ax, 1304h            ;print zero terminated string
    96 000055C4 CD30                <1>     int 30h
    97                              <1> 
    98 000055C6 59                  <1>     pop rcx
    99 000055C7 58                  <1>     pop rax                ;pop the exception number back into rax
   100 000055C8 E8DF000000          <1>     call .printbyte
   101                              <1> 
   102 000055CD 48B804130000000000- <1>     mov rax, 1304h
   102 000055D6 00                  <1>
   103 000055D7 30FF                <1>     xor bh, bh
   104 000055D9 48BD-               <1>     mov rbp, .fatal2
   104 000055DB [1258000000000000]  <1>
   105 000055E3 CD30                <1>     int 30h
   106                              <1> 
   107 000055E5 80F901              <1>     cmp cl, 1
   108 000055E8 773A                <1>     ja .cpuextendederror    ;rax contains error code, or extra cr2 value
   109                              <1> .cpurollprint:
   110 000055EA 488B1424            <1>     mov rdx, qword [rsp]    ;Get address
   111                              <1> ;Takes whats in rdx, rols left by one byte, prints al
   112 000055EE B108                <1>     mov cl, 8    ;8 bytes
   113                              <1> .cpurollprint1:
   114 000055F0 48C1C208            <1>     rol rdx, 8
   115 000055F4 88D0                <1>     mov al, dl
   116 000055F6 52                  <1>     push rdx
   117 000055F7 E8B0000000          <1>     call .printbyte
   118 000055FC 5A                  <1>     pop rdx
   119 000055FD FEC9                <1>     dec cl
   120 000055FF 75EF                <1>     jnz .cpurollprint1
   121                              <1> 
   122                              <1> .cpuexendloop:
   123 00005601 6631C0              <1>     xor ax, ax
   124 00005604 CD36                <1>     int 36h
   125 00005606 3C1B                <1>     cmp al, 1Bh    ;Check for escape pressed (unlikely?)
   126 00005608 740F                <1>     je .cpu_exception_appret
   127 0000560A 3C0D                <1>     cmp al, 0Dh ;Check for enter pressed
   128 0000560C 75F3                <1>     jne .cpuexendloop
   129                              <1> 
   130 0000560E 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   131 00005612 E8E0AAFFFF          <1>     call cls
   132 00005617 CD38                <1>     int 38h    ;Jump to debugger
   133                              <1> .cpu_exception_appret:
   134 00005619 66BB0700            <1>     mov bx, 0007h    ;cls attribs
   135 0000561D E8D5AAFFFF          <1>     call cls
   136 00005622 48CF                <1>     iretq ;Return to address on stack
   137                              <1> 
   138                              <1> .cpuextendederror:
   139 00005624 5A                  <1>     pop rdx
   140 00005625 48FFC9              <1>     dec rcx
   141 00005628 51                  <1>     push rcx
   142 00005629 B102                <1>     mov cl, 2    ;CAN CHANGE TO 4 BYTES IN THE FUTURE
   143                              <1> .pr1:
   144 0000562B C1C208              <1>     rol edx, 8    ;Print just edx
   145 0000562E 88D0                <1>     mov al, dl
   146 00005630 52                  <1>     push rdx
   147 00005631 E876000000          <1>     call .printbyte
   148 00005636 5A                  <1>     pop rdx
   149 00005637 FEC9                <1>     dec cl
   150 00005639 75F0                <1>     jnz .pr1
   151                              <1> 
   152 0000563B 48B804130000000000- <1>     mov rax, 1304h
   152 00005644 00                  <1>
   153 00005645 48BB17000000000000- <1>     mov rbx, 17h
   153 0000564E 00                  <1>
   154 0000564F 48BD-               <1>     mov rbp, .fatal2
   154 00005651 [1258000000000000]  <1>
   155 00005659 CD30                <1>     int 30h
   156 0000565B 59                  <1>     pop rcx    ;Bring the comparison value back into rcx
   157                              <1>     
   158 0000565C 48FFC9              <1>     dec rcx
   159 0000565F 7489                <1>     jz .cpurollprint
   160                              <1> 
   161 00005661 B108                <1>     mov cl, 8
   162 00005663 0F20D2              <1>     mov rdx, cr2    ;Get page fault address
   163                              <1> .pr2:
   164 00005666 48C1C208            <1>     rol rdx, 8    ;Print rdx
   165 0000566A 88D0                <1>     mov al, dl
   166 0000566C 52                  <1>     push rdx
   167 0000566D E83A000000          <1>     call .printbyte
   168 00005672 5A                  <1>     pop rdx
   169 00005673 FEC9                <1>     dec cl
   170 00005675 75EF                <1>     jnz .pr2
   171                              <1> 
   172 00005677 48B804130000000000- <1>     mov rax, 1304h
   172 00005680 00                  <1>
   173 00005681 48BB17000000000000- <1>     mov rbx, 17h
   173 0000568A 00                  <1>
   174 0000568B 48BD-               <1>     mov rbp, .fatal2
   174 0000568D [1258000000000000]  <1>
   175 00005695 CD30                <1>     int 30h
   176                              <1>     
   177 00005697 E94EFFFFFF          <1>     jmp .cpurollprint
   178                              <1> 
   179                              <1> 
   180                              <1> .char:    ;Print a single character
   181 0000569C 48BB-               <1>     mov rbx, .ascii
   181 0000569E [1658000000000000]  <1>
   182 000056A6 D7                  <1>     xlatb    ;point al to entry in ascii table, using al as offset into table
   183                              <1>     ;xor bh, bh
   184 000056A7 B40E                <1>     mov ah, 0Eh
   185 000056A9 CD30                <1>     int 30h    ;print char
   186 000056AB C3                  <1>     ret
   187                              <1> .printbyte:
   188 000056AC 88C2                <1>     mov dl, al            ;save byte in dl
   189 000056AE 6625F000            <1>     and ax, 00F0h        ;Hi nybble
   190 000056B2 6681E20F00          <1>     and dx, 000Fh        ;Lo nybble
   191 000056B7 66C1E804            <1>     shr ax, 4            ;shift one hex place value pos right
   192 000056BB E8DCFFFFFF          <1>     call .char
   193 000056C0 6689D0              <1>     mov ax, dx            ;mov lo nybble, to print
   194 000056C3 E8D4FFFFFF          <1>     call .char
   195 000056C8 C3                  <1>     ret    
   196 000056C9 5343502F42494F53    <1> .fatalt0:  db "SCP/BIOS"
   197 000056D1 4120706F74656E7469- <1> .fatal1:   db "A potentially fatal error has occured. To continue: ",0Ah,0Ah,0Dh
   197 000056DA 616C6C792066617461- <1>
   197 000056E3 6C206572726F722068- <1>
   197 000056EC 6173206F6363757265- <1>
   197 000056F5 642E20546F20636F6E- <1>
   197 000056FE 74696E75653A200A0A- <1>
   197 00005707 0D                  <1>
   198 00005708 202020205072657373- <1> db "    Press Enter to launch SYSDEBUG, or",0Ah,0Ah,0Dh 
   198 00005711 20456E74657220746F- <1>
   198 0000571A 206C61756E63682053- <1>
   198 00005723 595344454255472C20- <1>
   198 0000572C 6F720A0A0D          <1>
   199 00005731 202020205072657373- <1> db "    Press ESC to try and return to the application which caused the error," 
   199 0000573A 2045534320746F2074- <1>
   199 00005743 727920616E64207265- <1>
   199 0000574C 7475726E20746F2074- <1>
   199 00005755 6865206170706C6963- <1>
   199 0000575E 6174696F6E20776869- <1>
   199 00005767 636820636175736564- <1>
   199 00005770 20746865206572726F- <1>
   199 00005779 722C                <1>
   200 0000577B 6F720A0A0D          <1> db "or", 0Ah, 0Ah,0Dh,
   201 00005780 202020205072657373- <1> db "    Press CTRL+ALT+DEL to restart your system. If you do this,",0Ah,0Dh
   201 00005789 204354524C2B414C54- <1>
   201 00005792 2B44454C20746F2072- <1>
   201 0000579B 65737461727420796F- <1>
   201 000057A4 75722073797374656D- <1>
   201 000057AD 2E20496620796F7520- <1>
   201 000057B6 646F20746869732C0A- <1>
   201 000057BF 0D                  <1>
   202 000057C0 20202020796F752077- <1> db "    you will lose any unsaved information in all open applications.",0Ah, 
   202 000057C9 696C6C206C6F736520- <1>
   202 000057D2 616E7920756E736176- <1>
   202 000057DB 656420696E666F726D- <1>
   202 000057E4 6174696F6E20696E20- <1>
   202 000057ED 616C6C206F70656E20- <1>
   202 000057F6 6170706C6963617469- <1>
   202 000057FF 6F6E732E0A          <1>
   203 00005804 0A0D                <1> db 0Ah, 0Dh
   204 00005806 202020204572726F72- <1> db "    Error: ",0
   204 0000580F 3A2000              <1>
   205 00005812 203A2000            <1> .fatal2:   db " : ",0
   206 00005816 303132333435363738- <1> .ascii:    db '0123456789ABCDEF'
   206 0000581F 39414243444546      <1>
   114                                  ;==========================Dummy Interrupts======================
   115                                  %include "./Source/Resident/Hardware/dummyInt.asm"
     1                              <1> dummy_interrupt:
     2                              <1> .pic2:
     3 00005826 50                  <1>     push rax
     4 00005827 B020                <1>     mov al, EOI
     5 00005829 E6A0                <1>     out pic2command, al    ;EOI to pic2
     6 0000582B EB01                <1>     jmp short .p1
     7                              <1> .pic1:
     8 0000582D 50                  <1>     push rax
     9                              <1> .p1:
    10 0000582E B020                <1>     mov al, EOI
    11 00005830 E620                <1>     out pic1command, al    ;EOI to pic2
    12 00005832 58                  <1>     pop rax
    13                              <1> dummy_return_64:
    14 00005833 48CF                <1>     iretq
   116                                  %include "./Source/Resident/Misc/version.asm"
     1                              <1> ;----------------------------------------------------------------
     2 00005835 76302E392053435042- <1> signature:    db "v0.9 SCPBIOS"    ;12 byte signature
     2 0000583E 494F53              <1>
     3 00005841 436F70797269676874- <1> signature2:   db "Copyright (C) Yll Buzoku"
     3 0000584A 2028432920596C6C20- <1>
     3 00005853 42757A6F6B75        <1>
     4 00005859 31302F30352F323032- <1>               db "10/05/2024"
     4 00005862 34                  <1>
   117                                  codeResidentEndPtr:
   118                                  residentLength  equ $-$$
