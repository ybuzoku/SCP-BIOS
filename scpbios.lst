     1                                  [map all scpio64.map]
     2                                  ;-----------------------------------SCPIO.SYS-----------------------------------
     3                                  ;------------------------------------Equates------------------------------------
     4                                  permissionflags equ 003h    ;Page table Permission flags
     5                                  codedescriptor     equ 0008h
     6                                  
     7                                  BIOSStartAddr   equ 00110000h   ;Start just after HMA + 16 bytes
     8                                  BIOSInitAddr    equ 800h
     9                                  
    10                                  e820Seg         equ 1000h
    11                                  e820SizeOff     equ 0000h    ;First word is # of entries
    12                                  e820BaseOff     equ e820SizeOff + 2
    13                                  e820SizeAddr    equ (e820Seg<<4) + e820SizeOff
    14                                  ;---------------------PIC Chip IO values---------------------
    15                                  pic1command     equ 020h        ;Command port
    16                                  pic2command     equ 0A0h        ;Command port
    17                                  pic1data        equ 021h        ;Data port
    18                                  pic2data        equ 0A1h        ;Data port
    19                                  ;------------------------------------------------------------
    20                                  ;-----------------PS/2 IO port commands----------------------
    21                                  ps2command      equ 64h            ;Command Port (write)
    22                                  ps2status       equ 64h            ;Status Port  (read)
    23                                  ps2data         equ 60h           ;Data Port     (read/write)
    24                                  ;------------------------------------------------------------
    25                                  ;--------------------Serial port equates---------------------
    26                                  com1_base       equ 03F8h
    27                                  com2_base       equ 02F8h
    28                                  com3_base       equ 03E8h
    29                                  com4_base       equ 02E8h
    30                                  ;------------------------------------------------------------
    31                                  ;---------------------PIT port equates-----------------------
    32                                  PITbase         equ 40h
    33                                  PIT0            equ PITbase
    34                                  PIT1            equ PITbase + 1
    35                                  PIT2            equ PITbase + 2
    36                                  PITcommand      equ PITbase + 3
    37                                  ;------------------------------------------------------------
    38                                  ;---------------------CMOS port equates----------------------
    39                                  cmos_base        equ 70h
    40                                  cmos_data        equ 71h
    41                                  ;------------------------------------------------------------
    42                                  ;--------------------Keyboard equates------------------------
    43                                  kb_flag_rshift   equ    01h    ;Right Shift is being held
    44                                  kb_flag_lshift   equ    02h    ;Left Shift is being held
    45                                  kb_flag_ctrl     equ    04h    ;Ctrl is being held
    46                                  kb_flag_alt      equ    08h    ;Alt is being held
    47                                  kb_flag_scrlset  equ    10h    ;Scroll lock is set
    48                                  kb_flag_numset   equ    20h    ;Num lock is set
    49                                  kb_flag_capsset  equ    40h    ;Caps lock is set
    50                                  kb_flag_insset   equ    80h    ;Insert mode is set
    51                                  
    52                                  kb_flag2_e1      equ    01h    ;0E1h scancode procedure being processed
    53                                  kb_flag2_e0      equ    02h    ;0E0h scancode procedure being processed
    54                                  ;------------------------------------------------------------
    55                                  ;--------------------Screen equates--------------------------
    56                                  vga_index        equ    03D4h
    57                                  vga_data         equ    03D5h
    58                                  ;---------------- New Equates ----------------
    59                                  vga_aindex       equ    03B4h    ;Alt (MDA) IO Base
    60                                  vga_adata        equ    03B5h
    61                                  ;These equates are SEGMENTS, need to be SHL 4 to become addrs
    62                                  vga_bpage0       equ    0A0000h
    63                                  vga_bpage1       equ    0B0000h
    64                                  vga_bpage2       equ    0B8000h
    65                                  ;------------------------------------------------------------
    66                                  ;----------------------PCI equates---------------------------
    67                                  pci_index        equ    0CF8h
    68                                  pci_data         equ    0CFCh
    69                                  ;------------------------------------------------------------
    70                                  ;----------------------USB equates---------------------------
    71                                  usb_class        equ    0Ch    ;pci class
    72                                  usb_subclass     equ    03h    ;pci subclase
    73                                  uhci_interface   equ    00h    ;usb 1.0
    74                                  uhcimask         equ    10h
    75                                  ohci_interface   equ    10h    ;usb 1.0 alt
    76                                  ohcimask         equ    20h
    77                                  ehci_interface   equ    20h    ;usb 2.0
    78                                  ehcimask         equ    40h
    79                                  xhci_interface   equ    30h    ;usb 3.0
    80                                  xhcimask         equ    80h
    81                                  lousbtablesize   equ    0000E000h    ;Location of the table size, uword
    82                                  lousbtablebase   equ    lousbtablesize + 2 ;base of the table, tword entries
    83                                  debounceperiod   equ 200 ;double 200ms as per Windows, for inaccuracies
    84                                  ;                ------EHCI equates------
    85                                  ehcicaplength    equ    00h    ;Add this to base addr in table to find opparams
    86                                  ehciversion      equ    02h    ;Interface Version number
    87                                  ehcistrucparams  equ    04h    ;Structural Parameters
    88                                  ehcihccparams    equ    08h    ;Capability Parameters
    89                                  ehciportroute    equ    0Ch    ;Companion Port Route Description (v1 ignore)
    90                                  
    91                                  ;Operational registers below
    92                                  
    93                                  ehcicmd          equ    00h    ;USB command register
    94                                  ehcists          equ    04h    ;USB status register
    95                                  ehciintr         equ    08h    ;USB Interrupt Enable
    96                                  ehcifrindex      equ    0Ch    ;USB Frame Index
    97                                  ehcictrlseg      equ    10h    ;4Gb Segment Selector
    98                                  ehciperiodbase   equ    14h    ;Frame List Base Address
    99                                  ehciasyncaddr    equ    18h    ;Next Asynchronus List Address
   100                                  ehciconfigflag   equ    40h    ;Configured Flag Register
   101                                  ehciportsc       equ    44h    ;Read = 1 - # of ports, Write = port ctrl
   102                                  ;                ------------------------
   103                                  ;                -------MSD equates------
   104                                  setupReset       equ 0FFh
   105                                  setupGetMaxLUN   equ 0FEh
   106                                  ;                ------------------------
   107                                  ;                ------Bulk Storage equates------
   108                                  CBWSig           equ    043425355h
   109                                  CSWSig           equ 053425355h
   110                                  CBWFlagOut       equ    00h    ;Switch to send to device
   111                                  CBWFlagIn        equ    80h    ;Switch to recieve from
   112                                  bCSWPassed       equ    00h
   113                                  bCSWFailed       equ    01h
   114                                  bCSWPhase        equ    02h
   115                                  ;                ------------------------
   116                                  ;------------------USB Device table entry sizes------------------
   117                                  msdDevTblEntrySize    equ 10h
   118                                  hubDevTblEntrySize    equ 8h
   119                                  usbDevTblEntrySize    equ 3h
   120                                  usbMaxDevices         equ 10
   121                                  ;                ------------------------
   122                                  ;------------------EHCI Transfer Descriptor size------------------
   123                                  ehciSizeOfQH    equ 60h
   124                                  ehciSizeOfTD    equ 40h
   125                                  ;------------------------------------------------------------
   126                                  ;----------------------ATA equates---------------------------
   127                                  ata0_base       equ    1F0h
   128                                  ata0_ctrl       equ    3F6h
   129                                  ata1_base       equ    170h
   130                                  ata1_ctrl       equ    376h
   131                                  
   132                                  msd_class       equ    01h
   133                                  ide_subclass    equ    01h
   134                                  sata_subclass   equ    06h
   135                                  ;------------------------------------------------------------
   136                                  ;----------------------IDE equates---------------------------
   137                                  ideTableEntrySize     equ 10h
   138                                  ;----------------------FDD equates---------------------------
   139                                  fdd_base        equ    3F0h
   140                                  ;----------------------Int 33h Equates-----------------------
   141                                  fdiskTableEntrySize   equ 10h
   142                                  int33TblEntrySize     equ 10h
   143                                  ;------------------------------------------------------------
   144                                  ;------------------------------------------------------------
   145                                  ;------------------------Misc--------------------------------
   146                                  port61h         equ 61h         ;I/O port 61h
   147                                  EOI             equ 20h         ;End of interrupt signal
   148                                  waitp           equ 80h         ;debug port used to wait for io cycles
   149                                  bochsout        equ 0E9h        ;Emulator debug port
   150                                  BREAKPOINT      equ 0CCh        ;Use to manually encode breakpoints in program
   151                                  sizeOfMCPAlloc  equ 800h        ;2Kb allocated space
   152                                  ;------------------------------------------------------------
   153                                  ;----------------------------------------------------------------
   154                                  ;                 BIOS SYSTEM TABLE AREA                        :
   155                                  ;----------------------------------------------------------------
   156                                  Segment BIOSTables nobits start=BIOSStartAddr align=1
   157 00000000 <res 1000h>             BIOSIDTable     resq 2*256  ;256 paragraph entries reserved for IDT
   158 00001000 <res 6000h>             BIOSPageTbl     resq 0C00h  ;6000 bytes for page tables
   159 00007000 <res 18h>               BIOSGDTable     resq 3      ;3 entries in basic GDT
   160 00007018 ????????????????                        resq 1      ;Alignment qword
   161                                  ;----------------------------------------------------------------
   162                                  ;                    BIOS DATA AREA STARTS HERE                 :
   163                                  ;----------------------------------------------------------------
   164                                  Segment data nobits follows=BIOSTables align=1 
   165                                  ;Refer to MEMMAP.TXT for memory address reference!
   166                                  ;If Interrupt call is faulty, Carry will be set AND either:
   167                                  ;                    ah=80h => Invalid function.
   168                                  ;                    ah=86h => Not (yet) supported.
   169                                  ;------------------------------Data Area-------------------------
   170 00000000 ????                    IDTlength       resw 1 ;Maximum number of Interrupts is 256
   171                                  IDTpointer:
   172 00000002 ????                    .Limit          resw 1
   173 00000004 ????????????????        .Base           resq 1
   174                                  
   175 0000000C ????                    GDTlength       resw 1
   176                                  GDTpointer:
   177 0000000E ????                    .Limit          resw 1
   178 00000010 ????????????????        .Base           resq 1
   179                                  
   180 00000018 ????????????????        pageTablePtr:   resq 1
   181                                  ;----------------------------------------
   182                                  ;       Spurious Interrupt counter      :
   183                                  ;----------------------------------------
   184 00000020 ??                      spurint1        resb 1    ;Keep track of how many spur ints on pic1
   185 00000021 ??                      spurint2        resb 1    ;pic 2
   186                                  ;----------------------------------------
   187                                  ;            Keyboard Data Area         :
   188                                  ;----------------------------------------
   189 00000022 <res 20h>               kb_buffer       resw 10h
   190 00000042 ????????????????        kb_buf_head     resq 1    ;Pointer to Keyboard buffer head
   191 0000004A ????????????????        kb_buf_tail     resq 1    ;Pointer to Keyboard buffer tail 
   192 00000052 ????????????????        kb_buf_start    resq 1    ;Pointer for circular buffer start
   193 0000005A ????????????????        kb_buf_end      resq 1    ;Ditto..., for end
   194 00000062 ??                      kb_flags        resb 1    ;Keyboard state flags
   195 00000063 ??                      kb_flags_1      resb 1    ;Extended flags, empty for now
   196 00000064 ??                      kb_flags_2      resb 1    ;Bit 0 = E1 present, Bit 1 = E0 present
   197 00000065 ??                      break_flag      resb 1    ;Well, its not for the Print Screen key
   198                                  ;----------------------------------------
   199                                  ;            Serial Data Area           :
   200                                  ;----------------------------------------
   201 00000066 ??                      numCOM          resb 1  ;Number of Serial Ports
   202 00000067 ????????????????        com_addresses   resw 4     ;Space for 4 IO addresses
   203                                  
   204                                  comX_buffer:
   205 0000006F <res 10h>               com1_buffer     resb 10h 
   206 0000007F <res 10h>               com2_buffer     resb 10h
   207 0000008F <res 10h>               com3_buffer     resb 10h
   208 0000009F <res 10h>               com4_buffer     resb 10h
   209                                  
   210                                  comX_buf_head:
   211 000000AF ????????????????        com1_buf_head   resq 1
   212 000000B7 ????????????????        com2_buf_head   resq 1
   213 000000BF ????????????????        com3_buf_head   resq 1
   214 000000C7 ????????????????        com4_buf_head   resq 1
   215                                  
   216                                  comX_buf_tail:
   217 000000CF ????????????????        com1_buf_tail   resq 1
   218 000000D7 ????????????????        com2_buf_tail   resq 1
   219 000000DF ????????????????        com3_buf_tail   resq 1
   220 000000E7 ????????????????        com4_buf_tail   resq 1
   221                                  
   222                                  comX_buf_start:
   223 000000EF ????????????????        com1_buf_start  resq 1
   224 000000F7 ????????????????        com2_buf_start  resq 1
   225 000000FF ????????????????        com3_buf_start  resq 1
   226 00000107 ????????????????        com4_buf_start  resq 1
   227                                  
   228                                  comX_buf_end:
   229 0000010F ????????????????        com1_buf_end    resq 1
   230 00000117 ????????????????        com2_buf_end    resq 1
   231 0000011F ????????????????        com3_buf_end    resq 1
   232 00000127 ????????????????        com4_buf_end    resq 1
   233                                  
   234                                  ;----------------------------------------
   235                                  ;            Printer Data Area          :
   236                                  ;----------------------------------------
   237 0000012F ????????????            prt_addresses   resw 3    ;Space for 3 IO addresses
   238                                  ;----------------------------------------
   239                                  ;            Timer Data Area            :
   240                                  ;----------------------------------------
   241 00000135 ????                    pit_divisor     resw 1
   242 00000137 ????????                pit_ticks       resd 1    ;Similar to IBM PC, only with default divisor
   243                                  ;[31]=OF cnt, [30:21]=Res [20:16]=Hi cnt, [15,0]=Lo cnt
   244 0000013B ????????????????        rtc_ticks       resq 1
   245                                  ;----------------------------------------
   246                                  ;            Screen Data Area           :
   247                                  ;----------------------------------------
   248 00000143 <res 10h>               scr_curs_pos    resw 8    ;Cursor pos, hi byte = row / lo byte = column
   249 00000153 ??                      scr_cols        resb 1    ;80 Cols
   250 00000154 ??                      scr_rows        resb 1    ;25 Rows
   251 00000155 ????                    scr_curs_shape  resw 1    ;Packed start/end scan line
   252 00000157 ??                      scr_char_attr   resb 1    ;Grey text on black background
   253 00000158 ??                      scr_mode        resb 1    ;80x25, 16 colours default
   254 00000159 ??                      scr_active_page resb 1    ;Mode dependent
   255 0000015A ????                    scr_crtc_base   resw 1    ;03D4h for Graphics, 03B4h for MDA
   256 0000015C ????????                scr_page_addr   resd 1    ;CRTC Register 12 changes base address accessed
   257 00000160 ????????????????        scr_mode_params resq 1    ;Stub pointer location for future mode parameters
   258 00000168 <res 40h>               scr_vga_ptrs    resq 8  ;VGA pointers
   259                                  ;----------------------------------------
   260                                  ;       Mass storage Data Area          :
   261                                  ;----------------------------------------
   262 000001A8 ??                      i33Devices      resb 1  ;Number of devices Int 33h is aware of
   263 000001A9 ??                      msdStatus       resb 1  ;Status byte. Used by BIOS for all transfers with MSD.
   264 000001AA ??                      fdiskNum        resb 1  ;Number of fixed disks
   265 000001AB ??                      ir14_mutex      resb 1
   266 000001AC ??                      ir14_status     resb 1
   267 000001AD ??                      ir15_mutex      resb 1
   268 000001AE ??                      ir15_status     resb 1
   269 000001AF ????????????????        diskDptPtr      resq 1
   270 000001B7 ????????????????        fdiskDptPtr     resq 1
   271                                  ;----------------------------------------
   272                                  ;            SysInit Data Area          :
   273                                  ;----------------------------------------
   274 000001BF ????????????????        nextFilePtr     resq 1  ;Pointer to next file to load
   275 000001C7 ????                    numSectors      resw 1  ;Number of sectors to copy 
   276                                  ;----------------------------------------
   277                                  ;            Memory Data Area           :
   278                                  ;----------------------------------------
   279 000001C9 ????                    MachineWord     resw 1    ;Really Legacy Hardware Bitfield
   280 000001CB ????                    convRAM         resw 1  ;Conventional memory word
   281 000001CD ????????????????        userBase        resq 1    ;Start address of the user space
   282 000001D5 ??                      bigmapSize      resb 1    ;First byte, in units of 24 bytes
   283 000001D6 ????????????????        srData          resw 4  ;4 words for memory64MB word 0 is ax word 1 is bx etc.
   284 000001DE ????                    srData1         resw 1  ;Reserve 1 word for memory16MB
   285 000001E0 ????????????????        sysMem          resq 1  ;Size of usable system RAM (without SCP/BIOS)
   286 000001E8 ????????                scpSize         resd 1  ;Size of SCP/BIOS allocation
   287                                  ;----------------------------------------
   288                                  ;            MCP Data Area              :
   289                                  ;----------------------------------------
   290 000001EC ????????????????        mcpUserBase     resq 1  ;Pointer to register save space
   291 000001F4 ????????????????        mcpUserRip      resq 1  ;Save the custom user RIP for new jumps
   292 000001FC ????????????????        mcpUserkeybf    resq 1  ;Pointer to the keyboard buffer
   293 00000204 ????????????????        mcpUserRaxStore resq 1  ;Temp rax save space
   294 0000020C ????????????????        mcpStackPtr     resq 1  ;Address of base of user Stack Pointer
   295                                  ;----------------------------------------
   296                                  ;            USB Data Area              :
   297                                  ;----------------------------------------
   298 00000214 ??                      eControllers    resb 1    ;Number of EHCI controllers
   299 00000215 <res 20h>               eControllerList resq 4    ;Entry = PCI space addr|MMIO addrs
   300 00000235 ??                      usbDevices      resb 1    ;Max value, 10 for now!
   301 00000236 ????????????????        eHCErrorHandler resq 1  ;Address of default error handler
   302                                  ;----------------------------------------
   303                                  ;            EHCI Async Area            :
   304                                  ;----------------------------------------
   305 0000023E ????????????????        eCurrAsyncHead  resq 1      ;Point to the current head of the async list
   306 00000246 ??                      eNewBus         resb 1      ;Default to 0, if 1, a new bus was selected
   307 00000247 ??                      eActiveCtrlr    resb 1        ;Current working controller (default -1)
   308 00000248 ??                      eActiveInt      resb 1        ;Gives a copy of the usbsts intr bits
   309 00000249 ??                      eAsyncMutex     resb 1    
   310                                      ;Mutex, x1b=data NOT ready, wait. x0b=ready, data ready to access.
   311                                      ;        1xb=Internal buffer. 0xb=user provided buffer.
   312                                      ;        bits [7:2], number of interrupts to ignore (if any)
   313                                      ;            a value of 0 means dont ignore
   314                                  ;----------------------------------------
   315                                  ;            MSD Data Area              :
   316                                  ;----------------------------------------
   317 0000024A ??                      cbwTag          resb 1        ;cbw transaction unique id (inc post use)
   318 0000024B ??                      numMSD          resb 1        ;Number of MSD devices
   319                                  ;----------------------------------------
   320                                  ;           USB Tables                  :
   321                                  ;----------------------------------------
   322 0000024C <res 1Eh>               usbDevTbl       resb 10*usbDevTblEntrySize
   323                                  usbDevTblEnd    equ $
   324                                  usbDevTblE      equ ($ - usbDevTbl)/usbDevTblEntrySize ;Number of Entries
   325                                  ;Byte 0 = Dev Addr, Byte 1 = Root hub, Byte 2 = Class Code (USB standard)
   326                                  ; i.e. 08h=MSD, 09h=Hub
   327 0000026A <res 50h>               hubDevTbl       resb 10*hubDevTblEntrySize
   328                                  hubDevTblEnd    equ $
   329                                  hubDevTblE      equ ($ - hubDevTbl)/hubDevTblEntrySize
   330                                  ;bAddress - The assigned device address
   331                                  ;bBus - Host Bus [Root hub]
   332                                  ;bHostHub - Address of Hub we are attached to or 0 for Root
   333                                  ;bHubPort - Port number we are inserted in
   334                                  ;bMaxPacketSize0 - Max packet size to endpoint 0
   335                                  ;bNumPorts - Number of downstream ports on hub
   336                                  ;bPowerOn2PowerGood - Time in units of 2ms for device on port to turn on
   337                                  ;bRes- Endpoint address, for when we add interrupt eps
   338                                  ;   If bNumPorts=0 => Hub needs to undergo Hub Config
   339 000002BA <res A0h>               msdDevTbl       resb 10*msdDevTblEntrySize
   340                                  msdDevTblEnd    equ $
   341                                  msdDevTblE      equ    ($ - msdDevTbl)/msdDevTblEntrySize
   342                                  ;bAddress - The assigned device address [+ 0]
   343                                  ;bBus - Host Bus [Root hub] [+ 1]
   344                                  ;bHostHub - Address of Hub we are attached to or 0 for Root [+ 2]
   345                                  ;bHubPort - Port number we are inserted in  [+ 3]
   346                                  ;bInerfaceNumber - Interface number being used  [+ 4]
   347                                  ;bInterfaceSubclass - 00h (defacto SCSI), 06h (SCSI), 04h (UFI)     [+ 5]
   348                                  ;bInterfaceProtocol - 50h (BBB), 00h (CBI), 01h (CBI w/o interrupt) [+ 6]
   349                                  ;bMaxPacketSize0 - Max packet size to endpoint 0                    [+ 7]
   350                                  ;bEndpointInAddress - 4 bit address of IN EP                        [+ 8]
   351                                  ;wMaxPacketSizeIn - Max packet size to chosen In endpoint           [+ 9]
   352                                  ;bEndpointOutAddress - 4 bit address of OUT EP                      [+ 11]
   353                                  ;wMaxPacketSizeOut - Max packet size to OUT endpoint                [+ 12]
   354                                  ;bInEPdt - In Endpoints' dt bit                                     [+ 14]
   355                                  ;bOutEPdt - Out Endpoints' dt bit                                   [+ 15]
   356                                  ;These past two bytes are temporarily kept separate! Will bitstuff later
   357                                  ;----------------------------------------
   358                                  ;           IDE Tables                  :
   359                                  ;----------------------------------------
   360                                  ;Support up to two IDE controllers
   361 0000035A ??                      ideNumberOfControllers: resb 1
   362 0000035B <res 20h>               ideControllerTable:     resb  2*ideTableEntrySize ;Max 2 controllers
   363                                  ;dPCIAddress   - PCI IO address of controller   [+0]
   364                                  ;dPCIBAR4 - PCI BAR4, the Bus Mastery address [+4]
   365                                  ; Note that this address is given with the bottom nybble indicating
   366                                  ; if the address is IO or MMIO. Bit set => IO
   367                                  ;----------------------------------------
   368                                  ;           ATA Tables                  :
   369                                  ;----------------------------------------
   370 0000037B <res 40h>               fdiskTable:     resb 4*fdiskTableEntrySize  ;Max 4 fixed disks
   371                                  ; - BIOS address of device
   372                                  ;----------------------------------------
   373                                  ;            Int33h Table Area          :
   374                                  ;----------------------------------------
   375 000003BB <res A0h>               diskDevices:    resb 10*int33TblEntrySize
   376                                  diskDevicesE    equ ($ - diskDevices)/int33TblEntrySize
   377                                  ;bDevType - 0 = Unasigned, 1 = MSD EHCI, 2 = MSD xHCI, 3 = Floppy Physical,
   378                                  ;           4 = ATA device, 5 = ATAPI device   [+ 0]
   379                                  ;wDeviceAddress - USB Address/Bus pair OR local device table address  [+ 1]
   380                                  ;dBlockSize - Dword size of LBA block (should be 512 for remdev) [+ 3]
   381                                  ;qLastLBANum - Last LBA address (OS MAY minus 1 to avoid crashing device) [+ 7]
   382                                  ;bEPSize - 1 = 64 byte, 2 = 512 byte (EP size for sector transfer)  [+ 15]
   383                                  ;NOTE: LBA SECTOR 0 IS CHS SECTOR 0,0,1 !!
   384                                  ;----------------------------------------------------------------
   385                                  ;----------------------------------------------------------------
   386                                  ;                   MCP Transaction area                        :
   387                                  ;----------------------------------------------------------------
   388                                  Segment MCPseg nobits follows=codeResident align=1
   389 00000000 <res 800h>                              resb sizeOfMCPAlloc   ;2KB space
   390                                  MCPsegEnd:  ;Pointer to the end of the segment
   391                                  ;----------------------------------------------------------------
   392                                  ;                  BIOS Transaction area                        :
   393                                  ;                                                               :
   394                                  ;                   Must be the last segment                    :
   395                                  ;----------------------------------------------------------------
   396                                  Segment xdata nobits follows=MCPseg align=40h    ;eXtra data seg
   397                                  ;This segment comes after the resident code and is the transaction
   398                                  ;area. The ehci async schedule (and eventually periodic) live here.
   399                                  ;They are BOTH always postfixed by the big memory map.
   400                                  ehciAschedule:                  ;Static label for head of the asyncschedule
   401 00000000 <res 60h>               ehciQHead0      resb ehciSizeOfQH ;96 bytes, for address 0 device only
   402 00000060 <res 20h>                   alignb 40h
   403 00000080 <res 60h>               ehciQHead1      resb ehciSizeOfQH ;Used for cmds with an addressed usb device
   404 000000E0 <res 20h>                   alignb 40h
   405 00000100 <res 280h>              ehciTDSpace     resb 10*ehciSizeOfTD   ;640 bytes of transfer space
   406                                      alignb 40h
   407 00000380 <res 20h>               ehciDataOut     resb 20h               ;32 bytes
   408 000003A0 <res 20h>                   alignb 40h
   409                                  sectorbuffer:                       ;Same buffer for multiple purposes
   410 000003C0 <res 200h>              ehciDataIn      resb 200h           ;512 bytes, to get as much data as needed
   411                                      alignb 40h
   412 000005C0 <res 10h>               msdCSW          resb 10h                
   413                                  ;13 bytes, special, to be saved after each transfer
   414 000005D0 <res 10h>                   alignb 20h      
   415 000005E0 <res 10h>               prdt:           resq 2      ;2 entries in the prdt
   416                                  bigmapptr:                        ;Pointer to big mem map
   417                                  ;----------------------------------------------------------------
   418                                  ;                      SysInit Table                            :
   419                                  ;----------------------------------------------------------------
   420                                  Segment SysInitParams   nobits start=600h
   421                                  ;Use the bootsector reload space (600h-800h) as a temporary stack
   422                                  ; and a storage space for the SysInit table
   423                                  SysInitTable:
   424 00000000 ????                    .numSecW        resw 1
   425 00000002 ????????????????        .FileLBA        resq 1
   426 0000000A ????                    loMachineWord   resw 1
   427                                  ;----------------------------------------------------------------
   428                                  ;                      Real Mode Stack                          :
   429                                  ;----------------------------------------------------------------
   430                                  Segment lowStack    nobits  start=700h
   431 00000000 <res 100h>                              resb 100h
   432                                  lowStackPtr:
   433                                  ;----------------------------------------------------------------
   434                                  ORG 800h
   435                                  ;----------------------------------------------------------------
   436                                  ;                    INIT CODE STARTS HERE                      :
   437                                  ;----------------------------------------------------------------
   438                                  Segment codeInit start=BIOSInitAddr align=1
   439                                  BITS 16
   440                                  ;First set stack and save the SysInit Ptr, then set A20, check CPUID and 
   441                                  ; exended features. Then tell BIOS that we are going long and perhaps 
   442                                  ; protected then get the Int 11h word, store at 0:800h
   443                                  realInit:
   444                                  ;The Caller Far Jumps to set cs to 0
   445 00000000 FA                          cli     ;Stop interrupts as we dont know where the stack is
   446 00000001 31C0                        xor ax, ax
   447 00000003 8ED8                        mov ds, ax
   448 00000005 8ED0                        mov ss, ax
   449 00000007 BC[0001]                    mov sp, lowStackPtr ;Set up stack pointer
   450 0000000A FB                          sti
   451 0000000B 26803F0C                    cmp byte [es:bx], 0Ch   ;Check length
   452 0000000F 0F85ED00                    jne .fail   ;If thats not it, error 0
   453 00000013 268B4701                    mov ax, word [es:bx + 1]    ;Get number of sectors into ax 
   454 00000017 B92A00                      mov cx, 42  ;42 sectors maximum
   455 0000001A 39C8                        cmp ax, cx
   456 0000001C 0F43C1                      cmovnb ax, cx
   457 0000001F A3[0000]                    mov word [SysInitTable.numSecW], ax
   458 00000022 26668B4704                  mov eax, dword [es:bx + 4]      ;Get low dword
   459 00000027 66A3[0200]                  mov dword [SysInitTable.FileLBA], eax
   460 0000002B 26668B4708                  mov eax, dword [es:bx + 8]      ;Get high dword
   461 00000030 66A3[0600]                  mov dword [SysInitTable.FileLBA + 4], eax
   462 00000034 06                          push es
   463                                  .a20Proc:
   464 00000035 50                          push ax
   465 00000036 51                          push cx ;preserve ax and cx
   466 00000037 31C9                        xor cx, cx ;clear to use as a timeout counter
   467                                      
   468                                  .a20FastEnable:
   469 00000039 E492                        in al, 92h
   470 0000003B A802                        test al, 2
   471 0000003D 750B                        jnz .no92
   472 0000003F 0C02                        or al, 2
   473 00000041 24FE                        and al, 0FEh
   474 00000043 E692                        out 92h, al
   475                                      
   476 00000045 FEC1                        inc cl    ;increments the time out counter
   477 00000047 E94900                      jmp .a20Check
   478                                      
   479                                  .no92:
   480 0000004A B104                        mov cl, 4
   481 0000004C E96A00                      jmp .a20Fail
   482                                      
   483                                  .a20KeybEnable: ;communicating with the keyboard controller
   484 0000004F FA                          cli
   485                                   
   486 00000050 E83200                      call .a20wait
   487 00000053 B0AD                        mov al,0ADh
   488 00000055 E664                        out 64h,al ;disable the keyboard
   489 00000057 E82B00                      call .a20wait
   490 0000005A B0D0                        mov al,0D0h
   491 0000005C E664                        out 64h,al ;read from the keyboard input
   492 0000005E E82B00                      call .a20wait2
   493 00000061 E460                        in al,60h
   494 00000063 6650                        push eax    ;get the keyboard data and push it to the stack
   495 00000065 E81D00                      call .a20wait
   496 00000068 B0D1                        mov al,0D1h
   497 0000006A E664                        out 64h,al    ;output the command to prep to go a20 
   498 0000006C E81600                      call .a20wait
   499 0000006F 6658                        pop eax    ;need this be eax and not just ax?
   500 00000071 0C02                        or  al,2
   501 00000073 E660                        out 60h,al    ;output to go a20
   502 00000075 E80D00                      call .a20wait
   503 00000078 B0AE                        mov al,0AEh
   504 0000007A E664                        out 64h,al    ;reenable keyboard
   505 0000007C E80600                      call .a20wait    ;done!
   506 0000007F FB                          sti
   507                                  
   508 00000080 FEC1                        inc cl    ;increments the time out counter
   509 00000082 E90E00                      jmp .a20Check
   510                                      
   511                                  .a20wait:
   512 00000085 E464                        in al,64h
   513 00000087 A802                        test al,2
   514 00000089 75FA                        jnz .a20wait
   515 0000008B C3                          ret
   516                                   
   517                                  .a20wait2: 
   518 0000008C E464                        in al,64h
   519 0000008E A801                        test al,1
   520 00000090 74FA                        jz .a20wait2
   521 00000092 C3                          ret
   522                                  
   523                                  .a20Check:
   524 00000093 B8FFFF                      mov ax, 0FFFFh
   525 00000096 50                          push ax
   526 00000097 07                          pop es ;es to FFFF
   527 00000098 BF1000                      mov di, 0010h ;FFFF:0010 == 0000:0000
   528 0000009B 31F6                        xor si, si    ;remember ds = 0000
   529 0000009D 268A05                      mov al, byte [es:di]
   530 000000A0 3E3804                      cmp byte [ds:si], al
   531 000000A3 7414                        je .a20Fail
   532 000000A5 FEC0                        inc al    ;make change to al
   533 000000A7 3E8804                      mov byte [ds:si], al ;al is now incremented and saved at address 0000:0000
   534 000000AA 263805                      cmp byte [es:di], al ;check against overflown version
   535 000000AD 740A                        je .a20Fail
   536                                      
   537                                  .a20Pass:
   538 000000AF FEC8                        dec al    ;return al to its original value
   539 000000B1 3E8804                      mov byte [ds:si], al ;return to original position
   540                                      
   541 000000B4 59                          pop cx
   542 000000B5 58                          pop ax
   543 000000B6 07                          pop es
   544 000000B7 EB11                        jmp short .a20Exit
   545                                      
   546                                  .a20Fail:
   547 000000B9 80F903                      cmp cl, 3
   548 000000BC 0F8E79FF                    jle .a20FastEnable
   549 000000C0 80F906                      cmp cl, 6
   550 000000C3 7E8A                        jle .a20KeybEnable
   551                                      
   552 000000C5 59                          pop cx
   553 000000C6 58                          pop ax
   554 000000C7 07                          pop es
   555 000000C8 EB2E                        jmp short .noa20
   556                                  
   557                                  .a20Exit:
   558 000000CA 669C                        pushfd
   559 000000CC 6658                        pop eax
   560 000000CE 6689C1                      mov ecx, eax ;save original flag state for later
   561 000000D1 663500002000                xor eax, 00200000h ;21st bit - CPUID bit, switch it!!
   562 000000D7 6650                        push eax
   563 000000D9 669D                        popfd
   564                                      
   565 000000DB 669C                        pushfd
   566 000000DD 6658                        pop eax
   567 000000DF 6685C8                      test eax, ecx ; compare the registers. If they are the same
   568 000000E2 7416                        je .noCPUID
   569 000000E4 6651                        push ecx
   570 000000E6 669D                        popfd
   571                                  
   572                                  .extCheck:
   573 000000E8 66B800000080                mov eax, 80000000h
   574 000000EE 0FA2                        cpuid
   575 000000F0 663D01000080                cmp eax, 80000001h ;If this is true, CPU supports extended functionality
   576 000000F6 733C                        jae tellBIOS
   577                                  .noa20:
   578 000000F8 B401                        mov ah, 1    ;noa20 error code
   579                                  .noCPUID:
   580 000000FA B402                        mov ah, 2    ;noCPUID error code
   581 000000FC EB02                        jmp short .fail
   582 000000FE B403                        mov ah, 3    ;no Extended functionality error code
   583                                  .fail:
   584 00000100 88E2                        mov dl, ah    ;store ax to get error code printed
   585 00000102 BE[2801]                    mov si, .msg
   586 00000105 E81100                      call .write
   587 00000108 88D0                        mov al, dl
   588 0000010A BB0700                      mov bx, 0007h    ;Attribs
   589 0000010D B40E                        mov ah, 0Eh        ;TTY print char
   590 0000010F 0430                        add al, 30h        ;add '0' to digit
   591 00000111 CD10                        int 10h
   592 00000113 31C0                        xor ax, ax
   593 00000115 CD16                        int 16h    ;await keystroke
   594 00000117 CD18                        int 18h
   595                                  ;Error codes: 
   596                                  ;   00h - Bad SysInit Data
   597                                  ;   01h - No A20 Line
   598                                  ;   02h - No CPUID 
   599                                  ;   03h - No Extended Functionality
   600                                  .write: ;destroys registers ax and bx
   601 00000119 AC                          lodsb
   602 0000011A 3C00                        cmp al, 0 ;check for zero
   603 0000011C 7409                        je .return
   604 0000011E B40E                        mov ah, 0Eh    ;TTY output
   605 00000120 BB0700                      mov bx, 0007h ;colour
   606 00000123 CD10                        int 10h
   607 00000125 EBF2                        jmp short .write
   608                                  .return:
   609 00000127 C3                          ret
   610 00000128 426F6F74206572726F-     .msg: db 'Boot error:',0
   610 00000131 723A00             
   611                                  tellBIOS:
   612 00000134 66B800EC0000                mov eax, 0EC00h ;Tell BIOS we are going long
   613 0000013A B303                        mov bl, 03h     ;Both Long and Protected modes
   614 0000013C CD15                        int 15h         ;Ignore response
   615 0000013E CD11                        int 11h
   616 00000140 A3[0A00]                    mov word [loMachineWord], ax
   617                                  ;Getting Memory Map
   618                                  rmE820Map:
   619 00000143 06                          push es
   620 00000144 1E                          push ds
   621 00000145 B80010                      mov ax, e820Seg
   622 00000148 8ED8                        mov ds, ax
   623 0000014A 8EC0                        mov es, ax
   624 0000014C BF0200                      mov di,    e820BaseOff
   625 0000014F 6631DB                      xor ebx, ebx
   626 00000152 31ED                        xor bp,bp
   627 00000154 66BA50414D53                mov edx, 0534D4150h    ;Magic dword
   628 0000015A 66B820E80000                mov eax, 0E820h
   629 00000160 2666C7451401000000          mov dword [es:di + 20], 1
   630 00000169 66B918000000                mov ecx, 24            ;Get 24 bytes
   631 0000016F CD15                        int 15h
   632 00000171 7257                        jc .mapfail            ;Carry set => Fail
   633 00000173 66BA50414D53                mov edx, 0534D4150h    ;Magic dword
   634 00000179 6639D0                      cmp eax, edx        ;Must be equal on success
   635 0000017C 754C                        jne .mapfail
   636 0000017E 6685DB                      test ebx, ebx         ;One table entry, bad
   637 00000181 7447                        jz .mapfail
   638 00000183 EB1F                        jmp short .map1
   639                                  .map0:
   640 00000185 66B820E80000                mov eax, 0E820h
   641 0000018B 2666C7451401000000          mov dword  [es:di + 20], 1
   642 00000194 66B918000000                mov ecx, 24
   643 0000019A CD15                        int 15h
   644 0000019C 722C                        jc .mapexit
   645 0000019E 66BA50414D53                mov edx, 0534D4150h
   646                                  .map1:
   647 000001A4 E31D                        jcxz .map3
   648 000001A6 80F914                      cmp cl, 20
   649 000001A9 7607                        jbe .map2
   650 000001AB 26F6451401                  test byte [es:di + 20], 1
   651 000001B0 7411                        je .map3
   652                                  .map2:
   653 000001B2 26668B4D08                  mov ecx, dword [es:di + 8]
   654 000001B7 26660B4D0C                  or ecx, [es:di + 12]
   655 000001BC 7405                        jz .map3
   656 000001BE 45                          inc bp
   657 000001BF 81C71800                    add di, 24
   658                                  .map3:
   659 000001C3 6685DB                      test ebx, ebx
   660 000001C6 75BD                        jne .map0
   661 000001C8 EB00                        jmp short .mapexit
   662                                  .mapfail:
   663                                  .mapexit:
   664 000001CA 26892E0000                  mov word [es:e820SizeOff], bp  ;Num entries in var space (3 qwords/entry)
   665                                  ;Second memory test
   666 000001CF 31C9                        xor cx, cx
   667 000001D1 31D2                        xor dx, dx
   668 000001D3 B801E8                      mov ax, 0E801h
   669 000001D6 CD15                        int 15h
   670 000001D8 7216                        jc .badmem2
   671 000001DA 80FC86                      cmp ah, 86h    ;unsupported command
   672 000001DD 7411                        je .badmem2
   673 000001DF 3D8000                      cmp ax, 80h    ;invalid command
   674 000001E2 740C                        je .badmem2
   675                                  .mem2write:
   676 000001E4 AB                          stosw
   677 000001E5 89D8                        mov ax, bx
   678 000001E7 AB                          stosw
   679 000001E8 89C8                        mov ax, cx
   680 000001EA AB                          stosw
   681 000001EB 89D0                        mov ax, dx
   682 000001ED AB                          stosw
   683 000001EE EB0B                        jmp short .mem3test
   684                                  .badmem2:
   685 000001F0 31C0                        xor ax, ax
   686 000001F2 31DB                        xor bx, bx
   687 000001F4 31C9                        xor cx, cx
   688 000001F6 31D2                        xor dx, dx
   689 000001F8 E9E9FF                      jmp .mem2write
   690                                  .mem3test:
   691 000001FB F8                          clc
   692 000001FC B488                        mov ah, 88h
   693 000001FE CD15                        int 15h
   694 00000200 31DB                        xor bx, bx 
   695 00000202 0F42C3                      cmovc ax, bx    ;if error, store zero
   696 00000205 3D8600                      cmp ax, 86h
   697 00000208 0F44C3                      cmovz ax, bx
   698 0000020B 3D8000                      cmp ax, 80h
   699 0000020E 0F44C3                      cmovz ax, bx
   700 00000211 AB                          stosw
   701                                  .finalmemtest:
   702 00000212 F8                          clc
   703 00000213 CD12                        int 12h
   704 00000215 0F42C3                      cmovc ax, bx    ;If carry on, store a zero
   705 00000218 AB                          stosw    ;Store the word
   706                                  rmGetFontPointers:
   707                                  ;Get ROM Font Pointers, immediately after Memory map
   708                                  ;Each entry is 8 bytes long: es=Seg, bp=Off, cx=bytes/char, dx=# of rows - 1
   709 00000219 31DB                        xor bx, bx         ;Clear bh
   710                                  .gfp1:    
   711                                  ;Over protective routine in the event that the BIOS routine clobbers registers
   712 0000021B BE0010                      mov si, 1000h    ;Save segment loader
   713 0000021E 31C9                        xor cx, cx
   714 00000220 31D2                        xor dx, dx
   715 00000222 31ED                        xor bp, bp
   716 00000224 53                          push bx            ;Save bx
   717                                  
   718 00000225 B83011                      mov ax, 1130h    ;Get font pointer function
   719 00000228 CD10                        int 10h
   720                                  
   721 0000022A 8CC0                        mov ax, es        ;Get segment into ax to store
   722 0000022C 8EC6                        mov es, si        ;Reload segment for stos to work
   723 0000022E AB                          stosw
   724 0000022F 89E8                        mov ax, bp        ;Get offset
   725 00000231 AB                          stosw
   726 00000232 89C8                        mov ax, cx        ;bytes/char
   727 00000234 AB                          stosw
   728 00000235 88D0                        mov al, dl        ;dl contains # of rows, but zero extended for alignment
   729 00000237 30E4                        xor ah, ah
   730 00000239 AB                          stosw
   731 0000023A 5B                          pop bx            ;Get the count back
   732 0000023B FEC7                        inc bh
   733 0000023D 80FF07                      cmp bh, 7
   734 00000240 76D9                        jbe .gfp1        ;Once above 7, fall through
   735                                  
   736 00000242 1F                          pop ds
   737 00000243 07                          pop es    ;Bring back original es value
   738                                  rmSetTables:
   739                                  ;Memory tables live in 0:8000h - 0:E000h range
   740 00000244 66BF00800000                mov edi, 8000h
   741 0000024A 0F22DF                      mov cr3, edi    ;Cannot lsh cr3
   742 0000024D B90030                      mov cx, 3000h    ;6000h bytes (6x4Kb) of zero to clear table area
   743 00000250 57                          push di
   744 00000251 31C0                        xor ax, ax
   745 00000253 F3AB                        rep stosw        ;Store 3000h words of zero
   746                                  
   747 00000255 5F                          pop di            ;Return zero to the head of the table, at 08000h
   748 00000256 B80390                      mov ax, 9000h|permissionflags    ;9000h is the low word of the address.
   749 00000259 AB                          stosw    ;store the low word of the address
   750 0000025A 81C7FE0F                    add di, 0FFEh
   751 0000025E B90400                      mov cx, 4
   752                                  rmUtables:            ;di should point to 8000h
   753 00000261 050010                      add ax, 1000h
   754 00000264 AB                          stosw    ;ax is now A003h,B003h,C003h,D003h
   755 00000265 81C70600                    add di, 6    ;qword alignment
   756 00000269 49                          dec cx
   757 0000026A 75F5                        jnz rmUtables
   758                                  
   759 0000026C B90008                      mov cx, 800h    ;4x512 consecutive entries
   760 0000026F 31C0                        xor ax, ax
   761 00000271 50                          push ax            ;push for algorithm to work
   762 00000272 BF00A0                      mov di, 0A000h
   763                                  rmPDTentries:
   764 00000275 B88300                      mov ax, 83h        ;bit 7|permission flags
   765 00000278 AB                          stosw            ;di incremented twice
   766 00000279 58                          pop ax            ;get current address
   767 0000027A AB                          stosw            ;di incremented twice. store the address
   768 0000027B 052000                      add ax, 20h        ;add the offset to the next page
   769 0000027E 50                          push ax            ;push current address into memory
   770 0000027F 81C70400                    add di, 4        ;qword Align
   771 00000283 49                          dec cx
   772 00000284 75EF                        jnz rmPDTentries
   773                                  
   774 00000286 0F20E0                      mov eax, cr4                 
   775 00000289 660DA0000000                or eax, 0A0h ;Set PAE and PGE, for glbl page and physical page extensions
   776 0000028F 0F22E0                      mov cr4, eax 
   777                                      
   778 00000292 66B9800000C0                mov ecx, 0C0000080h    ;Read EFER MSD into EDX:EAX
   779 00000298 0F32                        rdmsr    ; Read information from the msr.
   780 0000029A 660D00010000                or eax, 00000100h ; Set the Long mode bit!
   781 000002A0 0F30                        wrmsr  ; Write the data back
   782                                      
   783 000002A2 FA                          cli
   784 000002A3 B0FF                        mov al, 0FFh             ; Out 0xFF to 0xA1 and 0x21 to disable all IRQs.
   785 000002A5 E6A1                        out 0A1h, al
   786 000002A7 E621                        out 21h, al
   787                                  
   788 000002A9 0F0116[DA02]                lgdt [GDT.Pointer] ;Load the Global Descriptor Table pointer
   789                                  
   790 000002AE 0F20C0                      mov eax, cr0
   791 000002B1 660D01000080                or eax, 80000001h ;Set the Paging and Protected Mode bits (Bits 31 and 0)
   792 000002B7 0F22C0                      mov cr0, eax  ;write it back!
   793 000002BA EA[E402]0800                jmp GDT.Code:longmode_ep
   794                                  
   795                                  GDT:                    ;Global Descriptor Table (64-bit).
   796                                  .Null: equ $ - GDT      ;The null descriptor.
   797 000002BF 0000000000000000            dq 0
   798                                  .Code: equ $ - GDT      ;The 32-bit code descriptor. Limit = FFFFFh, Base=0
   799 000002C7 FFFF                        dw 0FFFFh           ;Limit 0:15
   800 000002C9 0000                        dw 00000h           ;Base 0:15
   801 000002CB 00                          db 00h              ;Base 16:23
   802 000002CC 9A                          db 09Ah             ;Access Byte
   803 000002CD 3F                          db 03Fh             ;Limit 16:19
   804 000002CE 00                          db 00b              ;Base 24:31
   805                                  
   806                                  .Data: equ $ - GDT      ;The 32-bit data descriptor. 
   807 000002CF FFFF                        dw 0FFFFh           ;Limit 0:15
   808 000002D1 0000                        dw 00000h           ;Base 0:15
   809 000002D3 00                          db 0h               ;Base 16:23
   810 000002D4 92                          db 092h             ;Access Byte
   811 000002D5 1F                          db 01Fh             ;Limit 16:19 then Flags
   812 000002D6 00                          db 00h              ;Base 24:31
   813 000002D7 90                      ALIGN 4
   814 000002D8 0000                        dw 0
   815 000002DA 1A00                    .Pointer    dw $ - GDT - 1      ; GDT pointer.
   816 000002DC [BF02000000000000]      .Base       dq GDT                 ; GDT offset.
   817                                  ;----------------------------------------------------------------
   818                                  BITS 64
   819                                  ;----------------------------------------------------------------
   820                                  ;                    Long Mode Initialisation                   :
   821                                  ;----------------------------------------------------------------
   822                                  ; Sets up Segment registers, copies the resident portion of SCPBIOS
   823                                  ; high, initialises the BDA, copies data from real mode BIOS to 
   824                                  ; SCPBIOS internal area, Identity maps the first 4 Gb, creates 
   825                                  ; an IVT and moves the GDT to its final resting place,
   826                                  ; and directs cr3, gdtr and idtr to the BDA vars and reinits the video
   827                                  ; to VGA Mode 3. Finish by printing boot message and memory sizes.
   828                                  ;----------------------------------------------------------------
   829                                  longmode_ep:
   830 000002E4 66B81000                    mov ax, 10h
   831 000002E8 668ED8                      mov ds, ax
   832 000002EB 668EC0                      mov es, ax
   833 000002EE 668EE0                      mov fs, ax
   834 000002F1 668EE8                      mov gs, ax
   835 000002F4 668ED0                      mov ss, ax
   836                                  ;-----------------Write BDA constants-----------------
   837 000002F7 48BF-                       mov rdi, section.data.start
   837 000002F9 [0000000000000000] 
   838 00000301 66B80001                    mov ax, 100h
   839 00000305 66AB                        stosw            ;IDT Length
   840 00000307 66B8FF0F                    mov ax, (100h*10h) - 1    ;IDT Limit
   841 0000030B 66AB                        stosw
   842 0000030D 48B8-                       mov rax, BIOSIDTable    ;IDT Base
   842 0000030F [0000000000000000] 
   843 00000317 48AB                        stosq
   844 00000319 66B80300                    mov ax, 3h
   845 0000031D 66AB                        stosw
   846 0000031F 66B81700                    mov ax, (3h*8h)-1
   847 00000323 66AB                        stosw
   848 00000325 48B8-                       mov rax, BIOSGDTable
   848 00000327 [0070000000000000] 
   849 0000032F 48AB                        stosq
   850 00000331 48B8-                       mov rax, BIOSPageTbl
   850 00000333 [0010000000000000] 
   851 0000033B 48AB                        stosq
   852 0000033D 31C0                        xor eax, eax    ;Clears upper dword too
   853                                  ;Clear spur int counters
   854 0000033F 66AB                        stosw
   855                                  ;Keyboard area
   856 00000341 B904000000                  mov ecx, 4h
   857 00000346 F348AB                      rep stosq    ;Clear kb buffer for 16 words
   858 00000349 48B8-                       mov rax, kb_buffer
   858 0000034B [2200000000000000] 
   859 00000353 66B90300                    mov cx, 3h    ;Circular pointers
   860 00000357 F348AB                      rep stosq
   861 0000035A 480520000000                add rax, 20h    ;End of buffer pointer
   862 00000360 48AB                        stosq
   863 00000362 31C0                        xor eax, eax
   864 00000364 AB                          stosd    ;Store keyboard flags bytes
   865                                  ;Serial Area
   866 00000365 AA                          stosb   ;Clear number of COM devices byte
   867 00000366 48AB                        stosq    ;Clear com_addresses (4 words)
   868 00000368 66B90800                    mov cx, 8
   869 0000036C F348AB                      rep stosq    ;Store 8 qwords for COM buffers
   870                                  ;Buffer heads
   871 0000036F 48B8-                       mov rax, com1_buffer
   871 00000371 [6F00000000000000] 
   872 00000379 48AB                        stosq
   873 0000037B 480510000000                add rax, 10h    ;Com2
   874 00000381 48AB                        stosq
   875 00000383 480510000000                add rax, 10h    ;Com3
   876 00000389 48AB                        stosq
   877 0000038B 480510000000                add rax, 10h    ;Com4
   878 00000391 48AB                        stosq
   879                                  ;Buffer Tails
   880 00000393 482D30000000                sub rax, 30h
   881 00000399 48AB                        stosq
   882 0000039B 480510000000                add rax, 10h    ;Com2
   883 000003A1 48AB                        stosq
   884 000003A3 480510000000                add rax, 10h    ;Com3
   885 000003A9 48AB                        stosq
   886 000003AB 480510000000                add rax, 10h    ;Com4
   887 000003B1 48AB                        stosq
   888                                  ;Buffer start
   889 000003B3 482D30000000                sub rax, 30h
   890 000003B9 48AB                        stosq
   891 000003BB 480510000000                add rax, 10h    ;Com2
   892 000003C1 48AB                        stosq
   893 000003C3 480510000000                add rax, 10h    ;Com3
   894 000003C9 48AB                        stosq
   895 000003CB 480510000000                add rax, 10h    ;Com4
   896 000003D1 48AB                        stosq
   897                                  ;Buffer end
   898 000003D3 482D20000000                sub rax, 20h
   899 000003D9 48AB                        stosq
   900 000003DB 480510000000                add rax, 10h    ;Com2
   901 000003E1 48AB                        stosq
   902 000003E3 480510000000                add rax, 10h    ;Com3
   903 000003E9 48AB                        stosq
   904 000003EB 480510000000                add rax, 10h    ;Com4
   905 000003F1 48AB                        stosq
   906                                  ;Printer area
   907 000003F3 31C0                        xor eax, eax
   908 000003F5 66B90300                    mov cx, 3h
   909 000003F9 F366AB                      rep stosw
   910                                  ;Timers area
   911 000003FC 66AB                        stosw   ;Default pit_divisor, 0 = 65536
   912 000003FE AB                          stosd    ;pit_ticks
   913 000003FF 48AB                        stosq    ;rtc_ticks
   914                                  ;Screen area
   915 00000401 66B90200                    mov cx, 2h
   916 00000405 F348AB                      rep stosq    ;rax, is 0
   917 00000408 66B85000                    mov ax, 50h
   918 0000040C AA                          stosb
   919 0000040D 66B81900                    mov ax, 19h
   920 00000411 AA                          stosb
   921 00000412 6631C0                      xor ax, ax
   922 00000415 66AB                        stosw
   923 00000417 66B80700                    mov ax, 07
   924 0000041B AA                          stosb
   925 0000041C 66B80300                    mov ax, 03
   926 00000420 AA                          stosb
   927 00000421 6631C0                      xor ax, ax
   928 00000424 AA                          stosb
   929 00000425 66B8D403                    mov ax, vga_index
   930 00000429 66AB                        stosw
   931 0000042B B800800B00                  mov eax, vga_bpage2
   932 00000430 AB                          stosd
   933 00000431 31C0                        xor eax, eax    ;zero rax
   934                                  ;Store scr_mode_params and scr_vga_ptrs
   935 00000433 B909000000                  mov ecx, 9
   936 00000438 F348AB                      rep stosq
   937                                  ;HDD/FDD data area
   938 0000043B 31C0                        xor eax, eax
   939 0000043D 66AB                        stosw   ;Int 33h entries and msdStatus
   940 0000043F AA                          stosb   ;Fixed disk entries
   941 00000440 AB                          stosd   ;Hard drive status entries
   942 00000441 48B8-                       mov rax, diskdpt
   942 00000443 [711A000000000000] 
   943 0000044B 48AB                        stosq   ;Store the address of the default remdev format table
   944 0000044D 48B8-                       mov rax, fdiskdpt
   944 0000044F [7C1A000000000000] 
   945 00000457 48AB                        stosq
   946 00000459 31C0                        xor eax, eax
   947                                  ;SysInit area
   948 0000045B 488B0425[02000000]          mov rax, qword [SysInitTable.FileLBA]
   949 00000463 48AB                        stosq   ;NextFileLBA
   950 00000465 0FB70425[00000000]          movzx eax, word [SysInitTable.numSecW] 
   951 0000046D 66AB                        stosw   ;numSectors Word
   952 0000046F 31C0                        xor eax, eax
   953                                  ;Memory Data area
   954 00000471 AB                          stosd    ;0 MachineWord and convRAM 
   955 00000472 48AB                        stosq   ;0 userBase
   956 00000474 AA                          stosb    ;0 bigmapSize
   957 00000475 48AB                        stosq   ;0 srData, 4 words
   958 00000477 66AB                        stosw   ;0 srData1, 1 word
   959 00000479 48AB                        stosq   ;0 sysMem, 1 qword
   960 0000047B AB                          stosd   ;0 scpSize, 1 dword
   961                                  ;MCP data area
   962 0000047C 48C70425[EC010000]-         mov qword [mcpUserBase], section.MCPseg.start
   962 00000484 [00000000]         
   963 00000488 48C70425[F4010000]-         mov qword [mcpUserRip], section.MCPseg.start + 180h
   963 00000490 [80010000]         
   964 00000494 48C70425[FC010000]-         mov qword [mcpUserkeybf], section.MCPseg.start + 100h
   964 0000049C [00010000]         
   965 000004A0 48C70425[0C020000]-         mov qword [mcpStackPtr], MCPsegEnd
   965 000004A8 [00080000]         
   966 000004AC 48C70425[04020000]-         mov qword [mcpUserRaxStore], 0
   966 000004B4 00000000           
   967 000004B8 4881C728000000              add rdi, 5*8    ;Go forwards by 5 entries
   968                                  ;USB Area
   969 000004BF AA                          stosb
   970 000004C0 66B90400                    mov cx, 4
   971 000004C4 F348AB                      rep stosq    ;eControllerList
   972 000004C7 AA                          stosb
   973 000004C8 48B8-                       mov rax, USB.ehciCriticalErrorHandler ;Get the critical error handler ptr
   973 000004CA [8932000000000000] 
   974 000004D2 48AB                        stosq       ;Install eHCErrorHandler
   975 000004D4 31C0                        xor eax, eax    ;Rezero rax
   976 000004D6 66FFC8                      dec ax
   977 000004D9 48AB                        stosq       ;eCurrAsyncHead
   978 000004DB AA                          stosb       ;eActiveAddr
   979 000004DC AA                          stosb        ;eActiveCtrlr
   980 000004DD 66FFC0                      inc ax
   981 000004E0 AB                          stosd
   982                                  ;USB Tables
   983 000004E1 66B91E00                    mov cx, 10*usbDevTblEntrySize
   984 000004E5 F3AA                        rep stosb
   985 000004E7 66B95000                    mov cx, 10*hubDevTblEntrySize
   986 000004EB F3AA                        rep stosb
   987 000004ED 66B9A000                    mov cx, 10*msdDevTblEntrySize
   988 000004F1 F3AA                        rep stosb
   989                                  ;IDE and Int 33h stuff
   990 000004F3 AA                          stosb       ;ideNumberOfControllers
   991 000004F4 66B92000                    mov cx, 2*ideTableEntrySize ;ideControllerTable
   992 000004F8 F3AA                        rep stosb
   993 000004FA 66B94000                    mov cx, 4*fdiskTableEntrySize
   994 000004FE F3AA                        rep stosb
   995 00000500 66B9A000                    mov cx, 10*int33TblEntrySize
   996 00000504 F3AA                        rep stosb
   997                                  ;End of BDA variable init
   998                                  
   999                                  ;Copy the resident portion of SCPBIOS.SYS to its offset
  1000                                  Relocate:
  1001 00000506 48BE-                       mov rsi, section.codeResident.start
  1001 00000508 [0000000000000000] 
  1002 00000510 48BF-                       mov rdi, section.codeResident.vstart    ;address for the end of the section
  1002 00000512 [0000000000000000] 
  1003 0000051A 48B9090A0000000000-         mov rcx, (residentLength/8) + 1
  1003 00000523 00                 
  1004 00000524 F348A5                      rep movsq    ;Copy resident portion high
  1005                                  
  1006                                  ;Copy machine word into var from 600h
  1007 00000527 668B0425[0A000000]          mov ax, word [loMachineWord]
  1008 0000052F 66890425[C9010000]          mov word [MachineWord], ax
  1009                                  
  1010                                  ;Copy Memory Maps DIRECTLY after USB dynamic space.
  1011 00000537 48BF-                       mov rdi, bigmapptr
  1011 00000539 [F005000000000000] 
  1012                                  .move820_0:    ;Add to the end
  1013 00000541 48BE00000100000000-         mov rsi, e820SizeAddr
  1013 0000054A 00                 
  1014 0000054B 66AD                        lodsw    ;Get number of entries for big map
  1015 0000054D 480FB6C0                    movzx rax, al    ;zero extend
  1016 00000551 488D0C40                    lea rcx, qword [rax + 2*rax]    ;Save 3*#of entries for countdown loop
  1017                                  .mv0:
  1018 00000555 F348A5                      rep movsq    ;Transfer 3*al qwords
  1019 00000558 0402                        add al, 2    ;Two more entries for BIOS
  1020 0000055A 880425[D5010000]            mov byte [bigmapSize], al    ;Save entries in al
  1021                                  ;Compute the size of BIOS allocation + space for two more entries up to next KB
  1022 00000561 4881C718000000              add rdi, 3*8 ;rdi now points to start of last allocated entry (added)
  1023 00000568 4889FB                      mov rbx, rdi 
  1024 0000056B 4881C318000000              add rbx, 3*8h   ;Add size of last new entry
  1025                                  ;Round to nearest KB
  1026 00000572 4881E300FCFFFF              and rbx, ~3FFh
  1027 00000579 4881C300040000              add rbx, 400h
  1028 00000580 48891C25[CD010000]          mov qword [userBase], rbx    ;Save userbase
  1029 00000588 4881EB00001100              sub rbx, BIOSStartAddr 
  1030 0000058F 891C25[E8010000]            mov dword [scpSize], ebx    ;Save Size
  1031                                  ;Calculate amount of system RAM available
  1032                                  .readSystemSize:
  1033 00000596 48BB-                       mov rbx, bigmapptr
  1033 00000598 [F005000000000000] 
  1034 000005A0 48BA01000000010000-         mov rdx, 0000000100000001h      ;Valid entry signature
  1034 000005A9 00                 
  1035 000005AA 0FB6C8                      movzx ecx, al       ;Get the number of 24 byte entries
  1036 000005AD 81E902000000                sub ecx, 2          ;Remove the allocated entries from the count
  1037 000005B3 31C0                        xor eax, eax                    ;Zero rax, use to hold cumulative sum
  1038                                  .rss1:
  1039 000005B5 48395310                    cmp qword [rbx + 2*8], rdx   ;Check valid entry
  1040 000005B9 7504                        jnz .rss2
  1041 000005BB 48034308                    add rax, qword [rbx + 8]    ;Add size to rax
  1042                                  .rss2:
  1043 000005BF 4881C318000000              add rbx, 3*8                ;Goto next entry
  1044 000005C6 FFC9                        dec ecx                     ;Decrement count
  1045 000005C8 75EB                        jnz .rss1                   ;Not at zero, keep going
  1046 000005CA 48890425[E0010000]          mov qword [sysMem], rax
  1047                                  ;Create and insert new entry. If no space found for new, just add to end
  1048                                  .addEntry:
  1049 000005D2 0FB60C25[D5010000]          movzx ecx, byte [bigmapSize]
  1050 000005DA 81E902000000                sub ecx, 2          ;Remove the allocated entries from the count   
  1051 000005E0 31D2                        xor edx, edx    ;Use as index pointer
  1052                                  .ae0:
  1053 000005E2 4881BA[F0050000]00-         cmp qword [bigmapptr+rdx], 100000h    ;Start of extended memory
  1053 000005EA 001000             
  1054 000005ED 7438                        je .ae1
  1055 000005EF 4881C218000000              add rdx, 18h    ;Go to next entry
  1056 000005F6 FFC9                        dec ecx 
  1057 000005F8 75E8                        jnz .ae0
  1058                                  ;If address not found, just add it to the end, deal with that here
  1059                                  ;Ignore the extra calculated allocated entry
  1060                                  ;rdi points to last new entry, so sub rdi to point to second to last entry
  1061 000005FA 4881EF18000000              sub rdi, 3*8h
  1062 00000601 48C70700001100              mov qword [rdi], BIOSStartAddr
  1063 00000608 488B0425[E8010000]          mov rax, qword [scpSize]
  1064 00000610 48894708                    mov qword [rdi + 8h], rax
  1065 00000614 48B802000000010000-         mov rax, 100000002h
  1065 0000061D 00                 
  1066 0000061E 48894708                    mov qword [rdi + 8h], rax
  1067 00000622 E99F000000                  jmp .altRAM
  1068                                  .ae1:
  1069                                  ;Address found, add new entry
  1070                                  ;ecx contains number of entries that need to be shifted + 1
  1071 00000627 56                          push rsi
  1072 00000628 57                          push rdi
  1073 00000629 4889FE                      mov rsi, rdi
  1074 0000062C 4881EE30000000              sub rsi, 2*18h
  1075 00000633 FFC9                        dec ecx
  1076 00000635 89C8                        mov eax, ecx    ;Use eax as row counter
  1077                                  .ae2:
  1078 00000637 B903000000                  mov ecx, 3      ;3 8 byte entries
  1079 0000063C F348A5                      rep movsq
  1080 0000063F 4881EE30000000              sub rsi, 2*18h
  1081 00000646 4881EF30000000              sub rdi, 2*18h
  1082 0000064D FFC8                        dec eax
  1083 0000064F 75E6                        jnz .ae2
  1084 00000651 5F                          pop rdi
  1085 00000652 5E                          pop rsi
  1086                                  ;Values copied, time to change values
  1087                                  ;Change HMA entry
  1088 00000653 4881C2[F0050000]            add rdx, bigmapptr    ;Add offset into table to rdx
  1089 0000065A 488B4A08                    mov rcx, qword [rdx + 8h]       ;Save size from entry into rax
  1090 0000065E 48C7420800000100            mov qword [rdx + 8h], 10000h    ;Free 64Kb entry (HMA)
  1091 00000666 4881C218000000              add rdx, 3*8h   ;Move to new SCP reserved entry
  1092                                  ;Now Create the SCPBIOS Space Entry
  1093 0000066D 48C70200001100              mov qword [rdx], BIOSStartAddr
  1094 00000674 31DB                        xor ebx, ebx
  1095 00000676 8B1C25[E8010000]            mov ebx, dword [scpSize]
  1096 0000067D 48895A08                    mov qword [rdx + 8h], rbx
  1097 00000681 48BB02000000010000-         mov rbx, 100000002h
  1097 0000068A 00                 
  1098 0000068B 48895A10                    mov qword [rdx + 10h], rbx  ;Reserved flags
  1099 0000068F 4881C218000000              add rdx, 3*8h
  1100                                  ;Now modify the Free space entry
  1101 00000696 488B0425[CD010000]          mov rax, qword [userBase]
  1102 0000069E 488902                      mov qword [rdx], rax
  1103 000006A1 31C0                        xor eax, eax
  1104 000006A3 8B0425[E8010000]            mov eax, dword [scpSize]
  1105 000006AA 4829C1                      sub rcx, rax
  1106 000006AD 4881E900000100              sub rcx, 10000h ;Sub HMA size
  1107 000006B4 48894A08                    mov qword [rdx + 8h], rcx    ;Put entry back
  1108 000006B8 48BB01000000010000-         mov rbx, 100000001h
  1108 000006C1 00                 
  1109 000006C2 48895A10                    mov qword [rdx + 10h], rbx  ;Free flags
  1110                                  .altRAM:
  1111                                  ;Copy Alt RAM values
  1112 000006C6 8B1C25[E8010000]            mov ebx, dword [scpSize]
  1113 000006CD C1EB0A                      shr ebx, 0Ah    ;Rescale from byts to KB
  1114 000006D0 81C340000000                add ebx, 40h    ;Add the HMA (64Kb)
  1115 000006D6 48BF-                       mov rdi, srData    ;Save qword in srData ah=E801h
  1115 000006D8 [D601000000000000] 
  1116 000006E0 48AD                        lodsq    ;Get into rax, inc rsi
  1117 000006E2 6629D8                      sub ax, bx      ;bx preserved, contains number of KB's plus 1
  1118 000006E5 48C1C820                    ror rax, 20h    ;Rotate over 32 bits
  1119 000006E9 6629D8                      sub ax, bx
  1120 000006EC 48C1C820                    ror rax, 20h    ;Rotate over 32 bits again
  1121 000006F0 48AB                        stosq            ;Save, inc rdi
  1122 000006F2 48BF-                       mov rdi, srData1    ;Save word for ah=88h
  1122 000006F4 [DE01000000000000] 
  1123 000006FC 66A5                        movsw    ;Save value, then reduce by BIOS size
  1124 000006FE 66295FFE                    sub word [rdi - 2], bx    ;Reduce the size of the previous stored val
  1125 00000702 48BF-                       mov rdi, convRAM    ;Int 12h value
  1125 00000704 [CB01000000000000] 
  1126 0000070C 66A5                        movsw
  1127                                  ;Copy VGA fonts to Internal Int 30h area
  1128 0000070E 48BF-                       mov rdi, scr_vga_ptrs
  1128 00000710 [6801000000000000] 
  1129 00000718 48B908000000000000-         mov rcx, 8
  1129 00000721 00                 
  1130 00000722 F348A5                      rep movsq
  1131                                  ;-----------------Write Long Mode Page Tables-----------------
  1132                                  ;Creates a 4Gb ID mapped page 
  1133 00000725 48BF-                       mov rdi, BIOSPageTbl
  1133 00000727 [0010000000000000] 
  1134 0000072F 57                          push rdi
  1135                                  Ptablefinal:
  1136 00000730 48B9000C0000000000-         mov rcx, 6000h/8;6000h bytes (6x4Kb) of zero to clear table area
  1136 00000739 00                 
  1137 0000073A 57                          push rdi
  1138 0000073B 4831C0                      xor rax, rax
  1139 0000073E F348AB                      rep stosq        ;Clear the space
  1140                                  
  1141 00000741 5F                          pop rdi            ;Return zero to the head of the table, at 08000h
  1142 00000742 4889F8                      mov rax, rdi    ;Load rax with the PML4 table location
  1143 00000745 480500100000                add rax, 1000h  ;Move rax to point to PDPT
  1144 0000074B 480D03000000                or rax, permissionflags    ;Write the PDPT entry as present and r/w
  1145 00000751 48AB                        stosq    ;store the low word of the address
  1146 00000753 4881C7F80F0000              add rdi, 0FF8h
  1147 0000075A B904000000                  mov ecx, 4
  1148                                  .utables:
  1149 0000075F 480500100000                add rax, 1000h  ;Write four entries in PDPT for each GB range
  1150 00000765 48AB                        stosq
  1151 00000767 FFC9                        dec ecx
  1152 00000769 75F4                        jnz .utables
  1153                                  
  1154 0000076B 4881C7E00F0000              add rdi, 0FE0h  ;rdi points to the new page tables, copy!
  1155 00000772 48BE00A00000000000-         mov rsi, 0A000h ;Get the first Page table
  1155 0000077B 00                 
  1156 0000077C B900080000                  mov ecx, 4000h/8 ;Number of bytes to copy 
  1157 00000781 F348A5                      rep movsq       ;Get the 4Gb tables into place
  1158 00000784 5F                          pop rdi            ;Bring back Table base
  1159 00000785 0F22DF                      mov cr3, rdi    ;Finalise change in paging address
  1160                                  
  1161                                  ;----------------------Write Interrupts----------------------
  1162 00000788 48B900010000000000-         mov rcx, 0100h    ;256 entries
  1162 00000791 00                 
  1163 00000792 48B8-                       mov rax, dummy_return_64
  1163 00000794 [1550000000000000] 
  1164 0000079C BB08000000                  mov ebx, codedescriptor
  1165 000007A1 31F6                        xor esi, esi
  1166 000007A3 66BA008F                    mov dx, 8F00h    
  1167                                      ;Toggle attribs. 8F = Interrupt Present, accessable from ring 0 and greater,
  1168                                      ;0 (so collectively 08h) and gate type 0Fh (64-bit trap gate (gate which 
  1169                                      ;leaves interrupts on))
  1170                                  idtFillDummy:
  1171 000007A7 E8(CB000000)                call idtWriteEntry
  1172 000007AC 66FFC9                      dec cx
  1173 000007AF 75F6                        jnz idtFillDummy
  1174                                  
  1175 000007B1 31F6                        xor esi, esi
  1176 000007B3 48B940000000000000-         mov rcx, ((IDT_TABLE_Length >> 3))
  1176 000007BC 00                 
  1177 000007BD 48BD-                       mov rbp, IDT_TABLE
  1177 000007BF [2F18000000000000] 
  1178                                  idtLoop:
  1179 000007C7 488B44F500                  mov rax, qword [rbp+(rsi*8)]
  1180 000007CC E8(CB000000)                call idtWriteEntry
  1181 000007D1 48FFC9                      dec rcx
  1182 000007D4 75F1                        jnz idtLoop
  1183                                  
  1184 000007D6 48BC00000800000000-         mov rsp, 80000h    ;Realign stack pointer
  1184 000007DF 00                 
  1185                                  ;Reload the interrupt table
  1186 000007E0 0F011C25[02000000]          lidt [IDTpointer]
  1187                                  ;Write GDT to its final High location
  1188 000007E8 48BE-                       mov rsi, GDT
  1188 000007EA [BF02000000000000] 
  1189 000007F2 48BF-                       mov rdi, BIOSGDTable
  1189 000007F4 [0070000000000000] 
  1190 000007FC 48B903000000000000-         mov rcx, 3
  1190 00000805 00                 
  1191 00000806 F348A5                      rep movsq    ;copy the three descriptors high
  1192                                  ;Reload the GDT Pointer
  1193 00000809 0F011425[0E000000]          lgdt [GDTpointer]
  1194                                  
  1195                                  ;Video Initialisation: VGA mode, CRTC at 3D4h, Mode 03h, 128k VRAM
  1196                                  ;For now, only unlock upper WO CRTC registers, by using undocumented 
  1197                                  ; CRTC register 11h.
  1198 00000811 668B1425[5A010000]          mov dx, word [scr_crtc_base]    ;Get current set CRTC index register
  1199 00000819 B011                        mov al, 11h     ;Register 11
  1200 0000081B 88D8                        mov al, bl
  1201 0000081D EE                          out dx, al
  1202 0000081E E680                        out waitp, al   ;Wait an I/O cycle
  1203 00000820 66FFC2                      inc dx  ;Point to data register
  1204 00000823 EC                          in al, dx   ;get register 11h
  1205 00000824 247F                        and al, 7Fh ;Clear upper bit
  1206 00000826 86C3                        xchg al, bl ;Get address back into al, save new register value in bl  
  1207 00000828 66FFCA                      dec dx  ;Return to index
  1208 0000082B EE                          out dx, al
  1209 0000082C FEC2                        inc dl
  1210 0000082E 86C3                        xchg al, bl
  1211 00000830 EE                          out dx, al  ;Output new byte, unlock upper WO CRTC registers for use!
  1212                                  ;Boot message/Verification of successful VGA card reset!
  1213                                  ;Print Boot Message
  1214 00000831 66B80413                    mov ax, 1304h
  1215 00000835 48BD-                       mov rbp, startboot
  1215 00000837 [8415000000000000] 
  1216 0000083F CD30                        int 30h
  1217                                  
  1218 00000841 E8170E0000                  call memprint    ;Print Memory status
  1219                                  
  1220                                  ;----------------------------------------------------------------
  1221                                  ;                        End of Initialisation                  :
  1222                                  ;----------------------------------------------------------------
  1223                                  ;----------------------------------------------------------------
  1224                                  ;                PIC Initialisation procedure                   :
  1225                                  ;----------------------------------------------------------------
  1226                                  ;Remapping the IO ports to Interrupt 0x40
  1227                                  PICremap:
  1228 00000846 B011                        mov al, 11h        ;bit 10h and 1h = Start initialisation
  1229 00000848 E620                        out pic1command, al
  1230 0000084A E680                        out waitp, al    
  1231 0000084C E6A0                        out pic2command, al
  1232 0000084E E680                        out waitp, al    
  1233                                      
  1234 00000850 B020                        mov al, 20h       ;PIC1 to take Int 20h - 27h
  1235 00000852 E621                        out pic1data, al
  1236 00000854 E680                        out waitp, al    
  1237 00000856 0408                        add al, 8        ;PIC2 to take Int 28h - 2Fh
  1238 00000858 E6A1                        out pic2data, al 
  1239 0000085A E680                        out waitp, al    
  1240                                      
  1241 0000085C B004                        mov al, 4
  1242 0000085E E621                        out pic1data, al    ;Tell PIC 1 that there is a PIC 2 at IRQ2 (00000100)
  1243 00000860 E680                        out waitp, al    
  1244 00000862 FEC8                        dec al
  1245 00000864 FEC8                        dec al
  1246 00000866 E6A1                        out pic2data, al    ;Tell PIC 2 its cascade identity (00000010)
  1247 00000868 E680                        out waitp, al
  1248                                      
  1249 0000086A B001                        mov al, 01h        ;Initialise in 8086 mode
  1250 0000086C E621                        out pic1data, al
  1251 0000086E E680                        out waitp, al    
  1252 00000870 E6A1                        out pic2data, al
  1253 00000872 E680                        out waitp, al    
  1254                                      
  1255 00000874 B0FF                        mov al, 0FFh    ;Mask all interrupts 
  1256 00000876 E621                        out pic1data, al
  1257 00000878 E6A1                        out pic2data, al
  1258                                  
  1259                                  ;Ensure that interrupts are still masked
  1260                                  ;----------------------------------------------------------------
  1261                                  ;                        End of Initialisation                  :
  1262                                  ;----------------------------------------------------------------
  1263                                  ;----------------------------------------------------------------
  1264                                  ;                            PCI Enumeration                    :
  1265                                  ;----------------------------------------------------------------
  1266                                  ; This proc enumerates only the PCI devices we care for
  1267                                  ;----------------------------------------------------------------
  1268 0000087A 4831ED                      xor rbp, rbp
  1269 0000087D 66892C2500E00000            mov word [lousbtablesize], bp
  1270 00000885 4889E9                      mov rcx, rbp    ;reset cx now too, for below
  1271                                  pci_scan:    ;Enumerate PCI devices (formerly, USB devices)
  1272 00000888 4831DB                      xor rbx, rbx       ;Used to save the value of eax temporarily
  1273 0000088B 48B808000081000000-         mov rax, 81000008h ;Set bit 31 and lower byte to 2, for register 2/offset 8
  1273 00000894 00                 
  1274                                                         ;also make it the largest register so that we enumerate 
  1275                                                         ;backwards and set up USB controllers in order from 
  1276                                                         ;newest to oldest.
  1277                                  .u1:
  1278 00000895 2D00010000                  sub eax, 100h      ;mov eax into valid PCI range, go to next device
  1279 0000089A 66BAF80C                    mov dx, pci_index  ;PCI index register
  1280 0000089E EF                          out dx, eax   ;output the next packed bus,device,function,register combo
  1281                                  
  1282 0000089F 89C3                        mov ebx, eax       ;save to be used later, to access PCI BARS
  1283                                      
  1284 000008A1 66BAFC0C                    mov dx, pci_data   ;PCI data register
  1285 000008A5 ED                          in eax, dx    ;Get Class, subclass and interface value in upper three bytes
  1286                                      
  1287 000008A6 C1E808                      shr eax, 8                ;shift down the details by a byte
  1288                                  ;IF any of these are satisfied, remember ebx has the device index
  1289 000008A9 3D00030C00                  cmp eax, ((usb_class << 16) +(usb_subclass << 8)+uhci_interface)
  1290 000008AE 0F8446010000                je .uhci_found
  1291 000008B4 3D10030C00                  cmp eax, ((usb_class << 16) +(usb_subclass << 8)+ohci_interface)
  1292 000008B9 0F847D010000                je .ohci_found
  1293 000008BF 3D20030C00                  cmp eax, ((usb_class << 16) +(usb_subclass << 8)+ehci_interface)
  1294 000008C4 0F847C010000                je .ehci_found
  1295 000008CA 3D30030C00                  cmp eax, ((usb_class << 16) +(usb_subclass << 8)+xhci_interface)
  1296 000008CF 0F84D0010000                je .xhci_found
  1297 000008D5 50                          push rax
  1298 000008D6 C1E808                      shr eax, 8              ;roll over rid of function number
  1299 000008D9 3D01010000                  cmp eax, (msd_class << 8) + (ide_subclass)
  1300 000008DE 7452                        je .idePCIEnum
  1301 000008E0 3D06010000                  cmp eax, (msd_class << 8) + (sata_subclass)
  1302 000008E5 7414                        je .sataPCIEnum
  1303 000008E7 58                          pop rax
  1304                                  .u11:    ;After a device found, jump here to continue enumeration
  1305 000008E8 6681E50F00                  and bp, 000Fh       ;Zero the upper nybble again.
  1306 000008ED 89D8                        mov eax, ebx        ;Return pci value into eax
  1307 000008EF 3D08000080                  cmp eax, 80000008h  ;The lowest value
  1308 000008F4 7F9F                        jg .u1
  1309 000008F6 E9A9040000                  jmp pciExit
  1310                                  .sataPCIEnum:
  1311 000008FB 58                          pop rax
  1312 000008FC 50                          push rax
  1313 000008FD 55                          push rbp
  1314 000008FE 66B80413                    mov ax, 1304h
  1315 00000902 48BD-                       mov rbp, .spemsg
  1315 00000904 [1509000000000000] 
  1316 0000090C CD30                        int 30h
  1317 0000090E 5D                          pop rbp
  1318 0000090F 58                          pop rax
  1319 00000910 E9D3FFFFFF                  jmp .u11
  1320 00000915 0A0D41484349205341-     .spemsg: db 0Ah, 0Dh, "AHCI SATA controller found", 0
  1320 0000091E 544120636F6E74726F-
  1320 00000927 6C6C657220666F756E-
  1320 00000930 6400               
  1321                                  .idePCIEnum:
  1322 00000932 58                          pop rax
  1323 00000933 50                          push rax
  1324 00000934 55                          push rbp
  1325 00000935 66B80413                    mov ax, 1304h
  1326 00000939 48BD-                       mov rbp, .ipemsg
  1326 0000093B [A809000000000000] 
  1327 00000943 CD30                        int 30h
  1328 00000945 5D                          pop rbp
  1329 00000946 58                          pop rax
  1330 00000947 50                          push rax
  1331 00000948 B404                        mov ah, 04h
  1332 0000094A CD30                        int 30h
  1333 0000094C 58                          pop rax
  1334                                  ;If function is 80h, then it will respond to default IO addresses
  1335 0000094D A880                        test al, 80h ;Check if bus mastery is enabled. Only support DMA transfers
  1336 0000094F 7497                        jz .u11      ;Exit if not enabled
  1337 00000951 3C80                        cmp al, 80h  ;If 80h, device hardwired bus master legacy mode, all good.
  1338 00000953 742B                        je .ipeWriteTable
  1339                                  ;Bit bash, and reread, if it works, yay, if not, fail cancel
  1340 00000955 66BAF80C                    mov dx, pci_index
  1341 00000959 89D8                        mov eax, ebx
  1342 0000095B EF                          out dx, eax     ;Register offset 8
  1343 0000095C 6681C20400                  add dx, 4       ;Point to pci_data
  1344 00000961 25FFFAFFFF                  and eax, 0FFFFFAFFh     ;Zero bits 0 and 2 of nybble 3
  1345 00000966 EF                          out dx, eax
  1346 00000967 6681EA0400                  sub dx, 4
  1347 0000096C 89D8                        mov eax, ebx
  1348 0000096E EF                          out dx, eax
  1349 0000096F 6681C20400                  add dx, 4
  1350 00000974 ED                          in eax, dx
  1351 00000975 A900050000                  test eax, 00000500h  ;Test bits 0 and 2 of nybble 3 have been zeroed
  1352 0000097A 0F8568FFFFFF                jnz .u11    ;IF not, fail
  1353                                  .ipeWriteTable:
  1354                                  ;Now the controller and devices have been set to legacy, they should
  1355                                  ; respond to the default IO addresses and IRQ. Save BAR 5 for Bus mastering.
  1356 00000980 50                          push rax
  1357 00000981 55                          push rbp
  1358 00000982 48BD-                       mov rbp, .ipemsg2
  1358 00000984 [CB09000000000000] 
  1359 0000098C 66B80413                    mov ax, 1304h
  1360 00000990 CD30                        int 30h
  1361 00000992 5D                          pop rbp
  1362 00000993 58                          pop rax
  1363 00000994 89D8                        mov eax, ebx    
  1364 00000996 B020                        mov al, 20h ;BAR4 Address
  1365 00000998 66BAF80C                    mov dx, pci_index
  1366 0000099C EF                          out dx, eax
  1367 0000099D 6681C20400                  add dx, 4
  1368 000009A2 ED                          in eax, dx  ;Get BAR 4 address
  1369                                      ;call IDE.addControllerTable
  1370                                      ;jc .u11     ;If this fails, exit gracefully
  1371 000009A3 E940FFFFFF                  jmp .u11
  1372 000009A8 0A0D49444520415441-     .ipemsg:    db 0Ah, 0Dh,"IDE ATA Controller found. Type: ", 0
  1372 000009B1 20436F6E74726F6C6C-
  1372 000009BA 657220666F756E642E-
  1372 000009C3 20547970653A2000   
  1373 000009CB 0A0D49444520415441-     .ipemsg2:   db 0Ah, 0Dh, "IDE ATA Controller set to compatibility mode",0
  1373 000009D4 20436F6E74726F6C6C-
  1373 000009DD 65722073657420746F-
  1373 000009E6 20636F6D7061746962-
  1373 000009EF 696C697479206D6F64-
  1373 000009F8 6500               
  1374                                  ;bp lo = status register, 
  1375                                  ;bp hi = controller being serviced (ie 1000xxxx => xHCI being serviced)
  1376                                  .uhci_found:
  1377 000009FA 6681CD1100                  or bp, 00010001b    ;set bit 0/mask = 1
  1378 000009FF 55                          push rbp
  1379 00000A00 50                          push rax
  1380 00000A01 53                          push rbx
  1381 00000A02 66B80413                    mov ax, 1304h
  1382 00000A06 30FF                        xor bh, bh
  1383 00000A08 48BD-                       mov rbp, .uhci_succ
  1383 00000A0A [1C0A000000000000] 
  1384 00000A12 CD30                        int 30h
  1385 00000A14 5B                          pop rbx
  1386 00000A15 58                          pop rax
  1387 00000A16 5D                          pop rbp
  1388 00000A17 E9A6000000                  jmp .controlController
  1389 00000A1C 0A0D5548434920636F-     .uhci_succ:    db    0Ah, 0Dh,'UHCI controller found on IRQ ', 0
  1389 00000A25 6E74726F6C6C657220-
  1389 00000A2E 666F756E64206F6E20-
  1389 00000A37 4952512000         
  1390                                  .ohci_found:
  1391 00000A3C 6681CD2200                  or bp, 00100010b    ;set bit 1/mask = 2
  1392 00000A41 E9A2FEFFFF                  jmp .u11
  1393                                  .ehci_found:
  1394 00000A46 6681CD4400                  or bp, 01000100b    ;set bit 2/mask = 4
  1395 00000A4B 55                          push rbp
  1396 00000A4C 50                          push rax
  1397 00000A4D 53                          push rbx
  1398 00000A4E 66B80413                    mov ax, 1304h
  1399 00000A52 30FF                        xor bh, bh
  1400 00000A54 48BD-                       mov rbp, .ehci_succ
  1400 00000A56 [650A000000000000] 
  1401 00000A5E CD30                        int 30h
  1402 00000A60 5B                          pop rbx
  1403 00000A61 58                          pop rax
  1404 00000A62 5D                          pop rbp
  1405 00000A63 EB5D                        jmp short .controlController
  1406 00000A65 0A0D4548434920636F-     .ehci_succ:    db    0Ah, 0Dh,'EHCI controller found on IRQ ', 0
  1406 00000A6E 6E74726F6C6C657220-
  1406 00000A77 666F756E64206F6E20-
  1406 00000A80 4952512000         
  1407 00000A85 0A0D7848434920636F-     .xhci_succ:    db    0Ah, 0Dh,'xHCI controller found on IRQ ', 0
  1407 00000A8E 6E74726F6C6C657220-
  1407 00000A97 666F756E64206F6E20-
  1407 00000AA0 4952512000         
  1408                                  .xhci_found:
  1409 00000AA5 55                          push rbp
  1410 00000AA6 50                          push rax
  1411 00000AA7 53                          push rbx
  1412 00000AA8 66B80413                    mov ax, 1304h
  1413 00000AAC 30FF                        xor bh, bh
  1414 00000AAE 48BD-                       mov rbp, .xhci_succ
  1414 00000AB0 [850A000000000000] 
  1415 00000AB8 CD30                        int 30h
  1416 00000ABA 5B                          pop rbx
  1417 00000ABB 58                          pop rax
  1418 00000ABC 5D                          pop rbp
  1419 00000ABD 6681CD8800                  or bp, 10001000b    ;set bit 3/mask = 8
  1420                                  
  1421                                  .controlController:
  1422                                  ;This for now will get the IRQ line for all controllers,
  1423                                  ;and install a USB handler there, then disabling the HC rather than just the 
  1424                                  ;legacy support.
  1425                                  ;EAX doesnt need to be saved since the first instruction of .u11 is to move the 
  1426                                  ;value of ebx back into eax.
  1427                                  ;EDX doesnt need to be saved since the port data gets loaded in the proc above
  1428                                  ;DO NOT MODIFY EBX
  1429 00000AC2 31D2                        xor edx, edx
  1430 00000AC4 89D8                        mov eax, ebx    ;Move a copy of ebx, the PCI config space device address
  1431 00000AC6 B03C                        mov al, 3Ch     ;offset 3C has interrupt masks in lower word
  1432 00000AC8 66BAF80C                    mov dx, pci_index
  1433 00000ACC EF                          out dx, eax       ;set to give interrupt masks
  1434 00000ACD 66BAFC0C                    mov dx, pci_data
  1435 00000AD1 ED                          in eax, dx        ;Get info into eax (formally, al)
  1436 00000AD2 50                          push rax
  1437 00000AD3 240F                        and al, 0Fh
  1438 00000AD5 B404                        mov ah, 04h
  1439 00000AD7 CD30                        int 30h
  1440 00000AD9 58                          pop rax
  1441 00000ADA 66F7C54000                  test bp, 40h      ;Check if EHCI
  1442 00000ADF 0F8490000000                jz .cc1           ;Skip mapping
  1443 00000AE5 240F                        and al, 0Fh       ;Clear upper nybble for good measure
  1444 00000AE7 3C10                        cmp al, 10h
  1445 00000AE9 0F8786000000                ja .cc1           ;Cant map it
  1446 00000AEF 3C08                        cmp al, 08h        
  1447 00000AF1 733E                        jae .cc0
  1448 00000AF3 56                          push rsi
  1449 00000AF4 52                          push rdx
  1450 00000AF5 50                          push rax
  1451 00000AF6 53                          push rbx
  1452 00000AF7 480FB6F0                    movzx rsi, al
  1453 00000AFB 81C620000000                add esi, 20h
  1454 00000B01 66BA008F                    mov dx, 8F00h
  1455 00000B05 48B8-                       mov rax, ehci_IRQ.pic1    ;PIC1 ep
  1455 00000B07 [500B000000000000] 
  1456 00000B0F BB08000000                  mov ebx, codedescriptor
  1457 00000B14 E8(CB000000)                call idtWriteEntry
  1458 00000B19 5B                          pop rbx
  1459 00000B1A 58                          pop rax
  1460 00000B1B 5A                          pop rdx
  1461 00000B1C 5E                          pop rsi
  1462 00000B1D 51                          push rcx
  1463 00000B1E 88C1                        mov cl, al
  1464 00000B20 B001                        mov al, 1
  1465 00000B22 D2E0                        shl al, cl          ;Shift bit to appropriate position
  1466 00000B24 F6D0                        not al              ;Turn into a bitmask
  1467 00000B26 88C4                        mov ah, al          ;Save in ah
  1468 00000B28 E421                        in al, pic1data
  1469 00000B2A 20E0                        and al, ah          ;Add bitmask to current mask
  1470 00000B2C E621                        out pic1data, al    ;Unmask this line
  1471 00000B2E 59                          pop rcx
  1472 00000B2F EB44                        jmp short .cc1
  1473                                  .cc0:
  1474 00000B31 56                          push rsi
  1475 00000B32 52                          push rdx
  1476 00000B33 50                          push rax
  1477 00000B34 53                          push rbx
  1478 00000B35 480FB6F0                    movzx rsi, al
  1479 00000B39 81C620000000                add esi, 20h    ;Start of PIC range
  1480 00000B3F 66BA008F                    mov dx, 8F00h
  1481 00000B43 48B8-                       mov rax, ehci_IRQ
  1481 00000B45 [490B000000000000] 
  1482 00000B4D BB08000000                  mov ebx, codedescriptor
  1483 00000B52 E8(CB000000)                call idtWriteEntry
  1484 00000B57 5B                          pop rbx
  1485 00000B58 58                          pop rax
  1486 00000B59 5A                          pop rdx
  1487 00000B5A 5E                          pop rsi
  1488 00000B5B 51                          push rcx
  1489 00000B5C 2C08                        sub al, 8
  1490 00000B5E 88C1                        mov cl, al
  1491 00000B60 E421                        in al, pic1data
  1492 00000B62 24FB                        and al, 0FBh  ;Clear Cascade bit
  1493 00000B64 E621                        out pic1data, al
  1494 00000B66 B001                        mov al, 1
  1495 00000B68 D2E0                        shl al, cl    ;Shift bit to appropriate position
  1496 00000B6A F6D0                        not al        ;Turn into a bitmask
  1497 00000B6C 88C4                        mov ah, al    ;Save in ah
  1498 00000B6E E4A1                        in al, pic2data
  1499 00000B70 20E0                        and al, ah    ;Add bitmask to current mask
  1500 00000B72 E6A1                        out pic2data, al    ;Unmask this line
  1501 00000B74 59                          pop rcx
  1502                                  .cc1:
  1503 00000B75 89D8                        mov eax, ebx    ;Bring back a copy of ebx, the PCI config space addr to eax
  1504 00000B77 B010                        mov al, 10h     ;Change the register from Class code to BAR0
  1505                                      
  1506 00000B79 66BAF80C                    mov dx, pci_index
  1507 00000B7D EF                          out dx, eax        ;Set to give BAR0
  1508 00000B7E 66BAFC0C                    mov dx, pci_data
  1509 00000B82 ED                          in eax, dx        ;get unrefined BAR0/BASE pointer into eax
  1510                                  
  1511 00000B83 2500FFFFFF                  and eax, 0FFFFFF00h    ;refine eax into an mmio register
  1512 00000B88 50                          push rax    ;push BASE pointer onto stack
  1513                                  
  1514                                  ;Write USB controller table:
  1515                                  ;Each table entry (tword), as follows:
  1516                                  ;Offset:
  1517                                  ; 00h - hci type (bp) [word]
  1518                                  ; 02h - PCI address (ebx) [dword]
  1519                                  ; 06h - MMIO address (eax) [dword]
  1520                                  ;ALL REGISTERS PRESERVED, data stored at usbtablebase, size at usbtablesize
  1521 00000B89 56                          push rsi
  1522 00000B8A 51                          push rcx
  1523 00000B8B 0FB70C2500E00000            movzx ecx, word [lousbtablesize]    ;get number of table entries
  1524 00000B93 89CE                        mov esi, ecx
  1525 00000B95 D1E1                        shl ecx, 1    ;Multiply by 2
  1526 00000B97 678DB4F102E00000            lea esi, [8*esi + ecx + lousbtablebase] 
  1527                                      ;multiply esi by 10 to get table offset & add to table base
  1528                                      ;store table offset back in esi
  1529 00000B9F 6667892E                    mov word [esi], bp    ;Store controller type
  1530 00000BA3 81C602000000                add esi, 2
  1531 00000BA9 67891E                      mov dword [esi], ebx    
  1532                                          ;Store PCI device config space address (set to register 2)
  1533 00000BAC 81C604000000                add esi, 4
  1534 00000BB2 678906                      mov dword [esi], eax    ;Store device MMIO Address (refined BAR0 value)
  1535 00000BB5 59                          pop rcx
  1536 00000BB6 5E                          pop rsi
  1537 00000BB7 66FF042500E00000            inc word [lousbtablesize]
  1538                                  
  1539 00000BBF 6681FD8000                  cmp bp, 80h    ;Are we servicing xHCI, EHCI or UHCI?
  1540 00000BC4 7D7A                        jge .controlxHCI
  1541 00000BC6 6681FD4000                  cmp bp, 40h    ;Are we servicing EHCI or UHCI? 
  1542 00000BCB 0F8DC9000000                jge .controlEHCI
  1543                                  ;If neither of these, collapse into UHCI
  1544                                  .controlUHCI:
  1545                                  ;eax points to the refined base pointer
  1546 00000BD1 53                          push rbx                    ;temp stack save 
  1547 00000BD2 89D8                        mov eax, ebx     ;get the current packed bus,device,function,register combo
  1548 00000BD4 2500F8FFFF                  and eax, 0FFFFF800h         ;Clear bottom 10 bytes.
  1549 00000BD9 0DC0020000                  or eax, 2C0h                ;Function 2, register offset C0h
  1550                                  
  1551 00000BDE 50                          push rax                    ;temp save address value on stack
  1552                                  
  1553 00000BDF 66BAF80C                    mov dx, pci_index
  1554 00000BE3 EF                          out dx, eax
  1555 00000BE4 80C204                      add dl, 4                   ;dx now points to pci_index
  1556 00000BE7 ED                          in eax, dx                  ;Bring register value into eax
  1557                                  
  1558 00000BE8 66B8008F                    mov ax, 8F00h               ;Clear all SMI bits (no SMI pls)
  1559 00000BEC 89C3                        mov ebx, eax                ;save temporarily in ebx
  1560                                  
  1561 00000BEE 58                          pop rax                     ;bring back address value from stack
  1562                                  
  1563 00000BEF 80EA04                      sub dl, 4                   ;put dx back to pci_index
  1564 00000BF2 EF                          out dx, eax                 ;select legsup register
  1565                                  
  1566 00000BF3 80C204                      add dl, 4                   ;aim dx back to pci_data
  1567 00000BF6 89D8                        mov eax, ebx                ;bring back new legsup value
  1568 00000BF8 EF                          out dx, eax                 ;send it back!
  1569                                  
  1570                                  ;Now set bit 6 of the command register to 1 (semaphore)
  1571 00000BF9 5B                          pop rbx                     ;Return original ebx value
  1572 00000BFA 89D8                        mov eax, ebx  ;Move a copy of ebx, PCI config space device address (index)
  1573 00000BFC B020                        mov al, 20h                 ;Change the register from Class code to BAR4 
  1574 00000BFE 6681EA0400                  sub dx, 4                   ;Point dx back to pci_index
  1575 00000C03 EF                          out dx, eax                 ;Get the data we want!
  1576 00000C04 6681C20400                  add dx, 4
  1577 00000C09 ED                          in eax, dx              ;Bring the value of BAR4 into eax, to add to BASE
  1578 00000C0A 25FCFFFFFF                  and eax, 0FFFFFFFCh         ;Refine the IO address that we got
  1579 00000C0F 6689C2                      mov dx, ax                  ;Mov the base IO address into dx
  1580                                  ;dx contains the base io address!
  1581 00000C12 66B80200                    mov ax, 0002h               ;Reset the HC
  1582 00000C16 66EF                        out dx, ax
  1583 00000C18 51                          push rcx
  1584                                  .cu0:
  1585 00000C19 4831C9                      xor rcx, rcx
  1586 00000C1C FEC9                        dec cl
  1587                                  .cu1:
  1588 00000C1E E2FE                        loop .cu1    ;wait
  1589                                  
  1590 00000C20 66ED                        in ax, dx    ;Bring value in
  1591 00000C22 66250200                    and ax, 0002h
  1592 00000C26 75F1                        jnz .cu0     ;Reset still in progress, loop again
  1593 00000C28 59                          pop rcx
  1594                                  
  1595 00000C29 6631C0                      xor ax, ax
  1596 00000C2C 6681C20400                  add dx, 4   ;point to USBINTR
  1597 00000C31 66EF                        out dx, ax
  1598 00000C33 6681EA0400                  sub dx, 4   ;return to cmd
  1599 00000C38 66EF                        out dx, ax  ;zero everything.
  1600                                  
  1601 00000C3A 58                          pop rax     ;Get BASE (dereferenced BAR0) value back (stack align)
  1602 00000C3B E9A8FCFFFF                  jmp .u11                     ;return
  1603                                  ;End UHCI
  1604                                  
  1605                                  .controlxHCI:
  1606                                  ;mov HCCPARAMS1 into edx, eax contains BASE pointer from BAR0 (offset 10h for 
  1607                                  ; register)
  1608 00000C40 678B5010                    mov edx, dword [eax + 10h]    
  1609 00000C44 81E20000FFFF                and edx, 0FFFF0000h
  1610                                  ;mov hi word into lo word and shl by 2 to adjust that we are in units of DWORDS
  1611 00000C4A C1EA0E                      shr edx, 0Eh            
  1612 00000C4D 01D0                        add eax, edx            ;add offset from base onto base
  1613                                                              ;eax now pointing at USBLEGSUP
  1614                                  .suohoc0: 
  1615 00000C4F 678B10                      mov edx, dword [eax]    ;store upper byte of USBLEGSUP into dl
  1616 00000C52 81CA00000001                or edx, (1<<24)         ;Set the HCOSSEM Semaphore
  1617 00000C58 678910                      mov dword [eax], edx    ;replace the upper byte with HCOSSEM set
  1618                                  
  1619 00000C5B 51                          push rcx                ;push poll counter
  1620 00000C5C 4831C9                      xor rcx, rcx            
  1621                                  .suohoc1:    ;Remove control from BIOS and check for confirmation
  1622 00000C5F 66FFC9                      dec cx                  ;drop counter by one
  1623 00000C62 0F84DE000000                jz .weirdEHCI1          ;temporary label
  1624 00000C68 F390                        pause                   ;wait
  1625 00000C6A 678B10                      mov edx, dword [eax]    ;Check if owned by BIOS
  1626 00000C6D 81E200000100                and edx, (1<<16)
  1627 00000C73 75EA                        jnz .suohoc1            ;not zero, keep polling
  1628                                  
  1629 00000C75 66B9FFFF                    mov cx, 0FFFFh
  1630                                  .suohoc2:    ;Check if control to OS has been given
  1631 00000C79 66FFC9                      dec cx
  1632 00000C7C 740D                        jz .suohoc21            ;timeout, assume it has.
  1633 00000C7E F390                        pause                
  1634 00000C80 678B10                      mov edx, dword [eax]
  1635 00000C83 81E200000001                and edx, (1<<24)
  1636 00000C89 74EE                        jz .suohoc2             ;if zero, keep polling until bit set => owned by OS
  1637                                  .suohoc21:    ;Check for legsup being present, assume for now.
  1638 00000C8B 59                          pop rcx                   ;return poll counter
  1639                                  .suohoc3:
  1640 00000C8C 67C7400400000000            mov dword [eax + 4], 0    ;Set all SMI bytes to 0 so no SMIs will be set.
  1641 00000C94 58                          pop rax                   ;Bring back BAR0 into eax
  1642 00000C95 E94EFCFFFF                  jmp .u11                  ;return
  1643                                  
  1644                                  .controlEHCI:
  1645 00000C9A 678B5008                    mov edx, dword [eax + 8h]
  1646 00000C9E 81E200FF0000                and edx, 0000FF00h
  1647 00000CA4 66C1EA08                    shr dx, 8
  1648 00000CA8 81FA40000000                cmp edx, 40h        
  1649 00000CAE 7C05                        jl .ce0            ;No EECP pointer present, skip BIOS/OS EHCI handover
  1650 00000CB0 E81B000000                  call .ehcieecpsetup
  1651                                  .ce0:
  1652 00000CB5 31D2                        xor edx, edx       ;clear edx
  1653 00000CB7 58                          pop rax            ;Bring back refined base into eax
  1654 00000CB8 678B10                      mov edx, dword [eax]
  1655 00000CBB 81E2FF000000                and edx, 000000FFh
  1656 00000CC1 01D0                        add eax, edx
  1657 00000CC3 67816040FEFFFFFF            and dword [eax + 40h], 0FFFFFFFEh
  1658                                                              ;located at offset 40 of the opregs.
  1659                                  
  1660 00000CCB E918FCFFFF                  jmp .u11                ;return
  1661                                  .ehcieecpsetup:
  1662                                  ;eax has hccparams
  1663                                  ;ebx has pci register, to get class code
  1664 00000CD0 50                          push rax
  1665 00000CD1 52                          push rdx
  1666 00000CD2 53                          push rbx
  1667 00000CD3 51                          push rcx
  1668 00000CD4 88D3                        mov bl, dl       ;Move EECP pointer into low byte of PCI address
  1669 00000CD6 89D8                        mov eax, ebx     ;Move this address to eax
  1670 00000CD8 66BAF80C                    mov dx, pci_index
  1671 00000CDC EF                          out dx, eax      ;Return EHCI EECP register
  1672 00000CDD 66BAFC0C                    mov dx, pci_data
  1673 00000CE1 ED                          in eax, dx       ;Get this register into eax
  1674 00000CE2 0D00000001                  or eax, 1000000h ;Set bit 24, to tell bios to give up control!
  1675 00000CE7 93                          xchg eax, ebx    ;Swap these two temporarily
  1676 00000CE8 66BAF80C                    mov dx, pci_index
  1677 00000CEC EF                          out dx, eax
  1678 00000CED 93                          xchg eax, ebx    ;Bring back out value to eax
  1679 00000CEE 66BAFC0C                    mov dx, pci_data
  1680 00000CF2 EF                          out dx, eax      ;Tell BIOS who is boss of the EHCI controller
  1681                                      
  1682 00000CF3 4831C9                      xor rcx, rcx
  1683 00000CF6 89D8                        mov eax, ebx     ;Get address back into eax
  1684                                  .ees1:
  1685 00000CF8 66FFC9                      dec cx
  1686 00000CFB 7449                        jz .weirdEHCI1
  1687 00000CFD E680                        out waitp, al    ;Wait a bit, for device to process request
  1688                                  
  1689 00000CFF 66BAF80C                    mov dx, pci_index
  1690 00000D03 EF                          out dx, eax
  1691 00000D04 66BAFC0C                    mov dx, pci_data
  1692 00000D08 ED                          in eax, dx       ;Get word back into eax
  1693 00000D09 2500000100                  and eax, 10000h  ;BIOS should set this bit to zero
  1694 00000D0E 75E8                        jnz .ees1        ;Not zero yet, try again!
  1695                                  
  1696 00000D10 4831C9                      xor rcx, rcx
  1697 00000D13 89D8                        mov eax, ebx    ;Get address back into eax    
  1698                                  .ees2:
  1699 00000D15 66FFC9                      dec cx
  1700 00000D18 742C                        jz .weirdEHCI1
  1701 00000D1A E680                        out waitp, al    ;Wait a bit, for device to process request
  1702                                  
  1703 00000D1C 66BAF80C                    mov dx, pci_index
  1704 00000D20 EF                          out dx, eax
  1705 00000D21 66BAFC0C                    mov dx, pci_data
  1706 00000D25 ED                          in eax, dx        ;Get word back into eax
  1707 00000D26 2500000001                  and eax, 1000000h    ;This should set this bit to one now (OS control)
  1708 00000D2B 74E8                        jz .ees2        ;Not set yet, try again!
  1709                                  ;Now we have control! :D Finally, now lets clear SMI bits
  1710 00000D2D 81C304000000                add ebx, 4h
  1711 00000D33 89D8                        mov eax, ebx
  1712 00000D35 66BAF80C                    mov dx, pci_index
  1713 00000D39 EF                          out dx, eax
  1714 00000D3A 31C0                        xor eax, eax
  1715 00000D3C 66BAFC0C                    mov dx, pci_data
  1716 00000D40 EF                          out dx, eax        ;NO MORE SMI INTERRUPTS
  1717                                  
  1718 00000D41 59                          pop rcx
  1719 00000D42 5B                          pop rbx
  1720 00000D43 5A                          pop rdx
  1721 00000D44 58                          pop rax
  1722 00000D45 C3                          ret
  1723                                  
  1724                                  .weirdEHCI1:
  1725 00000D46 48B804130000000000-         mov rax, 1304h
  1725 00000D4F 00                 
  1726 00000D50 48BB07000000000000-         mov rbx, 0007h
  1726 00000D59 00                 
  1727 00000D5A 48B931000000000000-         mov rcx, failmsglen
  1727 00000D63 00                 
  1728 00000D64 48BD-                       mov rbp, .failmsg
  1728 00000D66 [730D000000000000] 
  1729 00000D6E CD30                        int 30h    ; write strng
  1730 00000D70 F390                        pause
  1731 00000D72 F4                          hlt
  1732 00000D73 0A0D78484349206F72-     .failmsg: db 0Ah,0Dh,"xHCI or EHCI controller fail, halting system", 0Ah, 0Dh, 0
  1732 00000D7C 204548434920636F6E-
  1732 00000D85 74726F6C6C65722066-
  1732 00000D8E 61696C2C2068616C74-
  1732 00000D97 696E67207379737465-
  1732 00000DA0 6D0A0D00           
  1733                                  failmsglen    equ    $ - .failmsg
  1734                                  
  1735                                  pciExit:
  1736                                  ;----------------------------------------------------------------
  1737                                  ;                            End Proc                           :
  1738                                  ;----------------------------------------------------------------
  1739                                  ;----------------------------------------------------------------
  1740                                  ;                PIT Initialisation procedure                   :
  1741                                  ;----------------------------------------------------------------
  1742                                  PITreset:       ;Set Timer 0 to trigger every 55ms
  1743 00000DA4 B036                        mov al, 36h    ;Set bitmap for frequency write to channel 0 of pit
  1744 00000DA6 E643                        out PITcommand, al    ;43h = PIT command register
  1745 00000DA8 668B0425[35010000]          mov ax, word [pit_divisor]
  1746 00000DB0 E640                        out PIT0, al    ;mov low byte into divisor register
  1747 00000DB2 88E0                        mov al, ah      ;bring hi byte into low byte
  1748 00000DB4 E640                        out PIT0, al    ;mov hi byte into divisor register
  1749                                  ;PIT unmasked below
  1750                                  ;----------------------------------------------------------------
  1751                                  ;                     End of Initialisation                     :
  1752                                  ;----------------------------------------------------------------
  1753                                  ;----------------------------------------------------------------
  1754                                  ;                RTC Initialisation procedure                   :
  1755                                  ;----------------------------------------------------------------
  1756                                  rtc_init:
  1757                                  ;Set tick rate to 1024Hz and ensure RTC doesnt generate IRQ8
  1758 00000DB6 66B88A8A                    mov ax, 8A8Ah    ;Status A register with NMI disable
  1759 00000DBA E670                        out cmos_base, al
  1760 00000DBC E680                        out waitp, al    ;Latch wait
  1761 00000DBE EB00                        jmp short $+2
  1762 00000DC0 B026                        mov al, 00100110b ;32KHz timebase, 1024Hz square wave output
  1763 00000DC2 E671                        out cmos_data, al
  1764                                  ;Now ensure NO interrupts are cooked
  1765 00000DC4 FEC4                        inc ah    ;ah=8Bh
  1766 00000DC6 88E0                        mov al, ah
  1767 00000DC8 E670                        out cmos_base, al
  1768 00000DCA E680                        out waitp, al  ;Latch wait
  1769 00000DCC EB00                        jmp short $+2
  1770 00000DCE B002                        mov al, 02h    ;Zero all int bits, time: BCD, 24hr, Daylight saving off
  1771 00000DD0 E671                        out cmos_data, al
  1772                                  ;Clear any cooked IRQs
  1773 00000DD2 FEC4                        inc ah    ;ah=8Ch
  1774 00000DD4 88E0                        mov al, ah
  1775 00000DD6 E670                        out cmos_base, al
  1776 00000DD8 E680                        out waitp, al    ;Latch wait
  1777 00000DDA EB00                        jmp short $+2
  1778 00000DDC E471                        in al, cmos_data
  1779                                  ;Get final CMOS RAM status byte
  1780 00000DDE B00D                        mov al, 0Dh     ;Status D register with NMI enable
  1781 00000DE0 E670                        out cmos_base, al
  1782 00000DE2 E680                        out waitp, al    ;Latch wait
  1783 00000DE4 EB00                        jmp short $+2
  1784 00000DE6 E471                        in al, cmos_data
  1785                                  ;Unmask RTC and PIT here!
  1786 00000DE8 E4A1                        in al, pic2data    ;Get current state
  1787 00000DEA 24FE                        and al, 0FEh    ;Unmask RTC
  1788 00000DEC E6A1                        out pic2data, al
  1789 00000DEE E421                        in al, pic1data
  1790 00000DF0 24FA                        and al, 0FAh    ;Unmask PIT and Cascade
  1791 00000DF2 E621                        out pic1data, al
  1792 00000DF4 FB                          sti             ;Enable maskable interrupts
  1793                                  ;----------------------------------------------------------------
  1794                                  ;                     End of Initialisation                     :
  1795                                  ;----------------------------------------------------------------
  1796 00000DF5 48B9C8000000000000-         mov rcx, 200    ;Beep for a 200ms
  1796 00000DFE 00                 
  1797 00000DFF BBA9040000                  mov ebx, 04A9h  ;Frequency divisor for 1000Hz tone
  1798 00000E04 66B800C5                    mov ax, 0C500h
  1799 00000E08 CD35                        int 35h
  1800                                  ;----------------------------------------------------------------
  1801                                  ;                Serial Port Initialisation procedure           :
  1802                                  ;----------------------------------------------------------------
  1803                                  ;Initial init procedure, check which ports exist and 
  1804                                  ; write the address to Data area
  1805 00000E0A 66B85A5A                    mov ax, 5A5Ah
  1806 00000E0E 4831C9                      xor rcx, rcx
  1807 00000E11 48BD-                       mov rbp, com_addresses
  1807 00000E13 [6700000000000000] 
  1808                                  checkCOM:
  1809 00000E1B 668B9409[A41A0000]          mov dx, word [serial_abt + rcx*2]    ;Multiplied by 2 for word offsets
  1810 00000E23 6681C20700                  add dx, 7    ;Scratch register
  1811 00000E28 EE                          out dx, al    ;Output
  1812 00000E29 EB00                        jmp short $ + 2
  1813 00000E2B EC                          in al, dx    ;Read the value
  1814 00000E2C 38C4                        cmp ah, al   ;Check if theyre the same 
  1815 00000E2E 7514                        jne COMinitproceed ;Scratch register non-existant, IO registers not present
  1816 00000E30 6681EA0700                  sub dx, 7    ;point dx back to base
  1817 00000E35 66899409[67000000]          mov word [com_addresses + rcx*2], dx    ;Save dx into data area table
  1818 00000E3D FEC1                        inc cl
  1819 00000E3F 80F904                      cmp cl, 4
  1820 00000E42 75D7                        jne checkCOM    ;Keep looping
  1821                                  COMinitproceed:
  1822                                  ;Sets all active COM ports to 2400,N,8,1, FIFO on, hware handshaking
  1823 00000E44 880C25[66000000]            mov byte [numCOM], cl
  1824 00000E4B 30C9                        xor cl, cl
  1825                                  serialinit:
  1826 00000E4D 668B9409[67000000]          mov dx, word [com_addresses + rcx*2]  ;get the serial port base addr in dx
  1827 00000E55 6685D2                      test dx, dx
  1828 00000E58 743E                        jz COMinitexit    ;invalid address, port doesnt exist, init complete
  1829                                  ;Disable interrupts
  1830 00000E5A 66FFC2                      inc dx        ;point at base + 1
  1831 00000E5D 30C0                        xor al, al    ;get zero to out it to the interrupt register
  1832 00000E5F EE                          out dx, al    ;Disable all interrupts
  1833                                  ;Set DLAB
  1834 00000E60 6681C20200                  add dx, 2    ;point dx to the Line Control register (LCR)
  1835 00000E65 EC                          in al, dx    ;get the LCR byte into al
  1836 00000E66 0C80                        or al, 10000000b    ;set bit 7, DLAB bit on
  1837 00000E68 EE                          out dx, al    ;output the set bit
  1838                                  ;Set baud rate
  1839 00000E69 6681EA0300                  sub dx, 3    ;word of baud divisor
  1840 00000E6E 66B83000                    mov ax, 0030h    ;the divisor for 2400 baud (cf table below)
  1841 00000E72 66EF                        out dx, ax    ;out put the divisor word
  1842                                  ;Clear DLAB, set the parity, break stop and word length
  1843 00000E74 6681C20300                  add dx, 3    ;repoint at LCR (base + 3)
  1844 00000E79 B003                        mov al, 00000011b  ;DLAB off, 8,n,1, no break, no stick
  1845 00000E7B EE                          out dx, al    ;out that byte
  1846                                  ;Clear FIFO
  1847 00000E7C 66FFCA                      dec dx        ;base + 2, FIFO register
  1848 00000E7F B006                        mov al, 00000110b    ;Clear FIFO, set char mode
  1849 00000E81 EE                          out dx, al    ;out that stuff
  1850                                  ;Enable interrupts and RTS/DTR
  1851 00000E82 66FFCA                      dec dx        ;base + 1, Interrupt Enable Register
  1852 00000E85 B001                        mov al, 1     ;ONLY set the data receive interrupt, none of the other 
  1853                                                    ; status or transmit type interrupts
  1854 00000E87 EE                          out dx, al
  1855                                  
  1856 00000E88 6681C20300                  add dx, 3    ;base + 4, Modem control register
  1857 00000E8D EC                          in al, dx    ;preserve reserved upper bits
  1858 00000E8E 24E0                        and al, 11100000b
  1859 00000E90 0C0B                        or al, 00001011b    ;Set OUT2 (ie IRQ enable), set RTS/DTR.
  1860 00000E92 EE                          out dx, al
  1861 00000E93 66FFC1                      inc cx
  1862 00000E96 EBB5                        jmp short serialinit
  1863                                  COMinitexit:
  1864                                  ;Unmask com ports here!
  1865 00000E98 E421                        in al, pic1data
  1866 00000E9A 24E7                        and al, 0E7h    ;Unmask Com lines 1 and 2 (bits 3 and 4)
  1867 00000E9C E621                        out pic1data, al
  1868                                  ;----------------------------------------------------------------
  1869                                  ;                     End of Initialisation                     :
  1870                                  ;----------------------------------------------------------------
  1871                                  
  1872                                  ;----------------------------------------------------------------
  1873                                  ;             PS/2 Keyboard Initialisation procedure            :
  1874                                  ;----------------------------------------------------------------
  1875                                  keybsetup:    ;proc near
  1876 00000E9E 66B80A0E                    mov ax, 0E0Ah
  1877 00000EA2 CD30                        int 30h
  1878 00000EA4 66B80D0E                    mov ax, 0E0Dh
  1879 00000EA8 CD30                        int 30h    ;Send a crlf to con
  1880                                  
  1881 00000EAA 66B80413                    mov ax, 1304h
  1882 00000EAE 30FF                        xor bh, bh
  1883 00000EB0 48BD-                       mov rbp, ps2stage.startMsg ;Prompt to strike a key
  1883 00000EB2 [DB11000000000000] 
  1884 00000EBA CD30                        int 30h
  1885                                  
  1886 00000EBC B05F                        mov al, 05Fh        ;PS/2 Stage signature
  1887 00000EBE E680                        out waitp, al
  1888 00000EC0 E6E9                        out bochsout, al    
  1889                                  
  1890 00000EC2 4D31C0                      xor r8, r8          ;use as an stage counter 
  1891 00000EC5 E926000000                  jmp .step1
  1892                                  .kbscdetermine:
  1893 00000ECA B0F0                        mov al, 0F0h    
  1894 00000ECC E8C5020000                  call ps2talk.p3
  1895 00000ED1 E8AB020000                  call ps2talk.p1
  1896 00000ED6 3CFA                        cmp al, 0FAh        ;ACK?
  1897 00000ED8 75F0                        jne .kbscdetermine  ;Not ack, try again
  1898                                  .pt1:
  1899 00000EDA 30C0                        xor al, al
  1900 00000EDC E8B5020000                  call ps2talk.p3
  1901 00000EE1 E89B020000                  call ps2talk.p1     ;Get ack into al, 
  1902 00000EE6 3CFA                        cmp al, 0FAh
  1903 00000EE8 75F0                        jne .pt1
  1904 00000EEA E892020000                  call ps2talk.p1     ;Get scancode into al
  1905 00000EEF C3                          ret
  1906                                  
  1907                                  ;----------------------------------------------------------------
  1908                                  ;Do all writes using ps2talk:
  1909                                  ;    ah = 0 - Read Status port into al
  1910                                  ;    ah = 1 - Read Data port into al
  1911                                  ;    ah = 2 - Write al into Command port 
  1912                                  ;    ah = 3 - Write al into Data port
  1913                                  ;----------------------------------------------------------------
  1914                                  ; Step 1) Disable ps2 port 1 using command word ADh and port 2 using command 
  1915                                  ;  word A7h.
  1916                                  ; Step 2) Flush buffer and check bit 2 is set (else fail)
  1917                                  ; Step 3) Read controller configuration byte (command word 20h)
  1918                                  ; Step 4) Disable IRQs bits 0,1 (clear bit 0,1) [and manually disable second 
  1919                                  ;  ps2 port (bit 5 set)]
  1920                                  ; Step 5) Write controller config byte back (command word 60h)
  1921                                  ; Step 6) Test controller using AAh command word. Return 55h or fail.
  1922                                  ; Step 7) Test ps2 port 1 using ABh command word. Return 00h or fail.
  1923                                  ; Step 8) Enable ps2 port 1 using AEh command word. Enable IRQ by setting bit 0 
  1924                                  ;  of the config byte.
  1925                                  ; Step 9) Reset ps2 port 1 device using FFh data word. If AAh returned, 
  1926                                  ;  proceed, else if ACK (FAh), await AAh. FCh and FDh indicate fail. FEh = 
  1927                                  ;  resend command.
  1928                                  ; Step 10) Reset scan code set to 1 using F0h data word with 01h data word. If 
  1929                                  ;  ACK (FAh) proceed, if RESEND (FEh), resend 10h tries.
  1930                                  ; Setp 11) Enable scanning (ie keyboard sends scan codes) using data word F4h.
  1931                                  ;----------------------------------------------------------------
  1932                                  ;Step 1
  1933                                  .step1:
  1934 00000EF0 B0AD                        mov al, 0ADh
  1935 00000EF2 E897020000                  call ps2talk.p2
  1936 00000EF7 B0A7                        mov al, 0A7h        ;Cancel second interface if it exists (DO NOT REENABLE)
  1937 00000EF9 E890020000                  call ps2talk.p2
  1938                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1939 00000EFE 49FFC0                      inc r8           ;Checkpoint 1
  1940 00000F01 E8CB020000                  call ps2stage    ;print which stage is complete
  1941                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1942                                  ;Step 2
  1943                                  
  1944 00000F06 E460                        in al, ps2data     ;manually flush ps2data port
  1945                                      
  1946                                  ;Step 3
  1947                                  keyb0:
  1948 00000F08 B020                        mov al, 20h
  1949 00000F0A E87F020000                  call ps2talk.p2    ;out ps2command, al
  1950 00000F0F E86D020000                  call ps2talk.p1    ;Read config byte into al
  1951                                  ;Step 4
  1952 00000F14 88C3                        mov bl, al         ;copy al into bl to check for bit 2
  1953 00000F16 80E3BC                      and bl, 10111100b  ;Disable translation, enable later if needed
  1954                                  ;Step 5
  1955 00000F19 B060                        mov al, 60h
  1956 00000F1B E86E020000                  call ps2talk.p2    ;Write config byte command
  1957 00000F20 88D8                        mov al, bl
  1958 00000F22 E86F020000                  call ps2talk.p3    ;Out new config byte
  1959                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1960 00000F27 49FFC0                      inc r8             ;Checkpoint 2
  1961 00000F2A E8A2020000                  call ps2stage      ;print which stage is complete
  1962                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1963                                  ;Step 6
  1964 00000F2F B0AA                        mov al, 0AAh ;Can reset the config byte, out bl to ps2data at end of stage
  1965 00000F31 E858020000                  call ps2talk.p2
  1966 00000F36 E846020000                  call ps2talk.p1
  1967 00000F3B 3C55                        cmp al, 55h
  1968 00000F3D 0F855B020000                jne ps2error
  1969                                      
  1970 00000F43 B060                        mov al, 60h  ;Previous code may have reset our new config byte, resend it!
  1971 00000F45 E844020000                  call ps2talk.p2            ;Write config byte command
  1972 00000F4A 88D8                        mov al, bl
  1973 00000F4C E845020000                  call ps2talk.p3            ;Out new config byte
  1974                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1975 00000F51 49FFC0                      inc r8             ;Checkpoint 3
  1976 00000F54 E878020000                  call ps2stage      ;print which stage is complete
  1977                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1978                                  ;Step 7
  1979 00000F59 B0AB                        mov al, 0ABh            ;Test controller 1
  1980 00000F5B E82E020000                  call ps2talk.p2
  1981 00000F60 E81C020000                  call ps2talk.p1
  1982 00000F65 84C0                        test al, al                ;Check al is zero
  1983 00000F67 0F8531020000                jnz ps2error
  1984                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1985 00000F6D 49FFC0                      inc r8             ;Checkpoint 4
  1986 00000F70 E85C020000                  call ps2stage      ;print which stage is complete
  1987                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  1988                                  ;Step 8
  1989 00000F75 B0AE                        mov al, 0AEh
  1990 00000F77 E812020000                  call ps2talk.p2
  1991                                  
  1992                                  ;Set IRQ 1 to connect to port 1
  1993 00000F7C B020                        mov al, 20h
  1994 00000F7E E80B020000                  call ps2talk.p2        ;Write
  1995 00000F83 E8F9010000                  call ps2talk.p1        ;Read
  1996 00000F88 0C01                        or al, 00000001b    ;Set bit 0
  1997 00000F8A 24EF                        and al, 11101111b    ;Zero bit 4, First port Clock
  1998 00000F8C 88C3                        mov bl, al
  1999 00000F8E B060                        mov al, 60h
  2000 00000F90 E8F9010000                  call ps2talk.p2
  2001 00000F95 88D8                        mov al, bl
  2002 00000F97 E8FA010000                  call ps2talk.p3
  2003                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2004 00000F9C 49FFC0                      inc r8           ;Checkpoint 5
  2005 00000F9F E82D020000                  call ps2stage    ;print which stage is complete
  2006                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2007                                  ;Step 9
  2008 00000FA4 6631C9                      xor cx, cx
  2009                                  keyb1:
  2010 00000FA7 66FFC9                      dec cx ;timeout counter
  2011 00000FAA 0F84EE010000                jz ps2error
  2012 00000FB0 B0FF                        mov al, 0FFh
  2013 00000FB2 E8DF010000                  call ps2talk.p3
  2014                                  .k1:
  2015 00000FB7 E8C5010000                  call ps2talk.p1 ;read from ps2data
  2016 00000FBC 3CAA                        cmp al, 0AAh    ;success
  2017 00000FBE 7409                        je keyb20
  2018 00000FC0 3CFA                        cmp al, 0FAh    ;ACK    
  2019 00000FC2 74F3                        je .k1          ;Loop if ACK recieved, just read ps2data
  2020 00000FC4 E9DEFFFFFF                  jmp keyb1       ;Else, loop whole thing (assume fail recieved)
  2021                                  ;Step 10
  2022                                  keyb20:
  2023                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2024 00000FC9 49FFC0                      inc r8           ;Checkpoint 6
  2025 00000FCC E800020000                  call ps2stage    ;print which stage is complete
  2026                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2027 00000FD1 31C9                        xor ecx, ecx
  2028                                  keyb2:
  2029 00000FD3 FFC9                        dec ecx
  2030 00000FD5 0F84C3010000                jz ps2error
  2031                                  .k0:
  2032 00000FDB B0F0                        mov al, 0F0h
  2033 00000FDD E8B4010000                  call ps2talk.p3
  2034                                      
  2035 00000FE2 B401                        mov ah, 01h
  2036 00000FE4 E898010000                  call ps2talk.p1
  2037 00000FE9 3CFE                        cmp al, 0FEh    ;Did we recieve an resend?
  2038 00000FEB 74EE                        je .k0          ;Resend the data!
  2039 00000FED 3CFA                        cmp al, 0FAh    ;Compare to Ack?
  2040 00000FEF 75E2                        jne keyb2       ;If not equal, dec one from the loop counter and try again
  2041                                      
  2042 00000FF1 B001                        mov al, 01h     ;write 01 to data port (set scan code set 1)
  2043 00000FF3 E89E010000                  call ps2talk.p3
  2044                                  .k1:
  2045 00000FF8 E884010000                  call ps2talk.p1    ;read data port for ACK or resend response
  2046 00000FFD 3CFA                        cmp al, 0FAh
  2047 00000FFF 7407                        je keyb30    ;IF ack revieved, scancode set, advance.
  2048 00001001 E2F5                        loop .k1     ;Keep polling port
  2049 00001003 E9CBFFFFFF                  jmp keyb2
  2050                                  ;Step 11
  2051                                  keyb30:
  2052                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2053 00001008 49FFC0                      inc r8           ;Checkpoint 7
  2054 0000100B E8C1010000                  call ps2stage    ;print which stage is complete
  2055                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2056 00001010 31C9                        xor ecx, ecx
  2057                                  keyb3:
  2058 00001012 66FFC9                      dec cx
  2059 00001015 0F8483010000                jz ps2error
  2060                                      
  2061 0000101B B0F4                        mov al, 0F4h
  2062 0000101D E874010000                  call ps2talk.p3
  2063                                  .k1:
  2064 00001022 E85A010000                  call ps2talk.p1 ;read data port for ACK or resend response
  2065 00001027 3CFA                        cmp al, 0FAh
  2066 00001029 7407                        je keyb40
  2067 0000102B E2F5                        loop .k1        ;Keep polling port
  2068 0000102D E9E0FFFFFF                  jmp keyb3       ;Fail, retry the whole process
  2069                                      
  2070                                  ;Step 12
  2071                                  keyb40:
  2072                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2073 00001032 49FFC0                      inc r8           ;Checkpoint 8
  2074 00001035 E897010000                  call ps2stage    ;print which stage is complete
  2075                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2076                                  keyb4:
  2077 0000103A B0ED                        mov al, 0EDh     ;Set lights
  2078 0000103C E855010000                  call ps2talk.p3
  2079 00001041 E83B010000                  call ps2talk.p1  ;get response, remember ps2talk does its own timeout
  2080 00001046 3CFA                        cmp al, 0FAh
  2081 00001048 75F0                        jne keyb4        ;No ack, try again.
  2082                                  .k1:
  2083 0000104A B000                        mov al, 00h        ;Flash lock on and off
  2084 0000104C E845010000                  call ps2talk.p3
  2085 00001051 E82B010000                  call ps2talk.p1    ;flush, remember ps2talk does its own timeout
  2086                                      
  2087                                  ;End Proc
  2088                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2089 00001056 49FFC0                      inc r8           ;Checkpoint 9
  2090 00001059 E873010000                  call ps2stage    ;print which stage is complete
  2091                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2092                                  
  2093                                  keyb5:
  2094 0000105E B0EE                        mov al, 0EEh     ;Echo command
  2095 00001060 E831010000                  call ps2talk.p3
  2096 00001065 30C0                        xor al, al       ;Zero al to ensure that the result is EEh
  2097                                  .k1:
  2098 00001067 E815010000                  call ps2talk.p1
  2099 0000106C 3CEE                        cmp al, 0EEh
  2100 0000106E 7429                        je .k2           ;If equal, continue
  2101 00001070 48BD-                       mov rbp, .noecho
  2101 00001072 [8610000000000000] 
  2102 0000107A 66B80413                    mov ax, 1304h
  2103 0000107E 30FF                        xor bh, bh
  2104 00001080 CD30                        int 30h
  2105 00001082 F390                        pause
  2106 00001084 EB13                        jmp short .k2
  2107 00001086 4E6F204563686F2072-     .noecho:        db    "No Echo recieved", 0Ah, 0Dh, 0
  2107 0000108F 656369657665640A0D-
  2107 00001098 00                 
  2108                                  .k2:
  2109                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2110 00001099 49FFC0                      inc r8           ;Checkpoint 0Ah
  2111 0000109C E830010000                  call ps2stage    ;print which stage is complete
  2112                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2113                                  keyb6:    ;Set typematic rate/delay, 250ms, 30 reports/second
  2114 000010A1 B0F3                        mov al, 0F3h     ;Set typematic rate
  2115 000010A3 E8EE000000                  call ps2talk.p3
  2116 000010A8 30C0                        xor al, al       ;Set rate
  2117 000010AA E8E7000000                  call ps2talk.p3
  2118 000010AF 6631C9                      xor cx, cx
  2119                                  .k1:
  2120 000010B2 66FFC9                      dec cx
  2121 000010B5 0F84E3000000                jz ps2error
  2122 000010BB E8C1000000                  call ps2talk.p1
  2123 000010C0 3CFA                        cmp al, 0FAh    ;Ack?
  2124 000010C2 75EE                        jnz .k1
  2125                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2126 000010C4 49FFC0                      inc r8           ;Checkpoint 0Bh
  2127 000010C7 E805010000                  call ps2stage    ;print which stage is complete
  2128                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2129                                  scancode_faff:
  2130 000010CC B020                        mov al, 20h      ;Get command byte from command port
  2131 000010CE E8BB000000                  call ps2talk.p2  ;al should contain command byte
  2132 000010D3 88C4                        mov ah, al       ;temp save cmd byte in ah
  2133                                  
  2134 000010D5 31C9                        xor ecx, ecx
  2135                                  .p1:
  2136 000010D7 66FFC9                      dec cx
  2137 000010DA 7439                        jz keybflushe
  2138 000010DC E8E9FDFFFF                  call keybsetup.kbscdetermine ;Get the current scancode set id
  2139 000010E1 80CC01                      or ah, 00000001b    ;Do basic or, ie set IRQ for port 1
  2140                                  
  2141                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2142 000010E4 49FFC0                      inc r8           ;Checkpoint 0Ch
  2143 000010E7 E8E5000000                  call ps2stage    ;print which stage is complete
  2144                                  ;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
  2145                                  
  2146 000010EC 3C43                        cmp al, 43h      ;43h is sc1 signature
  2147 000010EE 740B                        je .writeback
  2148 000010F0 3C01                        cmp al, 01h      ;Untranslated value
  2149 000010F2 7407                        je .writeback
  2150 000010F4 3CFA                        cmp al, 0FAh     ;Got an ACK for some reason, manually get next byte
  2151 000010F6 7416                        je .get_next_byte
  2152                                  
  2153 000010F8 80CC40                      or ah, 01000000b    ;Neither value passed the test, invoke translation
  2154                                  .writeback:
  2155 000010FB 4989C7                      mov r15, rax     ;Save the scancode value to print later
  2156 000010FE B060                        mov al, 60h
  2157 00001100 E889000000                  call ps2talk.p2
  2158 00001105 88E0                        mov al, ah       ;return command byte
  2159 00001107 E88A000000                  call ps2talk.p3
  2160 0000110C EB0B                        jmp short keybflush
  2161                                  .get_next_byte:
  2162 0000110E E86E000000                  call ps2talk.p1  ;Get the byte safely into al!
  2163 00001113 EBC2                        jmp short .p1    ;Recheck the scancode signature
  2164                                  
  2165                                  keybflushe:
  2166 00001115 4180CFF0                    or r15b,0F0h    ;Add signature to scancode value denoting error
  2167                                  keybflush:    ;Flush internal ram of random bytes before enabling IRQ1
  2168 00001119 66B91000                    mov cx, 10h
  2169                                  .kbf1:
  2170 0000111D 66FFC9                      dec cx
  2171 00001120 7404                        jz keybinitend
  2172 00001122 E460                        in al, ps2data        ;Read 16 bytes out (even if empty) and discard
  2173 00001124 EBF7                        jmp short .kbf1
  2174                                  
  2175                                  keybinitend:
  2176 00001126 30FF                        xor bh, bh  ;We are on page 0
  2177 00001128 B403                        mov ah, 03h ;Get current cursor row number in dh 
  2178 0000112A CD30                        int 30h
  2179 0000112C B211                        mov dl, 17  ;End of PS/2 Keyboard message at column 17
  2180 0000112E 30FF                        xor bh, bh  ;Page 0
  2181 00001130 B402                        mov ah, 02h ;Set cursor
  2182 00001132 CD30                        int 30h
  2183                                  
  2184 00001134 52                          push rdx    ;Save row/column in dx on stack
  2185 00001135 B91B000000                  mov ecx, 27 ;27 chars in keystrike message
  2186                                  .kbe0:
  2187 0000113A B8200E0000                  mov eax, 0E20h 
  2188 0000113F CD30                        int 30h
  2189 00001141 E2F7                        loop .kbe0
  2190                                  
  2191 00001143 5A                          pop rdx
  2192 00001144 30FF                        xor bh, bh  ;Page 0
  2193 00001146 B402                        mov ah, 02h ;Set cursor
  2194 00001148 CD30                        int 30h
  2195                                  
  2196 0000114A 48BD-                       mov rbp, ps2stage.okMsg
  2196 0000114C [0A12000000000000] 
  2197 00001154 48B804130000000000-         mov rax, 1304h    ;print 0 terminated string
  2197 0000115D 00                 
  2198 0000115E 30FF                        xor bh, bh
  2199 00001160 CD30                        int 30h
  2200                                  
  2201                                  ;Unmask IRQ1 here
  2202 00001162 E421                        in al, pic1data
  2203 00001164 24FD                        and al, 0FDh    ;Unmask bit 1
  2204 00001166 E621                        out pic1data, al
  2205                                  
  2206 00001168 E9A0000000                  jmp debuggerInit
  2207                                  ;Relevant Procs for PS/2 keyboard setup
  2208                                  ps2talk:
  2209                                  ;   ah = 0 - Read Status port into al
  2210                                  ;   ah = 1 - Read Data port into al
  2211                                  ;   ah = 2 - Write al into Command port 
  2212                                  ;   ah = 3 - Write al into Data port
  2213 0000116D 84E4                        test ah, ah
  2214 0000116F 740D                        jz .p0
  2215 00001171 FECC                        dec ah
  2216 00001173 740C                        jz .p1
  2217 00001175 FECC                        dec ah
  2218 00001177 7415                        jz .p2
  2219 00001179 E918000000                  jmp .p3
  2220                                  .p0:
  2221 0000117E E464                        in al, ps2status
  2222 00001180 C3                          ret
  2223                                  .p1:
  2224 00001181 EB00                        jmp short $ + 2
  2225 00001183 E464                        in al, ps2status
  2226 00001185 A801                        test al, 1    ;Can something be read from KB?
  2227 00001187 74F8                        jz .p1        ;Zero if no. Not zero = read.
  2228 00001189 EB00                        jmp short $ + 2
  2229 0000118B E460                        in al, ps2data  ;Read it in
  2230 0000118D C3                          ret
  2231                                  .p2:
  2232 0000118E E8(B6000000)                call ps2wait    ;preserves ax
  2233 00001193 E664                        out ps2command, al
  2234 00001195 C3                          ret
  2235                                  .p3:
  2236 00001196 E8(B6000000)                call ps2wait
  2237 0000119B E660                        out ps2data, al
  2238 0000119D C3                          ret
  2239                                  ps2error:
  2240 0000119E 48BD-                       mov rbp, .ps2errormsg
  2240 000011A0 [B411000000000000] 
  2241 000011A8 66B80413                    mov ax, 1304h
  2242 000011AC 30FF                        xor bh, bh
  2243 000011AE CD30                        int 30h
  2244                                  .loop:
  2245 000011B0 F390                        pause
  2246 000011B2 EBFC                        jmp short .loop
  2247 000011B4 0A0D50532F32207374-     .ps2errormsg: db 0Ah, 0Dh,"PS/2 stage init error...", 0Ah, 0Dh, 0
  2247 000011BD 61676520696E697420-
  2247 000011C6 6572726F722E2E2E0A-
  2247 000011CF 0D00               
  2248                                  
  2249                                  ps2stage:
  2250                                  ;Outputs r8b to waitport and Bochs out
  2251 000011D1 50                          push rax
  2252 000011D2 4488C0                      mov al, r8b
  2253 000011D5 E680                        out waitp, al
  2254 000011D7 E6E9                        out bochsout, al
  2255 000011D9 58                          pop rax
  2256 000011DA C3                          ret
  2257 000011DB 0A0D50532F32204B65-     .startMsg db 0Ah, 0Dh,'PS/2 Keyboard... Strike a key to continue...',0 
  2257 000011E4 79626F6172642E2E2E-
  2257 000011ED 20537472696B652061-
  2257 000011F6 206B657920746F2063-
  2257 000011FF 6F6E74696E75652E2E-
  2257 00001208 2E00               
  2258 0000120A 4F4B00                  .okMsg db 'OK', 0 ;This should go 17 chars in
  2259                                  ;----------------------------------------------------------------
  2260                                  ;                      End of Initialisation                    :
  2261                                  ;----------------------------------------------------------------
  2262                                  ;----------------------------------------------------------------
  2263                                  ;              Debugger Initialisation procedures               :
  2264                                  ;----------------------------------------------------------------
  2265                                  debuggerInit:
  2266                                  ;Int 40h can be used by the Debugger to return to it or if a DOS present, 
  2267                                  ; to return to DOS.
  2268 0000120D 48B8-                       mov rax, MCP_int ;The application return point
  2268 0000120F [DF20000000000000] 
  2269 00001217 48BE40000000000000-         mov rsi, 40h
  2269 00001220 00                 
  2270 00001221 66BA008F                    mov dx, 8F00h    ;Attribs
  2271 00001225 BB08000000                  mov ebx, codedescriptor
  2272 0000122A E8(CB000000)                call idtWriteEntry    
  2273                                  ;----------------------------------------------------------------
  2274                                  ;              Drive Enum and Initialisation procedures         :
  2275                                  ;----------------------------------------------------------------
  2276                                  ideInitialisation:
  2277                                  ;This is truly read once code
  2278                                  ;Check primary and secondary bus for master and slave drives
  2279                                  ; Maximum of 4 "fixed" ATA drives
  2280                                  ;Use PIO for identification of drives on bus
  2281 0000122F EB15                        jmp short hciParse
  2282 00001231 B0A0                        mov al, 0A0h
  2283 00001233 66BAF001                    mov dx, ata0_base
  2284 00001237 48BF-                       mov rdi, sectorbuffer
  2284 00001239 [C003000000000000] 
  2285 00001241 E8(2D320000)                call IDE.identifyDevice
  2286                                  
  2287                                  ;            ------------USB section below------------
  2288                                  ;                   ---- PCI table parse ----
  2289                                  ;Parse the PCI tables for ehci controllers
  2290                                  hciParse:
  2291 00001246 C60425[4B020000]00          mov byte [numMSD], 0
  2292 0000124E 4C0FB70C2500E00000          movzx r9, word [lousbtablesize]
  2293 00001257 BE02E00000                  mov esi, lousbtablebase
  2294 0000125C BF[15020000]                mov edi, eControllerList
  2295                                  .hcip1:
  2296 00001261 6667F7064000                test word [esi], ehcimask    ;check if we at a ehci mask
  2297 00001267 7418                        jz .hcip2   ;If not, skip adding to ehci table
  2298                                      ;First catch all clause (temporary for version 1 of BIOS with max 4 
  2299                                      ; controllers)
  2300 00001269 803C25[14020000]04          cmp byte [eControllers], 4
  2301 00001271 7430                        je .pr0    ;escape this whole setup proc if at 4 controllers
  2302 00001273 67488B4602                  mov rax, qword [esi + 2]    ;take pci and mmio address into rax
  2303 00001278 48AB                        stosq                        ;store into rdi and inc rdi by 8 to next entry
  2304 0000127A FE0425[14020000]            inc byte [eControllers]    ;increase the number of controllers variable
  2305                                  .hcip2:
  2306                                  ;Any additional data saving occurs here
  2307 00001281 81C60A000000                add esi, 10    ;Goto next table entry
  2308 00001287 41FEC9                      dec r9b     ;Once all table entries exhausted, fall through
  2309 0000128A 75D5                        jnz .hcip1
  2310                                      
  2311                                  ;               ---- EHCI controller enumeration ----
  2312                                  ;Enumerate each ehci ctrlr root hub for valid usb devices (hubs and valid MSD)
  2313 0000128C 8A0C25[14020000]            mov cl, byte [eControllers]
  2314 00001293 66B80413                    mov ax, 1304h
  2315 00001297 48BD-                       mov rbp, .echiInitMsg
  2315 00001299 [1B13000000000000] 
  2316 000012A1 CD30                        int 30h
  2317                                  .pr0:   ;If ctrlr failure or ports exhausted, ret to here for next ctrlr
  2318 000012A3 84C9                        test cl, cl
  2319 000012A5 0F8409020000                jz end    ;No EHCI controllers or last controler? Exit
  2320 000012AB FEC9                        dec cl    ;Undo the absolute count from above
  2321 000012AD 88C8                        mov al, cl
  2322 000012AF E8(BD320000)                call USB.setupEHCIcontroller
  2323 000012B4 72ED                        jc .pr0    ;Continue to next controller
  2324 000012B6 E8(38340000)                call USB.ehciRunCtrlr       ;Activate online controller
  2325 000012BB 72E6                        jc .pr0
  2326 000012BD E8(99340000)                call USB.ehciAdjustAsyncSchedCtrlr ;Start schedule and lock ctrlr as online
  2327 000012C2 72DF                        jc .pr0
  2328 000012C4 E8(16350000)                call USB.ehciCtrlrGetNumberOfPorts
  2329 000012C9 88C2                        mov dl, al      ;Save the number of ports in dl
  2330 000012CB 8A3425[47020000]            mov dh, byte [eActiveCtrlr]    ;Save current active ctrlr in dh
  2331 000012D2 4D31D2                      xor r10, r10    ;Host hub 0 [ie Root Hub enum only] (for enum)
  2332                                  .pr1:
  2333 000012D5 FECA                        dec dl
  2334 000012D7 49BC03000000000000-         mov r12, 3      ;Attempt three times to enumerate
  2334 000012E0 00                 
  2335                                  .pr11:
  2336 000012E1 E8(B2380000)                call USB.ehciEnumerateRootPort
  2337 000012E6 7413                        jz .pr2
  2338 000012E8 803C25[A9010000]20          cmp byte [msdStatus], 20h  ;General Controller Failure
  2339 000012F0 0F84(82320000)              je USB.ehciCriticalErrorWrapper
  2340 000012F6 49FFCC                      dec r12
  2341 000012F9 75E6                        jnz .pr11
  2342                                  .pr2:
  2343 000012FB 84D2                        test dl, dl
  2344 000012FD 75D6                        jnz .pr1
  2345 000012FF 84C9                        test cl, cl ;Once cl is zero we have gone through all controllers
  2346 00001301 75A0                        jnz .pr0
  2347                                  
  2348 00001303 B804130000                  mov eax, 1304h
  2349 00001308 48BD-                       mov rbp, remDevInit.ok
  2349 0000130A [1F14000000000000] 
  2350 00001312 30FF                        xor bh, bh
  2351 00001314 CD30                        int 30h
  2352 00001316 E929000000                  jmp remDevInit
  2353 0000131B 0A0D496E697469616C-     .echiInitMsg db 0Ah,0Dh,"Initialising USB and EHCI root hubs...",0
  2353 00001324 6973696E6720555342-
  2353 0000132D 20616E642045484349-
  2353 00001336 20726F6F7420687562-
  2353 0000133F 732E2E2E00         
  2354                                  remDevInit:
  2355                                  ;Devices on root hubs have been enumerated, and added to tables,
  2356                                  ;Now we reset them (in the case of MSD) and enumerate further (on Hubs)
  2357 00001344 66B80413                    mov ax, 1304h
  2358 00001348 80F70B                      xor bh, 0bh
  2359 0000134B 48BD-                       mov rbp, .rmhmsg
  2359 0000134D [0314000000000000] 
  2360 00001355 CD30                        int 30h
  2361                                  .hubs_init:
  2362 00001357 48BE-                       mov rsi, hubDevTbl
  2362 00001359 [6A02000000000000] 
  2363                                  ;First we scan for hubs only
  2364                                  .redi1:
  2365 00001361 803E00                      cmp byte [rsi], 0   ;Not an entry
  2366 00001364 7417                        jz .hubnextentry
  2367 00001366 807E0500                    cmp byte [rsi + 5], 0   ;If number of ports on hub is 0, dev uncofigured
  2368 0000136A 7511                        jnz .hubnextentry  ;Device must be already enumerated
  2369                                  
  2370 0000136C 8A4601                      mov al, byte [rsi + 1]  ;Get bus number into al
  2371                                  
  2372 0000136F E8(99340000)                call USB.ehciAdjustAsyncSchedCtrlr
  2373 00001374 7207                        jc .hubnextentry
  2374                                  
  2375 00001376 E8(013F0000)                call USB.ehciDevSetupHub  ;Only needs a valid device in rsi
  2376 0000137B 7200                        jc .hubnextentry
  2377                                  .hubnextentry:
  2378 0000137D 4881C608000000              add rsi, hubDevTblEntrySize ;Goto next table entry
  2379 00001384 4881FE[BA020000]            cmp rsi, hubDevTbl + 10*hubDevTblEntrySize  ;End of table address
  2380 0000138B 72D4                        jb .redi1  ;We are still in table
  2381                                  .hub_rescan:
  2382                                  ;Now we check that all hubs are initialised
  2383 0000138D 48BE-                       mov rsi, hubDevTbl  ;Return to head of table
  2383 0000138F [6A02000000000000] 
  2384                                  ;Leave as a stub for now. Dont support deeper than 1 level of devices
  2385                                  ;The specification allows for a maximum of 7 levels of depth.
  2386                                  .msds_init:
  2387 00001397 66B80413                    mov ax, 1304h
  2388 0000139B 80F70B                      xor bh, 0bh
  2389 0000139E 48BD-                       mov rbp, .ok
  2389 000013A0 [1F14000000000000] 
  2390 000013A8 CD30                        int 30h
  2391 000013AA 66B80413                    mov ax, 1304h
  2392 000013AE 80F70B                      xor bh, 0bh
  2393 000013B1 48BD-                       mov rbp, .msdmsg
  2393 000013B3 [2314000000000000] 
  2394 000013BB CD30                        int 30h
  2395 000013BD 48BE-                       mov rsi, msdDevTbl
  2395 000013BF [BA02000000000000] 
  2396                                  .msd1:
  2397 000013C7 803E00                      cmp byte [rsi], 0   ;Not an entry
  2398 000013CA 740F                        jz .msdNextEntry
  2399 000013CC E8(90420000)                call USB.ehciMsdInitialise
  2400 000013D1 7308                        jnc .msdNextEntry
  2401 000013D3 FEC8                        dec al
  2402 000013D5 0F84(82320000)              jz USB.ehciCriticalErrorWrapper ;al = 1 => Host error, 
  2403                                  ;                                    al = 2 => Bad dev, removed from MSD tables
  2404                                  .msdNextEntry:
  2405 000013DB 4881C610000000              add rsi, msdDevTblEntrySize ;Goto next entry
  2406 000013E2 4881FE[5A030000]            cmp rsi, msdDevTbl + 10*msdDevTblEntrySize
  2407 000013E9 75DC                        jne .msd1
  2408                                  .rediexit:
  2409 000013EB 66B80413                    mov ax, 1304h
  2410 000013EF 80F70B                      xor bh, 0bh
  2411 000013F2 48BD-                       mov rbp, .ok
  2411 000013F4 [1F14000000000000] 
  2412 000013FC CD30                        int 30h
  2413 000013FE E93E000000                  jmp int33hinit
  2414 00001403 0A0D496E697469616C-     .rmhmsg db 0Ah,0Dh,"Initialising USB ports...",0
  2414 0000140C 6973696E6720555342-
  2414 00001415 20706F7274732E2E2E-
  2414 0000141E 00                 
  2415 0000141F 204F4B00                .ok db " OK",0
  2416 00001423 0A0D496E697469616C-     .msdmsg db 0Ah,0Dh,"Initialising MSD devices...",0
  2416 0000142C 6973696E67204D5344-
  2416 00001435 20646576696365732E-
  2416 0000143E 2E2E00             
  2417                                  ;----------------------------------------------------------------
  2418                                  ;                         End of Enum                           :
  2419                                  ;----------------------------------------------------------------    
  2420                                  ;----------------------------------------------------------------
  2421                                  ;                      Int 33h Initialisation                   :
  2422                                  ;----------------------------------------------------------------    
  2423                                  int33hinit:
  2424                                  ;Create Int 33h data table entry for each MSD/floppy device using steps 1-3.
  2425                                  ;Go through MSD table and add devices to diskDevices
  2426 00001441 48BD-                       mov rbp, usbDevTbl
  2426 00001443 [4C02000000000000] 
  2427 0000144B 48BF-                       mov rdi, diskDevices
  2427 0000144D [BB03000000000000] 
  2428                                  .i33i1:
  2429 00001455 807D0208                    cmp byte [rbp + 2], 08h ;MSD USB Class code
  2430 00001459 7525                        jne .i33proceed
  2431                                  ;Successfully found a valid MSD device. Talk to it
  2432 0000145B 668B4500                    mov ax, word [rbp]  ;Get address/bus pair
  2433 0000145F E8(6A3D0000)                call USB.ehciGetDevicePtr    ;Get pointer to MSD dev in rsi
  2434 00001464 E8(DD190000)                call disk_io.deviceInit
  2435 00001469 3C01                        cmp al, 1   ;Critical error
  2436 0000146B 0F84(82320000)              je USB.ehciCriticalErrorWrapper
  2437 00001471 3C02                        cmp al, 2   ;Device stopped responding, remove from USB data tables
  2438 00001473 7420                        je .i33ibad 
  2439 00001475 3C03                        cmp al, 3   ;Device not added to data tables
  2440 00001477 7407                        je .i33proceed
  2441                                  ;Valid device added, increment rdi to next diskDevices table entry
  2442 00001479 4881C710000000              add rdi, int33TblEntrySize
  2443                                  .i33proceed:
  2444 00001480 4881FD[6A020000]            cmp rbp, usbDevTblEnd
  2445 00001487 741D                        je .i33iend
  2446 00001489 4881C503000000              add rbp, usbDevTblEntrySize
  2447 00001490 E9C0FFFFFF                  jmp .i33i1
  2448                                  .i33ibad:   ;If it goes here, clear table entry
  2449 00001495 48C70700000000              mov qword [rdi], 0  ;Remove from diskDevice table
  2450 0000149C 668B06                      mov ax, word [rsi]
  2451 0000149F E8(F53B0000)                call USB.ehciRemoveDevFromTables    ;Remove from USB tables
  2452 000014A4 EBDA                        jmp short .i33proceed ;Goto next device
  2453                                  .i33iend:
  2454 000014A6 8A0425[4B020000]            mov al, byte [numMSD]
  2455 000014AD 000425[A8010000]            add byte [i33Devices], al   ;Add the number of MSD devices to Int 33h total
  2456                                  ;----------------------------------------------------------------
  2457                                  ;                End of Enum and Initialisation                 :
  2458                                  ;----------------------------------------------------------------    
  2459                                  end:
  2460 000014B4 66B80413                    mov ax, 1304h
  2461 000014B8 48BD-                       mov rbp, dbgmsg
  2461 000014BA [2A16000000000000] 
  2462 000014C2 CD30                        int 30h
  2463 000014C4 8A0425[4B020000]            mov al, byte [numMSD]
  2464 000014CB B404                        mov ah, 04h
  2465 000014CD CD30                        int 30h
  2466                                  
  2467 000014CF 66B80413                    mov ax, 1304h
  2468 000014D3 48BD-                       mov rbp, dbgmsg2
  2468 000014D5 [3B16000000000000] 
  2469 000014DD CD30                        int 30h
  2470 000014DF 8A0425[A8010000]            mov al, byte [i33Devices]
  2471 000014E6 B404                        mov ah, 04h
  2472 000014E8 CD30                        int 30h
  2473                                  
  2474 000014EA 66B80413                    mov ax, 1304h
  2475 000014EE 48BD-                       mov rbp, dbgmsg3
  2475 000014F0 [4F16000000000000] 
  2476 000014F8 CD30                        int 30h
  2477 000014FA 8A0425[66000000]            mov al, byte [numCOM]
  2478 00001501 B404                        mov ah, 04h
  2479 00001503 CD30                        int 30h
  2480                                  
  2481 00001505 803C25[A8010000]00          cmp byte [i33Devices], 0    ;If there are no i33 devices, skip bootstrap
  2482 0000150D 740C                        jz endNoDevFound
  2483                                  
  2484 0000150F 66C70425FE7D000000-         mov word [7DFEh], 0 ;Clear out the old bootloader signature
  2484 00001518 00                 
  2485 00001519 CD39                        int 39h             ;Bootstrap loader
  2486                                  endNoDevFound:
  2487 0000151B 48BD-                       mov rbp, endboot
  2487 0000151D [9A15000000000000] 
  2488 00001525 66B80413                    mov ax, 1304h
  2489 00001529 CD30                        int 30h
  2490                                      
  2491 0000152B 6631C0                      xor ax, ax  ;Pause for any key
  2492 0000152E CD36                        int 36h
  2493                                  
  2494 00001530 66BB0700                    mov bx, 0007h    ;cls attribs
  2495 00001534 E8(F7000000)                call cls
  2496                                  
  2497 00001539 6631C9                      xor cx, cx
  2498 0000153C 6631D2                      xor dx, dx
  2499 0000153F B402                        mov ah, 2
  2500 00001541 30FF                        xor bh, bh
  2501 00001543 CD30                        int 30h 
  2502                                  
  2503 00001545 66B80413                    mov ax, 1304h
  2504 00001549 48BD-                       mov rbp, endboot2
  2504 0000154B [0A16000000000000] 
  2505 00001553 CD30                        int 30h
  2506                                  
  2507 00001555 4831C0                      xor rax, rax
  2508 00001558 4831DB                      xor rbx, rbx
  2509 0000155B 4831C9                      xor rcx, rcx
  2510 0000155E 4831D2                      xor rdx, rdx
  2511 00001561 4831F6                      xor rsi, rsi
  2512 00001564 4831FF                      xor rdi, rdi
  2513 00001567 4831ED                      xor rbp, rbp
  2514 0000156A 4D31C0                      xor r8, r8
  2515 0000156D 4D31C9                      xor r9, r9
  2516 00001570 4D31D2                      xor r10, r10
  2517 00001573 4D31DB                      xor r11, r11
  2518 00001576 4D31E4                      xor r12, r12
  2519 00001579 4D31ED                      xor r13, r13
  2520 0000157C 4D31F6                      xor r14, r14
  2521 0000157F 4D31FF                      xor r15, r15
  2522                                  
  2523 00001582 CD38                        int 38h
  2524                                  
  2525                                  
  2526 00001584 4C6F6164696E672053-     startboot:  db "Loading SCP/BIOS...", 0Ah, 0Dh, 0
  2526 0000158D 43502F42494F532E2E-
  2526 00001596 2E0A0D00           
  2527 0000159A 0A0D5343502F42494F-     endboot:    db    0Ah,0Dh,"SCP/BIOS system initialisation complete", 0Ah, 0Dh 
  2527 000015A3 532073797374656D20-
  2527 000015AC 696E697469616C6973-
  2527 000015B5 6174696F6E20636F6D-
  2527 000015BE 706C6574650A0D     
  2528 000015C5 4E6F204F7065726174-             db "No Operating System detected. Strike any key to launch SYSDEBUG."
  2528 000015CE 696E67205379737465-
  2528 000015D7 6D2064657465637465-
  2528 000015E0 642E20537472696B65-
  2528 000015E9 20616E79206B657920-
  2528 000015F2 746F206C61756E6368-
  2528 000015FB 205359534445425547-
  2528 00001604 2E                 
  2529 00001605 2E2E0A0D00                          db "..",0Ah, 0Dh,0
  2530 0000160A 5374617274696E6720-     endboot2:   db "Starting SCP/BIOS SYSDEBUG...",0Ah,0Dh,0
  2530 00001613 5343502F42494F5320-
  2530 0000161C 53595344454255472E-
  2530 00001625 2E2E0A0D00         
  2531 0000162A 0A0A0D4D5344206465-     dbgmsg:     db 0Ah,0Ah,0Dh,"MSD devices: ",0
  2531 00001633 76696365733A2000   
  2532 0000163B 0A0D496E7420333368-     dbgmsg2:    db 0Ah,0Dh,"Int 33h devices: ",0
  2532 00001644 20646576696365733A-
  2532 0000164D 2000               
  2533 0000164F 0A0D434F4D20706F72-     dbgmsg3:    db 0Ah,0Dh,"COM ports: ",0
  2533 00001658 74733A2000         
  2534                                  memprint:
  2535                                  ;Simple proc to print memory status
  2536 0000165D 6631DB                      xor bx, bx 
  2537 00001660 48BD-                       mov rbp, .convmemmsg
  2537 00001662 [B617000000000000] 
  2538 0000166A 66B80413                    mov ax, 1304h
  2539 0000166E CD30                        int 30h
  2540 00001670 CD32                        int 32h    ;Get conv Size
  2541 00001672 25FFFF0000                  and eax, 0FFFFh ;Clear upper bits
  2542 00001677 E8F4000000                  call .printdecimalword
  2543 0000167C 48BD-                       mov rbp, .kb
  2543 0000167E [2D18000000000000] 
  2544 00001686 66B80413                    mov ax, 1304h
  2545 0000168A CD30                        int 30h
  2546                                  
  2547 0000168C 66B801E8                    mov ax, 0E801h
  2548 00001690 CD35                        int 35h
  2549 00001692 25FFFF0000                  and eax, 0FFFFh
  2550 00001697 81E3FFFF0000                and ebx, 0FFFFh
  2551 0000169D 81E1FFFF0000                and ecx, 0FFFFh
  2552 000016A3 81E2FFFF0000                and edx, 0FFFFh
  2553 000016A9 53                          push rbx
  2554 000016AA 52                          push rdx
  2555 000016AB 4839C8                      cmp rax, rcx
  2556 000016AE 740C                        je .sense1    ;Sensible
  2557 000016B0 4885C0                      test rax, rax
  2558 000016B3 480F44C1                    cmovz rax, rcx
  2559 000016B7 4885C0                      test rax, rax
  2560 000016BA 7427                        jz .pt2
  2561                                  .sense1:
  2562 000016BC 50                          push rax
  2563 000016BD 48BD-                       mov rbp, .extmemmsg
  2563 000016BF [D317000000000000] 
  2564 000016C7 66B80413                    mov ax, 1304h
  2565 000016CB CD30                        int 30h
  2566 000016CD 58                          pop rax
  2567 000016CE E89D000000                  call .printdecimalword
  2568 000016D3 48BD-                       mov rbp, .kb
  2568 000016D5 [2D18000000000000] 
  2569 000016DD 66B80413                    mov ax, 1304h
  2570 000016E1 CD30                        int 30h
  2571                                  .pt2:
  2572 000016E3 58                          pop rax
  2573 000016E4 59                          pop rcx
  2574 000016E5 4839C8                      cmp rax, rcx
  2575 000016E8 740C                        je .sense2    ;Sensible
  2576 000016EA 4885C0                      test rax, rax
  2577 000016ED 480F44C1                    cmovz rax, rcx
  2578 000016F1 4885C0                      test rax, rax
  2579 000016F4 742B                        jz .pt3
  2580                                  .sense2:
  2581 000016F6 50                          push rax
  2582 000016F7 48BD-                       mov rbp, .extmemmsg2
  2582 000016F9 [F117000000000000] 
  2583 00001701 66B80413                    mov ax, 1304h
  2584 00001705 CD30                        int 30h
  2585 00001707 58                          pop rax
  2586                                  
  2587 00001708 48C1E006                    shl rax, 6    ;Turn 64Kb into Kb
  2588 0000170C E85F000000                  call .printdecimalword
  2589 00001711 48BD-                       mov rbp, .kb
  2589 00001713 [2D18000000000000] 
  2590 0000171B 66B80413                    mov ax, 1304h
  2591 0000171F CD30                        int 30h
  2592                                  .pt3:   ;Read total free size from big map
  2593 00001721 50                          push rax
  2594 00001722 48BD-                       mov rbp, .totalmem
  2594 00001724 [1018000000000000] 
  2595 0000172C B804130000                  mov eax, 1304h
  2596 00001731 CD30                        int 30h
  2597 00001733 58                          pop rax
  2598 00001734 488B0425[E0010000]          mov rax, qword [sysMem]
  2599 0000173C 31DB                        xor ebx, ebx
  2600 0000173E 8B1C25[E8010000]            mov ebx, dword [scpSize]
  2601 00001745 4829D8                      sub rax, rbx
  2602 00001748 48C1E80A                    shr rax, 0Ah                ;Get number of Kb's free
  2603 0000174C E81F000000                  call .printdecimalword  
  2604 00001751 48BD-                       mov rbp, .kb
  2604 00001753 [2D18000000000000] 
  2605 0000175B 66B80413                    mov ax, 1304h
  2606 0000175F CD30                        int 30h
  2607                                  
  2608 00001761 B80A0E0000                  mov eax, 0E0Ah
  2609 00001766 CD30                        int 30h
  2610 00001768 B80D0E0000                  mov eax, 0E0Dh   ;CR/LF
  2611 0000176D CD30                        int 30h
  2612                                  
  2613 0000176F C3                          ret
  2614                                  
  2615                                  .printdecimalword:
  2616                                  ;Takes the qword in rax and prints its decimal representation
  2617 00001770 52                          push rdx
  2618 00001771 51                          push rcx
  2619 00001772 53                          push rbx
  2620 00001773 50                          push rax
  2621 00001774 55                          push rbp
  2622 00001775 4831C9                      xor rcx, rcx
  2623 00001778 6631ED                      xor bp, bp    ;Use bp as #of digits counter
  2624 0000177B 48BB0A000000000000-         mov rbx, 0Ah  ;Divide by 10
  2624 00001784 00                 
  2625                                  .pdw0:
  2626 00001785 FFC5                        inc ebp
  2627 00001787 48C1E108                    shl rcx, 8    ;Space for next nybble
  2628 0000178B 31D2                        xor edx, edx
  2629 0000178D 48F7F3                      div rbx
  2630 00001790 80C230                      add dl, '0'
  2631 00001793 80FA39                      cmp dl, '9'
  2632 00001796 7603                        jbe .pdw1
  2633 00001798 80C207                      add dl, 'A'-'0'-10
  2634                                  .pdw1:
  2635 0000179B 88D1                        mov cl, dl    ;Save remainder byte
  2636 0000179D 4885C0                      test rax, rax
  2637 000017A0 75E3                        jnz .pdw0
  2638                                  .pdw2:
  2639 000017A2 88C8                        mov al, cl    ;Get most sig digit into al
  2640 000017A4 48C1E908                    shr rcx, 8    ;Get next digit down
  2641 000017A8 B40E                        mov ah, 0Eh
  2642 000017AA CD30                        int 30h
  2643 000017AC FFCD                        dec ebp
  2644 000017AE 75F2                        jnz .pdw2
  2645                                  
  2646 000017B0 5D                          pop rbp
  2647 000017B1 58                          pop rax
  2648 000017B2 5B                          pop rbx
  2649 000017B3 59                          pop rcx
  2650 000017B4 5A                          pop rdx
  2651 000017B5 C3                          ret
  2652 000017B6 0A0D4672656520436F-     .convmemmsg:        db 0Ah,0Dh,"Free Conventional Memory: ",0
  2652 000017BF 6E76656E74696F6E61-
  2652 000017C8 6C204D656D6F72793A-
  2652 000017D1 2000               
  2653 000017D3 0A0D546F74616C204C-     .extmemmsg:         db 0Ah,0Dh,"Total Low Extended Memory: ",0    
  2653 000017DC 6F7720457874656E64-
  2653 000017E5 6564204D656D6F7279-
  2653 000017EE 3A2000             
  2654 000017F1 0A0D546F74616C2048-     .extmemmsg2:        db 0Ah,0Dh,"Total High Extended Memory: ",0
  2654 000017FA 69676820457874656E-
  2654 00001803 646564204D656D6F72-
  2654 0000180C 793A2000           
  2655 00001810 0A0D546F74616C2046-     .totalmem:          db 0Ah,0Dh,"Total Free System Memory: ",0
  2655 00001819 726565205379737465-
  2655 00001822 6D204D656D6F72793A-
  2655 0000182B 2000               
  2656 0000182D 4B00                    .kb:                db "K",0
  2657                                  ;----------------------Interrupt Tables--------------------------
  2658                                  IDT_TABLE:
  2659                                  CPU_IDT:
  2660 0000182F [F64B000000000000]          dq i0
  2661 00001837 [FE4B000000000000]          dq i1
  2662 0000183F [0D4C000000000000]          dq i2
  2663 00001847 [1C4C000000000000]          dq i3
  2664 0000184F [2B4C000000000000]          dq i4
  2665 00001857 [3A4C000000000000]          dq i5
  2666 0000185F [494C000000000000]          dq i6
  2667 00001867 [584C000000000000]          dq i7
  2668 0000186F [674C000000000000]          dq i8
  2669 00001877 [764C000000000000]          dq i9
  2670 0000187F [854C000000000000]          dq i10
  2671 00001887 [944C000000000000]          dq i11
  2672 0000188F [A34C000000000000]          dq i12
  2673 00001897 [B24C000000000000]          dq i13
  2674 0000189F [BE4C000000000000]          dq i14
  2675 000018A7 [CA4C000000000000]          dq i15
  2676 000018AF [D64C000000000000]          dq i16
  2677 000018B7 [E24C000000000000]          dq i17
  2678 000018BF [EE4C000000000000]          dq i18
  2679 000018C7 [FA4C000000000000]          dq i19
  2680 000018CF [064D000000000000]          dq i20
  2681 000018D7 [124D000000000000]          dq i21
  2682 000018DF [1550000000000000]-         times 0Ah dq dummy_return_64    ;just return, reserved interrupts!
  2682 000018DF <rep Ah>           
  2683                                  HW_IDT:
  2684                                  ;--------PIC1--------:    ;Int 20h-27h
  2685 0000192F [0F01000000000000]          dq timer_IRQ0
  2686 00001937 [4F01000000000000]          dq kb_IRQ1
  2687 0000193F [0F50000000000000]          dq dummy_interrupt.pic1
  2688 00001947 [CF09000000000000]          dq ser_IRQ3
  2689 0000194F [E109000000000000]          dq ser_IRQ4
  2690 00001957 [0F50000000000000]          dq dummy_interrupt.pic1
  2691 0000195F [AA0A000000000000]          dq fdd_IRQ6
  2692 00001967 [B20A000000000000]          dq default_IRQ7
  2693                                  ;--------PIC2--------:    ;Int 28h-2Fh
  2694 0000196F [D20A000000000000]          dq rtc_IRQ8
  2695 00001977 [0850000000000000]          dq dummy_interrupt.pic2
  2696 0000197F [0850000000000000]          dq dummy_interrupt.pic2
  2697 00001987 [0850000000000000]          dq dummy_interrupt.pic2
  2698 0000198F [0850000000000000]          dq dummy_interrupt.pic2
  2699 00001997 [0850000000000000]          dq dummy_interrupt.pic2
  2700 0000199F [050B000000000000]          dq hdd_IRQ14
  2701 000019A7 [150B000000000000]          dq default_IRQ15
  2702                                  SW_IDT:    ;Int 30h onwards!
  2703 000019AF [6B0C000000000000]          dq scr_io            ;Int 30h, VGA Screen drawing/TTY functions
  2704 000019B7 [F512000000000000]          dq machineWord_io    ;Int 31h, Give the BIOS hardware bitfield
  2705 000019BF [2C13000000000000]          dq convRAM_io        ;Int 32h, Give conv memory available
  2706 000019C7 [4F13000000000000]          dq disk_io           ;Int 33h, Storage device Functions
  2707 000019CF [AC1A000000000000]          dq serial_io         ;Int 34h, Serial Port Functions
  2708 000019D7 [1A1C000000000000]          dq misc_io           ;Int 35h, Misc functions
  2709 000019DF [BC1F000000000000]          dq kb_io             ;Int 36h, Keyboard functions
  2710 000019E7 [3E20000000000000]          dq printer_io        ;Int 37h, Reserved [Who uses parallel anymore?]
  2711 000019EF [DF20000000000000]          dq MCP_int           ;Int 38h, launch MCP, and install its "API" handle
  2712 000019F7 [D72E000000000000]          dq bootstrapInt      ;Int 39h, restart the PC using an interrupt
  2713 000019FF [542F000000000000]          dq timerInt          ;Int 3Ah, Time of day
  2714 00001A07 [BF31000000000000]          dq ctrlbreak_io      ;Int 3Bh, user Break
  2715 00001A0F [1550000000000000]          dq dummy_return_64   ;Int 3Ch, user IRQ0 hook
  2716 00001A17 [C131000000000000]          dq scr_params_io     ;Int 3Dh, Screen Mode parameters return function
  2717 00001A1F [CD31000000000000]          dq disk_params_io    ;Int 3Eh, disk parameters return function
  2718 00001A27 [DF31000000000000]          dq cga_ret_io        ;Int 3Fh, video extention return function
  2719                                  IDT_TABLE_Length equ $ - IDT_TABLE
  2720                                  seg0len equ ($ - $$)
  2721                                  
  2722                                  ;----------------------------------------------------------------
  2723                                  ;                BIOS RESIDENT CODE AREA STARTS HERE            :
  2724                                  ;----------------------------------------------------------------
  2725                                  Segment codeResident follows=codeInit vfollows=data align=1 valign=1
  2726                                  ;---------------------------------Procs--------------------------
  2727                                  e820print:
  2728 00000000 56                          push rsi
  2729 00000001 52                          push rdx
  2730 00000002 51                          push rcx
  2731 00000003 53                          push rbx
  2732 00000004 50                          push rax
  2733 00000005 48BE-                       mov rsi, bigmapptr
  2733 00000007 [F005000000000000] 
  2734 0000000F 480FB61425-                 movzx rdx, byte [bigmapSize]    ;Get the number of 24 byte entries
  2734 00000014 [D5010000]         
  2735                                  .e0:
  2736 00000018 48AD                        lodsq
  2737 0000001A E82D000000                  call .printqword
  2738 0000001F E845000000                  call .printpipe
  2739 00000024 48AD                        lodsq
  2740 00000026 E821000000                  call .printqword
  2741 0000002B E839000000                  call .printpipe
  2742 00000030 48AD                        lodsq   
  2743 00000032 E815000000                  call .printqword
  2744 00000037 E844000000                  call .printcrlf
  2745 0000003C 6631C0                      xor ax, ax
  2746 0000003F CD36                        int 36h
  2747 00000041 48FFCA                      dec rdx
  2748 00000044 75D2                        jnz .e0
  2749 00000046 58                          pop rax
  2750 00000047 5B                          pop rbx
  2751 00000048 59                          pop rcx
  2752 00000049 5A                          pop rdx
  2753 0000004A 5E                          pop rsi
  2754 0000004B C3                          ret
  2755                                  .printqword:
  2756 0000004C 4889C3                      mov rbx, rax
  2757 0000004F 480FCB                      bswap rbx
  2758 00000052 48B908000000000000-         mov rcx, 8
  2758 0000005B 00                 
  2759                                  .pq1:
  2760 0000005C 88D8                        mov al, bl
  2761 0000005E B404                        mov ah, 04h
  2762 00000060 CD30                        int 30h
  2763 00000062 48C1EB08                    shr rbx, 8
  2764 00000066 E2F4                        loop .pq1
  2765 00000068 C3                          ret
  2766                                  .printpipe:
  2767 00000069 55                          push rbp
  2768 0000006A 48BD-                       mov rbp, .pipestr
  2768 0000006C [7C00000000000000] 
  2769 00000074 66B80413                    mov ax, 1304h
  2770 00000078 CD30                        int 30h
  2771 0000007A 5D                          pop rbp
  2772 0000007B C3                          ret
  2773 0000007C 207C2000                .pipestr:   db " | ",0
  2774                                  .printcrlf:
  2775 00000080 55                          push rbp
  2776 00000081 48BD-                       mov rbp, .crlfstr
  2776 00000083 [9300000000000000] 
  2777 0000008B 66B80413                    mov ax, 1304h
  2778 0000008F CD30                        int 30h
  2779 00000091 5D                          pop rbp
  2780 00000092 C3                          ret
  2781 00000093 0A0D00                  .crlfstr: db 0Ah,0Dh, 0
  2782                                  beep:
  2783                                  ;Destroys old PIT2 divisor.
  2784                                  ;Input: 
  2785                                  ;   bx = Frequency divisor to use for tone
  2786                                  ;   rcx = # of ms to beep for
  2787                                  ;All registers preserved
  2788 00000096 50                          push rax
  2789 00000097 B0B6                        mov al, 0B6h ;Get PIT command bitfield, PIT2, lo/hi, Mode 3, Binary
  2790 00000099 E643                        out PITcommand, al
  2791                                  
  2792 0000009B 6689D8                      mov ax, bx       ;Move frequency divisor into ax
  2793 0000009E E642                        out PIT2, al     ;Output lo byte of divisor
  2794 000000A0 88E0                        mov al, ah
  2795 000000A2 E642                        out PIT2, al     ;Output hi byte of divisor
  2796                                  
  2797 000000A4 E461                        in al, port61h  ;Save original state of port 61h in ah
  2798 000000A6 0C03                        or al, 3        ;Set bits 0 and 1 to turn on the speaker
  2799 000000A8 E661                        out port61h, al
  2800                                  
  2801 000000AA B486                        mov ah, 86h     ;Wait for beep to complete
  2802 000000AC CD35                        int 35h
  2803                                  
  2804 000000AE E461                        in al, port61h    ;Read state of port 61h afresh
  2805 000000B0 24FC                        and al, ~3        ;Clear bits 0 and 1 to turn off the speaker
  2806 000000B2 E661                        out port61h, al
  2807                                  
  2808 000000B4 58                          pop rax
  2809 000000B5 C3                          ret
  2810                                  
  2811                                  ps2wait:
  2812 000000B6 50                          push rax
  2813                                  .wnok:
  2814 000000B7 EB00                        jmp short $ + 2
  2815 000000B9 E464                        in al, ps2status
  2816 000000BB A801                        test al, 1    ;Can something be read from KB?
  2817 000000BD 7406                        jz .wok       ;Zero = no, so loop back. Not zero = proceed to check if 
  2818                                                    ; something can be written
  2819 000000BF EB00                        jmp short $ + 2
  2820 000000C1 E460                        in al, ps2data    ;Read it in
  2821 000000C3 EBF2                        jmp short .wnok
  2822                                  .wok:
  2823 000000C5 A802                        test al, 2   ;Can something be written to KB?
  2824 000000C7 75EE                        jnz .wnok    ;Zero if yes and proceed.
  2825 000000C9 58                          pop rax
  2826 000000CA C3                          ret
  2827                                      
  2828                                  idtWriteEntry:
  2829                                  ;----------------------------------------------------------------
  2830                                  ;This proc writes an interrupt handler to a particular IDT entry.
  2831                                  ; rax = Interrupt handler ptr    (qword)
  2832                                  ; rsi = Interrupt Number         (qword)
  2833                                  ; dx = Attributes word           (word)
  2834                                  ; bx = Segment selector          (word)
  2835                                  ;On return:
  2836                                  ; rsi incremented by 1
  2837                                  ; Entry written
  2838                                  ;----------------------------------------------------------------
  2839 000000CB 56                          push rsi
  2840 000000CC 48C1E604                    shl rsi, 4h     ;Multiply IDT entry number by 16
  2841 000000D0 48033425[04000000]          add rsi, qword [IDTpointer.Base]    ;rsx points to IDT entry
  2842 000000D8 668906                      mov word [rsi], ax  ;Get low word into offset 15...0
  2843 000000DB 66895E02                    mov word [rsi + 2], bx  ;Move segment selector into place
  2844 000000DF 66895604                    mov word [rsi + 4], dx  ;Move attribute word into place
  2845 000000E3 48C1E810                    shr rax, 10h    ;Bring next word low
  2846 000000E7 66894606                    mov word [rsi + 6], ax  ;Get low word into offset 31...16
  2847 000000EB 48C1E810                    shr rax, 10h    ;Bring last dword low
  2848 000000EF 894608                      mov dword [rsi + 8], eax
  2849 000000F2 5E                          pop rsi
  2850 000000F3 48FFC6                      inc rsi         ;rsi contains number of next interrupt handler
  2851 000000F6 C3                          ret
  2852                                      
  2853                                  cls:    ;Clear the screen, bl attrib, always clear active scr
  2854 000000F7 50                          push rax
  2855 000000F8 52                          push rdx
  2856 000000F9 B40F                        mov ah, 0Fh
  2857 000000FB CD30                        int 30h ;Get current active page
  2858                                  
  2859 000000FD B402                        mov ah, 02h    ;Set cursor pos
  2860 000000FF 6631D2                      xor dx, dx
  2861 00000102 CD30                        int 30h
  2862 00000104 88DF                        mov bh, bl
  2863                                  ;No need for coordinates since al=00 means reset fullscreen
  2864 00000106 66B80006                    mov ax, 0600h
  2865 0000010A CD30                        int 30h    ;scroll page with grey on black
  2866 0000010C 5A                          pop rdx
  2867 0000010D 58                          pop rax
  2868 0000010E C3                          ret
  2869                                  
  2870                                  ;--------------------Interrupt Service routines------------------
  2871                                  
  2872                                  ;======================HARDWARE INTERRUPTS=======================
  2873                                  ;----------------Timer Interrupt IRQ 0/Int 20h-------------------
  2874                                  ;This interrupt simply increments an internal timer and 
  2875                                  ; calls a software interrupt (5Ch) which can be used by user 
  2876                                  ; applications.
  2877                                  ;----------------------------------------------------------------
  2878                                  timer_IRQ0:
  2879 0000010F FB                          sti    
  2880 00000110 50                          push rax
  2881 00000111 FF0425[37010000]            inc dword [pit_ticks]
  2882 00000118 8B0425[37010000]            mov eax, dword [pit_ticks]
  2883 0000011F 25FFFF1F00                  and eax, 1FFFFFh    ;Clear OF bit [mask on bits 20:0]
  2884 00000124 3DB0001800                  cmp eax, 1800B0h    ;Ticks in one full day
  2885 00000129 7519                        jnz .tret            ;Not quite there
  2886 0000012B 66C70425[37010000]-         mov word [pit_ticks], 0     ;Zero lo count
  2886 00000133 0000               
  2887 00000135 C60425[39010000]00          mov byte [pit_ticks + 2], 0    ;Zero hi count
  2888 0000013D FE0425[3A010000]            inc byte [pit_ticks + 3]    ;Increment day OF counter    
  2889                                  .tret:
  2890 00000144 CD3C                        int 3Ch        ;Call user handler
  2891                                  
  2892 00000146 B020                        mov al, EOI
  2893 00000148 E620                        out pic1command, al
  2894 0000014A E680                        out waitp, al    ;allow one io cycle to run
  2895                                  
  2896 0000014C 58                          pop rax
  2897 0000014D 48CF                        iretq
  2898                                  ;-------------------------End of Interrupt-----------------------
  2899                                  ;----------------Keyboard Interrupt IRQ 1/Int 21h----------------
  2900                                  ;This interrupt takes scancodes from the PC keyboard, translates 
  2901                                  ; them into scancode/ASCII char pair and stores the pair into 
  2902                                  ; the buffer for the software keyboard interrupt to use.
  2903                                  ;----------------------------------------------------------------
  2904                                  kb_IRQ1:
  2905 0000014F FB                          sti        ;Reenable interrupts
  2906 00000150 50                          push rax
  2907 00000151 53                          push rbx
  2908 00000152 51                          push rcx
  2909 00000153 57                          push rdi
  2910 00000154 4831C0                      xor rax, rax
  2911                                  
  2912                                  .k0:
  2913 00000157 E460                        in al, ps2data    ;Get the scancode (Set 1)
  2914 00000159 4885C0                      test rax, rax    ;Check to see if we got an error code from the keyboard.
  2915 0000015C 0F84A0020000                jz .kb_error
  2916 00000162 483D80000000                cmp rax, 80h
  2917 00000168 0F8ED8000000                jle .basickey    ;A normal keypress, nothing too magical.
  2918 0000016E 483DE0000000                cmp rax, 0E0h    ;Compare against special keys
  2919 00000174 7472                        je .special_keys
  2920 00000176 483DE1000000                cmp rax, 0E1h    ;Pause
  2921 0000017C 747D                        je .pause
  2922 0000017E 483DAA000000                cmp rax, 0AAh    ;LShift released
  2923 00000184 0F8490000000                je .lshift_released
  2924 0000018A 483DB6000000                cmp rax, 0B6h    ;RShift released
  2925 00000190 0F8488000000                je .rshift_released
  2926 00000196 483DB8000000                cmp rax, 0B8h    ;Alt Shift released
  2927 0000019C 7474                        je .alt_shift_released
  2928 0000019E 483D9D000000                cmp rax, 9Dh    ;Ctrl Shift released
  2929 000001A4 7470                        je .ctrl_shift_released
  2930 000001A6 483D2B0D0000                cmp rax, 0D2Bh    ;Toggle Insert
  2931 000001AC 7460                        je .insert_released
  2932 000001AE EB25                        jmp short .kb1_exit    ;Just exit if something weird gets sent
  2933                                  
  2934                                  .kb_store_in_buffer:
  2935 000001B0 488B1C25[4A000000]          mov rbx, qword [kb_buf_tail]    ;point rbx to tail
  2936 000001B8 4889DF                      mov rdi, rbx ;Save bx in di for storing the data in AX after bx gets inc 
  2937 000001BB E8651E0000                  call kb_io.kb_ptr_adv            ;safely advance the pointer
  2938 000001C0 483B1C25[42000000]          cmp rbx, qword [kb_buf_head]    ;Have we wrapped around?
  2939 000001C8 745F                        je .kb_buf_full_beep            ;discard and beep
  2940 000001CA 668907                      mov word [rdi], ax                ;mov scancode/ascii pair into buffer
  2941 000001CD 48891C25[4A000000]          mov qword [kb_buf_tail], rbx    ;store new pointer back into tail
  2942                                  
  2943                                  .kb1_exit:
  2944 000001D5 B0FC                        mov al, ~(kb_flag2_e0 | kb_flag2_e1)        ;move the notted version into al
  2945 000001D7 200425[64000000]            and byte [kb_flags_2], al        ;Nullify the e0 and e1 flag
  2946                                  .kb1_exit_e0:
  2947 000001DE B020                        mov al, EOI
  2948 000001E0 E620                        out pic1command, al    ;End of interrupt to pic1 command port
  2949                                  
  2950 000001E2 5F                          pop rdi
  2951 000001E3 59                          pop rcx
  2952 000001E4 5B                          pop rbx
  2953 000001E5 58                          pop rax
  2954 000001E6 48CF                        iretq
  2955                                  
  2956                                  .special_keys:    ;An E0 process
  2957 000001E8 B002                        mov al, kb_flag2_e0         ;Set the bit for the flag
  2958 000001EA 080425[64000000]            or byte [kb_flags_2], al    ;Set the flag
  2959 000001F1 802425[64000000]FE          and byte [kb_flags_2], ~kb_flag2_e1    ;clear the E1 bit
  2960 000001F9 EBE3                        jmp short .kb1_exit_e0      ;Exit from IRQ without resetting flags 
  2961                                  .pause:    ;An E1 process
  2962 000001FB B001                        mov al, kb_flag2_e1         ;Set the bit for the flag
  2963 000001FD 080425[64000000]            or byte [kb_flags_2], al    ;Toggle the flag, since 9D and C5 will be 
  2964                                                                  ; ignored by the Int handler
  2965 00000204 802425[64000000]FD          and byte [kb_flags_2], ~kb_flag2_e0    ;clear the E0 bit
  2966 0000020C EBD0                        jmp short .kb1_exit_e0
  2967                                  
  2968                                  .insert_released:
  2969 0000020E B07F                        mov al, ~kb_flag_insset     ;Flag negation
  2970 00000210 EB0E                        jmp short .shift_release_common
  2971                                  .alt_shift_released:
  2972 00000212 B0F7                        mov al, ~kb_flag_alt        ;Flag negation
  2973 00000214 EB0A                        jmp short .shift_release_common
  2974                                  .ctrl_shift_released:
  2975 00000216 B0FB                        mov al, ~kb_flag_ctrl       ;Flag negation
  2976 00000218 EB06                        jmp short .shift_release_common
  2977                                  .lshift_released:
  2978 0000021A B0FD                        mov al, ~kb_flag_lshift     ;Flag negation
  2979 0000021C EB02                        jmp short .shift_release_common
  2980                                  .rshift_released:
  2981 0000021E B0FE                        mov al, ~kb_flag_rshift     ;Flag negation
  2982                                  .shift_release_common:
  2983 00000220 200425[62000000]            and byte [kb_flags], al     ;Clear the relevant bit
  2984 00000227 EBAC                        jmp short .kb1_exit
  2985                                  
  2986                                  
  2987                                  .kb_buf_full_beep:
  2988 00000229 53                          push rbx
  2989 0000022A 51                          push rcx
  2990 0000022B BBA9040000                  mov ebx, 04A9h ;Frequency divisor for 1000Hz tone
  2991 00000230 48B9F4010000000000-         mov rcx, 500   ;Beep for a 1/2 second
  2991 00000239 00                 
  2992 0000023A E857FEFFFF                  call beep
  2993 0000023F 59                          pop rcx
  2994 00000240 5B                          pop rbx
  2995 00000241 E98FFFFFFF                  jmp .kb1_exit
  2996                                  
  2997                                  .basickey:          ;al contains the scancode
  2998 00000246 483D46000000                cmp rax, 46h
  2999 0000024C 0F8421010000                je .e0special   ;ctrl+break checker (E0 46h is make for break haha)
  3000                                  .kbbk1:
  3001 00000252 483D2A000000                cmp rax, 2Ah    ;Left Shift scancode
  3002 00000258 0F84E4000000                je .lshift_pressed
  3003 0000025E 483D36000000                cmp rax, 36h    ;Right Shift scancode
  3004 00000264 0F84DC000000                je .rshift_pressed
  3005 0000026A 483D38000000                cmp rax, 38h    ;Alt Shift key scancode
  3006 00000270 0F84C4000000                je .alt_shift_pressed
  3007 00000276 483D1D000000                cmp rax, 1Dh    ;Ctrl Shift key scancode
  3008 0000027C 0F84BC000000                je .ctrl_shift_pressed
  3009                                      
  3010 00000282 483D3A000000                cmp rax, 3Ah    ;Caps lock key
  3011 00000288 0F84CA000000                je .caps_lock
  3012 0000028E 483D45000000                cmp rax, 45h    ;Num lock key
  3013 00000294 0F84C2000000                je .num_lock
  3014                                  ;    cmp rax, 46h    ;Scroll lock key
  3015                                  ;    je .scroll_lock
  3016 0000029A 483D52000000                cmp rax, 52h    ;Insert key pressed
  3017 000002A0 0F84AE000000                je .ins_toggle    
  3018 000002A6 483D53000000                cmp rax, 53h    ;Delete key, for CTRL+ALT+DEL
  3019 000002AC 0F8408010000                je .ctrl_alt_del
  3020                                  .keylookup:
  3021 000002B2 48BB-                       mov rbx, .kb_sc_ascii_lookup
  3021 000002B4 [3F04000000000000] 
  3022                                                      ; upper 7 bytes of rax are completely clear
  3023 000002BC 66C1E004                    shl ax, 4       ;multiply ax, the scancode, by 16, to offset to correct row
  3024 000002C0 4801C3                      add rbx, rax    ;offset rbx to the correct row
  3025                                  ;Now check shift states, to align with column. rax is free again
  3026 000002C3 8A0425[62000000]            mov al, byte [kb_flags]
  3027                                  
  3028 000002CA A802                        test al, kb_flag_lshift
  3029 000002CC 7525                        jnz .addshiftvalue            ;If that bit is set, jump!
  3030 000002CE A801                        test al, kb_flag_rshift
  3031 000002D0 7521                        jnz .addshiftvalue
  3032 000002D2 A804                        test al, kb_flag_ctrl
  3033 000002D4 752E                        jnz .addctrlvalue
  3034 000002D6 A808                        test al, kb_flag_alt
  3035 000002D8 7533                        jnz .addaltvalue
  3036 000002DA A820                        test al, kb_flag_numset
  3037 000002DC 7538                        jnz .addnumvalue
  3038 000002DE A840                        test al, kb_flag_capsset
  3039 000002E0 753D                        jnz .addcapsvalue
  3040                                  
  3041                                  .keyget:
  3042 000002E2 668B03                      mov ax, word [rbx] ;Get correct word into ax!
  3043 000002E5 6685C0                      test ax, ax        ;check if the value is zero, if so, dont store in buffer
  3044 000002E8 0F84E7FEFFFF                jz .kb1_exit
  3045 000002EE E9BDFEFFFF                  jmp .kb_store_in_buffer
  3046                                  
  3047                                  .addshiftvalue:    ;first check if we shift with caps or num
  3048 000002F3 A820                        test al, kb_flag_numset
  3049 000002F5 753A                        jnz .addshiftnum
  3050 000002F7 A840                        test al, kb_flag_capsset
  3051 000002F9 752D                        jnz .addshiftcaps
  3052                                      ;Collapse through, it is just shift, add 2 to rbx
  3053 000002FB 4881C302000000              add rbx, 1h*2h
  3054 00000302 EBDE                        jmp short .keyget
  3055                                  .addctrlvalue:
  3056 00000304 4881C304000000              add rbx, 2h*2h
  3057 0000030B EBD5                        jmp short .keyget
  3058                                  .addaltvalue:
  3059 0000030D 4881C306000000              add rbx, 3h*2h
  3060 00000314 EBCC                        jmp short .keyget
  3061                                  .addnumvalue:
  3062 00000316 4881C308000000              add rbx, 4h*2h
  3063 0000031D EBC3                        jmp short .keyget
  3064                                  .addcapsvalue:
  3065 0000031F 4881C30A000000              add rbx, 5h*2h
  3066 00000326 EBBA                        jmp short .keyget
  3067                                  .addshiftcaps:
  3068 00000328 4881C30C000000              add rbx, 6h*2h
  3069 0000032F EBB1                        jmp short .keyget
  3070                                  .addshiftnum:
  3071 00000331 4881C30E000000              add rbx, 7h*2h
  3072 00000338 EBA8                        jmp short .keyget
  3073                                  
  3074                                  .alt_shift_pressed:
  3075 0000033A B008                        mov al, kb_flag_alt
  3076 0000033C EB0A                        jmp short .shift_pressed_common
  3077                                  .ctrl_shift_pressed:
  3078 0000033E B004                        mov al, kb_flag_ctrl
  3079 00000340 EB06                        jmp short .shift_pressed_common
  3080                                  .lshift_pressed:
  3081 00000342 B002                        mov al, kb_flag_lshift
  3082 00000344 EB02                        jmp short .shift_pressed_common
  3083                                  .rshift_pressed:
  3084 00000346 B001                        mov al, kb_flag_rshift
  3085                                  .shift_pressed_common:
  3086 00000348 080425[62000000]            or byte [kb_flags], al    ;toggle flag bits
  3087 0000034F E981FEFFFF                  jmp .kb1_exit             ;Exit
  3088                                  
  3089                                  .ins_toggle:
  3090 00000354 B080                        mov al, kb_flag_insset
  3091 00000356 EB0A                        jmp short .lock_common
  3092                                  .caps_lock:
  3093 00000358 B040                        mov al, kb_flag_capsset
  3094 0000035A EB06                        jmp short .lock_common
  3095                                  .num_lock:
  3096 0000035C B020                        mov al, kb_flag_numset
  3097 0000035E EB02                        jmp short .lock_common
  3098                                  .scroll_lock:
  3099 00000360 B010                        mov al, kb_flag_scrlset
  3100                                  .lock_common:
  3101 00000362 300425[62000000]            xor byte [kb_flags], al    ;toggle bit
  3102 00000369 E875000000                  call .set_kb_lights
  3103 0000036E E962FEFFFF                  jmp .kb1_exit
  3104                                  
  3105                                  .e0special:
  3106 00000373 F60425[64000000]02          test byte [kb_flags_2], 00000010b    ;Check for E0 set
  3107 0000037B 7505                        jnz .ctrl_break
  3108 0000037D E9DEFFFFFF                  jmp .scroll_lock    ;Assume scroll lock set
  3109                                  .ctrl_break:
  3110 00000382 800C25[65000000]01          or byte [break_flag], 1        ;set break_flag
  3111 0000038A 6631C0                      xor ax, ax
  3112 0000038D 53                          push rbx
  3113 0000038E 48BB-                       mov rbx, kb_buffer            ;mov the buffer addr to rbx
  3113 00000390 [2200000000000000] 
  3114 00000398 48891C25[42000000]          mov qword [kb_buf_head], rbx
  3115 000003A0 48891C25[4A000000]          mov qword [kb_buf_tail], rbx
  3116 000003A8 668903                      mov word [rbx], ax    ;Store zero as the first two bytes of the
  3117 000003AB 5B                          pop rbx
  3118 000003AC CD3B                        int 3Bh                      ;Call the CTRL+Break handler
  3119 000003AE 200425[65000000]            and byte [break_flag], al    ;clear break_flag
  3120 000003B5 E91BFEFFFF                  jmp .kb1_exit        ;return clearing E0
  3121                                  
  3122                                  .ctrl_alt_del:
  3123 000003BA 50                          push rax    ;save scancode
  3124 000003BB 8A0425[64000000]            mov al, byte [kb_flags_2]
  3125 000003C2 A802                        test al, kb_flag2_e0    ;Delete scancode is E0, 53, check if we first had E0
  3126 000003C4 7417                        jz .ctrl_alt_del_no_reset
  3127                                  
  3128 000003C6 8A0425[62000000]            mov al, byte [kb_flags]
  3129 000003CD 240C                        and al,  kb_flag_ctrl | kb_flag_alt
  3130 000003CF 3C0C                        cmp al, kb_flag_ctrl | kb_flag_alt    ;Test if Ctrl + Alt is being pressed
  3131 000003D1 750A                        jne .ctrl_alt_del_no_reset
  3132                                  .ctrl_alt_del_killPC:
  3133 000003D3 E464                        in al, 64h    ;Check if the input buffer is empty
  3134 000003D5 A802                        test al, 2    ;Check if clear
  3135 000003D7 75FA                        jne .ctrl_alt_del_killPC    ;keep waiting
  3136 000003D9 B0FE                        mov al, 0FEh    ;Pulse kill lines
  3137 000003DB E664                        out 64h, al    
  3138                                      ;PC dead, time to reboot!
  3139                                  .ctrl_alt_del_no_reset:
  3140 000003DD 58                          pop rax        ;return the OG scancode and proceed as normal
  3141 000003DE E9CFFEFFFF                  jmp .keylookup
  3142                                  
  3143                                  
  3144                                  .set_kb_lights:
  3145 000003E3 50                          push rax
  3146                                  
  3147 000003E4 E8CDFCFFFF                  call ps2wait
  3148                                  
  3149 000003E9 B0ED                        mov al, 0EDh
  3150 000003EB E660                        out ps2data, al
  3151                                  
  3152 000003ED E8C4FCFFFF                  call ps2wait
  3153                                      
  3154 000003F2 8A0425[62000000]            mov al, byte [kb_flags]    ;get flag into al
  3155 000003F9 C0E804                      shr al, 4
  3156 000003FC 2407                        and al, 111b    ;mask Insert bit off to isolate the NUM,CAPS,SCRL status 
  3157                                                      ; bits <=> LED status.
  3158 000003FE E660                        out ps2data, al    ;send the led status away
  3159                                  
  3160 00000400 58                          pop rax
  3161 00000401 C3                          ret
  3162                                  
  3163                                  .kb_error:     ;If error recieved from Keyboard, hang the system, cold reboot 
  3164                                                 ; needed.
  3165 00000402 FA                          cli        ;Disable interrupts/Further keystrokes
  3166 00000403 66BB0700                    mov bx, 0007h    ;cls attribs
  3167 00000407 E8EBFCFFFF                  call cls    ;clear the screen
  3168 0000040C 66B80413                    mov ax, 1304h
  3169 00000410 30FF                        xor bh, bh
  3170 00000412 48BD-                       mov rbp, .kb_error_msg
  3170 00000414 [2204000000000000] 
  3171 0000041C CD30                        int 30h
  3172                                  .kber1:
  3173 0000041E F390                        pause
  3174 00000420 EBFC                        jmp short .kber1
  3175 00000422 4B6579626F61726420-     .kb_error_msg:    db    "Keyboard Error. Halting...", 0Ah, 0Dh, 0
  3175 0000042B 4572726F722E204861-
  3175 00000434 6C74696E672E2E2E0A-
  3175 0000043D 0D00               
  3176                                  
  3177                                  .kb_sc_ascii_lookup:    ;Scancodes 00h-58h
  3178                                  ; Scancodes 00h-0Fh
  3179                                  ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
  3180 0000043F 000000000000000000-      dw 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h ;NUL
  3180 00000448 00000000000000     
  3181 0000044F 1B011B011B011B011B-      dw 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh, 011Bh ;Esc
  3181 00000458 011B011B011B01     
  3182 0000045F 310221020000007831-      dw 0231h, 0221h, 0000h, 7800h, 0231h, 0231h, 0221h, 0221h ;1 !
  3182 00000468 02310221022102     
  3183 0000046F 320322030003007932-      dw 0332h, 0322h, 0300h, 7900h, 0332h, 0332h, 0322h, 0322h ;2 "
  3183 00000478 03320322032203     
  3184 0000047F 33049C040000007A33-      dw 0433h, 049Ch, 0000h, 7A00h, 0433h, 0433h, 049Ch, 049Ch ;3 
  3184 00000488 0433049C049C04     
  3185 0000048F 340524050000007B34-      dw 0534h, 0524h, 0000h, 7B00h, 0534h, 0534h, 0524h, 0524h ;4 $
  3185 00000498 05340524052405     
  3186 0000049F 350625060000007C35-      dw 0635h, 0625h, 0000h, 7C00h, 0635h, 0635h, 0625h, 0625h ;5 %
  3186 000004A8 06350625062506     
  3187 000004AF 36075E071E07007D36-      dw 0736h, 075Eh, 071Eh, 7D00h, 0736h, 0736h, 075Eh, 075Eh ;6 ^
  3187 000004B8 0736075E075E07     
  3188 000004BF 370826080000007E37-      dw 0837h, 0826h, 0000h, 7E00h, 0837h, 0837h, 0826h, 0826h ;7 &
  3188 000004C8 08370826082608     
  3189 000004CF 38092A090000007F38-      dw 0938h, 092Ah, 0000h, 7F00h, 0938h, 0938h, 092Ah, 092Ah ;8 *
  3189 000004D8 0938092A092A09     
  3190 000004DF 390A280A0000008039-      dw 0A39h, 0A28h, 0000h, 8000h, 0A39h, 0A39h, 0A28h, 0A28h ;9 (
  3190 000004E8 0A390A280A280A     
  3191 000004EF 300B290B0000008130-      dw 0B30h, 0B29h, 0000h, 8100h, 0B30h, 0B30h, 0B29h, 0B29h ;0 )
  3191 000004F8 0B300B290B290B     
  3192 000004FF 2D0C5F0C000000822D-      dw 0C2Dh, 0C5Fh, 0000h, 8200h, 0C2Dh, 0C2Dh, 0C5Fh, 0C5Fh ;- _
  3192 00000508 0C2D0C5F0C5F0C     
  3193 0000050F 3D0D2B0D000000833D-      dw 0D3Dh, 0D2Bh, 0000h, 8300h, 0D3Dh, 0D3Dh, 0D2Bh, 0D2Bh ;= +
  3193 00000518 0D3D0D2B0D2B0D     
  3194 0000051F 080E080E7F0E000008-      dw 0E08h, 0E08h, 0E7Fh, 0000h, 0E08h, 0E08h, 0E08h, 0E08h ;bksp (ctrl -> del)
  3194 00000528 0E080E080E080E     
  3195 0000052F 090F000F0000000009-      dw 0F09h, 0F00h, 0000h, 0000h, 0F09h, 0F09h, 0F00h, 0F00h ;L2R Horizontal Tab
  3195 00000538 0F090F000F000F     
  3196                                  
  3197                                  ; Scancodes 10h-1Fh
  3198                                  ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
  3199 0000053F 711051101110001071-      dw 1071h, 1051h, 1011h, 1000h, 1071h, 1051h, 1071h, 1051h ;q Q
  3199 00000548 10511071105110     
  3200 0000054F 771157111711001177-      dw 1177h, 1157h, 1117h, 1100h, 1177h, 1157h, 1177h, 1157h ;w W
  3200 00000558 11571177115711     
  3201 0000055F 651245120512001265-      dw 1265h, 1245h, 1205h, 1200h, 1265h, 1245h, 1265h, 1245h ;e E
  3201 00000568 12451265124512     
  3202 0000056F 721352131213001372-      dw 1372h, 1352h, 1312h, 1300h, 1372h, 1352h, 1372h, 1352h ;r R
  3202 00000578 13521372135213     
  3203 0000057F 741454141414001474-      dw 1474h, 1454h, 1414h, 1400h, 1474h, 1454h, 1474h, 1454h ;t T
  3203 00000588 14541474145414     
  3204 0000058F 791559151915001579-      dw 1579h, 1559h, 1519h, 1500h, 1579h, 1559h, 1579h, 1559h ;y Y
  3204 00000598 15591579155915     
  3205 0000059F 751655161516001675-      dw 1675h, 1655h, 1615h, 1600h, 1675h, 1655h, 1675h, 1655h ;u U
  3205 000005A8 16551675165516     
  3206 000005AF 691749170917001769-      dw 1769h, 1749h, 1709h, 1700h, 1769h, 1749h, 1769h, 1749h ;i I
  3206 000005B8 17491769174917     
  3207 000005BF 6F184F180F1800186F-      dw 186Fh, 184Fh, 180Fh, 1800h, 186Fh, 184Fh, 186Fh, 184Fh ;o O
  3207 000005C8 184F186F184F18     
  3208 000005CF 701950191019001970-      dw 1970h, 1950h, 1910h, 1900h, 1970h, 1950h, 1970h, 1950h ;p P
  3208 000005D8 19501970195019     
  3209 000005DF 5B1A7B1A1B1A00005B-      dw 1A5Bh, 1A7Bh, 1A1Bh, 0000h, 1A5Bh, 1A5Bh, 1A7Bh, 1A7Bh ;[ {
  3209 000005E8 1A5B1A7B1A7B1A     
  3210 000005EF 5D1B7D1B1D1B00005D-      dw 1B5Dh, 1B7Dh, 1B1Dh, 0000h, 1B5Dh, 1B5Dh, 1B7Dh, 1B7Dh ;] }
  3210 000005F8 1B5D1B7D1B7D1B     
  3211 000005FF 0D1C0D1C0A1C00000D-      dw 1C0Dh, 1C0Dh, 1C0Ah, 0000h, 1C0Dh, 1C0Dh, 1C0Ah, 1C0Ah ;Enter (CR/LF)
  3211 00000608 1C0D1C0A1C0A1C     
  3212 0000060F 001D001D001D001D00-      dw 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h, 1D00h ;CTRL (left)
  3212 00000618 1D001D001D001D     
  3213 0000061F 611E411E011E001E61-      dw 1E61h, 1E41h, 1E01h, 1E00h, 1E61h, 1E41h, 1E61h, 1E41h ;a A
  3213 00000628 1E411E611E411E     
  3214 0000062F 731F531F131F001F73-      dw 1F73h, 1F53h, 1F13h, 1F00h, 1F73h, 1F53h, 1F73h, 1F53h ;s S
  3214 00000638 1F531F731F531F     
  3215                                  
  3216                                  ; Scancodes 20h-2Fh
  3217                                  ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
  3218 0000063F 642044200420002064-      dw 2064h, 2044h, 2004h, 2000h, 2064h, 2044h, 2064h, 2044h ;d D
  3218 00000648 20442064204420     
  3219 0000064F 662146210621002166-      dw 2166h, 2146h, 2106h, 2100h, 2166h, 2146h, 2166h, 2146h ;f F
  3219 00000658 21462166214621     
  3220 0000065F 672247220722002267-      dw 2267h, 2247h, 2207h, 2200h, 2267h, 2247h, 2267h, 2247h ;g G
  3220 00000668 22472267224722     
  3221 0000066F 682348230823002368-      dw 2368h, 2348h, 2308h, 2300h, 2368h, 2348h, 2368h, 2348h ;h H
  3221 00000678 23482368234823     
  3222 0000067F 6A244A240A2400246A-      dw 246Ah, 244Ah, 240Ah, 2400h, 246Ah, 244Ah, 246Ah, 244Ah ;j J
  3222 00000688 244A246A244A24     
  3223 0000068F 6B254B250B2500256B-      dw 256Bh, 254Bh, 250Bh, 2500h, 256Bh, 254Bh, 256Bh, 254Bh ;k K
  3223 00000698 254B256B254B25     
  3224 0000069F 6C264C260C2600266C-      dw 266Ch, 264Ch, 260Ch, 2600h, 266Ch, 264Ch, 266Ch, 264Ch ;l L
  3224 000006A8 264C266C264C26     
  3225 000006AF 3B273A27000000003B-      dw 273Bh, 273Ah, 0000h, 0000h, 273Bh, 273Bh, 273Ah, 273Ah ;; :
  3225 000006B8 273B273A273A27     
  3226 000006BF 272840280000000027-      dw 2827h, 2840h, 0000h, 0000h, 2827h, 2827h, 2840h, 2840h ;' @
  3226 000006C8 28272840284028     
  3227 000006CF 5C297C29000000005C-      dw 295Ch, 297Ch, 0000h, 0000h, 295Ch, 295Ch, 297Ch, 297Ch ;\ |
  3227 000006D8 295C297C297C29     
  3228 000006DF 002A002A002A002A00-      dw 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h, 2A00h ;LShift (2Ah)
  3228 000006E8 2A002A002A002A     
  3229 000006EF 232B7E2B1C2B000023-      dw 2B23h, 2B7Eh, 2B1Ch, 0000h, 2B23h, 2B23h, 2B7Eh, 2B7Eh ;# ~
  3229 000006F8 2B232B7E2B7E2B     
  3230 000006FF 7A2C5A2C1A2C002C7A-      dw 2C7Ah, 2C5Ah, 2C1Ah, 2C00h, 2C7Ah, 2C5Ah, 2C7Ah, 2C5Ah ;z Z
  3230 00000708 2C5A2C7A2C5A2C     
  3231 0000070F 782D582D182D002D78-      dw 2D78h, 2D58h, 2D18h, 2D00h, 2D78h, 2D58h, 2D78h, 2D58h ;x X
  3231 00000718 2D582D782D582D     
  3232 0000071F 632E432E032E002E63-      dw 2E63h, 2E43h, 2E03h, 2E00h, 2E63h, 2E43h, 2E63h, 2E43h ;c C
  3232 00000728 2E432E632E432E     
  3233 0000072F 762F562F162F002F76-      dw 2F76h, 2F56h, 2F16h, 2F00h, 2F76h, 2F56h, 2F76h, 2F56h ;v V
  3233 00000738 2F562F762F562F     
  3234                                  
  3235                                  ; Scancodes 30h-3Fh
  3236                                  ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
  3237 0000073F 623042300230003062-      dw 3062h, 3042h, 3002h, 3000h, 3062h, 3042h, 3062h, 3042h ;b B
  3237 00000748 30423062304230     
  3238 0000074F 6E314E310E3100316E-      dw 316Eh, 314Eh, 310Eh, 3100h, 316Eh, 314Eh, 316Eh, 314Eh ;n N
  3238 00000758 314E316E314E31     
  3239 0000075F 6D324D320D3200326D-      dw 326Dh, 324Dh, 320Dh, 3200h, 326Dh, 324Dh, 326Dh, 324Dh ;m M
  3239 00000768 324D326D324D32     
  3240 0000076F 2C333C33000000002C-      dw 332Ch, 333Ch, 0000h, 0000h, 332Ch, 332Ch, 333Ch, 333Ch ;, <
  3240 00000778 332C333C333C33     
  3241 0000077F 2E343E34000000002E-      dw 342Eh, 343Eh, 0000h, 0000h, 342Eh, 342Eh, 343Eh, 343Eh ;. >
  3241 00000788 342E343E343E34     
  3242 0000078F 2F353F35000000002F-      dw 352Fh, 353Fh, 0000h, 0000h, 352Fh, 352Fh, 353Fh, 353Fh ;/ ?
  3242 00000798 352F353F353F35     
  3243 0000079F 003600360036003600-      dw 3600h, 3600h, 3600h, 3600h, 3600h, 3600h, 3600h, 3600h ;RShift
  3243 000007A8 36003600360036     
  3244 000007AF 2A370000103700002A-      dw 372Ah, 0000h, 3710h, 0000h, 372Ah, 372Ah, 0000h, 0000h ;KP *
  3244 000007B8 372A3700000000     
  3245 000007BF 003800380038003800-      dw 3800h, 3800h, 3800h, 3800h, 3800h, 3800h, 3800h, 3800h ;Alt
  3245 000007C8 38003800380038     
  3246 000007CF 203920390039000020-      dw 3920h, 3920h, 3900h, 0000h, 3920h, 3920h, 3920h, 3920h ;Space
  3246 000007D8 39203920392039     
  3247 000007DF 003A003A003A003A00-      dw 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h, 3A00h ;Caps Lock
  3247 000007E8 3A003A003A003A     
  3248 000007EF 003B0054005E006800-      dw 3B00h, 5400h, 5E00h, 6800h, 3B00h, 3B00h, 5400h, 5400h ;F1
  3248 000007F8 3B003B00540054     
  3249 000007FF 003C0055005F006900-      dw 3C00h, 5500h, 5F00h, 6900h, 3C00h, 3C00h, 5500h, 5500h ;F2
  3249 00000808 3C003C00550055     
  3250 0000080F 003D00560060006A00-      dw 3D00h, 5600h, 6000h, 6A00h, 3D00h, 3D00h, 5600h, 5600h ;F3
  3250 00000818 3D003D00560056     
  3251 0000081F 003E00570061006B00-      dw 3E00h, 5700h, 6100h, 6B00h, 3E00h, 3E00h, 5700h, 5700h ;F4
  3251 00000828 3E003E00570057     
  3252 0000082F 003F00580062006C00-      dw 3F00h, 5800h, 6200h, 6C00h, 3F00h, 3F00h, 5800h, 5800h ;F5
  3252 00000838 3F003F00580058     
  3253                                  
  3254                                  ; Scancodes 40h-4Fh
  3255                                  ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
  3256 0000083F 004000590063006D00-      dw 4000h, 5900h, 6300h, 6D00h, 4000h, 4000h, 5900h, 5900h ;F6
  3256 00000848 40004000590059     
  3257 0000084F 0041005A0064006E00-      dw 4100h, 5A00h, 6400h, 6E00h, 4100h, 4100h, 5A00h, 5A00h ;F7
  3257 00000858 410041005A005A     
  3258 0000085F 0042005B0065006F00-      dw 4200h, 5B00h, 6500h, 6F00h, 4200h, 4200h, 5B00h, 5B00h ;F8
  3258 00000868 420042005B005B     
  3259 0000086F 0043005C0066007000-      dw 4300h, 5C00h, 6600h, 7000h, 4300h, 4300h, 5C00h, 5C00h ;F9
  3259 00000878 430043005C005C     
  3260 0000087F 0044005D0067007100-      dw 4400h, 5D00h, 6700h, 7100h, 4400h, 4400h, 5D00h, 5D00h ;F10
  3260 00000888 440044005D005D     
  3261 0000088F 004500450045004500-      dw 4500h, 4500h, 4500h, 4500h, 4500h, 4500h, 4500h, 4500h ;Num Lock
  3261 00000898 45004500450045     
  3262 0000089F 004600460046004600-      dw 4600h, 4600h, 4600h, 4600h, 4600h, 4600h, 4600h, 4600h ;Scroll Lock
  3262 000008A8 46004600460046     
  3263 000008AF 004737470077000037-      dw 4700h, 4737h, 7700h, 0000h, 4737h, 4700h, 4737h, 4700h ;(KP)Home
  3263 000008B8 47004737470047     
  3264 000008BF 004838480000000038-      dw 4800h, 4838h, 0000h, 0000h, 4838h, 4800h, 4838h, 4800h ;(KP)Up arrow
  3264 000008C8 48004838480048     
  3265 000008CF 004939490084000039-      dw 4900h, 4939h, 8400h, 0000h, 4939h, 4900h, 4939h, 4900h ;(KP)PgUp 
  3265 000008D8 49004939490049     
  3266 000008DF 2D4A2D4A000000002D-      dw 4A2Dh, 4A2Dh, 0000h, 0000h, 4A2Dh, 4A2Dh, 4A2Dh, 4A2Dh ;(KP)-
  3266 000008E8 4A2D4A2D4A2D4A     
  3267 000008EF 004B344B0073000034-      dw 4B00h, 4B34h, 7300h, 0000h, 4B34h, 4B00h, 4B34h, 4B00h ;(KP)Left arrow
  3267 000008F8 4B004B344B004B     
  3268 000008FF 004C354C0000000035-      dw 4C00h, 4C35h, 0000h, 0000h, 4C35h, 4C00h, 4C35h, 4C00h ;(KP)Center
  3268 00000908 4C004C354C004C     
  3269 0000090F 004D364D0074000036-      dw 4D00h, 4D36h, 7400h, 0000h, 4D36h, 4D00h, 4D36h, 4D00h ;(KP)Right arrow
  3269 00000918 4D004D364D004D     
  3270 0000091F 2B4E2B4E000000002B-      dw 4E2Bh, 4E2Bh, 0000h, 0000h, 4E2Bh, 4E2Bh, 4E2Bh, 4E2Bh ;(KP)+
  3270 00000928 4E2B4E2B4E2B4E     
  3271 0000092F 004F314F0075000031-      dw 4F00h, 4F31h, 7500h, 0000h, 4F31h, 4F00h, 4F31h, 4F00h ;(KP)End
  3271 00000938 4F004F314F004F     
  3272                                  
  3273                                  ; Scancodes 50h-58h
  3274                                  ;   base   shift   ctrl   alt   num    caps   shcap  shnum 
  3275 0000093F 005032500000000032-      dw 5000h, 5032h, 0000h, 0000h, 5032h, 5000h, 5032h, 5000h ;(KB)Down arrow
  3275 00000948 50005032500050     
  3276 0000094F 005133510076000033-      dw 5100h, 5133h, 7600h, 0000h, 5133h, 5100h, 5133h, 5100h ;(KB)PgDn
  3276 00000958 51005133510051     
  3277 0000095F 005230520000000030-      dw 5200h, 5230h, 0000h, 0000h, 5230h, 5200h, 5230h, 5200h ;(KB)Ins
  3277 00000968 52005230520052     
  3278 0000096F 00532E53000000002E-      dw 5300h, 532Eh, 0000h, 0000h, 532Eh, 5300h, 532Eh, 5300h ;(KB)Del
  3278 00000978 5300532E530053     
  3279 0000097F 005400540054005400-      dw 5400h, 5400h, 5400h, 5400h, 5400h, 5400h, 5400h, 5400h ;ALT+PRTSC -> Sysreq
  3279 00000988 54005400540054     
  3280 0000098F 000000000000000000-      dw 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h, 0000h ;xxxxNOTUSEDxxxx
  3280 00000998 00000000000000     
  3281 0000099F 5C567C56000000005C-      dw 565Ch, 567Ch, 0000h, 0000h, 565Ch, 565Ch, 567Ch, 567Ch ;\ |
  3281 000009A8 565C567C567C56     
  3282 000009AF 005700000000000000-      dw 5700h, 0000h, 0000h, 0000h, 5700h, 5700h, 0000h, 0000h ;F11
  3282 000009B8 57005700000000     
  3283 000009BF 005800000000000000-      dw 5800h, 0000h, 0000h, 0000h, 5800h, 5800h, 0000h, 0000h ;F12
  3283 000009C8 58005800000000     
  3284                                  ;------------------------End of Interrupt------------------------
  3285                                  ;------------------Serial Interrupt IRQ 3/Int 23h----------------
  3286                                  ;Serves serial ports 1 and 3 should they exist. Only considers 
  3287                                  ; data recieving. Disregards all sending data interrupts.
  3288                                  ;Puts recieved data into respective buffer and clears RTS 
  3289                                  ; (base+5) if buffer full.
  3290                                  ;----------------------------------------------------------------
  3291                                  ser_IRQ3:
  3292 000009CF FA                          cli
  3293 000009D0 50                          push rax
  3294 000009D1 52                          push rdx
  3295 000009D2 55                          push rbp
  3296 000009D3 51                          push rcx
  3297 000009D4 57                          push rdi
  3298 000009D5 53                          push rbx
  3299                                  
  3300 000009D6 BB08000000                  mov ebx, 8
  3301 000009DB 66BAFA02                    mov dx, com2_base + 2 ;Interrupt ID register
  3302 000009DF EB10                        jmp short ser_common
  3303                                  ;------------------------End of Interrupt------------------------
  3304                                  ;---------------------Serial Interrupt IRQ 3/Int 23h-------------
  3305                                  ;Serves serial ports 1 and 3 should they exist. Only considers 
  3306                                  ; data recieving. Disregards all sending data interrupts.
  3307                                  ;Puts recieved data into respective buffer and clears RTS 
  3308                                  ; (base+5) if buffer full.
  3309                                  ;----------------------------------------------------------------
  3310                                  ser_IRQ4:
  3311 000009E1 FA                          cli
  3312 000009E2 50                          push rax
  3313 000009E3 52                          push rdx
  3314 000009E4 55                          push rbp
  3315 000009E5 51                          push rcx
  3316 000009E6 57                          push rdi
  3317 000009E7 53                          push rbx
  3318                                  
  3319 000009E8 BB06000000                  mov ebx, 6
  3320 000009ED 66BAFA03                    mov dx, com1_base + 2 ;Interrupt ID register
  3321                                  ser_common:
  3322 000009F1 EC                          in al, dx
  3323 000009F2 A801                        test al, 1    ;Check if bit zero is clear ie interrupt pending
  3324 000009F4 741F                        jz .si1       ;Clear, interrupt pending on COM 1 port
  3325                                  .si0:
  3326 000009F6 668B93[67000000]            mov dx, word [com_addresses + rbx] ;now point to HI COM Interrupt ID registr
  3327 000009FD 6685D2                      test dx, dx
  3328 00000A00 0F8497000000                jz .siexit            ;Nothing here, exit
  3329 00000A06 66FFC2                      inc dx
  3330 00000A09 66FFC2                      inc dx                ;dx = base + 2
  3331 00000A0C EC                          in al, dx
  3332 00000A0D A801                        test al, 1     ;Check if bit zero is clear
  3333 00000A0F 0F8588000000                jnz .siexit    ;Bad behavior, or no Int on com3 after com1 processed, exit
  3334                                  .si1:
  3335                                  ;Confirm Data available Interrupt (ie bits 1,2,3 are 010b)
  3336 00000A15 A804                        test al, 00000100b
  3337 00000A17 0F8480000000                jz .siexit   ;bad behavior, exit
  3338 00000A1D 6681C20300                  add dx, 3    ;dx = base + 5
  3339                                  .si41:
  3340 00000A22 EC                          in al, dx
  3341 00000A23 2401                        and al, 1
  3342 00000A25 74FB                        jz .si41
  3343                                  
  3344 00000A27 6681EA0500                  sub dx, 5
  3345 00000A2C EC                          in al, dx    ;get char into al
  3346 00000A2D 88C4                        mov ah, al   ;save al in ah temporarily
  3347 00000A2F 4831C9                      xor rcx, rcx
  3348                                  .si2:    ;Get offset into table structures into cx
  3349 00000A32 663B9409[67000000]          cmp dx, word [com_addresses + rcx*2]    ;table of addresses, dx is at base
  3350 00000A3A 740C                        je .si3
  3351 00000A3C 66FFC1                      inc cx
  3352 00000A3F 6681F90400                  cmp cx, 4    ;rcx should be {0,3}
  3353 00000A44 7CEC                        jl .si2
  3354 00000A46 EB55                        jmp short .siexit    ;bad value, exit
  3355                                  .si3:    ;Store in buffer algorithm
  3356 00000A48 488B1CCD[CF000000]          mov rbx, qword [comX_buf_tail + rcx*8]
  3357 00000A50 4889DF                      mov rdi, rbx
  3358 00000A53 48FFC3                      inc rbx        ;increment by one char
  3359 00000A56 483B1CCD[0F010000]          cmp rbx, qword [comX_buf_end + rcx*8]
  3360 00000A5E 7508                        jne .si4
  3361 00000A60 488B1CCD[EF000000]          mov rbx, qword [comX_buf_start + rcx*8]    ;Wrap around buffer
  3362                                  .si4:
  3363 00000A68 483B1CCD[AF000000]          cmp rbx, qword [comX_buf_head + rcx*8]    ;Check if buffer full
  3364 00000A70 740F                        je .si5    ;Buffer full, indicate wait to data source
  3365                                  
  3366 00000A72 8827                        mov byte [rdi], ah    ;store char into buffer
  3367 00000A74 48891CCD[CF000000]          mov qword [comX_buf_tail + rcx*8], rbx    ;store new tail into variable
  3368                                  
  3369 00000A7C E975FFFFFF                  jmp .si0    ;If com1/2, now check that com 3/4 didnt fire interrupt.
  3370                                  
  3371                                  .si5:    ;Buffer full, Deassert DTR bit 
  3372                                  ;dx points at the base register
  3373 00000A81 6681C20400                  add dx, 4    ;Point at Modem Control Register
  3374 00000A86 EC                          in al, dx
  3375 00000A87 24FE                        and al, 11111110b    ;Clear the bottom bit
  3376 00000A89 EE                          out dx, al    ;Set the DTR bit down (not ready to recieve data)
  3377 00000A8A 6681C20300                  add dx, 3    ;Point to scratch register
  3378 00000A8F 88E0                        mov al, ah    ;return ah into al
  3379 00000A91 EE                          out dx, al    ;put the overrun char into scratch register
  3380 00000A92 6681F90200                  cmp cx, 2    ;If this was com1/2, now check for com 3/4.
  3381 00000A97 0F8559FFFFFF                jne .si0
  3382                                  ;exit since we dont want to take whats in the UART buffer just yet.
  3383                                  .siexit:
  3384 00000A9D B020                        mov al, EOI
  3385 00000A9F E620                        out pic1command, al
  3386                                  
  3387 00000AA1 5B                          pop rbx
  3388 00000AA2 5F                          pop rdi
  3389 00000AA3 59                          pop rcx
  3390 00000AA4 5D                          pop rbp
  3391 00000AA5 5A                          pop rdx
  3392 00000AA6 58                          pop rax
  3393 00000AA7 FB                          sti
  3394 00000AA8 48CF                        iretq
  3395                                  ;------------------------End of Interrupt------------------------
  3396                                  ;----------------FDD Interrupt IRQ 6/Int 26h---------------------
  3397                                  fdd_IRQ6:
  3398 00000AAA 50                          push rax
  3399 00000AAB B020                        mov al, EOI
  3400 00000AAD E620                        out pic1command, al
  3401 00000AAF 58                          pop rax
  3402 00000AB0 48CF                        iretq
  3403                                  ;------------------------End of Interrupt------------------------
  3404                                  ;-----------------Spurious Int Handler/Int 27h-------------------
  3405                                  ; Catches and handles spurious interrupts on the first pic.
  3406                                  ;----------------------------------------------------------------
  3407                                  default_IRQ7:
  3408 00000AB2 50                          push rax
  3409 00000AB3 B00B                        mov al, 0Bh    ;Read ISR 
  3410 00000AB5 E620                        out pic1command, al
  3411 00000AB7 E680                        out waitp, al    ;Latch wait
  3412 00000AB9 EB00                        jmp short $+2
  3413 00000ABB E420                        in al, pic1command    ;Get the ISR
  3414 00000ABD A880                        test al, 80h
  3415 00000ABF 750A                        jne .exit
  3416 00000AC1 66FF0425[20000000]          inc word [spurint1]
  3417 00000AC9 EB04                        jmp short .e2    ;Avoid sending EOI
  3418                                  .exit:
  3419 00000ACB B020                        mov al, EOI
  3420 00000ACD E620                        out pic1command, al
  3421                                  .e2:
  3422 00000ACF 58                          pop rax
  3423 00000AD0 48CF                        iretq
  3424                                  ;---------------RTC Interrupt IRQ 8/Int 28h----------------------
  3425                                  ; This IRQ should only trigger for the periodic and alarm 
  3426                                  ; interrupts. If a programmer wishes to use the time update 
  3427                                  ; complete interrupt feature, they should hook their own 
  3428                                  ; interrupt handler.
  3429                                  ;----------------------------------------------------------------
  3430                                  rtc_IRQ8:
  3431 00000AD2 50                          push rax
  3432 00000AD3 FA                          cli             ;Disable interrupts
  3433 00000AD4 B08C                        mov al, 8Ch     ;Register C with NMI disabled
  3434 00000AD6 E670                        out cmos_base, al
  3435 00000AD8 E680                        out waitp, al    ;allow one io cycle to run
  3436 00000ADA EB00                        jmp short $+2
  3437 00000ADC E471                        in al, cmos_data    ;Get the data byte to confirm IRQ recieved
  3438 00000ADE 2460                        and al, 060h        ;Isolate Alarm and Periodic bits only
  3439 00000AE0 A840                        test al, 40h        ;Periodic?
  3440 00000AE2 7408                        jz .noPeriodic      ;No, skip the periodic
  3441                                  .periodic:
  3442 00000AE4 48FF0C25[3B010000]          dec qword [rtc_ticks]
  3443                                  .noPeriodic:
  3444 00000AEC A820                        test al, 20h        ;Alarm?
  3445 00000AEE 7402                        jz .exit
  3446                                  .alarm:
  3447 00000AF0 CD6A                        int 6Ah    ;User Alarm handler, behaves like Int 4Ah on 16-bit BIOS
  3448                                  .exit:
  3449 00000AF2 B00D                        mov al, 0Dh     ;Read Register D and reenable NMI
  3450 00000AF4 E670                        out cmos_base, al
  3451 00000AF6 E680                        out waitp, al    ;allow one io cycle to run
  3452 00000AF8 EB00                        jmp short $+2
  3453 00000AFA E471                        in al, cmos_data    
  3454 00000AFC B020                        mov al, EOI
  3455 00000AFE E6A0                        out pic2command, al
  3456 00000B00 E620                        out pic1command, al
  3457 00000B02 58                          pop rax
  3458 00000B03 48CF                        iretq
  3459                                  ;------------------------End of Interrupt------------------------
  3460                                  ;---------------HDD Interrupt IRQ 14/Int 2Eh---------------------
  3461                                  hdd_IRQ14:
  3462 00000B05 50                          push rax
  3463 00000B06 C60425[AB010000]00          mov byte [ir14_mutex], 0
  3464 00000B0E B020                        mov al, EOI
  3465 00000B10 E620                        out pic1command, al
  3466 00000B12 58                          pop rax
  3467 00000B13 48CF                        iretq
  3468                                  ;------------------------End of Interrupt------------------------
  3469                                  ;-----------------Spurious Int Handler/Int 2Fh-------------------
  3470                                  ; Catches and handles spurious interrupts on the second pic.
  3471                                  ;----------------------------------------------------------------
  3472                                  default_IRQ15:
  3473 00000B15 50                          push rax
  3474 00000B16 803C25[AD010000]01          cmp byte [ir15_mutex], 1    ;Check if mutex set
  3475 00000B1E 7508                        jne .spurcheck              ;If not set, then just check spur
  3476 00000B20 C60425[AD010000]00          mov byte [ir15_mutex], 0    ;Exit and check spur
  3477                                  .spurcheck:
  3478 00000B28 B00B                        mov al, 0Bh    ;Read ISR 
  3479 00000B2A E6A0                        out pic2command, al
  3480 00000B2C E680                        out waitp, al    ;Latch wait
  3481 00000B2E EB00                        jmp short $+2
  3482 00000B30 E4A0                        in al, pic2command    ;Get the ISR
  3483 00000B32 A880                        test al, 80h
  3484 00000B34 B020                        mov al, EOI    ;Still need to send EOI to pic1
  3485 00000B36 750A                        jne .exit
  3486 00000B38 66FF0425[21000000]          inc word [spurint2]
  3487 00000B40 EB02                        jmp short .e2    ;Avoid sending EOI
  3488                                  .exit:
  3489 00000B42 E6A0                        out pic2command, al
  3490                                  .e2:
  3491 00000B44 E620                        out pic1command, al
  3492 00000B46 58                          pop rax
  3493 00000B47 48CF                        iretq
  3494                                  ;------------------------End of Interrupt------------------------
  3495                                  ;-------------------EHCI Int Handler/Int 2Xh---------------------
  3496                                  ;This is installed by the PCI proc at runtime, onto the 
  3497                                  ; appropriate IRQ.
  3498                                  ;
  3499                                  ;If USB Host controller is doing transaction, this HC is 
  3500                                  ; nominally turned off. Bits [7:2] in the eAsyncMutex identify 
  3501                                  ; how many interrupts to ignore, before switching off the 
  3502                                  ; Schedule. This value is nominally zero.
  3503                                  ;----------------------------------------------------------------
  3504                                  ehci_IRQ:
  3505 00000B49 68[08500000]                push qword dummy_interrupt.pic2
  3506 00000B4E EB05                        jmp short .intr
  3507                                  .pic1:
  3508 00000B50 68[0F500000]                push qword dummy_interrupt.pic1
  3509                                  .intr:
  3510                                  ;EHCI Interrupt Handler 
  3511 00000B55 53                          push rbx
  3512 00000B56 50                          push rax
  3513                                  
  3514 00000B57 8A0425[47020000]            mov al, byte [eActiveCtrlr]
  3515 00000B5E 3CFF                        cmp al, -1    ;Spurious case, replace with manual poll then discard proc
  3516 00000B60 743F                        je .spur
  3517                                  
  3518 00000B62 E874400000                  call USB.ehciGetOpBase    ;returns opreg base in rax
  3519                                  .nonIRQmain:
  3520 00000B67 678B5804                    mov ebx, dword [eax + ehcists]  ;save USBSTS and clear usb interrupt
  3521 00000B6B 67095804                    or dword [eax + ehcists], ebx   ;WC all interrupt status
  3522 00000B6F 881C25[48020000]            mov byte [eActiveInt], bl    ;save interrupt status
  3523                                  
  3524                                  ;Test based on which bits are set. Higher bits have higher priority
  3525                                      ;test bl, 10h            ;Check if host error bit set
  3526                                      ;test bl, 8              ;Frame List rollover
  3527                                      ;test bl, 4              ;Port status change detected
  3528 00000B76 F6C302                      test bl, 2              ;Check if transation error bit is set
  3529 00000B79 7542                        jnz .transactionError
  3530 00000B7B F6C301                      test bl, 1              ;Check if short packet/interrupt bit set
  3531 00000B7E 741E                        jz .exit                ;If none of the bits were set, continue IRQ chain
  3532                                  ;IoC and Short Packet section
  3533 00000B80 8A0425[49020000]            mov al, byte [eAsyncMutex]    ;check if we should ignore interrupt
  3534 00000B87 24FC                        and al, 11111100b    ;clear out bottom two bits (dont care)
  3535 00000B89 84C0                        test al, al            ;Set zero flag if al is zero
  3536 00000B8B 7509                        jnz .usbignoreirq    ;If not zero, ignore irq (and dec counter!)
  3537                                  
  3538 00000B8D 880425[49020000]            mov byte [eAsyncMutex], al ;Wait no longer!! Data available
  3539                                  
  3540 00000B94 EB08                        jmp short .exit    ;Ignore the "ignore usb" section
  3541                                  .usbignoreirq:
  3542 00000B96 802C25[49020000]04          sub byte [eAsyncMutex], 4    ;sub the semaphore 
  3543                                  .exit:
  3544 00000B9E 58                          pop rax
  3545 00000B9F 5B                          pop rbx
  3546 00000BA0 C3                          ret
  3547                                  .spur:
  3548 00000BA1 30C0                        xor al, al
  3549                                  .s1:
  3550 00000BA3 E833400000                  call USB.ehciGetOpBase
  3551 00000BA8 678B5804                    mov ebx, dword [eax + ehcists] ;save USBSTS and clear usb interrupt 
  3552 00000BAC 67095804                    or dword [eax + ehcists], ebx    ;WC all interrupt status
  3553 00000BB0 FEC0                        inc al    ;Clear all interrupts on all controllers
  3554 00000BB2 3A0425[14020000]            cmp al, byte [eControllers]
  3555 00000BB9 72E8                        jb .s1
  3556 00000BBB EBE1                        jmp short .exit
  3557                                  .transactionError:
  3558 00000BBD C60425[49020000]00          mov byte [eAsyncMutex], 0   ;Unblock wait
  3559 00000BC5 EBD7                        jmp short .exit
  3560                                  .nonIRQep:
  3561 00000BC7 53                          push rbx
  3562 00000BC8 50                          push rax
  3563 00000BC9 EB9C                        jmp short .nonIRQmain
  3564                                  ;------------------------End of Interrupt------------------------
  3565                                  ;========================SOFTWARE INTERRUPTS=====================
  3566                                  ;----------------------Video Interrupt Int 30h-------------------
  3567                                  scr_io_table:
  3568 00000BCB [980C000000000000]          dq    scr_io.change_mode     ;AH = 0 -> Change Screen Mode (Currently no 
  3569                                                                   ; options)
  3570 00000BD3 [A70C000000000000]          dq    scr_io.set_curs_shape  ;AH = 1 -> Set Cursor Shape
  3571 00000BDB [BA0C000000000000]          dq    scr_io.set_curs_pos    ;AH = 2 -> Set Cursor Position
  3572 00000BE3 [DE0C000000000000]          dq    scr_io.get_curs_pos    ;AH = 3 -> Get Cursor Position
  3573 00000BEB [FE0C000000000000]          dq    scr_io.write_register  ;AH = 4 -> Reserved, Undoc, Write al in ASCII 
  3574                                                                   ; at cursor 
  3575 00000BF3 [470D000000000000]          dq    scr_io.select_page     ;AH = 5 -> Select Active Page
  3576 00000BFB [ED0D000000000000]          dq    scr_io.scroll_up       ;AH = 6 -> Scroll Active Page up
  3577 00000C03 [AB0E000000000000]          dq    scr_io.scroll_down     ;AH = 7 -> Scroll Active Page down
  3578 00000C0B [3D0F000000000000]          dq    scr_io.read_att_char   ;AH = 8 -> Read Attribute and Char at curs pos
  3579 00000C13 [6F0F000000000000]          dq    scr_io.write_att_char  ;AH = 9 -> Write Attribute and Char at curs pos
  3580 00000C1B [AF0F000000000000]          dq    scr_io.write_char      ;AH = 0Ah -> Write Char at curs position 
  3581                                                                   ; (using default attribute)
  3582 00000C23 [F70F000000000000]          dq    scr_io.gset_col_palette ;AH = 0Bh -> Graphics, Set Colour Palette
  3583 00000C2B [0610000000000000]          dq    scr_io.gwritedot       ;AH = 0Ch -> Graphics, Write a Dot to screen
  3584 00000C33 [1510000000000000]          dq    scr_io.greaddot        ;AH = 0Dh -> Graphics, Read a Dot from screen
  3585 00000C3B [2410000000000000]          dq    scr_io.write_tty       ;AH = 0Eh -> Write Teletype
  3586 00000C43 [F210000000000000]          dq    scr_io.get_mode        ;AH = 0Fh -> Get Screen Mode (currently, no 
  3587                                                                   ; options)
  3588 00000C4B [8D0C000000000000]          dq    scr_io.exitf           ;AH = 10h -> Reserved
  3589 00000C53 [8D0C000000000000]          dq  scr_io.exitf             ;AH = 11h -> Reserved
  3590 00000C5B [8D0C000000000000]          dq    scr_io.exitf           ;AH = 12h -> Reserved
  3591 00000C63 [1B11000000000000]          dq  scr_io.write_string      ;AH = 13h -> Write string
  3592                                  scr_io_table_length    equ    $ - scr_io_table
  3593                                  scr_io:
  3594 00000C6B FC                          cld        ;set direction to read the right way
  3595 00000C6C 56                          push rsi
  3596 00000C6D 50                          push rax
  3597 00000C6E C0E403                      shl ah, 3  ;Use ah as offset into table
  3598 00000C71 80FC98                      cmp ah, (scr_io_table_length - 8)    ;Ensure function number is within table
  3599 00000C74 7717                        ja .exitf
  3600 00000C76 88E0                        mov al, ah
  3601 00000C78 480FB6C0                    movzx rax, al               ;Zero extend ax into rax
  3602 00000C7C 4889C6                      mov rsi, rax                ;Note rsi is not being saved here!
  3603 00000C7F 58                          pop rax                     ;recover back into ax
  3604 00000C80 8A2425[58010000]            mov ah, byte [scr_mode]     ;Get the current mode into ah
  3605 00000C87 FFA6[CB0B0000]              jmp [scr_io_table + rsi]    ;Jump to correct function
  3606                                  .exitf:
  3607 00000C8D 58                          pop rax
  3608 00000C8E B480                        mov ah, 80h ;Function not supported
  3609 00000C90 804C241801                  or byte [rsp + 3*8h], 1 ;Set Carry flag, invalid function, skip rsi on stack
  3610                                  .exit:
  3611 00000C95 5E                          pop rsi
  3612 00000C96 48CF                        iretq
  3613                                      
  3614                                  .change_mode:
  3615 00000C98 48B8FFFF0000000000-         mov rax, 0FFFFh
  3615 00000CA1 00                 
  3616 00000CA2 E9EEFFFFFF                  jmp .exit    ;Currently unsupported function    
  3617                                  .set_curs_shape:
  3618                                  ;Input: CH = Scan Row Start, CL = Scan Row End
  3619 00000CA7 52                          push rdx
  3620 00000CA8 66890C25[55010000]          mov word [scr_curs_shape], cx
  3621                                  
  3622 00000CB0 B00A                        mov al, 0Ah
  3623 00000CB2 E86B050000                  call .write_crtc_word
  3624                                      
  3625 00000CB7 5A                          pop rdx
  3626 00000CB8 EBDB                        jmp short .exit
  3627                                  .set_curs_pos:
  3628                                  ;Input: DH = Row, DL = Column, BH = active page
  3629 00000CBA 51                          push rcx
  3630 00000CBB 52                          push rdx
  3631                                      
  3632 00000CBC 53                          push rbx
  3633 00000CBD 88FB                        mov bl, bh
  3634 00000CBF 480FB6DB                    movzx rbx, bl
  3635 00000CC3 6689941B[43010000]          mov word [scr_curs_pos + 2*rbx], dx
  3636 00000CCB 5B                          pop rbx
  3637 00000CCC 3A3C25[59010000]            cmp bh, byte [scr_active_page]
  3638 00000CD3 7505                        jne .scpexit    ;if the page is not the active page
  3639 00000CD5 E8E3050000                  call .cursor_proc
  3640                                  .scpexit:
  3641 00000CDA 5A                          pop rdx
  3642 00000CDB 59                          pop rcx
  3643 00000CDC EBB7                        jmp short .exit
  3644                                      
  3645                                  
  3646                                  .get_curs_pos:
  3647                                  ;Return: AX = 0, CH = Start scan line, CL = End scan line, DH = Row, DL = Column
  3648 00000CDE 53                          push rbx
  3649                                  
  3650 00000CDF 88FB                        mov bl, bh
  3651 00000CE1 480FB6DB                    movzx rbx, bl
  3652 00000CE5 668B941B[43010000]          mov dx, word [scr_curs_pos + 2*rbx] 
  3653 00000CED 668B0C25[55010000]          mov cx, word [scr_curs_shape]    ;Get cursor shape
  3654                                  
  3655 00000CF5 5B                          pop rbx
  3656 00000CF6 6631C0                      xor ax, ax 
  3657 00000CF9 E997FFFFFF                  jmp .exit
  3658                                  
  3659                                  .write_register:    ;al contains the byte to convert
  3660 00000CFE 52                          push rdx
  3661 00000CFF 53                          push rbx
  3662 00000D00 50                          push rax
  3663                                  
  3664 00000D01 88C2                        mov dl, al           ;save byte in dl
  3665 00000D03 6625F000                    and ax, 00F0h        ;Hi nybble
  3666 00000D07 6681E20F00                  and dx, 000Fh        ;Lo nybble
  3667 00000D0C 66C1E804                    shr ax, 4            ;shift one hex place value pos right
  3668 00000D10 E810000000                  call .wrchar
  3669 00000D15 6689D0                      mov ax, dx           ;mov lo nybble, to print
  3670 00000D18 E808000000                  call .wrchar
  3671                                  
  3672 00000D1D 58                          pop rax
  3673 00000D1E 5B                          pop rbx
  3674 00000D1F 5A                          pop rdx
  3675 00000D20 E970FFFFFF                  jmp .exit
  3676                                  .wrchar:
  3677 00000D25 48BB-                       mov rbx, .wrascii
  3677 00000D27 [370D000000000000] 
  3678 00000D2F D7                          xlatb    ;point al to entry in ascii table, using al as offset into table
  3679 00000D30 B40E                        mov ah, 0Eh
  3680 00000D32 B307                        mov bl, 07h
  3681 00000D34 CD30                        int 30h  ;print char
  3682 00000D36 C3                          ret
  3683 00000D37 303132333435363738-     .wrascii:    db    '0123456789ABCDEF'
  3683 00000D40 39414243444546     
  3684                                  .select_page:
  3685                                  ;ah contains the current screen mode
  3686                                  ;al contains new screen page
  3687                                  ;vga just returns as invalid FOR NOW
  3688                                  ;Handled differently between vga and classic modes
  3689 00000D47 80FC04                      cmp ah, 04
  3690 00000D4A 761D                        jbe .sp1
  3691 00000D4C 80FC07                      cmp ah, 07
  3692 00000D4F 7418                        je .sp1
  3693 00000D51 80FC0D                      cmp ah, 0Dh
  3694 00000D54 0F838E000000                jae .sp_vga
  3695                                  .spbad:
  3696 00000D5A 48B8FFFF0000000000-         mov rax, 0FFFFh
  3696 00000D63 00                 
  3697 00000D64 E92CFFFFFF                  jmp .exit    ;Bad argument
  3698                                  .sp1:
  3699 00000D69 3C08                        cmp al, 8
  3700 00000D6B 73ED                        jae .spbad    ;page should be 0-7
  3701                                  .spmain:
  3702 00000D6D 50                          push rax
  3703 00000D6E 53                          push rbx
  3704 00000D6F 51                          push rcx
  3705 00000D70 52                          push rdx
  3706 00000D71 880425[59010000]            mov byte [scr_active_page], al    ;change active page
  3707                                  ;----Modify this proc with data tables when finalised!!----
  3708 00000D78 48BE00080000000000-         mov rsi, 800h    ;mode 0,1 page size
  3708 00000D81 00                 
  3709 00000D82 48BB00100000000000-         mov rbx, 1000h    ;mode 2,3,7 page size
  3709 00000D8B 00                 
  3710 00000D8C 480FB6C8                    movzx rcx, al    ;Get count into rcx
  3711 00000D90 80FC02                      cmp ah, 2
  3712 00000D93 480F42DE                    cmovb rbx, rsi
  3713 00000D97 48BA00800B00000000-         mov rdx, vga_bpage2
  3713 00000DA0 00                 
  3714 00000DA1 48BE00000B00000000-         mov rsi, vga_bpage1    ;Base addr for mode 7
  3714 00000DAA 00                 
  3715                                  ;----Modify this proc with data tables when finalised!!----
  3716 00000DAB 80FC07                      cmp ah, 7
  3717 00000DAE 480F44D6                    cmove rdx, rsi
  3718 00000DB2 52                          push rdx    ;Push the saved page 0 address
  3719 00000DB3 E307                        jrcxz .spm2    ;If 0th page, dont add
  3720                                  .spm1:
  3721 00000DB5 4801DA                      add rdx, rbx
  3722 00000DB8 FEC9                        dec cl
  3723 00000DBA 75F9                        jnz .spm1
  3724                                  .spm2:
  3725 00000DBC 5E                          pop rsi     ;Get saved base into rsi
  3726 00000DBD 891425[5C010000]            mov dword [scr_page_addr], edx    ;Get new base addr
  3727 00000DC4 4829F2                      sub rdx, rsi    ;rsi has conditionally b8000 or b0000
  3728 00000DC7 50                          push rax
  3729 00000DC8 66D1EA                      shr dx, 1    ;Divide dx by 2 to get # of PELs
  3730 00000DCB 6689D1                      mov cx, dx    ;Get offset from crtc base addr
  3731 00000DCE 66B80C00                    mov ax, 0Ch    ;6845 Start Addr register
  3732 00000DD2 E84B040000                  call .write_crtc_word    ;Change "crtc view window"
  3733                                  
  3734 00000DD7 58                          pop rax        ;Get original ax back for page number
  3735 00000DD8 88C7                        mov bh, al
  3736 00000DDA E8DE040000                  call .cursor_proc    ;Move cursor on page
  3737                                      
  3738 00000DDF 5A                          pop rdx
  3739 00000DE0 59                          pop rcx
  3740 00000DE1 5B                          pop rbx
  3741 00000DE2 58                          pop rax
  3742 00000DE3 E9ADFEFFFF                  jmp .exit    ;Bad argument
  3743                                  .sp_vga:
  3744 00000DE8 E96DFFFFFF                  jmp .spbad
  3745                                  
  3746                                  .scroll_up:
  3747                                  ;Scrolls ACTIVE SCREEN only
  3748                                  ;Called with AL=number of lines to scroll, BH=Attribute for new area
  3749                                  ;    CH=ycor of top of scroll, CL=xcor of top of scroll
  3750                                  ;    DH=ycor of bottom of scroll, DL=xcor of bottom of scroll
  3751                                  ;If AL=0 then entire window is blanked, BH is used for blank attrib
  3752                                  ;ah contains the current screen mode
  3753 00000DED 80FC04                      cmp ah, 04    ;Test for Alpha mode
  3754 00000DF0 7209                        jb .su0
  3755 00000DF2 80FC07                      cmp ah, 07    ;Test for MDA Alpha mode
  3756 00000DF5 0F8509040000                jne .gscrollup    ;We in graphics mode, go to correct proc
  3757                                  .su0:
  3758 00000DFB 55                          push rbp
  3759 00000DFC 57                          push rdi
  3760 00000DFD 50                          push rax    ;Treat AX more or less as clobbered 
  3761                                      
  3762 00000DFE 84C0                        test al, al   ;Check if zero
  3763 00000E00 747F                        je .sblank    ;recall ah=06 then reset cursor and exit
  3764 00000E02 88C3                        mov bl, al    ;Save number of lines to scroll in bl
  3765                                  .su1:
  3766 00000E04 8B3425[5C010000]            mov esi, dword [scr_page_addr]    ;zeros upper dword
  3767 00000E0B 4889F7                      mov rdi, rsi  ;Point both pointers at base of active page
  3768 00000E0E 6689C8                      mov ax, cx    ;Bottom top corner into ax
  3769 00000E11 E870040000                  call .offset_from_ax    ;Get the page offset of dx
  3770 00000E16 480FB7C0                    movzx rax, ax
  3771 00000E1A 48D1E0                      shl rax, 1    ;Multiply by two for words
  3772 00000E1D 4801C7                      add rdi, rax  ;point to the top left of window
  3773 00000E20 4801C6                      add rsi, rax
  3774 00000E23 480FB60425-                 movzx rax, byte [scr_cols]
  3774 00000E28 [53010000]         
  3775 00000E2C 48D1E0                      shl rax, 1      ;number of columns * 2 for words!
  3776 00000E2F 4801C6                      add rsi, rax    ;Point rsi one row down
  3777 00000E32 51                          push rcx
  3778 00000E33 52                          push rdx
  3779                                  
  3780 00000E34 28EE                        sub dh, ch    ;work out number of rows to copy
  3781                                  .su2:
  3782 00000E36 56                          push rsi
  3783 00000E37 57                          push rdi
  3784 00000E38 E865040000                  call .text_scroll_c1    ;Scroll the selected row
  3785 00000E3D 5F                          pop rdi
  3786 00000E3E 5E                          pop rsi
  3787 00000E3F 4801C7                      add rdi, rax    ;goto next row
  3788 00000E42 4801C6                      add rsi, rax
  3789 00000E45 FECE                        dec dh
  3790 00000E47 75ED                        jnz .su2
  3791                                  
  3792 00000E49 5A                          pop rdx
  3793 00000E4A 59                          pop rcx
  3794                                  ;Draw blank line
  3795 00000E4B 50                          push rax
  3796 00000E4C 51                          push rcx
  3797 00000E4D 57                          push rdi
  3798                                  
  3799 00000E4E 6689C8                      mov ax, cx
  3800 00000E51 88F4                        mov ah, dh    ;Starting column from cx, starting row from dx
  3801 00000E53 E82E040000                  call .offset_from_ax
  3802 00000E58 8B3C25[5C010000]            mov edi, dword [scr_page_addr]
  3803 00000E5F 480FB7C0                    movzx rax, ax
  3804 00000E63 48D1E0                      shl rax, 1
  3805 00000E66 01C7                        add edi, eax   ;point to new line
  3806 00000E68 88FC                        mov ah, bh
  3807 00000E6A B020                        mov al, 20h    ;Blank char
  3808 00000E6C 4889E9                      mov rcx, rbp   ;move word count into cx
  3809 00000E6F F366AB                      rep stosw      ;write the word bp number of times
  3810 00000E72 5F                          pop rdi
  3811 00000E73 59                          pop rcx
  3812 00000E74 58                          pop rax
  3813 00000E75 FECB                        dec bl
  3814 00000E77 758B                        jnz .su1    ;Once we have done bl rows, exit
  3815                                  
  3816                                  .suexit:
  3817 00000E79 58                          pop rax
  3818 00000E7A 5F                          pop rdi
  3819 00000E7B 5D                          pop rbp
  3820 00000E7C E914FEFFFF                  jmp .exit
  3821                                  .sblank:
  3822                                  ;Fast clear function
  3823 00000E81 51                          push rcx
  3824 00000E82 52                          push rdx
  3825                                  
  3826 00000E83 88FC                        mov ah, bh    ;mov attrib into ah
  3827 00000E85 B020                        mov al, 20h    ;Space char
  3828 00000E87 8B3C25[5C010000]            mov edi, dword [scr_page_addr]
  3829 00000E8E 480FB61425-                 movzx rdx, byte [scr_rows]
  3829 00000E93 [54010000]         
  3830                                  .sbl0:
  3831 00000E97 480FB60C25-                 movzx rcx, byte [scr_cols]
  3831 00000E9C [53010000]         
  3832 00000EA0 F366AB                      rep stosw
  3833 00000EA3 FECA                        dec dl
  3834 00000EA5 75F0                        jnz .sbl0
  3835                                  
  3836 00000EA7 5A                          pop rdx
  3837 00000EA8 59                          pop rcx
  3838 00000EA9 EBCE                        jmp short .suexit
  3839                                  
  3840                                  .scroll_down:
  3841                                  ;Scrolls ACTIVE SCREEN only
  3842                                  ;Called with AL=number of lines to scroll, BH=Attribute for new area
  3843                                  ;    CH=ycor of top of scroll, CL=xcor of top of scroll
  3844                                  ;    DH=ycor of bottom of scroll, DL=xcor of bottom of scroll
  3845                                  ;If AL=0 then entire window is blanked, BH is used for blank attrib
  3846                                  ;ah contains the current screen mode
  3847 00000EAB 80FC04                      cmp ah, 04    ;Test for Alpha mode
  3848 00000EAE 7209                        jb .sd0
  3849 00000EB0 80FC07                      cmp ah, 07    ;Test for MDA Alpha mode
  3850 00000EB3 0F855A030000                jne .gscrolldown    ;We in graphics mode, go to correct proc
  3851                                  .sd0:
  3852 00000EB9 55                          push rbp
  3853 00000EBA 57                          push rdi
  3854 00000EBB 50                          push rax    ;Treat AX more or less as clobbered
  3855                                  
  3856 00000EBC 84C0                        test al, al    ;Check if zero
  3857 00000EBE 74C1                        je .sblank    ;recall ah=06 then reset cursor and exit
  3858 00000EC0 88C3                        mov bl, al    ;Save number of lines to scroll in bl
  3859 00000EC2 FD                          std    ;change the direction of string operations
  3860                                  .sd1:
  3861 00000EC3 8B3425[5C010000]            mov esi, dword [scr_page_addr]    ;point esi to bottom
  3862 00000ECA 6689D0                      mov ax, dx    ;point to bottom right 
  3863 00000ECD E8B4030000                  call .offset_from_ax
  3864 00000ED2 480FB7C0                    movzx rax, ax
  3865 00000ED6 48D1E0                      shl rax, 1
  3866 00000ED9 4801C6                      add rsi, rax
  3867 00000EDC 4889F7                      mov rdi, rsi
  3868 00000EDF 480FB60425-                 movzx rax, byte [scr_cols]
  3868 00000EE4 [53010000]         
  3869 00000EE8 48D1E0                      shl rax, 1
  3870 00000EEB 4829C6                      sub rsi, rax    ;Point rsi one row above rdi
  3871                                  
  3872 00000EEE 51                          push rcx
  3873 00000EEF 52                          push rdx
  3874 00000EF0 28EE                        sub dh, ch    ;Number of rows to copy
  3875                                  .sd2:
  3876 00000EF2 56                          push rsi
  3877 00000EF3 57                          push rdi
  3878 00000EF4 E8A9030000                  call .text_scroll_c1
  3879 00000EF9 5F                          pop rdi
  3880 00000EFA 5E                          pop rsi
  3881 00000EFB 4829C7                      sub rdi, rax
  3882 00000EFE 4829C6                      sub rsi, rax
  3883 00000F01 FECE                        dec dh
  3884 00000F03 75ED                        jnz .sd2
  3885                                  
  3886 00000F05 5A                          pop rdx
  3887 00000F06 59                          pop rcx
  3888                                  ;Draw blank line
  3889 00000F07 50                          push rax
  3890 00000F08 51                          push rcx
  3891 00000F09 57                          push rdi
  3892                                  
  3893 00000F0A 6689D0                      mov ax, dx
  3894 00000F0D 88EC                        mov ah, ch    ;Starting column from dx, starting row from cx
  3895 00000F0F E872030000                  call .offset_from_ax
  3896 00000F14 8B3C25[5C010000]            mov edi, dword [scr_page_addr]
  3897 00000F1B 480FB7C0                    movzx rax, ax
  3898 00000F1F 48D1E0                      shl rax, 1
  3899 00000F22 01C7                        add edi, eax    ;Point to appropriate line and col
  3900 00000F24 88FC                        mov ah, bh
  3901 00000F26 B020                        mov al, 20h
  3902 00000F28 4889E9                      mov rcx, rbp
  3903 00000F2B F366AB                      rep stosw    ;Store backwards
  3904 00000F2E 5F                          pop rdi
  3905 00000F2F 59                          pop rcx
  3906 00000F30 58                          pop rax
  3907 00000F31 FECB                        dec bl
  3908 00000F33 758E                        jnz .sd1
  3909                                  
  3910                                  .sdexit:
  3911 00000F35 58                          pop rax
  3912 00000F36 5F                          pop rdi
  3913 00000F37 5D                          pop rbp
  3914 00000F38 E958FDFFFF                  jmp .exit
  3915                                  .read_att_char:
  3916                                  ;Get ASCII char and attr at current cursor position on chosen page
  3917                                  ;Called with AH=08h, BH=Page number (if supported),
  3918                                  ;Returns, AH=Attrib, AL=Char
  3919                                  
  3920                                  ;On entry, ah contains current screen mode
  3921 00000F3D 80FC04                      cmp ah, 04    ;Test for Alpha mode
  3922 00000F40 7209                        jb .rac1
  3923 00000F42 80FC07                      cmp ah, 07    ;Test for MDA Alpha mode
  3924 00000F45 0F859B020000                jne .gread    ;We in graphics mode, go to correct proc
  3925                                  .rac1:
  3926 00000F4B 80FF07                      cmp bh, 7
  3927 00000F4E 0F8739FDFFFF                ja .exitf    ;All A/N modes can have 8 pages, any more, fail
  3928                                  
  3929 00000F54 88E3                        mov bl, ah    ;Move screen mode into bl for function call
  3930 00000F56 8B3425[5C010000]            mov esi, dword [scr_page_addr]
  3931 00000F5D E814030000                  call .page_cursor_offset    ;bx preserved
  3932 00000F62 48D1E0                      shl rax, 1        
  3933 00000F65 4801C6                      add rsi, rax    ;rsi should point to attrib/char 
  3934 00000F68 66AD                        lodsw            ;Load ah with attrib/char
  3935 00000F6A E926FDFFFF                  jmp .exit    ;Restoring rsi
  3936                                  
  3937                                  .write_att_char:
  3938                                  ;Puts ASCII char and attribute/colour at cursor
  3939                                  ;Called with AH=09h, AL=Char, BH=Page, 
  3940                                  ;    BL=Attrib/Color, CX=number of repeats
  3941                                  ;Returns nothing (just prints in page)
  3942                                  
  3943                                  ;When called, ah contains current screen mode
  3944 00000F6F 80FC04                      cmp ah, 04    ;Test for Alpha mode
  3945 00000F72 7209                        jb .wac1
  3946 00000F74 80FC07                      cmp ah, 07    ;Test for MDA Alpha mode
  3947 00000F77 0F8578020000                jne .gwrite    ;We in graphics mode, go to correct proc
  3948                                  .wac1:
  3949 00000F7D 80FF07                      cmp bh, 7
  3950 00000F80 0F8707FDFFFF                ja .exitf    ;All A/N modes can have 8 pages, any more, fail
  3951                                  
  3952 00000F86 86DC                        xchg bl, ah ;swap attrib and scr mode bytes
  3953 00000F88 57                          push rdi
  3954 00000F89 50                          push rax    ;Save the char/attrib word
  3955 00000F8A 8B3425[5C010000]            mov esi, dword [scr_page_addr]
  3956 00000F91 E8E0020000                  call .page_cursor_offset    ;bx preserved
  3957 00000F96 4889F7                      mov rdi, rsi    ;Change register for string ops
  3958 00000F99 48D1E0                      shl rax, 1
  3959 00000F9C 4801C7                      add rdi, rax    ;rsi now points to right place on right page
  3960 00000F9F 58                          pop rax
  3961                                  
  3962 00000FA0 51                          push rcx
  3963 00000FA1 480FB7C9                    movzx rcx, cx    ;zero upper bytes
  3964 00000FA5 F366AB                      rep stosw        ;Store packed ah/al cx times
  3965 00000FA8 59                          pop rcx
  3966 00000FA9 5F                          pop rdi
  3967 00000FAA E9E6FCFFFF                  jmp .exit    ;Restoring rsi
  3968                                  
  3969                                  .write_char:
  3970                                  ;Puts ASCII char and attribute/colour at cursor
  3971                                  ;Called with AH=0Ah, AL=Char, BH=Page, 
  3972                                  ;    BL=Color (G modes ONLY), CX=number of repeats
  3973                                  ;Returns nothing (just prints in page)
  3974 00000FAF 80FC04                      cmp ah, 04    ;Test for Alpha mode
  3975 00000FB2 7209                        jb .wc1
  3976 00000FB4 80FC07                      cmp ah, 07    ;Test for MDA Alpha mode
  3977 00000FB7 0F8538020000                jne .gwrite    ;We in graphics mode, go to correct proc
  3978                                  .wc1:
  3979 00000FBD 80FF07                      cmp bh, 7
  3980 00000FC0 0F87C7FCFFFF                ja .exitf    ;All A/N modes can have 8 pages, any more, fail
  3981                                  
  3982 00000FC6 88E3                        mov bl, ah ;mov scr mode byte into bl
  3983 00000FC8 57                          push rdi
  3984 00000FC9 50                          push rax    ;Save the char word
  3985 00000FCA 8B3425[5C010000]            mov esi, dword [scr_page_addr]
  3986 00000FD1 E8A0020000                  call .page_cursor_offset    ;bx preserved
  3987 00000FD6 4889F7                      mov rdi, rsi    ;Change register for string ops
  3988 00000FD9 48D1E0                      shl rax, 1
  3989 00000FDC 4801C7                      add rdi, rax    ;rdi now points to right place on right page
  3990 00000FDF 58                          pop rax
  3991                                  
  3992 00000FE0 51                          push rcx
  3993 00000FE1 480FB7C9                    movzx rcx, cx    ;zero upper bytes
  3994 00000FE5 E309                        jrcxz .wc3    ;If cx is zero, dont print anything, exit
  3995                                  .wc2:
  3996 00000FE7 AA                          stosb
  3997 00000FE8 48FFC7                      inc rdi
  3998 00000FEB 48FFC9                      dec rcx
  3999 00000FEE 75F7                        jnz .wc2
  4000                                  .wc3:
  4001 00000FF0 59                          pop rcx
  4002 00000FF1 5F                          pop rdi
  4003 00000FF2 E99EFCFFFF                  jmp .exit    ;Exit restoring rsi
  4004                                  
  4005                                  .gset_col_palette:
  4006 00000FF7 48B8FFFF0000000000-         mov rax, 0FFFFh
  4006 00001000 00                 
  4007 00001001 E98FFCFFFF                  jmp .exit    ;Currently unsupported function
  4008                                  .gwritedot:
  4009 00001006 48B8FFFF0000000000-         mov rax, 0FFFFh
  4009 0000100F 00                 
  4010 00001010 E980FCFFFF                  jmp .exit    ;Currently unsupported function
  4011                                  .greaddot:
  4012 00001015 48B8FFFF0000000000-         mov rax, 0FFFFh
  4012 0000101E 00                 
  4013 0000101F E971FCFFFF                  jmp .exit    ;Currently unsupported function
  4014                                  
  4015                                  .write_tty:
  4016                                  ;Called with al=char, bl=foreground color (graphics)
  4017                                  ;When called, ah contains current screen mode
  4018 00001024 51                          push rcx
  4019 00001025 52                          push rdx
  4020 00001026 53                          push rbx
  4021 00001027 50                          push rax
  4022                                  
  4023 00001028 8A3C25[59010000]            mov bh, byte [scr_active_page]    ;Get active page
  4024 0000102F 50                          push rax
  4025 00001030 B403                        mov ah, 3    ;Get cursor into dx
  4026 00001032 CD30                        int 30h
  4027 00001034 58                          pop rax
  4028                                  
  4029 00001035 3C08                        cmp al, 08h    ;Check for backspace
  4030 00001037 746B                        je .wttybspace
  4031 00001039 3C0A                        cmp al, 0Ah    ;Check for line feed
  4032 0000103B 747F                        je .wttylf
  4033 0000103D 3C0D                        cmp al, 0Dh    ;Check for carriage return
  4034 0000103F 0F848D000000                je .wttycr
  4035 00001045 3C07                        cmp al, 07h    ;ASCII bell
  4036 00001047 0F848C000000                je .wttybell
  4037                                  
  4038                                  .wttywrite:
  4039 0000104D 48B901000000000000-         mov rcx, 1    
  4039 00001056 00                 
  4040 00001057 B40A                        mov ah, 0Ah    ;Write 1 char w/o attrib byte
  4041 00001059 CD30                        int 30h    ;bh contains page to write for
  4042                                  
  4043                                  .wttycursorupdate:
  4044 0000105B FEC2                        inc dl
  4045 0000105D 3A1425[53010000]            cmp dl, byte [scr_cols]
  4046 00001064 730D                        jae .wttycu0    ;go down by a line, and start of the line
  4047                                  .wttycursorupdatego:
  4048 00001066 B402                        mov ah, 2
  4049 00001068 CD30                        int 30h     ;set cursor
  4050                                  .wttyexit:
  4051 0000106A 58                          pop rax
  4052 0000106B 5B                          pop rbx
  4053 0000106C 5A                          pop rdx
  4054 0000106D 59                          pop rcx
  4055 0000106E E922FCFFFF                  jmp .exit
  4056                                  
  4057                                  .wttycu0:
  4058 00001073 30D2                        xor dl, dl    ;Return to start of line
  4059 00001075 FEC6                        inc dh
  4060 00001077 3A3425[54010000]            cmp dh, byte [scr_rows]    ;are past the bottom of the screen?
  4061 0000107E 72E6                        jb .wttycursorupdatego    ;we are not past the bottom of the screen
  4062                                  .wttyscrollupone:
  4063 00001080 53                          push rbx
  4064 00001081 B408                        mov ah, 08h    ;Read char/attrib at cursor
  4065 00001083 CD30                        int 30h
  4066 00001085 88E7                        mov bh, ah    ;Move attrib byte into bh
  4067 00001087 4831C9                      xor rcx, rcx
  4068 0000108A 668B1425[53010000]          mov dx, word [scr_cols]    ;word access all ok
  4069 00001092 FECE                        dec dh
  4070 00001094 FECA                        dec dl
  4071 00001096 66B80106                    mov ax, 0601h    ;scroll up one line
  4072 0000109A CD30                        int 30h
  4073                                  
  4074 0000109C 30D2                        xor dl, dl 
  4075 0000109E 5B                          pop rbx
  4076 0000109F E9C2FFFFFF                  jmp .wttycursorupdatego
  4077                                  .wttybspace:
  4078 000010A4 84D2                        test dl, dl    ;compare if the column is zero
  4079 000010A6 750D                        jnz .wttybs1   ;if not just decrement row pos
  4080 000010A8 84F6                        test dh, dh    ;compare if zero row, if so do nothing
  4081 000010AA 74BE                        jz .wttyexit   ;at top left, just exit
  4082 000010AC FECE                        dec dh
  4083 000010AE 8A1425[53010000]            mov dl, byte [scr_cols]    ;move to end of prev row + 1
  4084                                  .wttybs1:
  4085 000010B5 FECA                        dec dl
  4086 000010B7 E9AAFFFFFF                  jmp .wttycursorupdatego
  4087                                  
  4088                                  .wttylf:
  4089 000010BC 52                          push rdx
  4090 000010BD 8A1425[54010000]            mov dl, byte [scr_rows]
  4091 000010C4 FECA                        dec dl
  4092 000010C6 38D6                        cmp dh, dl
  4093 000010C8 5A                          pop rdx
  4094 000010C9 74B5                        je .wttyscrollupone    ;if we need to scroll, scroll
  4095 000010CB FEC6                        inc dh    ;otherwise just send cursor down by one
  4096 000010CD E994FFFFFF                  jmp    .wttycursorupdatego
  4097                                  .wttycr:
  4098 000010D2 B200                        mov dl, 0    ;Set to 0 on row
  4099 000010D4 E98DFFFFFF                  jmp .wttycursorupdatego
  4100                                  .wttybell:
  4101 000010D9 48B9E8030000000000-         mov rcx, 1000   ;Beep for a second
  4101 000010E2 00                 
  4102 000010E3 BBA9040000                  mov ebx, 04A9h  ;Frequency divisor for 1000Hz tone
  4103 000010E8 E8A9EFFFFF                  call beep
  4104 000010ED E978FFFFFF                  jmp .wttyexit
  4105                                  
  4106                                  .get_mode:
  4107                                  ;Takes no arguments
  4108                                  ;Returns ah=Number of Columns, al=Current Screen mode, bh=active page
  4109 000010F2 8A2425[53010000]            mov ah, byte [scr_cols]
  4110 000010F9 8A0425[58010000]            mov al, byte [scr_mode]
  4111 00001100 8A3C25[59010000]            mov bh, byte [scr_active_page]
  4112 00001107 E989FBFFFF                  jmp .exit
  4113                                  
  4114                                  
  4115                                  ;Bad string argument for below function
  4116                                  .wsbad:
  4117 0000110C 48B8FFFF0000000000-         mov rax, 0FFFFh
  4117 00001115 00                 
  4118 00001116 E97AFBFFFF                  jmp .exit
  4119                                  .write_string:
  4120                                  ;bh=page to print on, bl=attribute, cx=number of chars to print
  4121                                  ;dh=y coord to print at, dl=x coord to print at, rbp=string
  4122                                  ;al contains subfunction
  4123                                  ;al=0 attrib in bl, cursor NOT updated
  4124                                  ;al=1 attrib in bl, cursor updated
  4125                                  ;al=2 string alt attrib/char, cursor NOT updated
  4126                                  ;al=3 string alt attrib/char, cursor updated
  4127                                  ;al=4 print 0 terminated string
  4128 0000111B 3C04                        cmp al, 4h
  4129 0000111D 0F84AA000000                je .wszero    ;If its a zero terminated string, go down
  4130 00001123 E3E7                        jrcxz .wsbad
  4131 00001125 3C04                        cmp al, 4h    ;Bad argument
  4132 00001127 77E3                        ja .wsbad
  4133                                  .ws:
  4134 00001129 56                          push rsi
  4135 0000112A 51                          push rcx
  4136 0000112B 52                          push rdx
  4137 0000112C 53                          push rbx
  4138 0000112D 50                          push rax
  4139                                  
  4140 0000112E 53                          push rbx
  4141 0000112F 88FB                        mov bl, bh
  4142 00001131 0FB6DB                      movzx ebx, bl
  4143 00001134 66678BB41B-                 mov si, word [scr_curs_pos + 2*ebx]    ;Fast get cursor position
  4143 00001139 [43010000]         
  4144 0000113D 5B                          pop rbx
  4145 0000113E 56                          push rsi    ;Save the current cursor position
  4146                                  
  4147 0000113F 50                          push rax
  4148 00001140 B402                        mov ah, 02h    ;Set cursor at dx
  4149 00001142 CD30                        int 30h
  4150 00001144 58                          pop rax
  4151                                  
  4152                                  .ws0:
  4153 00001145 51                          push rcx
  4154 00001146 53                          push rbx
  4155 00001147 50                          push rax
  4156 00001148 88C4                        mov ah, al
  4157 0000114A 8A4500                      mov al, byte [rbp] ;Get char
  4158 0000114D 48FFC5                      inc rbp
  4159 00001150 3C07                        cmp al, 07h
  4160 00001152 7462                        je .wsctrlchar
  4161 00001154 3C08                        cmp al, 08h
  4162 00001156 745E                        je .wsctrlchar
  4163 00001158 3C0A                        cmp al, 0Ah
  4164 0000115A 745A                        je .wsctrlchar
  4165 0000115C 3C0D                        cmp al, 0Dh
  4166 0000115E 7456                        je .wsctrlchar
  4167                                  
  4168 00001160 80FC02                      cmp ah, 2    ;Check if we need to get the char attrib too
  4169 00001163 7206                        jb .ws1
  4170 00001165 8A5D00                      mov bl, byte [rbp]    ;Get char attrib
  4171 00001168 48FFC5                      inc rbp
  4172                                  .ws1:
  4173 0000116B 66B90100                    mov cx, 1
  4174 0000116F B409                        mov ah, 09h    ;Print char and attrib (either given or taken)
  4175 00001171 CD30                        int 30h
  4176                                  
  4177 00001173 FEC2                        inc dl
  4178 00001175 3A1425[53010000]            cmp dl, byte [scr_cols]    ;Check if we passed the end of the row
  4179 0000117C 7515                        jne .ws2    ;We havent, skip the reset
  4180 0000117E 30D2                        xor dl, dl    ;Reset horizontal pos
  4181 00001180 FEC6                        inc dh        ;Goto next row
  4182 00001182 3A3425[53010000]            cmp dh, byte [scr_cols]    ;Have we passed the last row?
  4183 00001189 7508                        jne .ws2    ;No, put cursor
  4184 0000118B 66B80A0E                    mov ax, 0E0Ah    ;Yes, do  TTY Line feed
  4185 0000118F CD30                        int 30h
  4186 00001191 FECE                        dec dh        ;Mov cursor to start of last row on page
  4187                                  .ws2:
  4188 00001193 B402                        mov ah, 02
  4189 00001195 CD30                        int 30h    ;Put cursor at new location
  4190                                  .ws3:
  4191 00001197 58                          pop rax
  4192 00001198 5B                          pop rbx
  4193 00001199 59                          pop rcx
  4194                                  
  4195 0000119A 66FFC9                      dec cx
  4196 0000119D 75A6                        jnz .ws0
  4197                                  
  4198                                  .wsexitupdate:    ;Exit returning char to original position
  4199 0000119F 5A                          pop rdx
  4200 000011A0 3C01                        cmp al, 01h
  4201 000011A2 7408                        je .wsexit
  4202 000011A4 3C03                        cmp al, 03h
  4203 000011A6 7404                        je .wsexit
  4204                                  ;Exit returning char to original position    
  4205 000011A8 B402                        mov ah, 02h
  4206 000011AA CD30                        int 30h 
  4207                                  .wsexit:
  4208 000011AC 58                          pop rax
  4209 000011AD 5B                          pop rbx
  4210 000011AE 5A                          pop rdx
  4211 000011AF 59                          pop rcx
  4212 000011B0 5E                          pop rsi
  4213 000011B1 E9DFFAFFFF                  jmp .exit
  4214                                  .wsctrlchar:
  4215                                  ;Handles Control Characters: ASCII Bell, Bspace, LF and CR
  4216 000011B6 B40E                        mov ah, 0Eh
  4217 000011B8 CD30                        int 30h    ;Print control char as TTY
  4218 000011BA 88FB                        mov bl, bh
  4219 000011BC 0FB6DB                      movzx ebx, bl
  4220 000011BF 66678B941B-                 mov dx, word [scr_curs_pos + 2*ebx]    ;Fast get cursor position
  4220 000011C4 [43010000]         
  4221 000011C8 E9CAFFFFFF                  jmp .ws3
  4222                                  .wszero:
  4223                                  ;Print zero terminated string at cursor on current active page
  4224                                  ;Called with ax=1304, rbp=pointer to string
  4225 000011CD 55                          push rbp
  4226 000011CE 50                          push rax
  4227                                  .wsz1:
  4228 000011CF 8A4500                      mov al, byte [rbp]
  4229 000011D2 84C0                        test al, al    ;Check al got a zero char
  4230 000011D4 7409                        jz .wsz2
  4231 000011D6 48FFC5                      inc rbp
  4232 000011D9 B40E                        mov ah, 0Eh
  4233 000011DB CD30                        int 30h
  4234 000011DD EBF0                        jmp short .wsz1
  4235                                  .wsz2:
  4236 000011DF 58                          pop rax
  4237 000011E0 5D                          pop rbp
  4238 000011E1 E9AFFAFFFF                  jmp .exit
  4239                                  
  4240                                  ;Graphics mode specific versions!
  4241                                  .gread:
  4242 000011E6 48B8FFFF0000000000-         mov rax, 0FFFFh
  4242 000011EF 00                 
  4243 000011F0 E9A0FAFFFF                  jmp .exit    ;Currently unsupported function
  4244                                  .gwrite:
  4245 000011F5 48B8FFFF0000000000-         mov rax, 0FFFFh
  4245 000011FE 00                 
  4246 000011FF E991FAFFFF                  jmp .exit    ;Currently unsupported function
  4247                                  .gscrollup:
  4248 00001204 48B8FFFF0000000000-         mov rax, 0FFFFh
  4248 0000120D 00                 
  4249 0000120E E982FAFFFF                  jmp .exit    ;Currently unsupported function
  4250                                  .gscrolldown:
  4251 00001213 48B8FFFF0000000000-         mov rax, 0FFFFh
  4251 0000121C 00                 
  4252 0000121D E973FAFFFF                  jmp .exit    ;Currently unsupported function
  4253                                  
  4254                                  .write_crtc_word: ;Writes cx to the CRTC register in al and al+1
  4255 00001222 52                          push rdx
  4256                                  
  4257 00001223 668B1425[5A010000]          mov dx, word [scr_crtc_base]
  4258 0000122B EE                          out dx, al
  4259 0000122C FEC2                        inc dl
  4260 0000122E 88C4                        mov ah, al    ;Temp save al
  4261 00001230 88E8                        mov al, ch    ;Set high bits first
  4262 00001232 EE                          out dx, al
  4263                                  
  4264 00001233 FECA                        dec dl
  4265 00001235 88E0                        mov al, ah    ;Bring back al into al
  4266 00001237 FEC0                        inc al ;GOTO next CTRC address
  4267                                  
  4268 00001239 EE                          out dx, al
  4269 0000123A FEC2                        inc dl
  4270 0000123C 88C8                        mov al, cl
  4271 0000123E EE                          out dx, al 
  4272                                  
  4273 0000123F 5A                          pop rdx
  4274 00001240 C3                          ret
  4275                                  
  4276                                  .get_page_base:
  4277                                  ;Returns in rsi, the base address of the selected page
  4278                                  ;Called with BH = page number, BL=screen mode
  4279                                  ;return RSI=Base of selected page, since rsi is already clobbered
  4280 00001241 51                          push rcx
  4281 00001242 53                          push rbx
  4282                                  
  4283 00001243 88F9                        mov cl, bh    ;mov into cl, free bx
  4284 00001245 480FB6C9                    movzx rcx, cl
  4285                                  ;----Modify this proc with data tables when finalised!!----
  4286 00001249 80FB02                      cmp bl, 2
  4287 0000124C 66BB0010                    mov bx, 1000h    ;Doesnt affect flags
  4288 00001250 48BE00080000000000-         mov rsi, 800h    ;si is a free register
  4288 00001259 00                 
  4289 0000125A 660F42DE                    cmovb bx, si    ;if below, replace with 800h
  4290 0000125E 480FB7DB                    movzx rbx, bx        ;zero extend
  4291 00001262 8B3425[5C010000]            mov esi, dword [scr_page_addr]
  4292 00001269 E308                        jrcxz .gpb1        ;Dont enter the loop if cx is zero
  4293                                  .gpb0:
  4294 0000126B 4801DE                      add rsi, rbx    ;add pagesize cx times
  4295 0000126E 48FFC9                      dec rcx
  4296 00001271 75F8                        jnz .gpb0        ;go around
  4297                                  
  4298                                  .gpb1:
  4299 00001273 5B                          pop rbx
  4300 00001274 59                          pop rcx
  4301 00001275 C3                          ret
  4302                                  
  4303                                  .page_cursor_offset:
  4304                                  ;Returns in rax the offset into the RAM page of the cursor
  4305                                  ;Works for A/N modes and graphic, though must be shl by 1 for A/N modes
  4306                                  ;bh contains page to work out address 
  4307 00001276 53                          push rbx
  4308 00001277 88FB                        mov bl, bh    ;bring the page number from bh into bl
  4309 00001279 480FB6DB                    movzx rbx, bl            
  4310 0000127D 668B841B[43010000]          mov ax, word [scr_curs_pos + 2*rbx]    ;move cursor position into ax
  4311 00001285 5B                          pop rbx
  4312                                  .offset_from_ax:
  4313                                  ;Same as above but now ax needs to be packed as in the cursor
  4314 00001286 52                          push rdx
  4315 00001287 53                          push rbx
  4316 00001288 4831DB                      xor rbx, rbx
  4317 0000128B 00C3                        add bl, al    ;move columns into bl
  4318 0000128D 66C1E808                    shr ax, 8    ;mov rows from ah to al to use 8 bit mul
  4319                                      
  4320 00001291 F62425[53010000]            mul byte [scr_cols]    ;multiply the row we are on by columns, store in ax
  4321 00001298 6601D8                      add ax, bx        ;add number of columns to this mix!
  4322 0000129B 480FB7C0                    movzx rax, ax
  4323                                  
  4324 0000129F 5B                          pop rbx
  4325 000012A0 5A                          pop rdx
  4326 000012A1 C3                          ret
  4327                                  .text_scroll_c1:
  4328                                  ;Common function
  4329                                  ;Scrolls a single pair of lines from column given in cl to dl
  4330                                  ;rsi/rdi assumed to be pointing at the right place
  4331                                  ;Direction to be set by calling function
  4332                                  ;All registers EXCEPT pointers preserved, rbp returns # of words
  4333 000012A2 51                          push rcx
  4334 000012A3 52                          push rdx
  4335 000012A4 4831ED                      xor rbp, rbp
  4336 000012A7 88CE                        mov dh, cl    ;Save upper left corner in dh, freeing cx
  4337 000012A9 88D1                        mov cl, dl    
  4338 000012AB 28F1                        sub cl, dh    ;Get correct number of words to copy into cl
  4339 000012AD 480FB6C9                    movzx rcx, cl
  4340 000012B1 48FFC1                      inc rcx    ;absolute value, not offset
  4341 000012B4 4889CD                      mov rbp, rcx    ;Save number of words in rbp
  4342 000012B7 F366A5                      rep movsw    ;Move char/attrib for one row
  4343 000012BA 5A                          pop rdx
  4344 000012BB 59                          pop rcx
  4345 000012BC C3                          ret
  4346                                  .cursor_proc:
  4347                                  ;Called with bh containing page number
  4348                                  ;Sets cursor on page in bh
  4349                                  ;Returns nothing
  4350 000012BD E8B4FFFFFF                  call .page_cursor_offset    ;rax rets offset, no shift needed
  4351                                  
  4352 000012C2 88F9                        mov cl, bh
  4353 000012C4 480FB6C9                    movzx rcx, cl
  4354                                  ;----Modify this proc with data tables when finalised!!----
  4355 000012C8 6631F6                      xor si, si    
  4356 000012CB 66BA0008                    mov dx, 800h ;Most legacy Pages are sized 800h PELs, VGA greater
  4357 000012CF 803C25[58010000]02          cmp byte [scr_mode], 2
  4358 000012D7 7303                        jae .cp1
  4359 000012D9 66D1EA                      shr dx, 1    ;If in modes 0,1, 400h PELs per page
  4360                                  .cp1:
  4361 000012DC 84C9                        test cl, cl
  4362 000012DE 7407                        jz .cpwrite
  4363 000012E0 6601D6                      add si, dx 
  4364 000012E3 FEC9                        dec cl
  4365 000012E5 75F5                        jnz .cp1
  4366                                  
  4367                                  .cpwrite:
  4368 000012E7 6689C1                      mov cx, ax    ;move ax into cx
  4369 000012EA 6601F1                      add cx, si
  4370 000012ED B00E                        mov al, 0Eh    ;Cursor row
  4371 000012EF E82EFFFFFF                  call .write_crtc_word    ;cx has data to output, al is crtc reg
  4372                                  
  4373 000012F4 C3                          ret
  4374                                  ;------------------------End of Interrupt------------------------
  4375                                  ;-----------------------Basic Config Int 31h---------------------
  4376                                  ;This interrupt returns in ax the Hardware Bitfield from the 
  4377                                  ; data area and the mass storage device details.
  4378                                  ;----------------------------------------------------------------
  4379                                  machineWord_io:
  4380 000012F5 668B0425[C9010000]          mov ax, word [MachineWord]    ;Return the legacy bitfield
  4381                                  
  4382 000012FD 4C0FB60425-                 movzx r8, byte [i33Devices] ;Get Number of i33h devices
  4382 00001302 [A8010000]         
  4383 00001306 49C1E008                    shl r8, 8   ;Shift up by a byte
  4384 0000130A 448A0425[4B020000]          mov r8b, byte [numMSD]  ;Get the number of Mass Storage Devices (on EHCI)
  4385 00001312 49C1E008                    shl r8, 8   ;Shift up by a byte again
  4386 00001316 448A0425[AA010000]          mov r8b, byte [fdiskNum]    ;Get the number of fixed disks
  4387 0000131E 49C1E008                    shl r8, 8  ;Shift up by a byte again
  4388 00001322 448A0425[66000000]          mov r8b, byte [numCOM]      ;Get the number of COM ports
  4389                                  
  4390 0000132A 48CF                        iretq
  4391                                  ;------------------------End of Interrupt------------------------
  4392                                  ;------------------------Basic RAM Int 32h-----------------------
  4393                                  ;This interrupt returns in ax amount of conventional memory in ax
  4394                                  ;----------------------------------------------------------------
  4395                                  convRAM_io:
  4396 0000132C 668B0425[CB010000]          mov ax, word [convRAM]    ;Return the amount of conventional RAM
  4397 00001334 4C8B0425[CD010000]          mov r8, qword [userBase]    ;Return the userbase to a caller
  4398 0000133C 4C8B0C25[F0050000]          mov r9, qword [bigmapptr]   ;Return the big Map pointer 
  4399 00001344 4C0FB61425-                 movzx r10, byte [bigmapSize]    ;Return the number of 24 byte entries
  4399 00001349 [D5010000]         
  4400 0000134D 48CF                        iretq
  4401                                  ;------------------------End of Interrupt------------------------
  4402                                  ;---------------------Storage Interrupt Int 33h------------------
  4403                                  ;Input : dl = Drive number, rbx = Address of buffer, 
  4404                                  ;        al = number of sectors, ch = Track number, 
  4405                                  ;        cl = Sector number, dh = Head number
  4406                                  ;Input LBA: dl = Drive Number, rbx = Address of Buffer, 
  4407                                  ;           al = number of sectors, rcx = LBA number
  4408                                  ;
  4409                                  ;All registers not mentioned above, preserved
  4410                                  ;----------------------------------------------------------------
  4411                                  disk_io:
  4412 0000134F FC                          cld ;Ensure all string reads/writes are in the right way
  4413 00001350 F6C280                      test dl, 80h
  4414 00001353 0F8597000000                jnz .baddev    ;If bit 7 set, exit (temp for v0.9)
  4415 00001359 52                          push rdx
  4416 0000135A FEC2                        inc dl          ;Inc device number count to absolute value
  4417 0000135C 3A1425[A8010000]            cmp dl, byte [i33Devices]
  4418 00001363 5A                          pop rdx
  4419 00001364 0F8786000000                ja .baddev
  4420 0000136A 80FC16                      cmp ah, 16h
  4421 0000136D 0F84D6030000                jz .deviceChanged   ;Pick it off
  4422                                  
  4423 00001373 E8A7040000                  call .busScan   ;Bus scan only in valid cases
  4424 00001378 803C25[A9010000]40          cmp byte [msdStatus], 40h   ;Media seek failed
  4425 00001380 747E                        je .noDevInDrive
  4426                                  
  4427 00001382 84E4                        test ah, ah
  4428 00001384 0F8484000000                jz .reset           ;ah = 00h Reset Device
  4429 0000138A FECC                        dec ah
  4430 0000138C 0F84AF000000                jz .statusreport    ;ah = 01h Get status of last op and req. sense if ok 
  4431                                  
  4432 00001392 C60425[A9010000]00          mov byte [msdStatus], 00    ;Reset status byte for following operations
  4433                                  
  4434 0000139A FECC                        dec ah
  4435 0000139C 0F841E010000                jz .readsectors     ;ah = 02h CHS Read Sectors
  4436 000013A2 FECC                        dec ah
  4437 000013A4 0F843E010000                jz .writesectors    ;ah = 03h CHS Write Sectors
  4438 000013AA FECC                        dec ah
  4439 000013AC 0F8457010000                jz .verify          ;ah = 04h CHS Verify Sectors
  4440 000013B2 FECC                        dec ah
  4441 000013B4 0F8470010000                jz .format          ;ah = 05h CHS Format Track (Select Head and Cylinder)
  4442                                  
  4443 000013BA 80FC02                      cmp ah, 02h
  4444 000013BD 0F84A1020000                je .formatLowLevel  ;ah = 07h (SCSI) Low Level Format Device
  4445                                  
  4446 000013C3 80FC7D                      cmp ah, 7Dh         ;ah = 82h LBA Read Sectors
  4447 000013C6 0F84E5010000                je .lbaread
  4448 000013CC 80FC7E                      cmp ah, 7Eh         ;ah = 83h LBA Write Sectors
  4449 000013CF 0F8401020000                je .lbawrite
  4450 000013D5 80FC7F                      cmp ah, 7Fh         ;ah = 84h LBA Verify Sectors
  4451 000013D8 0F841D020000                je .lbaverify
  4452 000013DE 80FC80                      cmp ah, 80h         ;ah = 85h LBA Format Sectors
  4453 000013E1 0F8439020000                je .lbaformat
  4454 000013E7 80FC83                      cmp ah, 83h         ;ah = 88h LBA Read Drive Parameters
  4455 000013EA 0F8496020000                je .lbareadparams
  4456                                  .baddev:
  4457 000013F0 B401                        mov ah, 01h
  4458 000013F2 882425[A9010000]            mov byte [msdStatus], ah   ;Invalid function requested signature
  4459                                  .bad:
  4460 000013F9 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  4461 000013FE 48CF                        iretq
  4462                                  .noDevInDrive:
  4463 00001400 8A2425[A9010000]            mov ah, byte [msdStatus]
  4464 00001407 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  4465 0000140C 48CF                        iretq
  4466                                  .reset: ;Device Reset
  4467 0000140E 56                          push rsi
  4468 0000140F 52                          push rdx
  4469 00001410 E8E5020000                  call .i33ehciGetDevicePtr
  4470 00001415 E87F200000                  call USB.ehciAdjustAsyncSchedCtrlr
  4471 0000141A E8532F0000                  call USB.ehciMsdBOTResetRecovery
  4472                                  .rrexit:
  4473 0000141F 5A                          pop rdx
  4474 00001420 5E                          pop rsi
  4475 00001421 720E                        jc .rrbad
  4476 00001423 8A2425[A9010000]            mov ah, byte [msdStatus]
  4477 0000142A 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4478 0000142F 48CF                        iretq
  4479                                  .rrbad:
  4480 00001431 B405                        mov ah, 5   ;Reset failed
  4481 00001433 882425[A9010000]            mov byte [msdStatus], ah
  4482 0000143A 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  4483 0000143F 48CF                        iretq
  4484                                  .statusreport:  
  4485                                  ;If NOT a host/bus/ctrlr type error, request sense and ret code
  4486 00001441 8A2425[A9010000]            mov ah, byte [msdStatus]    ;Get last status into ah
  4487 00001448 84E4                        test ah, ah ;If status is zero, exit
  4488 0000144A 7507                        jnz .srmain
  4489 0000144C 80642410FE                  and byte [rsp + 2*8h], 0FEh     ;Clear CF
  4490 00001451 48CF                        iretq
  4491                                  .srmain:
  4492 00001453 C60425[A9010000]00          mov byte [msdStatus], 00    ;Reset status byte
  4493 0000145B 80FC20                      cmp ah, 20h     ;General Controller failure?
  4494 0000145E 7449                        je .srexit
  4495 00001460 80FC80                      cmp ah, 80h     ;Timeout?
  4496 00001463 7444                        je .srexit
  4497                                  ;Issue a Request sense command
  4498 00001465 56                          push rsi
  4499 00001466 50                          push rax    ;Save original error code in ah on stack
  4500 00001467 E88E020000                  call .i33ehciGetDevicePtr
  4501 0000146C E828200000                  call USB.ehciAdjustAsyncSchedCtrlr
  4502 00001471 7241                        jc .srexitbad1
  4503 00001473 E8C6340000                  call USB.ehciMsdBOTRequestSense
  4504 00001478 E8D52F0000                  call USB.ehciMsdBOTCheckTransaction
  4505 0000147D 6685C0                      test ax, ax
  4506 00001480 58                          pop rax         ;Get back original error code
  4507 00001481 752D                        jnz .srexitbad2
  4508 00001483 4C0FB60425-                 movzx r8, byte [ehciDataIn + 13]  ;Get ASCQ into r8
  4508 00001488 [CD030000]         
  4509 0000148C 49C1E008                    shl r8, 8                        ;Make space in lower byte of r8 for ASC key
  4510 00001490 448A0425[CC030000]          mov r8b, byte [ehciDataIn + 12]   ;Get ASC into r8
  4511 00001498 49C1E008                    shl r8, 8                    ;Make space in lower byte of r8 for sense key
  4512 0000149C 448A0425[C2030000]          mov r8b, byte [ehciDataIn + 2]  ;Get sense key into al
  4513 000014A4 4180C8F0                    or r8b, 0F0h                    ;Set sense signature (set upper nybble F)
  4514 000014A8 5E                          pop rsi
  4515                                  .srexit:
  4516 000014A9 804C241001                  or byte [rsp + 2*8h], 1 ;Non-zero error, requires CF=CY
  4517 000014AE 48CF                        iretq
  4518                                  .srexitbad2:
  4519 000014B0 B4FF                        mov ah, -1  ;Sense operation failed
  4520 000014B2 EB02                        jmp short .srexitbad
  4521                                  .srexitbad1:
  4522 000014B4 B420                        mov ah, 20h ;General Controller Failure
  4523                                  .srexitbad:
  4524 000014B6 5E                          pop rsi
  4525 000014B7 882425[A9010000]            mov byte [msdStatus], ah
  4526 000014BE EB21                        jmp short .rsbad
  4527                                  
  4528                                  .readsectors:
  4529 000014C0 57                          push rdi
  4530 000014C1 48BF-                       mov rdi, USB.ehciMsdBOTInSector512
  4530 000014C3 [624A000000000000] 
  4531 000014CB E8DE010000                  call .sectorsEHCI
  4532 000014D0 5F                          pop rdi
  4533 000014D1 8A2425[A9010000]            mov ah, byte [msdStatus]    ;Return Error code in ah
  4534 000014D8 7207                        jc .rsbad
  4535 000014DA 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4536 000014DF 48CF                        iretq
  4537                                  .rsbad:
  4538 000014E1 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  4539 000014E6 48CF                        iretq
  4540                                  
  4541                                  .writesectors:
  4542 000014E8 57                          push rdi
  4543 000014E9 48BF-                       mov rdi, USB.ehciMsdBOTOutSector512
  4543 000014EB [174A000000000000] 
  4544 000014F3 E8B6010000                  call .sectorsEHCI
  4545 000014F8 5F                          pop rdi
  4546 000014F9 8A2425[A9010000]            mov ah, byte [msdStatus]
  4547 00001500 72DF                        jc .rsbad
  4548 00001502 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4549 00001507 48CF                        iretq
  4550                                  
  4551                                  .verify:
  4552 00001509 57                          push rdi
  4553 0000150A 48BF-                       mov rdi, USB.ehciMsdBOTVerify
  4553 0000150C [EF48000000000000] 
  4554 00001514 E895010000                  call .sectorsEHCI   ;Verify sector by sector
  4555 00001519 5F                          pop rdi
  4556 0000151A 8A2425[A9010000]            mov ah, byte [msdStatus]
  4557 00001521 72BE                        jc .rsbad
  4558 00001523 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4559 00001528 48CF                        iretq
  4560                                  .format:
  4561                                  ;Cleans sectors on chosen track. DOES NOT Low Level Format.
  4562                                  ;Fills sectors with fill byte from table
  4563 0000152A 50                          push rax
  4564 0000152B 53                          push rbx
  4565 0000152C 51                          push rcx
  4566 0000152D 56                          push rsi
  4567 0000152E 57                          push rdi
  4568 0000152F 55                          push rbp
  4569                                  
  4570 00001530 51                          push rcx                    ;Save ch = Cylinder number
  4571 00001531 488B3425[AF010000]          mov rsi, qword [diskDptPtr]
  4572 00001539 B880000000                  mov eax, 80h                 ;128 bytes
  4573 0000153E 8A4E03                      mov cl, byte [rsi + 3]  ;Bytes per track
  4574 00001541 D3E0                        shl eax, cl                  ;Multiply 128 bytes per sector by multiplier
  4575 00001543 89C1                        mov ecx, eax
  4576 00001545 8A4608                      mov al, byte [rsi + 8]  ;Fill byte for format
  4577 00001548 48BF-                       mov rdi, sectorbuffer       ;Large enough buffer
  4577 0000154A [C003000000000000] 
  4578 00001552 F3AA                        rep stosb                   ;Create mock sector
  4579                                  
  4580 00001554 8A4E04                      mov cl, byte [rsi + 4]  ;Get sectors per track
  4581 00001557 0FB6E9                      movzx ebp, cl               ;Put number of sectors in Cylinder in ebp
  4582                                  
  4583 0000155A 59                          pop rcx                     ;Get back Cylinder number in ch
  4584 0000155B B101                        mov cl, 1                   ;Ensure start at sector 1 of Cylinder
  4585                                  
  4586 0000155D E8C6010000                  call .convertCHSLBA ;Converts to valid 32 bit LBA in ecx for geometry type
  4587                                      ;ecx now has LBA
  4588                                  .formatcommon:
  4589 00001562 E893010000                  call .i33ehciGetDevicePtr
  4590 00001567 7245                        jc .fbad
  4591 00001569 89CA                        mov edx, ecx    ;Load edx for function call
  4592                                  ;Replace this section with a single USB function
  4593 0000156B E8291F0000                  call USB.ehciAdjustAsyncSchedCtrlr
  4594 00001570 48BB-                       mov rbx, sectorbuffer
  4594 00001572 [C003000000000000] 
  4595                                  .f0:
  4596 0000157A E898340000                  call USB.ehciMsdBOTOutSector512
  4597 0000157F 0F826A010000                jc .sebadBB
  4598 00001585 FFC2                        inc edx ;Inc LBA
  4599 00001587 FFCD                        dec ebp ;Dec number of sectors to act on
  4600 00001589 75EF                        jnz .f0
  4601 0000158B F8                          clc
  4602                                  .formatexit:
  4603 0000158C 5D                          pop rbp
  4604 0000158D 5F                          pop rdi
  4605 0000158E 5E                          pop rsi
  4606 0000158F 59                          pop rcx
  4607 00001590 5B                          pop rbx
  4608 00001591 58                          pop rax
  4609 00001592 8A2425[A9010000]            mov ah, byte [msdStatus]
  4610 00001599 0F8242FFFFFF                jc .rsbad
  4611 0000159F 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4612 000015A4 48CF                        iretq
  4613                                  .fbadBB:
  4614 000015A6 C60425[A9010000]BB          mov byte [msdStatus], 0BBh  ;Unknown Error, request sense
  4615                                  .fbad:
  4616 000015AE F9                          stc
  4617 000015AF EBDB                        jmp short .formatexit
  4618                                  .lbaread:
  4619 000015B1 57                          push rdi
  4620 000015B2 48BF-                       mov rdi, USB.ehciMsdBOTInSector512
  4620 000015B4 [624A000000000000] 
  4621 000015BC E88D000000                  call .lbaCommon
  4622 000015C1 5F                          pop rdi
  4623 000015C2 8A2425[A9010000]            mov ah, byte [msdStatus]    ;Return Error code in ah
  4624 000015C9 0F8212FFFFFF                jc .rsbad
  4625 000015CF 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4626 000015D4 48CF                        iretq   
  4627                                  .lbawrite:
  4628 000015D6 57                          push rdi
  4629 000015D7 48BF-                       mov rdi, USB.ehciMsdBOTOutSector512
  4629 000015D9 [174A000000000000] 
  4630 000015E1 E868000000                  call .lbaCommon
  4631 000015E6 5F                          pop rdi
  4632 000015E7 8A2425[A9010000]            mov ah, byte [msdStatus]    ;Return Error code in ah
  4633 000015EE 0F82EDFEFFFF                jc .rsbad
  4634 000015F4 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4635 000015F9 48CF                        iretq
  4636                                  .lbaverify:
  4637 000015FB 57                          push rdi
  4638 000015FC 48BF-                       mov rdi, USB.ehciMsdBOTVerify
  4638 000015FE [EF48000000000000] 
  4639 00001606 E843000000                  call .lbaCommon
  4640 0000160B 5F                          pop rdi
  4641 0000160C 8A2425[A9010000]            mov ah, byte [msdStatus]    ;Return Error code in ah
  4642 00001613 0F82C8FEFFFF                jc .rsbad
  4643 00001619 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4644 0000161E 48CF                        iretq
  4645                                  .lbaformat:
  4646 00001620 50                          push rax
  4647 00001621 53                          push rbx
  4648 00001622 51                          push rcx
  4649 00001623 56                          push rsi
  4650 00001624 57                          push rdi
  4651 00001625 55                          push rbp
  4652 00001626 0FB6E8                      movzx ebp, al ;Save the number of sectors to format in ebp
  4653 00001629 51                          push rcx
  4654 0000162A 52                          push rdx
  4655 0000162B B900020000                  mov ecx, 200h
  4656 00001630 48BF-                       mov rdi, sectorbuffer
  4656 00001632 [C003000000000000] 
  4657 0000163A 488B1425[AF010000]          mov rdx, qword [diskDptPtr]
  4658 00001642 8A4208                      mov al, byte [rdx + 8]  ;Fill byte for format
  4659 00001645 F3AA                        rep stosb
  4660 00001647 5A                          pop rdx
  4661 00001648 59                          pop rcx
  4662 00001649 E914FFFFFF                  jmp .formatcommon
  4663                                  
  4664                                  .lbaCommon:
  4665 0000164E 50                          push rax
  4666 0000164F 56                          push rsi
  4667 00001650 53                          push rbx
  4668 00001651 51                          push rcx
  4669 00001652 52                          push rdx
  4670 00001653 55                          push rbp
  4671 00001654 84C0                        test al, al
  4672 00001656 0F848C000000                jz .se2 ;If al=0, skip copying sectors, clears CF
  4673 0000165C 0FB6E8                      movzx ebp, al
  4674 0000165F E95C000000                  jmp .seCommon
  4675                                  
  4676                                  ;Low level format, ah=07h
  4677                                  .formatLowLevel:
  4678 00001664 56                          push rsi
  4679 00001665 50                          push rax
  4680 00001666 E88F000000                  call .i33ehciGetDevicePtr   ;al = bus num, rsi = ehci device structure ptr
  4681 0000166B E815320000                  call USB.ehciMsdBOTFormatUnit
  4682 00001670 58                          pop rax
  4683 00001671 5E                          pop rsi
  4684 00001672 8A2425[A9010000]            mov ah, byte [msdStatus]
  4685 00001679 0F8262FEFFFF                jc .rsbad
  4686 0000167F 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4687 00001684 48CF                        iretq
  4688                                  .lbareadparams:
  4689                                  ;Reads drive parameters (for drive dl which is always valid at this point)
  4690                                  ;Output: rax = dBlockSize (Dword for LBA block size)
  4691                                  ;        rcx = qLastLBANum (Qword address of last LBA)
  4692 00001686 52                          push rdx
  4693 00001687 480FB6C2                    movzx rax, dl   ;Move drive number offset into rax
  4694 0000168B 48BA10000000000000-         mov rdx, int33TblEntrySize
  4694 00001694 00                 
  4695 00001695 48F7E2                      mul rdx
  4696 00001698 488D90[BB030000]            lea rdx, qword [diskDevices + rax]  ;Move address into rdx
  4697 0000169F 8B4203                      mov eax, dword [rdx + 3]    ;Get dBlockSize for device
  4698 000016A2 488B4A07                    mov rcx, qword [rdx + 7]    ;Get qLastLBANum for device
  4699 000016A6 5A                          pop rdx
  4700 000016A7 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4701 000016AC 48CF                        iretq
  4702                                  .sectorsEHCI:
  4703                                  ;Input: rdi = Address of USB EHCI MSD BBB function
  4704                                  ;Output: CF = CY: Error, exit
  4705                                  ;        CF = NC: No Error
  4706 000016AE 50                          push rax
  4707 000016AF 56                          push rsi
  4708 000016B0 53                          push rbx
  4709 000016B1 51                          push rcx
  4710 000016B2 52                          push rdx
  4711 000016B3 55                          push rbp
  4712 000016B4 84C0                        test al, al
  4713 000016B6 7430                        jz .se2 ;If al=0, skip copying sectors, clears CF
  4714 000016B8 0FB6E8                      movzx ebp, al   ;Move the number of sectors into ebp
  4715 000016BB E868000000                  call .convertCHSLBA ;Converts to valid 32 bit LBA in ecx for geometry type
  4716                                      ;ecx now has LBA
  4717                                  .seCommon:  ;Entered with ebp = Number of Sectors and ecx = Start LBA
  4718 000016C0 E835000000                  call .i33ehciGetDevicePtr
  4719 000016C5 7230                        jc .sebad
  4720 000016C7 4889CA                      mov rdx, rcx    ;Load edx for function call
  4721                                  ;Replace this section with a single USB function
  4722 000016CA E8CA1D0000                  call USB.ehciAdjustAsyncSchedCtrlr
  4723 000016CF 30C0                        xor al, al      ;Sector counter
  4724                                  .se1:
  4725 000016D1 FEC0                        inc al  ;Inc Sector counter
  4726 000016D3 50                          push rax
  4727 000016D4 FFD7                        call rdi
  4728 000016D6 58                          pop rax
  4729 000016D7 7216                        jc .sebadBB
  4730 000016D9 4881C300020000              add rbx, 200h   ;Goto next sector
  4731 000016E0 48FFC2                      inc rdx ;Inc LBA
  4732 000016E3 FFCD                        dec ebp ;Dec number of sectors to act on
  4733 000016E5 75EA                        jnz .se1
  4734 000016E7 F8                          clc
  4735                                  .se2:
  4736 000016E8 5D                          pop rbp
  4737 000016E9 5A                          pop rdx
  4738 000016EA 59                          pop rcx
  4739 000016EB 5B                          pop rbx
  4740 000016EC 5E                          pop rsi
  4741 000016ED 58                          pop rax
  4742 000016EE C3                          ret
  4743                                  .sebadBB:
  4744 000016EF C60425[A9010000]BB          mov byte [msdStatus], 0BBh  ;Unknown Error, request sense
  4745                                  .sebad:
  4746 000016F7 F9                          stc
  4747 000016F8 EBEE                        jmp short .se2
  4748                                  
  4749                                  .i33ehciGetDevicePtr:
  4750                                  ;Input: dl = Int 33h number whose 
  4751                                  ;Output: rsi = Pointer to ehci msd device parameter block
  4752                                  ;        al = EHCI bus the device is on
  4753 000016FA 53                          push rbx    ;Need to temporarily preserve rbx
  4754 000016FB 480FB6C2                    movzx rax, dl   ;Move drive number offset into rax
  4755 000016FF 48BA10000000000000-         mov rdx, int33TblEntrySize
  4755 00001708 00                 
  4756 00001709 48F7E2                      mul rdx
  4757 0000170C 488D90[BB030000]            lea rdx, qword [diskDevices + rax]  ;Move address into rdx
  4758 00001713 803A00                      cmp byte [rdx], 0   ;Check to see if the device type is 0 (ie doesnt exist)
  4759 00001716 740E                        jz .i33egdpbad ;If not, exit
  4760 00001718 668B4201                    mov ax, word [rdx + 1]  ;Get address/Bus pair into ax
  4761 0000171C E849260000                  call USB.ehciGetDevicePtr   ;Get device pointer into rsi
  4762 00001721 88E0                        mov al, ah          ;Get the bus into al
  4763 00001723 5B                          pop rbx
  4764 00001724 F8                          clc
  4765 00001725 C3                          ret
  4766                                  .i33egdpbad:
  4767 00001726 F9                          stc
  4768 00001727 C3                          ret
  4769                                  
  4770                                  .convertCHSLBA:
  4771                                  ;Converts a CHS address to LBA
  4772                                  ;Input: dl = Drive number, if dl < 80h, use diskdpt. If dl > 80h, use hdiskdpt
  4773                                  ;       ch = Track number, cl = Sector number, dh = Head number 
  4774                                  ;Output: ecx = LBA address
  4775                                  ;----------Reference Equations----------
  4776                                  ;C = LBA / (HPC x SPT)
  4777                                  ;H = (LBA / SPT) mod HPC
  4778                                  ;S = (LBA mod SPT) + 1
  4779                                  ;+++++++++++++++++++++++++++++++++++++++
  4780                                  ;LBA = (( C x HPC ) + H ) x SPT + S - 1
  4781                                  ;---------------------------------------
  4782                                  ;Use diskdpt.spt for sectors per track value! 
  4783                                  ;1.44Mb geometry => H=2, C=80, S=18
  4784 00001728 50                          push rax
  4785 00001729 56                          push rsi
  4786 0000172A 488B3425[AF010000]          mov rsi, qword [diskDptPtr]
  4787 00001732 D0E5                        shl ch, 1   ;Multiply by HPC=2
  4788 00001734 00F5                        add ch, dh  ;Add head number
  4789 00001736 88E8                        mov al, ch  ;al = ch = (( C x HPC ) + H )
  4790 00001738 F66604                      mul byte [rsi + 4]  ;Sectors per track
  4791 0000173B 30ED                        xor ch, ch  
  4792 0000173D 6601C8                      add ax, cx  ;Add sector number to ax
  4793 00001740 66FFC8                      dec ax
  4794 00001743 0FB7C8                      movzx ecx, ax
  4795 00001746 5E                          pop rsi
  4796 00001747 58                          pop rax
  4797 00001748 C3                          ret
  4798                                  .deviceChanged:
  4799                                  ;Entry: dl = Drive number
  4800                                  ;Exit: ah = 00h, No device changed occured, CF = CN
  4801                                  ;      ah = 01h, Device changed occured, CF = CN
  4802                                  ;      CF = CY if an error occured or device removed
  4803 00001749 53                          push rbx
  4804 0000174A 51                          push rcx
  4805 0000174B 52                          push rdx
  4806 0000174C 56                          push rsi
  4807 0000174D 57                          push rdi
  4808 0000174E 55                          push rbp
  4809 0000174F 4150                        push r8
  4810 00001751 4151                        push r9
  4811 00001753 4152                        push r10
  4812 00001755 4153                        push r11
  4813                                  
  4814 00001757 50                          push rax
  4815                                  
  4816 00001758 4C0FB61C25-                 movzx r11, byte [msdStatus] ;Preserve the original status byte
  4816 0000175D [A9010000]         
  4817 00001761 0FB6EA                      movzx ebp, dl               ;Save the device number in ebp
  4818 00001764 E891FFFFFF                  call .i33ehciGetDevicePtr   ;Get MSD dev data block ptr in rsi and bus in al
  4819                                  ;Check port on device for status change.
  4820 00001769 807E0200                    cmp byte [rsi + 2], 0   ;Check if root hub
  4821 0000176D 0F8490000000                jz .dcRoot
  4822                                  ;External Hub procedure
  4823 00001773 668B4601                    mov ax, word [rsi + 1]  ;Get bus and host hub address
  4824 00001777 86C4                        xchg al, ah             ;Swap endianness
  4825 00001779 4989F1                      mov r9, rsi
  4826 0000177C E8E9250000                  call USB.ehciGetDevicePtr   ;Get the hub address in rsi
  4827 00001781 88E0                        mov al, ah
  4828 00001783 E8111D0000                  call USB.ehciAdjustAsyncSchedCtrlr
  4829 00001788 C70425[C0030000]00-         mov dword [ehciDataIn], 0
  4829 00001790 000000             
  4830 00001793 48BAA3000000000004-         mov rdx, 00040000000000A3h ;Get Port status
  4830 0000179C 00                 
  4831 0000179D 410FB65903                  movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
  4832 000017A2 48C1E320                    shl rbx, 4*8    ;Shift port number to right position
  4833 000017A6 4809D3                      or rbx, rdx
  4834 000017A9 0FB64E04                    movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
  4835 000017AD 8A06                        mov al, byte [rsi]      ;Get upstream hub address
  4836 000017AF E8DB1E0000                  call USB.ehciGetRequest
  4837 000017B4 7231                        jc .dcError
  4838                                  
  4839 000017B6 49B8-                       mov r8, USB.ehciEnumerateHubPort    ;Store address for if bit is set
  4839 000017B8 [F53F000000000000] 
  4840 000017C0 8B1425[C0030000]            mov edx, dword [ehciDataIn]
  4841 000017C7 81E200000100                and edx, 10000h ;Isolate the port status changed bit
  4842 000017CD C1EA10                      shr edx, 10h    ;Shift status from bit 16 to bit 0
  4843                                  .dcNoError:
  4844 000017D0 44881C25[A9010000]          mov byte [msdStatus], r11b  ;Return back the original status byte
  4845 000017D8 58                          pop rax
  4846 000017D9 88D4                        mov ah, dl                  ;Place return value in ah
  4847 000017DB E814000000                  call .dcRetPop
  4848 000017E0 80642410FE                  and byte [rsp + 2*8h], 0FEh ;Clear CF
  4849 000017E5 48CF                        iretq
  4850                                  .dcError:
  4851 000017E7 58                          pop rax ;Just return the old rax value
  4852 000017E8 E807000000                  call .dcRetPop
  4853 000017ED 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  4854 000017F2 48CF                        iretq
  4855                                  .dcRetPop:
  4856 000017F4 415B                        pop r11
  4857 000017F6 415A                        pop r10
  4858 000017F8 4159                        pop r9
  4859 000017FA 4158                        pop r8
  4860 000017FC 5D                          pop rbp
  4861 000017FD 5F                          pop rdi
  4862 000017FE 5E                          pop rsi
  4863 000017FF 5A                          pop rdx
  4864 00001800 59                          pop rcx
  4865 00001801 5B                          pop rbx
  4866 00001802 C3                          ret
  4867                                  .dcRoot:
  4868                                  ;Root hub procedure.
  4869 00001803 E8911C0000                  call USB.ehciAdjustAsyncSchedCtrlr  ;Reset the bus if needed
  4870 00001808 E8CE330000                  call USB.ehciGetOpBase      ;Get opbase into rax
  4871 0000180D 0FB65E03                    movzx ebx, byte [rsi + 3]   ;Get MSD port number into dl
  4872 00001811 FFCB                        dec ebx                     ;Reduce by one
  4873 00001813 678B549844                  mov edx, dword [eax + 4*ebx + ehciportsc]  ;Get port status into eax
  4874 00001818 80E202                      and dl, 2h      ;Only save bit 1, status changed bit
  4875 0000181B D0EA                        shr dl, 1       ;Shift down by one bit
  4876 0000181D EBB1                        jmp short .dcNoError    ;Exit
  4877                                  .busScan:
  4878                                  ;Will request the hub bitfield from the RMH the device is plugged in to.
  4879                                  ;Preserves ALL registers.
  4880                                  ;dl = Device number
  4881                                  
  4882                                  ;If status changed bit set, call appropriate enumeration function.
  4883                                  ;If enumeration returns empty device, keep current device data blocks in memory,
  4884                                  ; but return Int 33h error 40h = Seek operation Failed.
  4885 0000181F 50                          push rax
  4886 00001820 53                          push rbx
  4887 00001821 51                          push rcx
  4888 00001822 52                          push rdx
  4889 00001823 56                          push rsi
  4890 00001824 57                          push rdi
  4891 00001825 55                          push rbp
  4892 00001826 4150                        push r8
  4893 00001828 4151                        push r9
  4894 0000182A 4152                        push r10
  4895 0000182C 4153                        push r11
  4896                                  
  4897 0000182E 4C0FB61C25-                 movzx r11, byte [msdStatus] ;Preserve the original status
  4897 00001833 [A9010000]         
  4898                                  
  4899 00001837 0FB6EA                      movzx ebp, dl               ;Save the device number in ebp
  4900 0000183A E8BBFEFFFF                  call .i33ehciGetDevicePtr   ;Get MSD dev data block ptr in rsi and bus in al
  4901                                  ;Check port on device for status change.
  4902 0000183F 807E0200                    cmp byte [rsi + 2], 0   ;Check if root hub
  4903 00001843 0F84CE000000                jz .bsRoot
  4904                                  ;External Hub procedure
  4905 00001849 668B4601                    mov ax, word [rsi + 1]  ;Get bus and host hub address
  4906 0000184D 86C4                        xchg al, ah             ;Swap endianness
  4907 0000184F 4989F1                      mov r9, rsi
  4908 00001852 E813250000                  call USB.ehciGetDevicePtr   ;Get the hub address in rsi
  4909 00001857 88E0                        mov al, ah
  4910 00001859 E83B1C0000                  call USB.ehciAdjustAsyncSchedCtrlr
  4911 0000185E C70425[C0030000]00-         mov dword [ehciDataIn], 0
  4911 00001866 000000             
  4912 00001869 48BAA3000000000004-         mov rdx, 00040000000000A3h ;Get Port status
  4912 00001872 00                 
  4913 00001873 410FB65903                  movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
  4914 00001878 48C1E320                    shl rbx, 4*8    ;Shift port number to right position
  4915 0000187C 4809D3                      or rbx, rdx
  4916 0000187F 0FB64E04                    movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
  4917 00001883 8A06                        mov al, byte [rsi]      ;Get upstream hub address
  4918 00001885 E8051E0000                  call USB.ehciGetRequest
  4919 0000188A 722C                        jc .bsErrorExit
  4920                                  
  4921 0000188C 49B8-                       mov r8, USB.ehciEnumerateHubPort    ;Store address for if bit is set
  4921 0000188E [F53F000000000000] 
  4922 00001896 8B1425[C0030000]            mov edx, dword [ehciDataIn]
  4923 0000189D 81E201000100                and edx, 10001h
  4924 000018A3 F7C200000100                test edx, 10000h
  4925 000018A9 752A                        jnz .bsClearPortChangeStatus    ;If top bit set, clear port change bit
  4926                                  .bsret:
  4927 000018AB F6C201                      test dl, 1h
  4928 000018AE 7418                        jz .bsrExit06h  ;Bottom bit not set, exit media changed Error (edx = 00000h)
  4929                                  .bsexit:    ;The fall through is (edx = 00001h), no change to dev in port
  4930 000018B0 44881C25[A9010000]          mov byte [msdStatus], r11b  ;Get back the original status byte
  4931                                  .bsErrorExit:
  4932 000018B8 415B                        pop r11
  4933 000018BA 415A                        pop r10
  4934 000018BC 4159                        pop r9
  4935 000018BE 4158                        pop r8
  4936 000018C0 5D                          pop rbp
  4937 000018C1 5F                          pop rdi
  4938 000018C2 5E                          pop rsi
  4939 000018C3 5A                          pop rdx
  4940 000018C4 59                          pop rcx
  4941 000018C5 5B                          pop rbx
  4942 000018C6 58                          pop rax
  4943 000018C7 C3                          ret
  4944                                  .bsrExit06h:    ;If its clear, nothing in port, return media changed error
  4945 000018C8 49BB06000000000000-         mov r11, 06h ;Change the msdStatus byte, media changed or removed
  4945 000018D1 00                 
  4946 000018D2 F9                          stc
  4947 000018D3 EBDB                        jmp short .bsexit
  4948                                  .bsClearPortChangeStatus:
  4949 000018D5 52                          push rdx
  4950 000018D6 C70425[C0030000]00-         mov dword [ehciDataIn], 0
  4950 000018DE 000000             
  4951 000018E1 48BA23011000000000-         mov rdx, 0000000000100123h  ;Set Port status
  4951 000018EA 00                 
  4952 000018EB 410FB65903                  movzx ebx, byte [r9 + 3]    ;Get the port number from device parameter block
  4953 000018F0 48C1E320                    shl rbx, 4*8    ;Shift port number to right position
  4954 000018F4 4809D3                      or rbx, rdx
  4955 000018F7 0FB64E04                    movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
  4956 000018FB 8A06                        mov al, byte [rsi]      ;Get device address
  4957 000018FD E8EE1C0000                  call USB.ehciSetNoData
  4958 00001902 5A                          pop rdx
  4959 00001903 72B3                        jc .bsErrorExit  ;If error exit by destroying the old msdStatus
  4960                                  
  4961 00001905 F6C201                      test dl, 1h
  4962 00001908 74BE                        jz .bsrExit06h  ;Bottom bit not set, exit media changed error (edx = 10000h)
  4963 0000190A EB4E                        jmp short .bsCommonEP   ;Else new device in port needs enum (edx = 10001h)
  4964                                  .bsRtNoDev:
  4965 0000190C 67814C984402000000          or dword [eax + 4*ebx + ehciportsc], 2  ;Clear the bit
  4966 00001915 EBB1                        jmp short .bsrExit06h   ;Exit with seek error
  4967                                  .bsRoot:
  4968                                  ;Root hub procedure.
  4969 00001917 E87D1B0000                  call USB.ehciAdjustAsyncSchedCtrlr  ;Reset the bus if needed
  4970 0000191C E8BA320000                  call USB.ehciGetOpBase      ;Get opbase into rax
  4971 00001921 0FB65E03                    movzx ebx, byte [rsi + 3]   ;Get MSD port number into dl
  4972 00001925 FFCB                        dec ebx                     ;Reduce by one
  4973 00001927 678B549844                  mov edx, dword [eax + 4*ebx + ehciportsc]  ;Get port status into eax
  4974 0000192C 80E203                      and dl, 3h      ;Only save bottom two bits
  4975 0000192F 84D2                        test dl, dl     ;No device in port  (dl=00b)
  4976 00001931 7495                        jz .bsrExit06h  ;Exit media changed error
  4977 00001933 FECA                        dec dl          ;Device in port     (dl=01b)
  4978 00001935 0F8475FFFFFF                jz .bsexit      ;Exit, no status change
  4979 0000193B FECA                        dec dl          ;New device, Device removed from port   (dl=10b)
  4980 0000193D 74CD                        jz .bsRtNoDev   ;Clear state change bit and exit Seek error
  4981                                  ;Fallthrough case, New device, Device inserted in port  (dl=11b)
  4982 0000193F 67814C984402000000          or dword [eax + 4*ebx + ehciportsc], 2  ;Clear the state change bit
  4983 00001948 49B8-                       mov r8,  USB.ehciEnumerateRootPort   ;The enumeration function to call
  4983 0000194A [B238000000000000] 
  4984 00001952 4989F1                      mov r9, rsi        ;Store the device pointer in r9
  4985 00001955 BE00000000                  mov esi, 0         ;Store 0 for root hub parameter block                 
  4986                                  .bsCommonEP:
  4987                                  ;Invalidate USB MSD and Int 33h table entries for device
  4988                                  ;r9 has device pointer block and rsi has host hub pointer (if on RMH)
  4989 0000195A 66418B19                    mov bx, word [r9]          ;bl = Address, bh = Bus
  4990 0000195E 88FE                        mov dh, bh                 ;dh = Bus
  4991 00001960 418A5103                    mov dl, byte [r9 + 3]      ;dl = Device Port
  4992 00001964 4D0FB65102                  movzx r10, byte [r9 + 2]   ;r10b = Host hub address (0 = Root hub)
  4993 00001969 6689D8                      mov ax, bx                 ;ax needs a copy for RemoveDevFromTables
  4994 0000196C E884220000                  call USB.ehciRemoveDevFromTables    ;Removes device from USB tables
  4995 00001971 87EA                        xchg ebp, edx                       ;device number -><- bus/dev pair
  4996 00001973 E8E5000000                  call .i33removeFromTable            ;Removes device from Int 33h table
  4997 00001978 87EA                        xchg ebp, edx                       ;bus/dev pair -><- device number
  4998                                  ;Devices enumerated, time to reenumerate!
  4999 0000197A B903000000                  mov ecx, 3
  5000 0000197F 85F6                        test esi, esi   ;Is device on root hub?
  5001 00001981 7502                        jnz .bsr0
  5002 00001983 FECA                        dec dl  ;Recall that device port must be device port - 1 for Root hub enum
  5003                                  .bsr0:
  5004 00001985 41FFD0                      call r8
  5005 00001988 7410                        jz .bsr1
  5006 0000198A 803C25[A9010000]20          cmp byte [msdStatus], 20h   ;General Controller Failure?
  5007 00001992 7439                        je .bsrFail
  5008 00001994 FFC9                        dec ecx
  5009 00001996 75ED                        jnz .bsr0
  5010 00001998 EB33                        jmp short .bsrFail
  5011                                  .bsr1:
  5012 0000199A 4C87CE                      xchg r9, rsi    ;MSD parameter blk -><- Hub parameter blk (or 0 if root)
  5013 0000199D E8EE280000                  call USB.ehciMsdInitialise
  5014 000019A2 84C0                        test al, al
  5015 000019A4 7527                        jnz .bsrFail    ;Exit if the device failed to initialise
  5016                                  ;Multiply dl by int33TblEntrySize to get the address to write Int33h table
  5017 000019A6 89EA                        mov edx, ebp    ;Move the device number into edx (dl)
  5018 000019A8 B810000000                  mov eax, int33TblEntrySize  ;Zeros the upper bytes
  5019 000019AD F6E2                        mul dl  ;Multiply dl by al. ax has offset into diskDevices table
  5020 000019AF 4805[BB030000]              add rax, diskDevices
  5021 000019B5 4889C7                      mov rdi, rax    ;Put the offset into the table into rdi
  5022 000019B8 E820000000                  call .deviceInit
  5023 000019BD 84C0                        test al, al
  5024 000019BF 0F84EBFEFFFF                jz .bsexit  ;Successful, exit!
  5025 000019C5 3C03                        cmp al, 3
  5026 000019C7 0F84E3FEFFFF                je .bsexit  ;Invalid device type, but ignore for now
  5027                                  .bsrFail:
  5028 000019CD 49BB20000000000000-         mov r11, 20h ;Change the msdStatus byte to Gen. Ctrlr Failure
  5028 000019D6 00                 
  5029 000019D7 F9                          stc
  5030 000019D8 E9D3FEFFFF                  jmp .bsexit
  5031                                  .deviceInit:    
  5032                                  ;Further initialises an MSD device for use with the int33h interface.
  5033                                  ;Adds device data to the allocated int33h data table.
  5034                                  ;Input: rdi = device diskDevice ptr (given by device number*int33TblEntrySize)
  5035                                  ;       rsi = device MSDDevTbl entry (USB address into getDevPtr)
  5036                                  ;Output: al = 0 : Device added successfully
  5037                                  ;        al = 1 : Bus error
  5038                                  ;        al = 2 : Read Capacities/Reset recovary failed after 10 attempts
  5039                                  ;        al = 3 : Invalid device type (Endpoint size too small, temporary)
  5040                                  ;   rax destroyed
  5041                                  ;IF DEVICE HAS MAX ENDPOINT SIZE 64, DO NOT WRITE IT TO INT 33H TABLES
  5042 000019DD 51                          push rcx
  5043 000019DE B003                        mov al, 3   ;Invalid EP size error code
  5044 000019E0 66817E090002                cmp word [rsi + 9], 200h  ;Check IN max EP packet size
  5045 000019E6 7573                        jne .deviceInitExit
  5046 000019E8 66817E0C0002                cmp word [rsi + 12], 200h ;Check OUT max EP packet size
  5047 000019EE 756B                        jne .deviceInitExit
  5048                                  
  5049 000019F0 8A4601                      mov al, byte [rsi + 1]  ;Get bus number
  5050 000019F3 E8A11A0000                  call USB.ehciAdjustAsyncSchedCtrlr
  5051 000019F8 B001                        mov al, 1       ;Bus error exit
  5052 000019FA 725F                        jc .deviceInitExit
  5053 000019FC B90A000000                  mov ecx, 10
  5054                                  .deviceInitReadCaps:
  5055 00001A01 E82E2E0000                  call USB.ehciMsdBOTReadCapacity10   ;Preserve al error code
  5056 00001A06 803C25[A9010000]20          cmp byte [msdStatus], 20h   ;General Controller Failure
  5057 00001A0E 744B                        je .deviceInitExit
  5058 00001A10 E83D2A0000                  call USB.ehciMsdBOTCheckTransaction
  5059 00001A15 6685C0                      test ax, ax     ;Clears CF
  5060 00001A18 7418                        jz .deviceInitWriteTableEntry   ;Success, write table entry
  5061 00001A1A E853290000                  call USB.ehciMsdBOTResetRecovery    ;Just force a device reset
  5062 00001A1F 803C25[A9010000]20          cmp byte [msdStatus], 20h   ;General Controller Failure
  5063 00001A27 7432                        je .deviceInitExit
  5064 00001A29 FFC9                        dec ecx
  5065 00001A2B 75D4                        jnz .deviceInitReadCaps
  5066 00001A2D B002                        mov al, 2   ;Non bus error exit
  5067 00001A2F F9                          stc ;Set carry, device failed to initialise properly
  5068 00001A30 EB29                        jmp short .deviceInitExit
  5069                                  .deviceInitWriteTableEntry:
  5070 00001A32 C60701                      mov byte [rdi], 1   ;MSD USB device signature
  5071                                  
  5072 00001A35 668B06                      mov ax, word [rsi]  ;Get address and bus into ax
  5073 00001A38 66894701                    mov word [rdi + 1], ax  ;Store in Int 33h table
  5074                                  
  5075 00001A3C 8B0425[C4030000]            mov eax, dword [ehciDataIn + 4] ;Get LBA block size
  5076 00001A43 0FC8                        bswap eax
  5077 00001A45 894703                      mov dword [rdi + 3], eax
  5078                                  
  5079 00001A48 8B0425[C0030000]            mov eax, dword [ehciDataIn] ;Get zx qword LastLBA
  5080 00001A4F 0FC8                        bswap eax
  5081 00001A51 48894707                    mov qword [rdi + 7], rax
  5082                                  
  5083 00001A55 C6470F02                    mov byte [rdi + 15], 2  ;Temporary, only accept devices with 200h EP sizes
  5084 00001A59 30C0                        xor al, al 
  5085                                  .deviceInitExit:
  5086 00001A5B 59                          pop rcx
  5087 00001A5C C3                          ret
  5088                                  .i33removeFromTable:
  5089                                  ;Uses Int 33h device number to invalidate the device table entry
  5090                                  ;Input: dl = Device number
  5091                                  ;Output: Nothing, device entry invalidated
  5092 00001A5D 50                          push rax
  5093 00001A5E 52                          push rdx
  5094 00001A5F B010                        mov al, int33TblEntrySize
  5095 00001A61 F6E2                        mul dl  ;Multiply tbl entry size by device number, offset in ax
  5096 00001A63 480FB7C0                    movzx rax, ax
  5097 00001A67 C680[BB030000]00            mov byte [diskDevices + rax], 0 ;Invalidate entry
  5098 00001A6E 5A                          pop rdx
  5099 00001A6F 58                          pop rax
  5100 00001A70 C3                          ret
  5101                                  
  5102                                  diskdpt:   ;Imaginary floppy disk parameter table with disk geometry. 
  5103                                  ;For more information on layout, see Page 3-26 of IBM BIOS ref
  5104                                  ;Assume 2 head geometry due to emulating a floppy drive
  5105 00001A71 00                      .fsb:   db 0    ;First specify byte
  5106 00001A72 00                      .ssb:   db 0    ;Second specify byte
  5107 00001A73 00                      .tto:   db 0    ;Number of timer ticks to wait before turning off drive motors
  5108 00001A74 02                      .bps:   db 2    ;Number of bytes per sector in multiples of 128 bytes, editable.
  5109                                                  ; 0 = 128 bytes, 1 = 256 bytes, 2 = 512 bytes etc
  5110                                                  ;Left shift 128 by bps to get the real bytes per sector
  5111 00001A75 09                      .spt:   db 9    ;Sectors per track
  5112 00001A76 00                      .gpl:   db 0    ;Gap length
  5113 00001A77 00                      .dtl:   db 0    ;Data length
  5114 00001A78 00                      .glf:   db 0    ;Gap length for format
  5115 00001A79 FF                      .fbf:   db 0FFh ;Fill byte for format
  5116 00001A7A 00                      .hst:   db 0    ;Head settle time in ms
  5117 00001A7B 01                      .mst:   db 1    ;Motor startup time in multiples of 1/8 of a second.
  5118                                  
  5119                                  fdiskdpt: ;Fixed drive table, only cyl, nhd and spt are valid. 
  5120                                  ;           This schema gives roughly 8.42Gb of storage.
  5121                                  ;           All fields with 0 in the comments are reserved post XT class BIOS.
  5122 00001A7C 0004                    .cyl:   dw  1024    ;1024 cylinders
  5123 00001A7E FF                      .nhd:   db  255     ;255 heads
  5124 00001A7F 0000                    .rwc:   dw  0       ;Reduced write current cylinder, 0
  5125 00001A81 FFFF                    .wpc:   dw  -1      ;Write precompensation number (-1=none)
  5126 00001A83 00                      .ecc:   db  0       ;Max ECC burst length, 0
  5127 00001A84 08                      .ctl:   db  08h     ;Control byte (more than 8 heads)
  5128 00001A85 00                      .sto:   db  0       ;Standard timeout, 0
  5129 00001A86 00                      .fto:   db  0       ;Formatting timeout, 0
  5130 00001A87 00                      .tcd:   db  0       ;Timeout for checking drive, 0
  5131 00001A88 FF03                    .clz:   dw  1023    ;Cylinder for landing zone
  5132 00001A8A 3F                      .spt:   db  63      ;Sectors per track
  5133 00001A8B 00                      .res:   db  0       ;Reserved byte
  5134                                  ;------------------------End of Interrupt------------------------
  5135                                  ;------------------Serial IO Interrupts Int 34h------------------
  5136                                  serial_baud_table:    ;DLAB devisor values
  5137 00001A8C 1704                        dw    0417h    ;110 baud,     00
  5138 00001A8E 0003                        dw    0300h    ;150 baud,     01
  5139 00001A90 8001                        dw    0180h    ;300 baud,     02
  5140 00001A92 C000                        dw    00C0h    ;600 baud,     03
  5141 00001A94 6000                        dw    0060h    ;1200 baud,    04
  5142 00001A96 3000                        dw    0030h    ;2400 baud,    05 
  5143 00001A98 1800                        dw    0018h    ;4800 baud,    06
  5144 00001A9A 0C00                        dw    000Ch    ;9600 baud,    07
  5145 00001A9C 0600                        dw    0006h    ;19200 baud,   08
  5146 00001A9E 0300                        dw    0003h    ;38400 baud,   09
  5147 00001AA0 0200                        dw    0002h    ;57600 baud,   0A
  5148 00001AA2 0100                        dw    0001h    ;115200 baud,  0B
  5149                                  serial_abt: ;serial port address base table. List of supported addresses!
  5150 00001AA4 F803                        dw com1_base
  5151 00001AA6 F802                        dw com2_base
  5152 00001AA8 E803                        dw com3_base
  5153 00001AAA E802                        dw com4_base
  5154                                  serial_io:
  5155 00001AAC 52                          push rdx        ;Save upper 7 bytes
  5156 00001AAD 6681FA0400                  cmp dx, 4        ;Check to see if the selected com port is within range
  5157 00001AB2 7D5A                        jge .sbadexit1    ;Bad dx value
  5158 00001AB4 480FB7D2                    movzx rdx, dx    ;zero the upper 6 bytes of rdx
  5159 00001AB8 668B9412[67000000]          mov dx, word [com_addresses + rdx*2]    ;get serial port base addr into dx
  5160 00001AC0 6685D2                      test dx, dx        ;is the address zero?
  5161 00001AC3 744D                        jz .sbadexit2    ;com port doesnt exist
  5162 00001AC5 50                          push rax        ;Saves upper 6 bytes
  5163 00001AC6 52                          push rdx        ;Save base for exit algorithm
  5164                                  
  5165 00001AC7 84E4                        test ah, ah
  5166 00001AC9 7451                        jz .userinit
  5167 00001ACB FECC                        dec ah 
  5168 00001ACD 0F848A000000                jz .transmit
  5169 00001AD3 FECC                        dec ah
  5170 00001AD5 0F84B7000000                jz .recieve
  5171 00001ADB FECC                        dec ah
  5172 00001ADD 741E                        jz .sioexit    ;since this puts the status into ax
  5173 00001ADF FECC                        dec ah
  5174 00001AE1 0F842A010000                jz .extinit
  5175 00001AE7 FECC                        dec ah
  5176 00001AE9 0F8422010000                jz .extstatus
  5177 00001AEF FECC                        dec ah
  5178 00001AF1 0F841A010000                jz .custombaud
  5179                                  
  5180                                  .badin:
  5181 00001AF7 5A                          pop rdx
  5182 00001AF8 58                          pop rax
  5183 00001AF9 B480                        mov ah, 80h    ;Invalid Function
  5184 00001AFB EB17                        jmp short .sbadcommon
  5185                                  .sioexit:
  5186 00001AFD 5A                          pop rdx   ;Get base back, to know exact offset
  5187 00001AFE 58                          pop rax        ;Return the upper bytes of rax into rax
  5188 00001AFF 6681C20500                  add dx, 5    ;point to the line status register
  5189 00001B04 EC                          in al, dx    ;get status
  5190 00001B05 88C4                        mov ah, al    ;save line status in ah
  5191 00001B07 66FFC2                      inc dx        ;point to the modem status register
  5192 00001B0A EC                          in al, dx    ;save modem status in al
  5193 00001B0B 5A                          pop rdx
  5194 00001B0C 48CF                        iretq
  5195                                  
  5196                                  .sbadexit1:    
  5197 00001B0E B0FF                        mov al, 0FFh    ;dx was too large
  5198 00001B10 EB02                        jmp short .sbadcommon
  5199                                  .sbadexit2:
  5200 00001B12 B0FE                        mov al, 0FEh    ;COM port doesnt exist
  5201                                  .sbadcommon:
  5202 00001B14 5A                          pop rdx        ;return original rdx value
  5203 00001B15 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  5204 00001B1A 48CF                        iretq
  5205                                  
  5206                                  .userinit:
  5207 00001B1C 88C4                        mov ah, al    ;save the data in ah for the baud rate
  5208 00001B1E 6681C20300                  add dx, 3    ;Point to the line control register
  5209 00001B23 241F                        and al, 00011111b   ;Zero out the upper three bits
  5210 00001B25 0C80                        or al, 10000000b    ;Set the DLAB bit
  5211 00001B27 EE                          out dx, al 
  5212                                  
  5213 00001B28 6681EA0300                  sub dx, 3    ;return point to base
  5214 00001B2D 66C1E80D                    shr ax, 0Dh  ;0Dh=move hi bits of hi word into low bits of low word
  5215 00001B31 480FB6C0                    movzx rax, al    ;zero upper 7 bytes of rax
  5216 00001B35 3C07                        cmp al, 00000111b    ;Check if set to 9600baud (for extension)
  5217 00001B37 7414                        je .ui2
  5218                                  .ui1:
  5219 00001B39 668B80[8C1A0000]            mov ax, word [serial_baud_table + rax]    ;rax is the offset into the table
  5220 00001B40 66EF                        out dx, ax    ;dx points to base with dlab on, set divisor! (word out)
  5221                                  ;Disable DLAB bit now
  5222 00001B42 6681C20300                  add dx, 3
  5223 00001B47 EC                          in al, dx    ;Get the Line Control Register (preserving the written data)
  5224 00001B48 247F                        and al, 01111111b    ;Clear the DLAB bit, preserve the other bits
  5225 00001B4A EE                          out dx, al    ;Clear the bit
  5226                                  
  5227 00001B4B EBB0                        jmp short .sioexit    ;exit!
  5228                                  .ui2:    ;Check r8b to make sure it is 0-4 inclusive.
  5229 00001B4D 4180F804                    cmp r8b, 4    ;greater than four defaults to 4
  5230 00001B51 7F05                        jg .ui3    ;r8b is greater than four, error!
  5231 00001B53 4400C0                      add al, r8b    ;increase the offset into the table
  5232 00001B56 EBE1                        jmp short .ui1    ;return to the get value from table
  5233                                  .ui3:    ;If r8b greater than 4, default to 4
  5234 00001B58 41B004                      mov r8b, 4   ;Error caught, user used a value greater than 4, default to 4
  5235 00001B5B EBF0                        jmp short .ui2    ;return to checker
  5236                                  
  5237                                  .transmit:
  5238 00001B5D 6681C20500                  add dx, 5    ;dx contains base address, point to Line status register
  5239 00001B62 88C4                        mov ah, al   ;temp save char to send in ah
  5240 00001B64 51                          push rcx
  5241 00001B65 6631C9                      xor cx, cx
  5242                                  .t1:
  5243 00001B68 66FFC9                      dec cx
  5244 00001B6B 7410                        jz .t2       ;timeout
  5245 00001B6D EC                          in al, dx    ;get the LSR byte in
  5246 00001B6E 2420                        and al, 00100000b    ;Check the transmit holding register empty bit
  5247 00001B70 74F6                        jz .t1    ;if this is zero, keep looping until it is 1 (aka empty)
  5248                                  
  5249 00001B72 59                          pop rcx
  5250 00001B73 88E0                        mov al, ah   ;return data byte down to al
  5251 00001B75 6681EA0500                  sub dx, 5    ;reaim to the IO port
  5252 00001B7A EE                          out dx, al   ;output the data byte to the serial line!!
  5253 00001B7B EB80                        jmp short .sioexit
  5254                                  .t2:
  5255 00001B7D 59                          pop rcx
  5256 00001B7E 5A                          pop rdx      ;Get base back, to know exact offset
  5257 00001B7F 58                          pop rax      ;Return the upper bytes of rax into rax
  5258 00001B80 6681C20500                  add dx, 5    ;point to the line status register
  5259 00001B85 EC                          in al, dx    ;get status
  5260 00001B86 88C4                        mov ah, al   ;save line status in ah
  5261 00001B88 80E480                      and ah, 80h  ;Set error bit (bit 7)
  5262 00001B8B 66FFC2                      inc dx       ;point to the modem status register
  5263 00001B8E EC                          in al, dx    ;save modem status in al
  5264 00001B8F 5A                          pop rdx
  5265 00001B90 48CF                        iretq
  5266                                  .recieve:
  5267                                      ;Gets byte out of appropriate buffer head and places it in al
  5268 00001B92 5A                          pop rdx
  5269 00001B93 58                          pop rax        
  5270 00001B94 5A                          pop rdx    ;Undoes the address entry and returns COM port number into dx    
  5271 00001B95 52                          push rdx   ;Save it once more
  5272 00001B96 53                          push rbx
  5273 00001B97 480FB7D2                    movzx rdx, dx
  5274                                  
  5275 00001B9B FA                          cli    ;Entering a critical area, interrupts off
  5276 00001B9C 488B1CD5[AF000000]          mov rbx, qword [comX_buf_head + rdx*8]
  5277 00001BA4 483B1CD5[CF000000]          cmp rbx, qword [comX_buf_tail + rdx*8]
  5278 00001BAC 7426                        je .r1    ;We are at the head of the buffer, signal error, no char to get.
  5279 00001BAE 8A03                        mov al, byte [rbx]    ;store byte into al
  5280 00001BB0 88C4                        mov ah, al ;temp save al in ah
  5281 00001BB2 48FFC3                      inc rbx    ;move buffer head
  5282 00001BB5 483B1CD5[0F010000]          cmp rbx, qword [comX_buf_end + rdx*8]    ;are we at the end of the buffer
  5283 00001BBD 7508                        jne .r0    ;no, save new position
  5284 00001BBF 488B1CD5[EF000000]          mov rbx, qword [comX_buf_start + rdx*8]  ;yes, wrap around
  5285                                  .r0:
  5286 00001BC7 48891CD5[AF000000]          mov qword [comX_buf_head + rdx*8], rbx   ;save new buffer position
  5287 00001BCF FB                          sti
  5288 00001BD0 5B                          pop rbx
  5289 00001BD1 5A                          pop rdx
  5290 00001BD2 EB07                        jmp short .rexit
  5291                                  .r1:
  5292 00001BD4 FB                          sti
  5293 00001BD5 B480                        mov ah, 80h    ;Equivalent to a timeout error.
  5294 00001BD7 5B                          pop rbx
  5295 00001BD8 5A                          pop rdx
  5296 00001BD9 48CF                        iretq
  5297                                  
  5298                                  .rexit:    ;Line status in ah. Char was got so ensure DTR is now high again!
  5299 00001BDB 668B9412[67000000]          mov dx, word [com_addresses + rdx*2]    ;Get the base address back into dx
  5300 00001BE3 6681C20400                  add dx, 4    ;point to the modem control register
  5301 00001BE8 EC                          in al, dx
  5302 00001BE9 A801                        test al, 1   ;Test DTR is clear
  5303 00001BEB 740B                        jz .getscratch
  5304                                  .gsret:
  5305 00001BED 0C01                        or al, 1    ;Set DTR bit on again
  5306 00001BEF EE                          out dx, al
  5307 00001BF0 66FFC2                      inc dx      ;point to the line status register
  5308 00001BF3 EC                          in al, dx   ;get status
  5309 00001BF4 86E0                        xchg ah, al ;swap them around
  5310 00001BF6 48CF                        iretq
  5311                                  .getscratch:
  5312 00001BF8 0C10                        or al, 00010000b    ;Enable loopback mode with DTR on
  5313 00001BFA EE                          out dx, al
  5314 00001BFB 6681C20300                  add dx, 3    ;Point to scratch register
  5315 00001C00 EC                          in al, dx    ;Get overrun char
  5316 00001C01 6681EA0700                  sub dx, 7    ;transmit register
  5317 00001C06 EE                          out dx, al   ;send the char (no need to play with DTR, we sending to 
  5318                                                   ; ourselves, generating an INT)
  5319 00001C07 6681C20400                  add dx, 4    ;point back to modem control register again!
  5320 00001C0C EC                          in al, dx
  5321 00001C0D 24EF                        and al, 11101111b    ;Clear loopback mode, DTR bit gets set in main proc
  5322 00001C0F EBDC                        jmp short .gsret    
  5323                                  
  5324                                  .extinit:
  5325                                  .extstatus:
  5326                                  .custombaud:
  5327 00001C11 5A                          pop rdx
  5328 00001C12 58                          pop rax
  5329 00001C13 B486                        mov ah, 86h
  5330 00001C15 E9FAFEFFFF                  jmp .sbadcommon
  5331                                  ;------------------------End of Interrupt------------------------
  5332                                  ;-------------------Misc IO Interrupts Int 35h-------------------
  5333                                  ;Misc features int that can be used for a variety of things.
  5334                                  ;This will break compatibility with BIOS, since hopefully more 
  5335                                  ; advanced features will be present.
  5336                                  ;
  5337                                  ; ah = 0 - 82h System Reserved
  5338                                  ; ah = 83h -> Reserved, Event wait
  5339                                  ; ah = 86h -> Delay rcx = # of milliseconds to wait
  5340                                  ; ah = 88h -> Basic High Mem Map 1 (First 16MB only)
  5341                                  ; ah = 89h to C4h - System Reserved
  5342                                  ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  5343                                  ; ah = C5h - FFh BIOS device class dispatcher extensions
  5344                                  ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  5345                                  ; ah = C5h -> Misc sys function dispatcher      (3 funct)
  5346                                  ; ah = E8h -> Adv mem management sys dispatcher (4 funct)
  5347                                  ; ah = F0h -> Sys data table dispatcher         (15 funct)
  5348                                  ; ah = F1h -> EHCI system dispatcher            (4 funct)
  5349                                  ;----------------------------------------------------------------
  5350                                  misc_io:
  5351 00001C1A 80FC86                      cmp ah, 86h
  5352 00001C1D 722F                        jb .badFunction
  5353 00001C1F 7436                        jz .delay
  5354 00001C21 80FC88                      cmp ah, 88h
  5355 00001C24 0F84B0000000                jz .memory16MB
  5356                                  
  5357 00001C2A 80FCC5                      cmp ah, 0C5h    ;Miscellaneous function dispatcher
  5358 00001C2D 0F84B1000000                jz .miscDispatcher 
  5359 00001C33 80FCE8                      cmp ah, 0E8h    ;Advanced memory management system dispatcher
  5360 00001C36 0F847E010000                jz .advSysMemDispatcher
  5361 00001C3C 80FCF0                      cmp ah, 0F0h    ;System table dispatcher
  5362 00001C3F 0F84F3010000                jz .sysDataTableDispatcher
  5363 00001C45 80FCF1                      cmp ah, 0F1h    ;EHCI function dispatcher
  5364 00001C48 0F843E030000                jz .ehciFunctionDispatcher
  5365                                  .badFunction:
  5366 00001C4E B480                        mov ah, 80h    ;Invalid Function
  5367                                  .badout:
  5368 00001C50 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  5369 00001C55 48CF                        iretq
  5370                                  
  5371                                  .delay:
  5372                                  ;Input: rcx = milliseconds to wait (rcx < 7FFFFFFFFFFFFFFFh)
  5373                                  ;Init IRQ 8, wait for loop to end, deactivate
  5374 00001C57 FA                          cli    ;NO INTERRUPTS
  5375 00001C58 4885C9                      test rcx, rcx
  5376 00001C5B 747B                        jz .return  ;Can avoid sti since we return caller flags
  5377 00001C5D 50                          push rax
  5378                                  ;Ensure PIC is saved
  5379 00001C5E E421                        in al, pic1data
  5380 00001C60 50                          push rax    ;Save unaltered pic1 value
  5381 00001C61 24FB                        and al, 0FBh ;Ensure Cascading pic1 line unmasked
  5382 00001C63 E621                        out pic1data, al
  5383                                  
  5384 00001C65 E4A1                        in al, pic2data
  5385 00001C67 50                          push rax    ;Save unaltered pic2 value
  5386 00001C68 24FE                        and al, 0FEh ;Ensure line 0 of pic2 unmasked 
  5387 00001C6A E6A1                        out pic2data, al
  5388                                  
  5389 00001C6C 48890C25[3B010000]          mov qword [rtc_ticks], rcx
  5390 00001C74 66B88B8B                    mov ax, 8B8Bh       
  5391 00001C78 E670                        out cmos_base, al   ;NMI disabled
  5392 00001C7A E680                        out waitp, al
  5393 00001C7C EB00                        jmp short $+2
  5394 00001C7E E471                        in al, cmos_data
  5395 00001C80 247F                        and al, 7Fh    ;Clear upper bit
  5396 00001C82 0C40                        or al, 40h    ;Set periodic interrupt bit
  5397 00001C84 86E0                        xchg ah, al
  5398 00001C86 E670                        out cmos_base, al
  5399 00001C88 E680                        out waitp, al
  5400 00001C8A EB00                        jmp short $+2
  5401 00001C8C 86C4                        xchg al, ah
  5402 00001C8E E671                        out cmos_data, al
  5403 00001C90 B00D                        mov al, 0Dh     ;Read Register D and reenable NMI
  5404 00001C92 E670                        out cmos_base, al
  5405 00001C94 E680                        out waitp, al    ;allow one io cycle to run
  5406 00001C96 EB00                        jmp short $+2
  5407 00001C98 E471                        in al, cmos_data  
  5408 00001C9A FB                          sti        ;Reenable interrupts
  5409                                  .loopdelay:
  5410 00001C9B F390                        pause ;allow an interrupt to occur
  5411 00001C9D 48813C25[3B010000]-         cmp qword [rtc_ticks], 0        ;See if we at 0 yet
  5411 00001CA5 00000000           
  5412 00001CA9 7FF0                        jg .loopdelay    ;If not, keep looping
  5413                                  ;Return CMOS to default state
  5414 00001CAB FA                          cli
  5415 00001CAC 66B88B8B                    mov ax, 8B8Bh   ;NMI disabled
  5416 00001CB0 E670                        out cmos_base, al
  5417 00001CB2 E680                        out waitp, al
  5418 00001CB4 EB00                        jmp short $+2
  5419 00001CB6 E471                        in al, cmos_data
  5420 00001CB8 240F                        and al, 0Fh    ;Clear all upper 4 bits
  5421 00001CBA 86E0                        xchg ah, al
  5422 00001CBC E670                        out cmos_base, al
  5423 00001CBE E680                        out waitp, al
  5424 00001CC0 EB00                        jmp short $+2
  5425 00001CC2 86E0                        xchg ah, al
  5426 00001CC4 E671                        out cmos_data, al
  5427 00001CC6 B00D                        mov al, 0Dh     ;Read Register D and reenable NMI
  5428 00001CC8 E670                        out cmos_base, al
  5429 00001CCA E680                        out waitp, al    ;allow one io cycle to run
  5430 00001CCC EB00                        jmp short $+2
  5431 00001CCE E471                        in al, cmos_data  
  5432                                  
  5433 00001CD0 58                          pop rax ;Return pic2 value
  5434 00001CD1 E6A1                        out pic2data, al
  5435 00001CD3 58                          pop rax    ;Return pic1 value
  5436 00001CD4 E621                        out pic1data, al
  5437                                  
  5438 00001CD6 58                          pop rax    ;Return rax value
  5439 00001CD7 FB                          sti
  5440                                  .return:
  5441 00001CD8 48CF                        iretq
  5442                                  .memory16MB:    ;ah=88 function
  5443 00001CDA 668B0425[DE010000]          mov ax, word [srData1]
  5444 00001CE2 48CF                        iretq
  5445                                  
  5446                                  .miscDispatcher:
  5447                                  ; ax = C500h -> Beep PC speaker
  5448                                  ; ax = C501h -> Connect Debugger 
  5449                                  ; ax = C502h -> Disconnect Debugger
  5450 00001CE4 84C0                        test al, al     ;Play a tone using PC speaker
  5451 00001CE6 0F84C7000000                jz .mdBeeper
  5452 00001CEC 3C01                        cmp al, 01h     ;Connect Debugger
  5453 00001CEE 7409                        jz .mdConnectDebugger
  5454 00001CF0 3C02                        cmp al, 02h     ;Disconnect Debugger
  5455 00001CF2 7460                        jz .mdDisconnectDebugger
  5456 00001CF4 E955FFFFFF                  jmp .badFunction
  5457                                  .mdConnectDebugger:
  5458 00001CF9 50                          push rax
  5459 00001CFA 53                          push rbx
  5460 00001CFB 52                          push rdx
  5461 00001CFC 56                          push rsi
  5462 00001CFD BA008F0000                  mov edx, 8F00h
  5463 00001D02 BB08000000                  mov ebx, codedescriptor
  5464 00001D07 48B8-                       mov rax, MCP_int.singleStepsEP  ;Pointer
  5464 00001D09 [6121000000000000] 
  5465 00001D11 48BE01000000000000-         mov rsi, 01 ;Interrupt number, Single Step
  5465 00001D1A 00                 
  5466 00001D1B E8ABE3FFFF                  call idtWriteEntry
  5467 00001D20 48B8-                       mov rax, MCP_int.debugEp  ;Pointer
  5467 00001D22 [B621000000000000] 
  5468 00001D2A 48BE03000000000000-         mov rsi, 03 ;Interrupt number, Software Breakpoint
  5468 00001D33 00                 
  5469 00001D34 E892E3FFFF                  call idtWriteEntry
  5470 00001D39 48B8-                       mov rax, MCP_int.debugEpHardware  ;Pointer
  5470 00001D3B [9621000000000000] 
  5471 00001D43 48BE3B000000000000-         mov rsi, 3Bh ;Interrupt number, Invoke debugger through hardware CTRL+BREAK
  5471 00001D4C 00                 
  5472 00001D4D E879E3FFFF                  call idtWriteEntry
  5473 00001D52 EB59                        jmp short .mdDebugExit
  5474                                  .mdDisconnectDebugger:
  5475 00001D54 50                          push rax
  5476 00001D55 53                          push rbx
  5477 00001D56 52                          push rdx
  5478 00001D57 56                          push rsi
  5479 00001D58 BA008F0000                  mov edx, 8F00h
  5480 00001D5D BB08000000                  mov ebx, codedescriptor
  5481 00001D62 48B8-                       mov rax, i1  ;Pointer
  5481 00001D64 [FE4B000000000000] 
  5482 00001D6C 48BE01000000000000-         mov rsi, 01 ;Interrupt number, Single Step
  5482 00001D75 00                 
  5483 00001D76 E850E3FFFF                  call idtWriteEntry
  5484 00001D7B 48B8-                       mov rax, i3  ;Pointer
  5484 00001D7D [1C4C000000000000] 
  5485 00001D85 48BE03000000000000-         mov rsi, 03 ;Interrupt number, Software Breakpoint
  5485 00001D8E 00                 
  5486 00001D8F E837E3FFFF                  call idtWriteEntry
  5487 00001D94 48B8-                       mov rax, ctrlbreak_io  ;Pointer
  5487 00001D96 [BF31000000000000] 
  5488 00001D9E 48BE3B000000000000-         mov rsi, 3Bh ;Interrupt number, CTRL+Break
  5488 00001DA7 00                 
  5489 00001DA8 E81EE3FFFF                  call idtWriteEntry
  5490                                  .mdDebugExit:
  5491 00001DAD 5E                          pop rsi
  5492 00001DAE 5A                          pop rdx
  5493 00001DAF 5B                          pop rbx
  5494 00001DB0 58                          pop rax
  5495 00001DB1 48CF                        iretq
  5496                                  
  5497                                  .mdBeeper:
  5498                                  ;Input: 
  5499                                  ;   bx = Frequency divisor to use for tone
  5500                                  ;   rcx = # of ms to beep for
  5501                                  ; All registers including ax preserved
  5502 00001DB3 E8DEE2FFFF                  call beep
  5503 00001DB8 48CF                        iretq
  5504                                  
  5505                                  .advSysMemDispatcher:
  5506                                  ; ax = E800h -> Return userBase pointer
  5507                                  ; ax = E801h -> Give RAM count, minus the size of SCPBIOS, in ax, bx, cx, dx.
  5508                                  ; ax = E802h -> Total RAM count (without SCP/BIOS)
  5509                                  ; ax = E820h -> Full Memory Map, including entry for SCPBIOS
  5510 00001DBA 84C0                        test al, al
  5511 00001DBC 7411                        jz .retUserBase
  5512 00001DBE 3C01                        cmp al, 01h
  5513 00001DC0 7417                        je .memory64MB
  5514 00001DC2 3C02                        cmp al, 02h
  5515 00001DC4 7435                        je .memoryBIOSseg
  5516 00001DC6 3C20                        cmp al, 20h
  5517 00001DC8 7451                        je .fullMemoryMap
  5518 00001DCA E97FFEFFFF                  jmp .badFunction
  5519                                  
  5520                                  .retUserBase:
  5521 00001DCF 488B0425[CD010000]          mov rax, qword [userBase]
  5522 00001DD7 48CF                        iretq
  5523                                  .memory64MB:
  5524 00001DD9 668B0425[D6010000]          mov ax, word [srData]
  5525 00001DE1 668B1C25[D8010000]          mov bx, word [srData + 2]
  5526 00001DE9 668B0C25[DA010000]          mov cx, word [srData + 4]
  5527 00001DF1 668B1425[DC010000]          mov dx, word [srData + 6]
  5528 00001DF9 48CF                        iretq    
  5529                                  .memoryBIOSseg:
  5530                                  ;This gives information about the SCP/BIOS segment
  5531 00001DFB 48B800001100000000-         mov rax, BIOSStartAddr  ;Start address of BIOS
  5531 00001E04 00                 
  5532 00001E05 31DB                        xor ebx, ebx
  5533 00001E07 8B1C25[E8010000]            mov ebx, dword [scpSize]    ;Total sum of segment sizes
  5534 00001E0E 488B1425[E0010000]          mov rdx, qword [sysMem]     ;Get total usable memory count
  5535 00001E16 4829DA                      sub rdx, rbx    ;Remove SCP/BIOS allocation from the size
  5536 00001E19 48CF                        iretq
  5537                                  
  5538                                  .fullMemoryMap:
  5539 00001E1B 488B0425[CD010000]          mov rax, qword [userBase]    ;Start space, returns userbase in r8
  5540 00001E23 48BE-                       mov rsi, bigmapptr
  5540 00001E25 [F005000000000000] 
  5541 00001E2D 8A0C25[D5010000]            mov cl, byte [bigmapSize]   ;Get the number of 24 byte entries
  5542 00001E34 30ED                        xor ch, ch                  ;Reserve the upper byte
  5543 00001E36 48CF                        iretq
  5544                                  
  5545                                  .sysDataTableDispatcher:
  5546                                  ; ax = F000h, Register new GDT ptr
  5547                                  ; ax = F001h, Register new IDT ptr
  5548                                  ; ax = F002h, Get Current GDT ptr
  5549                                  ; ax = F003h, Get Current IDT ptr
  5550                                  ; ax = F004h, Register New Page Tables
  5551                                  ; ax = F005h, Get physical address of PTables
  5552                                  ; ax = F006h, Get pointer to BIOS Data Area
  5553                                  ; ax = F007h, Read IDT entry
  5554                                  ; ax = F008h, Write IDT entry
  5555                                  ; ax = F009h, Register new Disk Parameter Table
  5556                                  ; ax = F00Ah, Get current DPT
  5557                                  ; ax = F00Bh, Register new Fixed Disk Parameter Table
  5558                                  ; ax = F00Ch, Get current fDPT
  5559                                  ; ax = F00Dh, Register new SysInit parameters 
  5560                                  ; ax = F00Eh, Get current SysInit parameters
  5561 00001E38 3C04                        cmp al, 4h          
  5562 00001E3A 725D                        jb .sdtDT           ;al = 00 - 03, goto sdtDT
  5563 00001E3C 3C04                        cmp al, 4           
  5564 00001E3E 0F8493000000                jz .sdtRegisterPage ;al = 04
  5565 00001E44 3C05                        cmp al, 5
  5566 00001E46 0F8495000000                jz .sdtGetPagePtr   ;al = 05
  5567 00001E4C 3C06                        cmp al, 6
  5568 00001E4E 0F8497000000                jz .sdtDataptr      ;al = 06
  5569 00001E54 3C07                        cmp al, 7
  5570 00001E56 0F849B000000                jz .sdtReadIDTEntry ;al = 07
  5571 00001E5C 3C08                        cmp al, 8
  5572 00001E5E 0F84C4000000                jz .sdtWriteIDTEntry    ;al = 08
  5573 00001E64 3C09                        cmp al, 9
  5574 00001E66 0F84D4000000                jz .sdtNewDDP       ;al = 09
  5575 00001E6C 3C0A                        cmp al, 0Ah
  5576 00001E6E 0F84E0000000                jz .sdtReadDDP      ;al = 0A
  5577 00001E74 3C0B                        cmp al, 0Bh         
  5578 00001E76 0F84CE000000                jz .sdtNewfDDP      ;al = 0Bh
  5579 00001E7C 3C0C                        cmp al, 0Ch
  5580 00001E7E 0F84DA000000                jz .sdtReadfDDP     ;al = 0Ch
  5581 00001E84 3C0D                        cmp al, 0Dh
  5582 00001E86 0F84DC000000                jz .sdtNewSysInit   ;al = 0Dh
  5583 00001E8C 3C0E                        cmp al, 0Eh
  5584 00001E8E 0F84E6000000                jz .sdtReadSysInit  ;al = 0Eh
  5585 00001E94 E9B5FDFFFF                  jmp .badFunction
  5586                                  
  5587                                  .sdtDT:
  5588                                  ;sys data tables Descriptor Table dispatcher
  5589                                  ;rbx has/will have I/GDT base pointer (qword)
  5590                                  ;ecx has/will have I/GDT limit (word)
  5591                                  ;edx has/will have Number of entries in I/GDT (word)
  5592 00001E99 57                          push rdi
  5593 00001E9A 56                          push rsi
  5594 00001E9B 48BF-                       mov rdi, GDTlength
  5594 00001E9D [0C00000000000000] 
  5595 00001EA5 48BE-                       mov rsi, IDTlength
  5595 00001EA7 [0000000000000000] 
  5596 00001EAF A801                        test al, 1  ;If al[0] = 1, want rdi to point to IDT area
  5597 00001EB1 480F45FE                    cmovnz rdi, rsi ;If al[0] = 0, rdi will keep pointing to GDT
  5598 00001EB5 A802                        test al, 2  ;If bit 2 is set, Get pointers
  5599 00001EB7 750F                        jnz .sdtGet
  5600 00001EB9 668917                      mov word [rdi], dx
  5601 00001EBC 66894F02                    mov word [rdi + 2], cx
  5602 00001EC0 48895F04                    mov qword [rdi + 4], rbx
  5603 00001EC4 56                          push rsi
  5604 00001EC5 5F                          pop rdi
  5605 00001EC6 48CF                        iretq
  5606                                  .sdtGet:
  5607 00001EC8 0FB717                      movzx edx, word [rdi]
  5608 00001ECB 0FB74F02                    movzx ecx, word [rdi + 2]
  5609 00001ECF 488B5F04                    mov rbx, qword [rdi + 4]
  5610 00001ED3 56                          push rsi
  5611 00001ED4 5F                          pop rdi
  5612 00001ED5 48CF                        iretq
  5613                                  .sdtRegisterPage:
  5614 00001ED7 48891C25[18000000]          mov qword [pageTablePtr], rbx   ;Registers pointer as new table space
  5615 00001EDF 48CF                        iretq
  5616                                  .sdtGetPagePtr:
  5617 00001EE1 488B1C25[18000000]          mov rbx, qword [pageTablePtr]  ;Return BIOS Page Table ptr
  5618 00001EE9 48CF                        iretq
  5619                                  .sdtDataptr:
  5620 00001EEB 48BB-                       mov rbx, section.data.start        ;Get BIOS Data area ptr into rax
  5620 00001EED [0000000000000000] 
  5621 00001EF5 48CF                        iretq
  5622                                  .sdtReadIDTEntry:
  5623                                  ;bx = Number of interrupt handler (00h-0FFFFh), uses only bl
  5624                                  ;Returns pointer in rbx, 
  5625                                  ;Segment selector in ax,
  5626                                  ;Attribute word in dx
  5627 00001EF7 480FB6DB                    movzx rbx, bl
  5628 00001EFB 488B1425[04000000]          mov rdx, qword [IDTpointer.Base]    ;Get base address
  5629 00001F03 48C1E304                    shl rbx, 4h         ;Multiply address number by 16
  5630 00001F07 4801DA                      add rdx, rbx        ;rdx point to IDT entry
  5631 00001F0A 8B4208                      mov eax, dword [rdx + 8]
  5632 00001F0D 48C1E020                    shl rax, 20h        ;Shift dword into upper dword
  5633 00001F11 668B5A06                    mov bx, word [rdx + 6]
  5634 00001F15 C1E310                      shl ebx, 10h        ;Shift word into upper word
  5635 00001F18 668B1A                      mov bx, word [rdx]  ;Get final word
  5636 00001F1B 4809C3                      or rbx, rax         ;Add upper dword to rbx
  5637 00001F1E 668B4202                    mov ax, word [rdx + 2]  ;Get Segment selector in ax
  5638 00001F22 668B5204                    mov dx, word [rdx + 4]  ;Get attributes word
  5639 00001F26 48CF                        iretq
  5640                                  .sdtWriteIDTEntry:
  5641                                  ;rbx = Pointer to new routine
  5642                                  ;cx = Number of the interrupt handler (00h-0FFFFh), uses only cl
  5643                                  ;dx = IDT entry attributes
  5644                                  ;si = Segment selector
  5645 00001F28 50                          push rax
  5646 00001F29 51                          push rcx
  5647 00001F2A 56                          push rsi
  5648 00001F2B 53                          push rbx
  5649 00001F2C 4889D8                      mov rax, rbx    ;Move pointer to new routine to rax
  5650 00001F2F 89F3                        mov ebx, esi    ;Move Segment selector from si to bx 
  5651 00001F31 480FB6F1                    movzx rsi, cl   ;Movzx low byte of interrupt number into rsi
  5652 00001F35 E891E1FFFF                  call idtWriteEntry
  5653 00001F3A 5B                          pop rbx
  5654 00001F3B 5E                          pop rsi
  5655 00001F3C 59                          pop rcx
  5656 00001F3D 58                          pop rax
  5657 00001F3E 48CF                        iretq
  5658                                  .sdtNewDDP:
  5659 00001F40 48891C25[AF010000]          mov qword [diskDptPtr], rbx
  5660 00001F48 48CF                        iretq
  5661                                  .sdtNewfDDP:
  5662 00001F4A 48891C25[B7010000]          mov qword [fdiskDptPtr], rbx
  5663 00001F52 48CF                        iretq
  5664                                  .sdtReadDDP:
  5665 00001F54 488B1C25[AF010000]          mov rbx, qword [diskDptPtr]
  5666 00001F5C 48CF                        iretq
  5667                                  .sdtReadfDDP:
  5668 00001F5E 488B1C25[B7010000]          mov rbx, qword [fdiskDptPtr]
  5669 00001F66 48CF                        iretq
  5670                                  .sdtNewSysInit:
  5671 00001F68 48891C25[BF010000]          mov qword [nextFilePtr], rbx
  5672 00001F70 66891425[C7010000]          mov word [numSectors], dx
  5673 00001F78 48CF                        iretq
  5674                                  .sdtReadSysInit:
  5675 00001F7A 488B1C25[BF010000]          mov rbx, qword [nextFilePtr]
  5676 00001F82 668B1425[C7010000]          mov dx, word [numSectors]
  5677 00001F8A 48CF                        iretq
  5678                                  .ehciFunctionDispatcher:
  5679                                  ;EHCI function dispatcher 0F1h
  5680                                  ; al = 00h -> EHCI get crit error handler
  5681                                  ; al = 01h -> EHCI set crit error handler
  5682                                  ; al = 02h -> Reserved, reset selected EHCI controller
  5683                                  ; al = 03h -> Reserved, re-enumerate devices downstream of EHCI Root hub
  5684 00001F8C 84C0                        test al, al
  5685 00001F8E 7411                        jz .ehciDispGetCritPtr
  5686 00001F90 FEC8                        dec al
  5687 00001F92 7417                        jz .ehciDispSetCritPtr
  5688 00001F94 FEC8                        dec al
  5689 00001F96 741D                        jz .ehciDispResetCtrlr
  5690 00001F98 FEC8                        dec al
  5691 00001F9A 7419                        jz .echiDispReEnumDevices
  5692 00001F9C E9ADFCFFFF                  jmp .badFunction
  5693                                  
  5694                                  .ehciDispGetCritPtr:
  5695                                  ;Gets the address of the current EHCI critical error handler into rbx
  5696 00001FA1 488B1C25[36020000]          mov rbx, qword [eHCErrorHandler]
  5697 00001FA9 48CF                        iretq
  5698                                  .ehciDispSetCritPtr:
  5699                                  ;Sets the address of the EHCI critical error handler to the ptr in rbx
  5700 00001FAB 48891C25[36020000]          mov qword [eHCErrorHandler], rbx
  5701 00001FB3 48CF                        iretq
  5702                                  .ehciDispResetCtrlr:
  5703                                  .echiDispReEnumDevices:
  5704 00001FB5 B486                        mov ah, 86h     ;Unsupported function call
  5705 00001FB7 E994FCFFFF                  jmp .badout  
  5706                                  ;------------------------End of Interrupt------------------------
  5707                                  ;-------------------Keyboard Interrupt Int 36h-------------------
  5708                                  ; Software keyboard interrupt. 
  5709                                  ; ah = 0 -> Read the next scancode/ASCII struck from the keyboard
  5710                                  ; ah = 1 -> Clear zero flag if there is a new char ready to be 
  5711                                  ;           read.
  5712                                  ; ah = 2 -> Returns the current shift status in the al register
  5713                                  ; ax and flags changed.
  5714                                  ;----------------------------------------------------------------
  5715                                  kb_io:
  5716 00001FBC 53                          push rbx
  5717 00001FBD FA                          cli            ;Interrupts off
  5718 00001FBE 84E4                        test ah, ah
  5719 00001FC0 7411                        jz .k0
  5720 00001FC2 FECC                        dec ah
  5721 00001FC4 7436                        jz .k1
  5722 00001FC6 FECC                        dec ah
  5723 00001FC8 7450                        jz .k2
  5724 00001FCA 804C241801                  or byte [rsp + 3*8h], 1    ;Set CF, invalid function, skip rbx on stack
  5725 00001FCF B480                        mov ah, 80h    ;Invalid Function
  5726 00001FD1 EB4E                        jmp short .kexit ;ah > 2, not a valid function
  5727                                      
  5728                                  .k0:    
  5729                                  ;This one moves the head to catch up with the tail.
  5730 00001FD3 FB                          sti
  5731 00001FD4 F390                        pause    ;Allow a keyboard interrupt to occur
  5732 00001FD6 FA                          cli
  5733 00001FD7 488B1C25[42000000]          mov rbx, qword [kb_buf_head]
  5734 00001FDF 483B1C25[4A000000]          cmp rbx, qword [kb_buf_tail]    ;Are we at the head of the buffer?
  5735 00001FE7 74EA                        je .k0    ;If we are, then the buffer is empty, await a keystroke
  5736 00001FE9 66678B03                    mov ax, word [ebx]        ;move the word pointed at by rbx to ax
  5737 00001FED E833000000                  call .kb_ptr_adv    ;Advance the buffer pointer
  5738                                      
  5739 00001FF2 48891C25[42000000]          mov qword [kb_buf_head], rbx    ;Move rbx into the buffer head variable
  5740 00001FFA EB25                        jmp short .kexit
  5741                                  
  5742                                  .k1:
  5743 00001FFC 488B1C25[42000000]          mov rbx, qword [kb_buf_head]
  5744 00002004 483B1C25[4A000000]          cmp rbx, qword [kb_buf_tail] ;sets flags, Z is set if equal 
  5745 0000200C 660F4503                    cmovnz ax, word [rbx]    ;move head of buffer into ax, IF Z clear
  5746 00002010 FB                          sti     ;renable interrupts 
  5747 00002011 9C                          pushfq    ;push flags onto stack
  5748 00002012 5B                          pop rbx    ;pop them into rbx
  5749 00002013 48895C2418                  mov [rsp + 3*8h], qword rbx    ;Replace with new flags, skip pushed rbx
  5750 00002018 EB07                        jmp short .kexit
  5751                                      
  5752                                  .k2:
  5753 0000201A 8A0425[62000000]            mov al, byte [kb_flags]
  5754                                  .kexit:
  5755 00002021 FB                          sti
  5756 00002022 5B                          pop rbx
  5757 00002023 48CF                        iretq
  5758                                  
  5759                                  .kb_ptr_adv:
  5760                                  ;Advance the pointer passed by rbx safely and return pointer!
  5761 00002025 48FFC3                      inc rbx
  5762 00002028 48FFC3                      inc rbx
  5763 0000202B 483B1C25[5A000000]          cmp rbx, qword [kb_buf_end]     ;Are we at the end of the buffer space
  5764 00002033 7508                        jne .kbpa1                      ;If not exit, if we are, wrap around space!
  5765 00002035 488B1C25[52000000]          mov rbx, qword [kb_buf_start]
  5766                                  .kbpa1:
  5767 0000203D C3                          ret
  5768                                  ;------------------------End of Interrupt------------------------
  5769                                  ;------------------------Printer Int 37h-------------------------
  5770                                  ; Reserved for printer specific functions. Both USB and Parallel.
  5771                                  ; Not currently supported
  5772                                  ;----------------------------------------------------------------
  5773                                  printer_io:
  5774 0000203E B486                        mov ah, 86h    ;Function not supported
  5775 00002040 804C241001                  or byte [rsp+ 2*8h], 1    ;Set carry
  5776 00002045 48CF                        iretq
  5777                                  ;------------------------End of Interrupt------------------------
  5778                                  ;---------------------MCP Interrupt Int 38h----------------------
  5779                                  ;This interrupt superceeds the IBM BASIC routine caller. 
  5780                                  ;This is a 64 bit port of my 16 bit MCP monitor program, 
  5781                                  ; allowing users to "interactively" get sectors from devices 
  5782                                  ; and run them. I might add some nicities to this version of MCP 
  5783                                  ; such as a function to list all devices.
  5784                                  ;----------------------------------------------------------------
  5785                                  MCPjmptbl:  ;Function jump table
  5786 00002047 [8129000000000000]          dq MCP_int.dumpMemory      ;Dump
  5787 0000204F [822B000000000000]          dq MCP_int.editMemory      ;Edit
  5788 00002057 [3E2C000000000000]          dq MCP_int.singleStep      ;Single step
  5789 0000205F [F22B000000000000]          dq MCP_int.jumpProc        ;Go
  5790 00002067 [4D2C000000000000]          dq MCP_int.proceedDefault  ;Proceed
  5791 0000206F [602C000000000000]          dq MCP_int.storageRead     ;Load
  5792 00002077 [682C000000000000]          dq MCP_int.storageWrite    ;Write
  5793 0000207F [F22C000000000000]          dq MCP_int.restartMcp      ;Quit   <- To call Int 40h for DOS compatibility
  5794 00002087 [F42C000000000000]          dq MCP_int.clearscreen     ;Clear screen
  5795 0000208F [5C24000000000000]          dq MCP_int.xchangeReg      ;Registers
  5796 00002097 [BF22000000000000]          dq MCP_int.debugRegs       ;Breakpoints
  5797 0000209F [3026000000000000]          dq MCP_int.hexCalc         ;Hex
  5798 000020A7 [7425000000000000]          dq MCP_int.inport          ;In
  5799 000020AF [C725000000000000]          dq MCP_int.outport         ;Out
  5800 000020B7 [7A22000000000000]          dq MCP_int.version         ;Version
  5801 000020BF [3E2C000000000000]          dq MCP_int.singleStep      ;Single Step (Alt), temp
  5802 000020C7 [4B21000000000000]          dq MCP_int.memoryMap       ;Print memory map
  5803 000020CF [1322000000000000]          dq MCP_int.connect         ;Connect Debugger
  5804 000020D7 [4522000000000000]          dq MCP_int.disconnect      ;Disconnect Debugger
  5805                                  MCP_int:
  5806                                      ;Entry point from external programs
  5807 000020DF 48890425[04020000]          mov qword [mcpUserRaxStore], rax
  5808 000020E7 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  5809 000020EF 48896008                    mov qword [rax + 08h], rsp
  5810 000020F3 E8080C0000                  call .storeMainRegisters    ;Save main registers
  5811                                  .z11:
  5812 000020F8 488B2425[0C020000]          mov rsp, qword [mcpStackPtr]  ;Point sp to new stack
  5813 00002100 B804130000                  mov eax, 1304h    ;Zero extends to rax
  5814 00002105 48BD-                       mov rbp, .prompt
  5814 00002107 [CE2E000000000000] 
  5815 0000210F 30FF                        xor bh, bh
  5816 00002111 CD30                        int 30h
  5817                                  .z2:
  5818 00002113 6631C0                      xor ax, ax 
  5819 00002116 CD36                        int 36h
  5820 00002118 3C08                        cmp al, 08h        ;If backspace, ignore
  5821 0000211A 74F7                        je .z2
  5822 0000211C E8820D0000                  call .print        ;Print input char
  5823 00002121 FD                          std
  5824 00002122 48BF-                       mov rdi, .prompt    ;end of lst is prompt
  5824 00002124 [CE2E000000000000] 
  5825 0000212C 48B914000000000000-         mov rcx, .lstl + 1
  5825 00002135 00                 
  5826 00002136 F2AE                        repne scasb
  5827 00002138 FC                          cld
  5828 00002139 0F85AC000000                jne .bad_command    ;Char not found!
  5829                                  .prog_sel:    ;Choose program
  5830 0000213F 68[F8200000]                push MCP_int.z11    ;to allow RETurning to application
  5831 00002144 FF24CD[47200000]            jmp qword [MCPjmptbl + 8*rcx]    ;Jump to chosen function         
  5832                                  .memoryMap:
  5833 0000214B 66B80A0E                    mov ax,0E0Ah
  5834 0000214F CD30                        int 30h
  5835 00002151 66B80D0E                    mov ax, 0E0Dh
  5836 00002155 CD30                        int 30h
  5837 00002157 E8A4DEFFFF                  call e820print  ;Print memory map
  5838 0000215C E997FFFFFF                  jmp .z11
  5839                                  .singleStepsEP:
  5840 00002161 48890425[04020000]          mov qword [mcpUserRaxStore], rax
  5841 00002169 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  5842 00002171 48896008                    mov qword [rax + 08h], rsp
  5843 00002175 E8860B0000                  call .storeMainRegisters
  5844 0000217A 488B0424                    mov rax, qword [rsp]    ;Get next instruction address
  5845 0000217E 48890425[F4010000]          mov qword [mcpUserRip], rax
  5846 00002186 E875050000                  call .dumpReg    ;Show register state
  5847 0000218B E802020000                  call .dumpDebugRegs
  5848 00002190 FB                          sti ;Restore interrupts
  5849 00002191 E962FFFFFF                  jmp .z11
  5850                                  .debugEpHardware:
  5851 00002196 48890425[04020000]          mov qword [mcpUserRaxStore], rax
  5852 0000219E 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  5853 000021A6 48896008                    mov qword [rax + 08h], rsp
  5854 000021AA E8510B0000                  call .storeMainRegisters
  5855 000021AF FB                          sti ;Restore interrupts
  5856 000021B0 B020                        mov al, EOI
  5857 000021B2 E620                        out pic1command, al
  5858 000021B4 EB1A                        jmp short .dep1
  5859                                  .debugEp:    
  5860                                  ;Return here after a single step or int 3. 
  5861                                  ;Support Int 3h thru manual encoding only, not via the debugger
  5862 000021B6 48890425[04020000]          mov qword [mcpUserRaxStore], rax
  5863 000021BE 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  5864 000021C6 48896008                    mov qword [rax + 08h], rsp
  5865 000021CA E8310B0000                  call .storeMainRegisters
  5866 000021CF FB                          sti ;Restore interrupts
  5867                                  .dep1:
  5868 000021D0 488B0424                    mov rax, qword [rsp]    ;Get next instruction address
  5869 000021D4 48890425[F4010000]          mov qword [mcpUserRip], rax
  5870 000021DC E81F050000                  call .dumpReg    ;Show register state
  5871 000021E1 E8AC010000                  call .dumpDebugRegs
  5872 000021E6 E90DFFFFFF                  jmp .z11
  5873                                  .bad_command:
  5874 000021EB 48B804130000000000-         mov rax, 1304h
  5874 000021F4 00                 
  5875 000021F5 30FF                        xor bh, bh
  5876 000021F7 48BD-                       mov rbp, .bc1
  5876 000021F9 [0822000000000000] 
  5877 00002201 CD30                        int 30h
  5878 00002203 E9F0FEFFFF                  jmp MCP_int.z11
  5879 00002208 0A0D205E204572726F-     .bc1: db 0Ah,0Dh," ^ Error",0
  5879 00002211 7200               
  5880                                  ;><><><><><><><-Internal Commands Begin Here-><><><><><><><
  5881                                  .connect:
  5882 00002213 50                          push rax
  5883 00002214 55                          push rbp
  5884 00002215 B801C50000                  mov eax, 0C501h ;Connect Debugger
  5885 0000221A CD35                        int 35h
  5886 0000221C B804130000                  mov eax, 1304h
  5887 00002221 48BD-                       mov rbp, .connectString
  5887 00002223 [3022000000000000] 
  5888 0000222B CD30                        int 30h
  5889 0000222D 5D                          pop rbp
  5890 0000222E 58                          pop rax
  5891 0000222F C3                          ret
  5892 00002230 0A0D53595344454255-     .connectString db 0Ah,0Dh,"SYSDEBUG Connected",0
  5892 00002239 4720436F6E6E656374-
  5892 00002242 656400             
  5893                                  .disconnect:
  5894 00002245 50                          push rax
  5895 00002246 55                          push rbp
  5896 00002247 B802C50000                  mov eax, 0C502h ;Disconnect Debugger
  5897 0000224C CD35                        int 35h
  5898 0000224E B804130000                  mov eax, 1304h
  5899 00002253 48BD-                       mov rbp, .disconnectString
  5899 00002255 [6222000000000000] 
  5900 0000225D CD30                        int 30h
  5901 0000225F 5D                          pop rbp
  5902 00002260 58                          pop rax
  5903 00002261 C3                          ret
  5904 00002262 0A0D53595344454255-     .disconnectString db 0Ah,0Dh,"SYSDEBUG Disconnected",0
  5904 0000226B 4720446973636F6E6E-
  5904 00002274 656374656400       
  5905                                  .version:
  5906 0000227A 66B80413                    mov ax, 1304h
  5907 0000227E 30FF                        xor bh, bh
  5908 00002280 48BD-                       mov rbp, .vstring
  5908 00002282 [A222000000000000] 
  5909 0000228A CD30                        int 30h
  5910 0000228C 48BE-                       mov rsi, signature + 1    ;Point to BIOS signature string (skip the v char)
  5910 0000228E [1850000000000000] 
  5911                                  .v1:
  5912 00002296 AC                          lodsb
  5913 00002297 3C20                        cmp al, 20h            ;Check space
  5914 00002299 7406                        je .v2
  5915 0000229B B40E                        mov ah, 0Eh
  5916                                      ;xor bh, bh
  5917 0000229D CD30                        int 30h
  5918 0000229F EBF5                        jmp short .v1
  5919                                  .v2:
  5920 000022A1 C3                          ret
  5921 000022A2 0A0D5343502F42494F-     .vstring:    db 0Ah, 0Dh,"SCP/BIOS SYSDEBUG Version ",0
  5921 000022AB 532053595344454255-
  5921 000022B4 472056657273696F6E-
  5921 000022BD 2000               
  5922                                  .debugRegs:
  5923 000022BF E8CE000000                  call .dumpDebugRegs
  5924 000022C4 66B80413                    mov ax, 1304h
  5925 000022C8 48BD-                       mov rbp, .crlf    ;Newline
  5925 000022CA [D42E000000000000] 
  5926 000022D2 CD30                        int 30h
  5927                                  
  5928 000022D4 66B82E0E                    mov ax, 0E2Eh    ;Print dot byte
  5929 000022D8 CD30                        int 30h
  5930                                  
  5931 000022DA 66B80101                    mov ax, 0101h    ;Process one byte
  5932 000022DE E81F0B0000                  call .keyb
  5933 000022E3 4885ED                      test rbp, rbp
  5934 000022E6 0F840CFEFFFF                jz .z11    ;If enter pressed, return to command line
  5935 000022EC E8B10A0000                  call .arg
  5936 000022F1 3C01                        cmp al, 1
  5937 000022F3 0F85DA070000                jne .dmbadexit
  5938                                  
  5939 000022F9 488B7D00                    mov rdi, qword [rbp]
  5940 000022FD 4881FF04000000              cmp rdi, 4
  5941 00002304 7213                        jb .xr11    ;Cant edit dr4, or 5. dr6 is read only
  5942 00002306 4881FF07000000              cmp rdi, 7  ;Can only edit 7
  5943 0000230D 0F85D8FEFFFF                jne .bad_command
  5944 00002313 48FFCF                      dec rdi     ;Is the fifth entry in the table
  5945 00002316 48FFCF                      dec rdi
  5946                                  .xr11:
  5947 00002319 48BD-                       mov rbp, .crlf
  5947 0000231B [D42E000000000000] 
  5948 00002323 66B80413                    mov ax, 1304h
  5949 00002327 30FF                        xor bh, bh
  5950 00002329 CD30                        int 30h
  5951                                  
  5952 0000232B 57                          push rdi    ;Save rdi
  5953 0000232C 48C1E702                    shl rdi, 2    ;Multiply by 4
  5954 00002330 66B90400                    mov cx, 4    ;4 chars to print
  5955                                  .xr1:   ;Print register name
  5956 00002334 8A87[44240000]              mov al, byte [.dregtbl + rdi]
  5957 0000233A B40E                        mov ah, 0Eh
  5958 0000233C CD30                        int 30h
  5959 0000233E 66FFC7                      inc di
  5960 00002341 66FFC9                      dec cx
  5961 00002344 75EE                        jnz .xr1
  5962                                  ;Get the qword into the keybuffer
  5963 00002346 5F                          pop rdi
  5964 00002347 66B80104                    mov ax, 0401h    ;Process one qword
  5965 0000234B E8B20A0000                  call .keyb
  5966 00002350 4885ED                      test rbp, rbp
  5967 00002353 0F84C6010000                jz .xcnoexit
  5968 00002359 E8440A0000                  call .arg
  5969 0000235E 3C01                        cmp al, 1
  5970 00002360 0F856D070000                jne .dmbadexit
  5971                                  
  5972 00002366 488B4500                    mov rax, qword [rbp]    ;rax has the replacement value
  5973 0000236A 4885FF                      test rdi, rdi
  5974 0000236D 7504                        jnz .xr2
  5975 0000236F 0F23C0                      mov dr0, rax
  5976 00002372 C3                          ret
  5977                                  .xr2:
  5978 00002373 48FFCF                      dec rdi
  5979 00002376 7504                        jnz .xr3
  5980 00002378 0F23C8                      mov dr1, rax
  5981 0000237B C3                          ret
  5982                                  .xr3:
  5983 0000237C 48FFCF                      dec rdi
  5984 0000237F 7504                        jnz .xr4
  5985 00002381 0F23D0                      mov dr2, rax
  5986 00002384 C3                          ret
  5987                                  .xr4:
  5988 00002385 48FFCF                      dec rdi
  5989 00002388 7504                        jnz .xr5
  5990 0000238A 0F23D8                      mov dr3, rax
  5991 0000238D C3                          ret
  5992                                  .xr5:
  5993 0000238E 0F23F8                      mov dr7, rax
  5994 00002391 C3                          ret
  5995                                  
  5996                                  .dumpDebugRegs:
  5997 00002392 48BD-                       mov rbp, .crlf
  5997 00002394 [D42E000000000000] 
  5998 0000239C 66B80413                    mov ax, 1304h
  5999 000023A0 30FF                        xor bh, bh
  6000 000023A2 CD30                        int 30h
  6001 000023A4 4831ED                      xor rbp, rbp
  6002 000023A7 4831FF                      xor rdi, rdi
  6003                                  
  6004 000023AA 0F21F8                      mov rax, dr7
  6005 000023AD 50                          push rax
  6006 000023AE 0F21F0                      mov rax, dr6
  6007 000023B1 50                          push rax
  6008 000023B2 0F21D8                      mov rax, dr3
  6009 000023B5 50                          push rax
  6010 000023B6 0F21D0                      mov rax, dr2
  6011 000023B9 50                          push rax
  6012 000023BA 0F21C8                      mov rax, dr1
  6013 000023BD 50                          push rax
  6014 000023BE 0F21C0                      mov rax, dr0
  6015 000023C1 50                          push rax
  6016                                  
  6017                                  .ddr1:
  6018 000023C2 4831C9                      xor rcx, rcx
  6019 000023C5 4881FF03000000              cmp rdi, 3      ;3 registers per row
  6020 000023CC 7450                        je .dregcrlf
  6021                                  .ddr11:
  6022 000023CE 8A840D[44240000]            mov al, byte [.dregtbl + rbp + rcx]
  6023 000023D5 B40E                        mov ah, 0Eh
  6024 000023D7 CD30                        int 30h
  6025 000023D9 66FFC1                      inc cx
  6026 000023DC 6681F90400                  cmp cx, 4
  6027 000023E1 75EB                        jnz .ddr11
  6028                                  
  6029 000023E3 48B908000000000000-         mov rcx, 8
  6029 000023EC 00                 
  6030                                  .ddr2:
  6031 000023ED 5B                          pop rbx    ;Get debug register
  6032 000023EE 480FCB                      bswap rbx
  6033                                  .ddr21:
  6034 000023F1 B404                        mov ah, 04h
  6035 000023F3 88D8                        mov al, bl
  6036 000023F5 CD30                        int 30h
  6037 000023F7 48C1EB08                    shr rbx, 8h
  6038 000023FB FEC9                        dec cl
  6039 000023FD 75F2                        jnz .ddr21
  6040 000023FF 48FFC7                      inc rdi
  6041                                  
  6042 00002402 B403                        mov ah, 3
  6043 00002404 CD30                        int 30h
  6044 00002406 80C203                      add dl, 3
  6045 00002409 B402                        mov ah, 2
  6046 0000240B CD30                        int 30h
  6047 0000240D 4881C504000000              add rbp, 4
  6048 00002414 4881FD18000000              cmp rbp, 24 ;number of chars in the below typed string
  6049 0000241B 72A5                        jb .ddr1
  6050                                  
  6051 0000241D C3                          ret
  6052                                  .dregcrlf:
  6053 0000241E 4831FF                      xor rdi, rdi
  6054 00002421 55                          push rbp
  6055 00002422 50                          push rax
  6056 00002423 53                          push rbx
  6057 00002424 48BD-                       mov rbp, .crlf
  6057 00002426 [D42E000000000000] 
  6058 0000242E 48B804130000000000-         mov rax, 1304h
  6058 00002437 00                 
  6059 00002438 30FF                        xor bh, bh
  6060 0000243A CD30                        int 30h
  6061 0000243C 5B                          pop rbx
  6062 0000243D 58                          pop rax
  6063 0000243E 5D                          pop rbp
  6064 0000243F E98AFFFFFF                  jmp .ddr11
  6065 00002444 4452303D4452313D44-     .dregtbl db "DR0=", "DR1=", "DR2=", "DR3=", "DR6=", "DR7="
  6065 0000244D 52323D4452333D4452-
  6065 00002456 363D4452373D       
  6066                                  
  6067                                  .xchangeReg:
  6068 0000245C E89F020000                  call .dumpReg
  6069 00002461 66B80413                    mov ax, 1304h
  6070 00002465 48BD-                       mov rbp, .crlf    ;Newline
  6070 00002467 [D42E000000000000] 
  6071 0000246F CD30                        int 30h
  6072                                  
  6073 00002471 66B82E0E                    mov ax, 0E2Eh    ;Print dot byte
  6074 00002475 CD30                        int 30h
  6075                                  
  6076 00002477 66B80101                    mov ax, 0101h    ;Process one byte
  6077 0000247B E882090000                  call .keyb
  6078 00002480 4885ED                      test rbp, rbp
  6079 00002483 0F846FFCFFFF                jz .z11    ;If enter pressed, return to command line
  6080 00002489 E814090000                  call .arg
  6081 0000248E 3C01                        cmp al, 1
  6082 00002490 0F853D060000                jne .dmbadexit
  6083                                  
  6084 00002496 488B7D00                    mov rdi, qword [rbp]    ;move this byte into rdi
  6085 0000249A 4881FF11000000              cmp rdi, 11h
  6086 000024A1 0F8744FDFFFF                ja .bad_command    ;If the user chooses a value greater than 11, exit!
  6087                                  
  6088 000024A7 48BD-                       mov rbp, .crlf
  6088 000024A9 [D42E000000000000] 
  6089 000024B1 66B80413                    mov ax, 1304h
  6090 000024B5 30FF                        xor bh, bh
  6091 000024B7 CD30                        int 30h
  6092                                  
  6093 000024B9 4881FF11000000              cmp rdi, 11h
  6094 000024C0 7467                        je .xcflags ;If the user typed 10, then xchange flags
  6095                                  
  6096 000024C2 57                          push rdi    ;Save rdi
  6097 000024C3 48C1E702                    shl rdi, 2    ;Multiply by 4
  6098 000024C7 66B90400                    mov cx, 4    ;4 chars to print
  6099                                  .xcr1:
  6100 000024CB 8A87[1B290000]              mov al, byte [.regtbl + rdi]
  6101 000024D1 B40E                        mov ah, 0Eh
  6102 000024D3 CD30                        int 30h
  6103 000024D5 66FFC7                      inc di
  6104 000024D8 66FFC9                      dec cx
  6105 000024DB 75EE                        jnz .xcr1
  6106                                  
  6107 000024DD 5F                          pop rdi
  6108 000024DE 66B80104                    mov ax, 0401h    ;Process one qword
  6109 000024E2 E81B090000                  call .keyb
  6110 000024E7 4885ED                      test rbp, rbp
  6111 000024EA 7433                        jz .xcnoexit
  6112 000024EC E8B1080000                  call .arg
  6113 000024F1 3C01                        cmp al, 1
  6114 000024F3 0F85DA050000                jne .dmbadexit
  6115                                  
  6116 000024F9 488B4500                    mov rax, qword [rbp]
  6117 000024FD 4881FF10000000              cmp rdi, 10h
  6118 00002504 741A                        je .xcipchange
  6119 00002506 488B1C25[EC010000]          mov rbx, qword [mcpUserBase]
  6120 0000250E 4881C380000000              add rbx, 80h
  6121 00002515 48C1E703                    shl rdi, 3  ;Multiply by 8
  6122 00002519 4829FB                      sub rbx, rdi
  6123 0000251C 488903                      mov qword [rbx], rax    ;Replace element with rax
  6124                                  .xcnoexit:
  6125 0000251F C3                          ret
  6126                                  .xcipchange:
  6127 00002520 48890425[F4010000]          mov qword [mcpUserRip], rax
  6128 00002528 C3                          ret
  6129                                  .xcflags:
  6130 00002529 48B907000000000000-         mov rcx, 7
  6130 00002532 00                 
  6131 00002533 4831FF                      xor rdi, rdi
  6132                                  .xcf1:
  6133 00002536 8A87[71290000]              mov al, byte [.rflgs + rdi]
  6134 0000253C B40E                        mov ah, 0Eh
  6135 0000253E CD30                        int 30h
  6136 00002540 66FFC7                      inc di
  6137 00002543 66FFC9                      dec cx
  6138 00002546 75EE                        jnz .xcf1
  6139                                  
  6140 00002548 66B80104                    mov ax, 0401h    ;Process one qword
  6141 0000254C E8B1080000                  call .keyb
  6142 00002551 4885ED                      test rbp, rbp
  6143 00002554 74C9                        jz .xcnoexit
  6144 00002556 E847080000                  call .arg
  6145 0000255B 3C01                        cmp al, 1
  6146 0000255D 0F8570050000                jne .dmbadexit
  6147 00002563 488B4500                    mov rax, qword [rbp]
  6148 00002567 488B2C25[EC010000]          mov rbp, qword [mcpUserBase]
  6149 0000256F 48894500                    mov qword [rbp], rax
  6150 00002573 C3                          ret
  6151                                  .inport:
  6152 00002574 66B80413                    mov ax, 1304h
  6153 00002578 30FF                        xor bh, bh
  6154 0000257A 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6154 0000257C [D22E000000000000] 
  6155 00002584 CD30                        int 30h
  6156                                  
  6157 00002586 66B80101                    mov ax, 0101h    ;Get 1 byte
  6158 0000258A E873080000                  call .keyb
  6159 0000258F 4885ED                      test rbp, rbp
  6160 00002592 0F8453FCFFFF                jz .bad_command
  6161 00002598 E805080000                  call .arg
  6162 0000259D 3C01                        cmp al, 1
  6163 0000259F 0F852E050000                jne .dmbadexit
  6164 000025A5 488B5500                    mov rdx, qword [rbp]    ;First arg, word io addr
  6165 000025A9 48BD-                       mov rbp, .crlf
  6165 000025AB [D42E000000000000] 
  6166 000025B3 48B804130000000000-         mov rax, 1304h
  6166 000025BC 00                 
  6167 000025BD 30FF                        xor bh, bh
  6168 000025BF CD30                        int 30h
  6169 000025C1 EC                          in al, dx
  6170 000025C2 B404                        mov ah, 04h
  6171 000025C4 CD30                        int 30h
  6172 000025C6 C3                          ret
  6173                                  
  6174                                  .outport:
  6175 000025C7 66B80413                    mov ax, 1304h
  6176 000025CB 48BB07000000000000-         mov rbx, 7h
  6176 000025D4 00                 
  6177 000025D5 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6177 000025D7 [D22E000000000000] 
  6178 000025DF CD30                        int 30h
  6179 000025E1 66B80102                    mov ax, 0201h    ;Get 1 word
  6180 000025E5 E818080000                  call .keyb
  6181 000025EA 4885ED                      test rbp, rbp
  6182 000025ED 0F84F8FBFFFF                jz .bad_command
  6183 000025F3 E8AA070000                  call .arg
  6184 000025F8 3C01                        cmp al, 1
  6185 000025FA 0F85D3040000                jne .dmbadexit
  6186 00002600 488B5500                    mov rdx, qword [rbp]    ;First arg, word io addr
  6187 00002604 B02E                        mov al, "."
  6188 00002606 E898080000                  call .print
  6189 0000260B 66B80101                    mov ax, 0101h    ;Get 1 byte
  6190 0000260F E8EE070000                  call .keyb
  6191 00002614 4885ED                      test rbp, rbp
  6192 00002617 0F84CEFBFFFF                jz .bad_command
  6193 0000261D E880070000                  call .arg
  6194 00002622 3C01                        cmp al, 1
  6195 00002624 0F85A9040000                jne .dmbadexit
  6196 0000262A 488B4500                    mov rax, qword [rbp]
  6197 0000262E EE                          out dx, al
  6198 0000262F C3                          ret
  6199                                  
  6200                                  .hexCalc:
  6201 00002630 66B80413                    mov ax, 1304h
  6202 00002634 30FF                        xor bh, bh
  6203 00002636 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6203 00002638 [D22E000000000000] 
  6204 00002640 CD30                        int 30h
  6205 00002642 66B80204                    mov ax, 0402h    ;Get 2 qwords
  6206 00002646 E8B7070000                  call .keyb
  6207 0000264B 4885ED                      test rbp, rbp
  6208 0000264E 0F8497FBFFFF                jz .bad_command
  6209 00002654 E849070000                  call .arg
  6210                                  
  6211 00002659 3C02                        cmp al, 2
  6212 0000265B 0F8572040000                jne .dmbadexit
  6213                                  
  6214 00002661 4C8B4508                    mov r8, qword [rbp + 8] ;First number 
  6215 00002665 4C8B4D00                    mov r9, qword [rbp]        ;Second number
  6216 00002669 4F8D1408                    lea r10, qword [r8+r9]
  6217                                  
  6218 0000266D 48BD-                       mov rbp, .crlf
  6218 0000266F [D42E000000000000] 
  6219 00002677 48B804130000000000-         mov rax, 1304h
  6219 00002680 00                 
  6220 00002681 30FF                        xor bh, bh
  6221 00002683 CD30                        int 30h
  6222                                  
  6223 00002685 4C89C2                      mov rdx, r8
  6224 00002688 E856000000                  call .hcprintquad
  6225 0000268D B02B                        mov al, "+"
  6226 0000268F E80F080000                  call .print
  6227 00002694 4C89CA                      mov rdx, r9
  6228 00002697 E847000000                  call .hcprintquad
  6229 0000269C B03D                        mov al, "="
  6230 0000269E E800080000                  call .print
  6231 000026A3 4C89D2                      mov rdx, r10
  6232 000026A6 E838000000                  call .hcprintquad
  6233                                  
  6234 000026AB 48B804130000000000-         mov rax, 1304h
  6234 000026B4 00                 
  6235 000026B5 30FF                        xor bh, bh
  6236 000026B7 CD30                        int 30h
  6237                                  
  6238 000026B9 4C89C2                      mov rdx, r8
  6239 000026BC E822000000                  call .hcprintquad
  6240 000026C1 B02D                        mov al, "-"
  6241 000026C3 E8DB070000                  call .print
  6242 000026C8 4C89CA                      mov rdx, r9
  6243 000026CB E813000000                  call .hcprintquad
  6244 000026D0 B03D                        mov al, "="
  6245 000026D2 E8CC070000                  call .print
  6246 000026D7 4D29C8                      sub r8, r9
  6247 000026DA 4C89C2                      mov rdx, r8
  6248 000026DD E801000000                  call .hcprintquad
  6249 000026E2 C3                          ret
  6250                                  
  6251                                  .hcprintquad:
  6252                                  ;Takes whats in rdx, and prints it
  6253 000026E3 480FCA                      bswap rdx
  6254 000026E6 48B908000000000000-         mov rcx, 8
  6254 000026EF 00                 
  6255                                  .hcpq1:
  6256 000026F0 88D0                        mov al, dl
  6257 000026F2 B404                        mov ah, 04h
  6258 000026F4 CD30                        int 30h
  6259 000026F6 48C1EA08                    shr rdx, 8
  6260 000026FA 66FFC9                      dec cx
  6261 000026FD 75F1                        jnz .hcpq1
  6262 000026FF C3                          ret
  6263                                  
  6264                                  .dumpReg:
  6265 00002700 48BD-                       mov rbp, .crlf
  6265 00002702 [D42E000000000000] 
  6266 0000270A 66B80413                    mov ax, 1304h
  6267 0000270E 30FF                        xor bh, bh
  6268 00002710 CD30                        int 30h
  6269 00002712 4831ED                      xor rbp, rbp
  6270 00002715 4831FF                      xor rdi, rdi
  6271 00002718 4831F6                      xor rsi, rsi
  6272 0000271B 488B3425[EC010000]          mov rsi, qword [mcpUserBase]
  6273 00002723 4881C680000000              add rsi, 80h
  6274                                  .dreg1:
  6275 0000272A 4831C9                      xor rcx, rcx
  6276 0000272D 4881FF03000000              cmp rdi, 3
  6277 00002734 0F84BB010000                je .regcrlf
  6278                                  .dreg11:    ;Print register name
  6279 0000273A 8A840D[1B290000]            mov al, byte [.regtbl+rbp+rcx]
  6280 00002741 B40E                        mov ah, 0Eh
  6281 00002743 CD30                        int 30h
  6282 00002745 66FFC1                      inc cx
  6283 00002748 6681F90400                  cmp cx, 4h
  6284 0000274D 75EB                        jnz .dreg11
  6285                                  .dreg2:
  6286 0000274F 48B908000000000000-         mov rcx, 8h
  6286 00002758 00                 
  6287                                  ;Now print register value
  6288 00002759 488B1E                      mov rbx, qword [rsi]    ;Get qword from storage
  6289 0000275C 81EE08000000                sub esi, 8
  6290 00002762 480FCB                      bswap rbx    ;Change endianness
  6291                                  .dreg21:
  6292 00002765 B404                        mov ah, 04h
  6293 00002767 88D8                        mov al, bl
  6294 00002769 CD30                        int 30h
  6295 0000276B 48C1EB08                    shr rbx, 8h    ;Shift down by a byte
  6296 0000276F FEC9                        dec cl
  6297 00002771 75F2                        jnz .dreg21
  6298 00002773 48FFC7                      inc rdi
  6299                                  
  6300 00002776 B403                        mov ah, 3
  6301 00002778 CD30                        int 30h
  6302 0000277A 80C203                      add dl, 3
  6303 0000277D B402                        mov ah, 2
  6304 0000277F CD30                        int 30h
  6305 00002781 4881C504000000              add rbp, 4
  6306 00002788 4881FD40000000              cmp rbp, 40h
  6307 0000278F 7299                        jb .dreg1
  6308                                  
  6309                                  ;Print RIP
  6310                                  .drip0:
  6311 00002791 4831C9                      xor rcx, rcx
  6312                                  .drip1:
  6313                                  ;Print name
  6314 00002794 8A840D[1B290000]            mov al, byte [.regtbl+rbp+rcx]
  6315 0000279B B40E                        mov ah, 0Eh
  6316 0000279D CD30                        int 30h
  6317 0000279F 66FFC1                      inc cx
  6318 000027A2 6681F90400                  cmp cx, 4h
  6319 000027A7 75EB                        jne .drip1
  6320                                  
  6321 000027A9 48B908000000000000-         mov rcx, 8
  6321 000027B2 00                 
  6322 000027B3 488B3425[F4010000]          mov rsi, qword [mcpUserRip]
  6323 000027BB 480FCE                      bswap rsi
  6324                                  .drip2:
  6325                                  ;Print value
  6326 000027BE B404                        mov ah, 04h
  6327 000027C0 4088F0                      mov al, sil
  6328 000027C3 CD30                        int 30h
  6329 000027C5 48C1EE08                    shr rsi, 8h    ;Shift down by a byte
  6330 000027C9 FEC9                        dec cl
  6331 000027CB 75F1                        jnz .drip2
  6332 000027CD 4881C504000000              add rbp, 4    ;Offset into table
  6333                                  
  6334 000027D4 55                          push rbp
  6335 000027D5 48BD-                       mov rbp, .ipstrg
  6335 000027D7 [7829000000000000] 
  6336 000027DF 66B80413                    mov ax, 1304h
  6337 000027E3 CD30                        int 30h    
  6338 000027E5 B107                        mov cl, 7
  6339 000027E7 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  6340 000027EF 488B4008                    mov rax, qword [rax + 08h]  ;Get the old stack pointer
  6341 000027F3 488B18                      mov rbx, qword [rax]    ;Get the address of 8 bytes at that instruction
  6342 000027F6 488B1B                      mov rbx, qword [rbx]    ;Get the bytes
  6343 000027F9 88D8                        mov al, bl
  6344 000027FB B404                        mov ah, 04h
  6345 000027FD CD30                        int 30h
  6346 000027FF 48C1EB08                    shr rbx, 8
  6347 00002803 B40E                        mov ah, 0Eh   ;Add a space to indicate mod r/m + optionals
  6348 00002805 B02D                        mov al, '-'
  6349 00002807 CD30                        int 30h
  6350                                  .ssep0:
  6351 00002809 88D8                        mov al, bl
  6352 0000280B B404                        mov ah, 04h
  6353 0000280D CD30                        int 30h
  6354 0000280F 48C1EB08                    shr rbx, 8
  6355 00002813 FEC9                        dec cl
  6356 00002815 75F2                        jnz .ssep0
  6357                                  
  6358 00002817 48BD-                       mov rbp, .crlf
  6358 00002819 [D42E000000000000] 
  6359 00002821 48B804130000000000-         mov rax, 1304h
  6359 0000282A 00                 
  6360 0000282B 48BB07000000000000-         mov rbx, 7h
  6360 00002834 00                 
  6361 00002835 CD30                        int 30h
  6362 00002837 5D                          pop rbp
  6363                                  
  6364 00002838 668CC8                      mov ax, cs
  6365 0000283B E87D000000                  call .dsegregwrite
  6366 00002840 668CD8                      mov ax, ds
  6367 00002843 E875000000                  call .dsegregwrite
  6368 00002848 668CC0                      mov ax, es
  6369 0000284B E86D000000                  call .dsegregwrite
  6370 00002850 668CD0                      mov ax, ss
  6371 00002853 E865000000                  call .dsegregwrite
  6372 00002858 668CE0                      mov ax, fs
  6373 0000285B E85D000000                  call .dsegregwrite
  6374 00002860 668CE8                      mov ax, gs
  6375 00002863 E855000000                  call .dsegregwrite
  6376                                  
  6377 00002868 55                          push rbp
  6378 00002869 48BD-                       mov rbp, .crlf
  6378 0000286B [D42E000000000000] 
  6379 00002873 48B804130000000000-         mov rax, 1304h
  6379 0000287C 00                 
  6380 0000287D 30FF                        xor bh, bh
  6381 0000287F CD30                        int 30h
  6382 00002881 5D                          pop rbp
  6383                                  .drflagwrite:
  6384 00002882 4831C9                      xor rcx, rcx
  6385                                  .drflg1:    ;Print register name
  6386 00002885 8A840D[1B290000]            mov al, byte [.regtbl+rbp+rcx]
  6387 0000288C B40E                        mov ah, 0Eh
  6388 0000288E CD30                        int 30h
  6389 00002890 48FFC1                      inc rcx
  6390 00002893 4881F907000000              cmp rcx, 7
  6391 0000289A 75E9                        jnz .drflg1
  6392                                  
  6393 0000289C 48FFC1                      inc rcx
  6394 0000289F 488B1425[EC010000]          mov rdx, qword [mcpUserBase]    ;Get flags into rdx
  6395 000028A7 488B12                      mov rdx, qword [rdx]
  6396 000028AA 480FCA                      bswap rdx
  6397                                  .drflg2:
  6398 000028AD B404                        mov ah, 04h
  6399 000028AF 88D0                        mov al, dl
  6400 000028B1 CD30                        int 30h
  6401 000028B3 48C1EA08                    shr rdx, 8
  6402 000028B7 48FFC9                      dec rcx
  6403 000028BA 75F1                        jnz .drflg2
  6404                                  
  6405                                  .dregexit:
  6406 000028BC C3                          ret
  6407                                  .dsegregwrite:
  6408 000028BD 4831C9                      xor rcx, rcx
  6409 000028C0 6689C2                      mov dx, ax    ;save
  6410                                  .dsegreg1:    ;Print register name
  6411 000028C3 8A840D[1B290000]            mov al, byte [.regtbl+rbp+rcx]
  6412                                      ;xor bh, bh
  6413 000028CA B40E                        mov ah, 0Eh
  6414 000028CC CD30                        int 30h
  6415 000028CE 48FFC1                      inc rcx
  6416 000028D1 4881F903000000              cmp rcx, 3
  6417 000028D8 75E9                        jnz .dsegreg1
  6418                                  
  6419 000028DA 88F0                        mov al, dh
  6420 000028DC B404                        mov ah, 04h
  6421 000028DE CD30                        int 30h
  6422 000028E0 88D0                        mov al, dl
  6423 000028E2 B404                        mov ah, 04h
  6424 000028E4 CD30                        int 30h
  6425                                  
  6426 000028E6 4801CD                      add rbp, rcx
  6427 000028E9 B403                        mov ah, 3
  6428 000028EB CD30                        int 30h
  6429 000028ED 80C202                      add dl, 2
  6430 000028F0 B402                        mov ah, 2
  6431 000028F2 CD30                        int 30h
  6432 000028F4 C3                          ret
  6433                                  
  6434                                  .regcrlf:
  6435 000028F5 4831FF                      xor rdi, rdi
  6436 000028F8 55                          push rbp
  6437 000028F9 50                          push rax
  6438 000028FA 53                          push rbx
  6439 000028FB 48BD-                       mov rbp, .crlf
  6439 000028FD [D42E000000000000] 
  6440 00002905 48B804130000000000-         mov rax, 1304h
  6440 0000290E 00                 
  6441 0000290F 30FF                        xor bh, bh
  6442 00002911 CD30                        int 30h
  6443 00002913 5B                          pop rbx
  6444 00002914 58                          pop rax
  6445 00002915 5D                          pop rbp
  6446 00002916 E91FFEFFFF                  jmp .dreg11
  6447                                  
  6448 0000291B 5241583D5242583D52-     .regtbl  db "RAX=", "RBX=", "RCX=", "RDX=", "RSI=", "RDI=", "R8 =",
  6448 00002924 43583D5244583D5253-
  6448 0000292D 493D5244493D523820-
  6448 00002936 3D                 
  6449 00002937 5239203D5231303D52-              db "R9 =", "R10=", "R11=", "R12=", "R13=", "R14=", "R15=",
  6449 00002940 31313D5231323D5231-
  6449 00002949 333D5231343D523135-
  6449 00002952 3D                 
  6450 00002953 5242503D5253503D52-              db "RBP=", "RSP=", "RIP=","CS=", "DS=", "ES=", "SS=", "FS=", 
  6450 0000295C 49503D43533D44533D-
  6450 00002965 45533D53533D46533D 
  6451 0000296E 47533D                           db "GS="
  6452 00002971 52464C4147533D          .rflgs   db "RFLAGS="
  6453 00002978 20205B5249505D3D00      .ipstrg: db "  [RIP]=",0
  6454                                  .dumpMemory:
  6455 00002981 50                          push rax
  6456 00002982 53                          push rbx
  6457 00002983 51                          push rcx
  6458 00002984 52                          push rdx
  6459 00002985 57                          push rdi
  6460 00002986 56                          push rsi
  6461 00002987 55                          push rbp
  6462 00002988 4150                        push r8
  6463 0000298A 4151                        push r9
  6464                                  
  6465 0000298C 66B80413                    mov ax, 1304h
  6466 00002990 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6466 00002992 [D22E000000000000] 
  6467 0000299A CD30                        int 30h
  6468 0000299C 66B80204                    mov ax, 0402h    ;Get 2 dwords
  6469 000029A0 E85D040000                  call .keyb
  6470 000029A5 4885ED                      test rbp, rbp
  6471 000029A8 0F8442010000                jz .dmnoargs
  6472 000029AE B002                        mov al, 2    ;Number of user inputs to convert
  6473 000029B0 E8ED030000                  call .arg
  6474 000029B5 FEC8                        dec al
  6475 000029B7 0F843D010000                jz .dmnoargs1
  6476 000029BD FEC8                        dec al    ;More than 2 args, error
  6477 000029BF 0F850E010000                jnz .dmbadexit
  6478 000029C5 4C8B4508                    mov r8, qword [rbp + 8]    ;First argument, #Base
  6479 000029C9 4C8B4D00                    mov r9, qword [rbp]    ;Second argument, #Number of bytes
  6480                                  .dmmain00:
  6481 000029CD 4D85C9                      test r9, r9
  6482 000029D0 0F84FD000000                jz .dmbadexit
  6483 000029D6 66B80413                    mov ax, 1304h
  6484 000029DA 48BD-                       mov rbp, .crlf
  6484 000029DC [D42E000000000000] 
  6485 000029E4 CD30                        int 30h
  6486 000029E6 4C89C2                      mov rdx, r8
  6487 000029E9 E85C010000                  call .dmcsaddrprint
  6488 000029EE 30FF                        xor bh, bh
  6489 000029F0 B403                        mov ah, 03h
  6490 000029F2 CD30                        int 30h
  6491 000029F4 B219                        mov dl, 25
  6492 000029F6 B402                        mov ah, 02h
  6493 000029F8 CD30                        int 30h
  6494 000029FA 4C89C6                      mov rsi, r8    ;point rsi at r8
  6495 000029FD 48F7C608000000              test rsi, 08h    ;If it starts between a qword and para
  6496                                  
  6497 00002A04 48F7C60F000000              test rsi, 0Fh
  6498 00002A0B 7430                        jz .dmmain0    ;If it starts on paragraph bndry, continue as normal
  6499 00002A0D 56                          push rsi
  6500 00002A0E 4881E60F000000              and rsi, 0Fh
  6501 00002A15 4881FE08000000              cmp rsi, 8
  6502 00002A1C 720F                        jb .dmmain01
  6503 00002A1E 48B901000000000000-         mov rcx, 1
  6503 00002A27 00                 
  6504 00002A28 E8F9000000                  call .dmal1    ;Print one space
  6505                                  .dmmain01:
  6506 00002A2D 5E                          pop rsi
  6507 00002A2E 48B801000000000000-         mov rax, 1
  6507 00002A37 00                 
  6508 00002A38 E8D0000000                  call .dmalign
  6509                                  
  6510                                  .dmmain0:
  6511 00002A3D 4889F7                      mov rdi, rsi    ;Save start point at rdi
  6512 00002A40 4151                        push r9
  6513                                  .dmmain1:    ;This loop prints a line
  6514 00002A42 AC                          lodsb
  6515 00002A43 B404                        mov ah, 4h
  6516 00002A45 CD30                        int 30h
  6517 00002A47 49FFC9                      dec r9
  6518 00002A4A 7416                        jz .dmmain2
  6519 00002A4C 48F7C608000000              test rsi, 08h    ;This is zero iff rsi has bit 4 set
  6520 00002A53 0F85D9000000                jnz .dmhyphen1
  6521 00002A59 48F7C60F000000              test rsi, 0Fh    ;This is zero iff lower nybble is zero
  6522 00002A60 75E0                        jnz .dmmain1
  6523                                  .dmmain2:
  6524                                  ;Now the numbers have been printed, get the ascii row too
  6525                                  ;First check if numbers have stopped short of 16
  6526 00002A62 4D85C9                      test r9, r9
  6527 00002A65 7500                        jnz .dmmain21    ;end of row
  6528                                  
  6529                                  .dmmain21:
  6530 00002A67 4159                        pop r9
  6531 00002A69 30FF                        xor bh, bh
  6532 00002A6B B403                        mov ah, 03h
  6533 00002A6D CD30                        int 30h
  6534 00002A6F B23E                        mov dl, 62
  6535 00002A71 B402                        mov ah, 02h
  6536 00002A73 CD30                        int 30h
  6537 00002A75 4889FE                      mov rsi, rdi    ;Reload value
  6538 00002A78 48F7C60F000000              test rsi, 0Fh
  6539 00002A7F 7408                        jz .dmmain3    ;If it starts on paragraph bndry, continue as normal
  6540 00002A81 4831C0                      xor rax, rax    ;no shift
  6541 00002A84 E884000000                  call .dmalign
  6542                                  
  6543                                  .dmmain3:
  6544 00002A89 AC                          lodsb
  6545 00002A8A 49FFC9                      dec r9
  6546 00002A8D 3C30                        cmp al, 30h
  6547 00002A8F 660F420425-                 cmovb ax, word [.dmdot]    ;bring the dot to ax
  6547 00002A94 [712B0000]         
  6548 00002A98 B40E                        mov ah, 0Eh
  6549 00002A9A CD30                        int 30h
  6550 00002A9C 4D85C9                      test r9, r9
  6551 00002A9F 7443                        jz .dmexit
  6552 00002AA1 48F7C60F000000              test rsi, 0Fh    ;Check if lower nybble is 0
  6553 00002AA8 75DF                        jnz .dmmain3
  6554                                  
  6555 00002AAA 48BD-                       mov rbp, .crlf
  6555 00002AAC [D42E000000000000] 
  6556 00002AB4 66B80413                    mov ax, 1304h
  6557 00002AB8 CD30                        int 30h
  6558                                  
  6559 00002ABA 4889F2                      mov rdx, rsi
  6560 00002ABD E888000000                  call .dmcsaddrprint
  6561                                  
  6562 00002AC2 B403                        mov ah, 03h
  6563 00002AC4 30FF                        xor bh, bh
  6564 00002AC6 CD30                        int 30h
  6565 00002AC8 B219                        mov dl, 25
  6566 00002ACA B402                        mov ah, 02h
  6567 00002ACC CD30                        int 30h
  6568 00002ACE E96AFFFFFF                  jmp .dmmain0
  6569                                  
  6570                                  .dmbadexit:
  6571 00002AD3 48BD-                       mov rbp, .dmbadargs
  6571 00002AD5 [732B000000000000] 
  6572 00002ADD 66B80413                    mov ax, 1304h
  6573 00002AE1 CD30                        int 30h
  6574 00002AE3 C3                          ret;Reload program, error!
  6575                                  .dmexit:
  6576 00002AE4 4159                        pop r9
  6577 00002AE6 4158                        pop r8
  6578 00002AE8 5D                          pop rbp
  6579 00002AE9 5E                          pop rsi
  6580 00002AEA 5F                          pop rdi
  6581 00002AEB 5A                          pop rdx
  6582 00002AEC 59                          pop rcx
  6583 00002AED 5B                          pop rbx
  6584 00002AEE 58                          pop rax
  6585 00002AEF C3                          ret
  6586                                  .dmnoargs:
  6587 00002AF0 4C8B0425[F4010000]          mov r8, qword [mcpUserRip]
  6588                                      ;add r8, 180h    ;Add 180 bytes, to bypass internal work areas
  6589 00002AF8 EB04                        jmp short .dmnoargscommon
  6590                                  .dmnoargs1:
  6591 00002AFA 4C8B4500                    mov r8, qword [rbp]
  6592                                  .dmnoargscommon:
  6593 00002AFE 49B980000000000000-         mov r9, 80h
  6593 00002B07 00                 
  6594 00002B08 E9C0FEFFFF                  jmp .dmmain00
  6595                                  
  6596                                  .dmalign:    ;Print blank chars for offset
  6597                                  ;Works out from rsi
  6598                                  ;rax contains value for shl
  6599 00002B0D 56                          push rsi
  6600 00002B0E 4889F1                      mov rcx, rsi
  6601 00002B11 4881E1F0FFFFFF              and rcx, 0FFFFFFFFFFFFFFF0h    ;Round down
  6602 00002B18 4829CE                      sub rsi, rcx
  6603 00002B1B 4887CE                      xchg rcx, rsi
  6604 00002B1E 5E                          pop rsi
  6605 00002B1F 4891                        xchg rcx, rax
  6606 00002B21 48D3E0                      shl rax, cl
  6607 00002B24 4891                        xchg rcx, rax
  6608                                  .dmal1:
  6609 00002B26 66B8200E                    mov ax, 0E20h
  6610 00002B2A CD30                        int 30h
  6611 00002B2C 48FFC9                      dec rcx
  6612 00002B2F 75F5                        jnz .dmal1
  6613 00002B31 C3                          ret
  6614                                  
  6615                                  .dmhyphen1:
  6616 00002B32 48F7C607000000              test rsi, 07h    ;If the rest of the bits are set, go away
  6617 00002B39 0F8503FFFFFF                jnz .dmmain1
  6618 00002B3F 66B82D0E                    mov ax, 0E2Dh    ;2dh="-"
  6619 00002B43 CD30                        int 30h
  6620 00002B45 E9F8FEFFFF                  jmp .dmmain1
  6621                                  .dmcsaddrprint:
  6622 00002B4A 668CC8                      mov ax, cs    ;Get current code segment into ax
  6623 00002B4D 88E0                        mov al, ah
  6624 00002B4F B404                        mov ah, 04h    ;print upper byte
  6625 00002B51 CD30                        int 30h
  6626 00002B53 668CC8                      mov ax, cs
  6627 00002B56 B404                        mov ah, 04h
  6628 00002B58 CD30                        int 30h        ;print lower byte
  6629 00002B5A 66B83A0E                    mov ax, 0E3Ah
  6630                                  
  6631 00002B5E B108                        mov cl, 8
  6632 00002B60 CD30                        int 30h
  6633                                  
  6634                                  .dmrollprint:
  6635                                  ;Takes whats in rdx, rols left by one byte, prints al
  6636                                  ;repeats, cl times.
  6637 00002B62 48C1C208                    rol rdx, 8
  6638 00002B66 88D0                        mov al, dl
  6639 00002B68 B404                        mov ah, 04h
  6640 00002B6A CD30                        int 30h
  6641 00002B6C FEC9                        dec cl
  6642 00002B6E 75F2                        jnz .dmrollprint
  6643 00002B70 C3                          ret
  6644 00002B71 2E00                    .dmdot:    db    ".",0
  6645 00002B73 0A0D53796E74617820-     .dmbadargs:    db 0Ah, 0Dh,"Syntax error",0
  6645 00002B7C 6572726F7200       
  6646                                  
  6647                                  .editMemory:
  6648 00002B82 66B80413                    mov ax, 1304h
  6649 00002B86 30FF                        xor bh, bh
  6650 00002B88 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6650 00002B8A [D22E000000000000] 
  6651 00002B92 CD30                        int 30h
  6652                                  
  6653 00002B94 66B80104                    mov ax, 0401h    ;Get up to one qword
  6654 00002B98 E865020000                  call .keyb
  6655 00002B9D 4885ED                      test rbp, rbp        ;No chars entered?
  6656 00002BA0 0F8445F6FFFF                jz .bad_command
  6657 00002BA6 E8F7010000                  call .arg
  6658 00002BAB 488B7D00                    mov rdi, qword [rbp]    ;First arg, Dword Address 
  6659                                  
  6660 00002BAF 48BD-                       mov rbp, .crlf
  6660 00002BB1 [D42E000000000000] 
  6661 00002BB9 30FF                        xor bh, bh
  6662 00002BBB 48B804130000000000-         mov rax, 1304h
  6662 00002BC4 00                 
  6663 00002BC5 CD30                        int 30h
  6664                                      
  6665 00002BC7 4889FE                      mov rsi, rdi
  6666 00002BCA AC                          lodsb    ;Get byte into al
  6667 00002BCB B404                        mov ah, 04
  6668 00002BCD CD30                        int 30h
  6669 00002BCF B02E                        mov al, "."
  6670 00002BD1 E8CD020000                  call .print
  6671 00002BD6 66B80101                    mov ax, 0101h    ;Get 1 byte
  6672 00002BDA E823020000                  call .keyb
  6673 00002BDF 4885ED                      test rbp, rbp        ;No chars entered?
  6674 00002BE2 0F84EBFEFFFF                jz .dmbadexit
  6675 00002BE8 E8B5010000                  call .arg
  6676 00002BED 4889EE                      mov rsi, rbp    ;Point rsi to the stack
  6677 00002BF0 A4                          movsb            ;Move byte from rsi to rdi
  6678                                  
  6679 00002BF1 C3                          ret
  6680                                  
  6681                                  .jumpProc:
  6682 00002BF2 66B80413                    mov ax, 1304h
  6683 00002BF6 30FF                        xor bh, bh
  6684 00002BF8 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6684 00002BFA [D22E000000000000] 
  6685 00002C02 CD30                        int 30h
  6686 00002C04 66B80104                    mov ax, 0401h    ;Get 1 dword (forbit going too high eh?)
  6687 00002C08 E8F5010000                  call .keyb
  6688 00002C0D 4885ED                      test rbp, rbp        ;No chars entered?
  6689 00002C10 743B                        jz .proceedDefault
  6690 00002C12 E88B010000                  call .arg
  6691 00002C17 FEC8                        dec al
  6692 00002C19 0F85B4FEFFFF                jnz .dmbadexit
  6693 00002C1F 488B6D00                    mov rbp, qword [rbp]    ;First argument, Address of procedure
  6694 00002C23 48892C25[F4010000]          mov qword [mcpUserRip], rbp   ;Move first argument into new Rip  
  6695 00002C2B E81B010000                  call .loadMainRegisters
  6696 00002C30 488B6008                    mov rsp, qword [rax + 08h]
  6697 00002C34 488B0425[04020000]          mov rax, qword [mcpUserRaxStore]
  6698 00002C3C 48CF                        iretq
  6699                                  .singleStep:
  6700                                  ;When s is pressed, the program proceeds by a single step.
  6701                                  ;Sets trap flag on
  6702 00002C3E 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  6703 00002C46 48810800010000              or qword [rax + 00h], 100h  ;Set trap flag on
  6704                                  .proceedDefault:
  6705 00002C4D E8F9000000                  call .loadMainRegisters
  6706 00002C52 488B6008                    mov rsp, qword [rax + 08h]
  6707 00002C56 488B0425[04020000]          mov rax, qword [mcpUserRaxStore]
  6708 00002C5E 48CF                        iretq
  6709                                  
  6710                                  .storageRead:
  6711 00002C60 50                          push rax
  6712 00002C61 B800820000                  mov eax, 8200h ;LBA Read function
  6713 00002C66 EB06                        jmp short .storageCommon
  6714                                  .storageWrite:
  6715 00002C68 50                          push rax
  6716 00002C69 B800830000                  mov eax, 8300h ;LBA Write function
  6717                                  .storageCommon:
  6718                                  ;l/w [Address Buffer] [Drive] [Sector] [Count]
  6719 00002C6E 53                          push rbx
  6720 00002C6F 51                          push rcx
  6721 00002C70 52                          push rdx
  6722 00002C71 56                          push rsi
  6723 00002C72 57                          push rdi
  6724 00002C73 55                          push rbp
  6725                                  
  6726 00002C74 89C6                        mov esi, eax        ;Save LBA r/w function number in esi
  6727 00002C76 66B80413                    mov ax, 1304h
  6728 00002C7A 48BD-                       mov rbp, .prompt2    ;Give the user the prompt
  6728 00002C7C [D22E000000000000] 
  6729 00002C84 CD30                        int 30h
  6730                                  
  6731 00002C86 66B80404                    mov ax, 0404h    ;Get 4 qwords
  6732 00002C8A E873010000                  call .keyb
  6733 00002C8F 4885ED                      test rbp, rbp
  6734 00002C92 7452                        jz .storageError
  6735 00002C94 B004                        mov al, 4    ;Number of user inputs to convert
  6736 00002C96 E807010000                  call .arg
  6737 00002C9B 3C04                        cmp al, 4   ;If not 4 arguments, fail
  6738 00002C9D 7547                        jne .storageError
  6739 00002C9F BF05000000                  mov edi, 5
  6740                                  .sc0:
  6741 00002CA4 89F0                        mov eax, esi                ;Get back LBA r/w function number into eax
  6742 00002CA6 488B5D18                    mov rbx, qword [rbp + 24]   ;First argument, Address buffer
  6743 00002CAA 488B5510                    mov rdx, qword [rbp + 16]   ;dl ONLY, Second argument
  6744 00002CAE 4881E2FF000000              and rdx, 0FFh
  6745 00002CB5 488B4D08                    mov rcx, qword [rbp + 08]   ;LBA starting sector, third argument
  6746 00002CB9 488B7500                    mov rsi, qword [rbp]        ;Sector count into rsi
  6747 00002CBD 4881E6FF000000              and rsi, 0FFh               ;Sector count can be at most 255
  6748 00002CC4 09F0                        or eax, esi                 ;Add the sector count to eax
  6749 00002CC6 89C6                        mov esi, eax                ;Copy the function number into esi for failures
  6750 00002CC8 81E600FF0000                and esi, 0FF00h             ;Save only byte two of esi, the function number
  6751 00002CCE CD33                        int 33h
  6752 00002CD0 7308                        jnc .storageExit
  6753                                  
  6754 00002CD2 31C0                        xor eax, eax
  6755 00002CD4 CD33                        int 33h
  6756 00002CD6 FFCF                        dec edi
  6757 00002CD8 75CA                        jnz .sc0
  6758                                  .storageExit:
  6759 00002CDA 5D                          pop rbp
  6760 00002CDB 5F                          pop rdi
  6761 00002CDC 5E                          pop rsi
  6762 00002CDD 5A                          pop rdx
  6763 00002CDE 59                          pop rcx
  6764 00002CDF 5B                          pop rbx
  6765 00002CE0 58                          pop rax   
  6766 00002CE1 E912F4FFFF                  jmp MCP_int.z11
  6767                                  .storageError: 
  6768 00002CE6 5D                          pop rbp
  6769 00002CE7 5F                          pop rdi
  6770 00002CE8 5E                          pop rsi
  6771 00002CE9 5A                          pop rdx
  6772 00002CEA 59                          pop rcx
  6773 00002CEB 5B                          pop rbx
  6774 00002CEC 58                          pop rax
  6775 00002CED E9F9F4FFFF                  jmp .bad_command
  6776                                  .restartMcp:
  6777 00002CF2 CD40                        int 40h     ;To allow returning to DOS
  6778                                  .clearscreen:
  6779 00002CF4 B307                        mov bl, 07h
  6780 00002CF6 E8FCD3FFFF                  call cls
  6781 00002CFB E9F8F3FFFF                  jmp MCP_int.z11
  6782                                  .storeMainRegisters:
  6783 00002D00 9C                          pushfq
  6784 00002D01 8F00                        pop qword [rax + 00h]      ;Flags
  6785                                      ;mov qword [rax + 08h], rsp
  6786 00002D03 48896810                    mov qword [rax + 10h], rbp
  6787 00002D07 4C897818                    mov qword [rax + 18h], r15
  6788 00002D0B 4C897020                    mov qword [rax + 20h], r14
  6789 00002D0F 4C896828                    mov qword [rax + 28h], r13
  6790 00002D13 4C896030                    mov qword [rax + 30h], r12
  6791 00002D17 4C895838                    mov qword [rax + 38h], r11
  6792 00002D1B 4C895040                    mov qword [rax + 40h], r10
  6793 00002D1F 4C894848                    mov qword [rax + 48h], r9
  6794 00002D23 4C894050                    mov qword [rax + 50h], r8
  6795 00002D27 48897858                    mov qword [rax + 58h], rdi
  6796 00002D2B 48897060                    mov qword [rax + 60h], rsi
  6797 00002D2F 48895068                    mov qword [rax + 68h], rdx
  6798 00002D33 48894870                    mov qword [rax + 70h], rcx
  6799 00002D37 48895878                    mov qword [rax + 78h], rbx
  6800 00002D3B 488B1C25[04020000]          mov rbx, qword [mcpUserRaxStore]
  6801 00002D43 48899880000000              mov qword [rax + 80h], rbx  ;Store rax
  6802 00002D4A C3                          ret
  6803                                  .loadMainRegisters:
  6804 00002D4B 488B0425[EC010000]          mov rax, qword [mcpUserBase]
  6805 00002D53 488B5008                    mov rdx, qword [rax + 08h]  ;Get old stack pointer into rdx
  6806 00002D57 488B1C25[F4010000]          mov rbx, qword [mcpUserRip]
  6807 00002D5F 48891A                      mov qword [rdx], rbx    ;Move the userRip into rdx
  6808 00002D62 488B18                      mov rbx, qword [rax + 00h]
  6809 00002D65 48895A10                    mov qword [rdx + 10h], rbx  ;Move new flags into position on stack
  6810 00002D69 488B5878                    mov rbx, qword [rax + 78h]
  6811 00002D6D 488B4870                    mov rcx, qword [rax + 70h]
  6812 00002D71 488B5068                    mov rdx, qword [rax + 68h]
  6813 00002D75 488B7060                    mov rsi, qword [rax + 60h]
  6814 00002D79 488B7858                    mov rdi, qword [rax + 58h]
  6815 00002D7D 4C8B4050                    mov r8,  qword [rax + 50h]
  6816 00002D81 4C8B4848                    mov r9,  qword [rax + 48h]
  6817 00002D85 4C8B5040                    mov r10, qword [rax + 40h]
  6818 00002D89 4C8B5838                    mov r11, qword [rax + 38h]
  6819 00002D8D 4C8B6030                    mov r12, qword [rax + 30h]
  6820 00002D91 4C8B6828                    mov r13, qword [rax + 28h]
  6821 00002D95 4C8B7020                    mov r14, qword [rax + 20h]
  6822 00002D99 4C8B7818                    mov r15, qword [rax + 18h]
  6823 00002D9D 488B6810                    mov rbp, qword [rax + 10h]
  6824 00002DA1 C3                          ret
  6825                                  ;ARG    PROC    NEAR
  6826                                  .arg:
  6827                                  ;Number of arguments expected in buffer in al (could early terminate due to 
  6828                                  ; enter)
  6829                                  ;Converted qwords stored on stack with al indicating how many processed
  6830                                  ;rbp returns the base of the stack of stored arguments
  6831                                  ;rdx is our scratch register
  6832 00002DA2 53                          push rbx
  6833 00002DA3 51                          push rcx
  6834 00002DA4 52                          push rdx
  6835 00002DA5 56                          push rsi
  6836 00002DA6 4889E5                      mov rbp, rsp    ;Preserve stack pointer
  6837 00002DA9 488B3425[FC010000]          mov rsi, qword [mcpUserkeybf]
  6838 00002DB1 30C9                        xor cl, cl        ;Keep track of how many arguments processed
  6839                                  .a01:
  6840 00002DB3 4831D2                      xor rdx, rdx    ;Clean rdx
  6841                                  .a1:
  6842 00002DB6 AC                          lodsb        ;Get the first byte into al
  6843 00002DB7 3C11                        cmp al, 11h    ;Offset 11h is the space key
  6844 00002DB9 740E                        jz .a2
  6845 00002DBB 3C12                        cmp al, 12h    ;Offset 12h is the enter key
  6846 00002DBD 740F                        jz .aexit        ;Anyway, enter is exit!
  6847 00002DBF 48C1E204                    shl rdx, 4    ;Go to next sig fig
  6848 00002DC3 08C2                        or dl, al    ;Put this byte into dl
  6849 00002DC5 7013                        jo .error
  6850 00002DC7 EBED                        jmp short .a1
  6851                                  .a2:
  6852 00002DC9 52                          push rdx    ;Store argument on stack
  6853 00002DCA FEC1                        inc cl        ;One more argument processed
  6854 00002DCC EBE5                        jmp short .a01
  6855                                  .aexit:
  6856 00002DCE 480FB6C1                    movzx rax, cl    ;Return #of args processed
  6857 00002DD2 4887E5                      xchg rsp, rbp    ;rbp points to bottom of argument stack 
  6858 00002DD5 5E                          pop rsi
  6859 00002DD6 5A                          pop rdx
  6860 00002DD7 59                          pop rcx
  6861 00002DD8 5B                          pop rbx
  6862 00002DD9 C3                          ret
  6863                                  .error:
  6864 00002DDA 48BD-                       mov rbp, .emsg
  6864 00002DDC [F12D000000000000] 
  6865 00002DE4 30FF                        xor bh, bh
  6866 00002DE6 66B80413                    mov ax, 1304h
  6867 00002DEA CD30                        int 30h
  6868 00002DEC 5E                          pop rsi
  6869 00002DED 5A                          pop rdx
  6870 00002DEE 59                          pop rcx
  6871 00002DEF 5B                          pop rbx
  6872 00002DF0 C3                          ret
  6873 00002DF1 0A0D417267756D656E-     .emsg:    db 0Ah, 0Dh,"Argument error",0
  6873 00002DFA 74206572726F7200   
  6874                                  ;ARG    ENDP
  6875                                  
  6876                                  ;KEYB     PROC     NEAR
  6877                                  .keyb:
  6878                                  ;Number of arguments to accept is passed in al, in units of ah
  6879                                  ;ah=4 => Qwords, ah=3 => dwords... ah=2 => word, ah=1 => bytes
  6880                                  ;Arguments are stored in buffer, after USB area, of size 2*al qwords
  6881                                  ;All arguments CAN be up to qword in size, though not all subprogs,
  6882                                  ;    may use the full qword.
  6883                                  ;ch returns number of chars not processed
  6884 00002E02 50                          push rax
  6885 00002E03 53                          push rbx
  6886                                      ;push rcx
  6887 00002E04 57                          push rdi
  6888 00002E05 52                          push rdx
  6889                                  
  6890 00002E06 4831C9                      xor rcx, rcx
  6891 00002E09 88C1                        mov cl, al
  6892 00002E0B 51                          push rcx
  6893 00002E0C 88E1                        mov cl, ah
  6894 00002E0E D2E0                        shl al, cl  ;Multiply by 16 to get the number of bytes needed w/o spaces
  6895 00002E10 59                          pop rcx
  6896 00002E11 00C8                        add al, cl  ;Add space for spaces
  6897 00002E13 FEC8                        dec al      ;We reserve one space for a "non-user accessible" EOL at the end
  6898                                  
  6899 00002E15 488B3C25[FC010000]          mov rdi, qword [mcpUserkeybf]    ;Data area in command tail
  6900 00002E1D 50                          push rax
  6901 00002E1E 48B810000000000000-         mov rax, 10h
  6901 00002E27 00                 
  6902 00002E28 57                          push rdi
  6903 00002E29 F348AB                      rep stosq    ;Clear buffer space for al qwords (max 8)
  6904 00002E2C 5F                          pop rdi
  6905 00002E2D 58                          pop rax
  6906                                  
  6907 00002E2E 88C5                        mov ch, al    ;Rememebr 1 Qword is 16 ASCII chars
  6908 00002E30 88C2                        mov dl, al    ;Let dl save this number
  6909 00002E32 4831ED                      xor rbp, rbp    ;Cheap cop out char counter
  6910                                  
  6911                                  .k1:
  6912 00002E35 6631C0                      xor ax, ax
  6913 00002E38 CD36                        int 36h
  6914 00002E3A 3C71                        cmp al, "q"    ;Quit option
  6915 00002E3C 0F84B6F2FFFF                je .z11
  6916 00002E42 3C08                        cmp al, 08h    ;Backspace
  6917 00002E44 7447                        je .kb2
  6918 00002E46 3C0D                        cmp al, 0Dh    ;Enter key pressed, we done
  6919 00002E48 7438                        je .kend
  6920                                  
  6921 00002E4A 84ED                        test ch, ch    ;Have we filled a 16 char buffer?
  6922 00002E4C 74E7                        jz .k1        ;Yes, await control key
  6923                                  
  6924 00002E4E 4889FB                      mov rbx, rdi    ;Save current offset into bbuffer
  6925 00002E51 51                          push rcx
  6926 00002E52 48BF-                       mov rdi, .ascii
  6926 00002E54 [A82E000000000000] 
  6927 00002E5C 48B913000000000000-         mov rcx, .asciil
  6927 00002E65 00                 
  6928 00002E66 F2AE                        repne scasb        ;Find the offset of the char in al in the table
  6929 00002E68 59                          pop rcx            ;Doesnt affect flags
  6930 00002E69 4887FB                      xchg rdi, rbx    ;Return value back to rdi 
  6931 00002E6C 75C7                        jne .k1            ;Not a key from our buffer, loop again
  6932 00002E6E 48FFC5                      inc rbp
  6933 00002E71 E82D000000                  call .print        ;Print typed char
  6934                                  
  6935 00002E76 488D83(57D1FFFF)            lea rax, qword [rbx - .ascii -1]    ;Work out difference
  6936                                  
  6937 00002E7D AA                          stosb            ;Store the value in storage buffer, inc rdi
  6938 00002E7E FECD                        dec ch            ;Decrement the number of typable chars
  6939 00002E80 EBB3                        jmp short .k1    ;Get next char
  6940                                  .kend:
  6941 00002E82 66B81112                    mov ax, 1211h    ;Store a space and EOF at the end (little endian!)
  6942 00002E86 66AB                        stosw
  6943                                  
  6944 00002E88 5A                          pop rdx
  6945 00002E89 5F                          pop rdi
  6946                                      ;pop rcx    ;Return in cl the number of processed chars
  6947 00002E8A 5B                          pop rbx
  6948 00002E8B 58                          pop rax
  6949                                  .kb1:        
  6950 00002E8C C3                          ret
  6951                                  .kb2:
  6952                                  ;When a backspace is entered, DONT MOVE THIS PROC!
  6953 00002E8D 68[352E0000]                push .k1
  6954 00002E92 38D5                        cmp ch, dl    ;If bbuf is empty, ignore backspace 
  6955 00002E94 74F6                        jz .kb1
  6956 00002E96 48FFCF                      dec rdi        ;Decrement pointer and print the bspace char
  6957 00002E99 FEC5                        inc ch        ;Increment the number of typable chars
  6958 00002E9B 4885ED                      test rbp, rbp
  6959 00002E9E 7403                        jz .print    ;Dont decrement if rbp is zero
  6960 00002EA0 48FFCD                      dec rbp
  6961                                  ;KEYB    ENDP
  6962                                  .print:    ;Print char in al
  6963 00002EA3 B40E                        mov ah, 0Eh
  6964                                      ;xor bh, bh
  6965 00002EA5 CD30                        int 30h
  6966 00002EA7 C3                          ret
  6967 00002EA8 303132333435363738-     .ascii       db    "0123456789abcdef", 08h, 20h, 0Dh ;b/space, enter
  6967 00002EB1 396162636465660820-
  6967 00002EBA 0D                 
  6968                                  .asciil       equ    $ - .ascii
  6969 00002EBB 64657367706C777163-     .lst       db    'desgplwqcrbhiovamkx';dump,edit,go,single step,read,write,quit,
  6969 00002EC4 726268696F76616D6B-
  6969 00002ECD 78                 
  6970                                  ;clearscreen,registers,deBug regs,hex,in,out,version,Single Step alt, memory map
  6971                                  ; (k)connect, dixonnect
  6972                                  .lstl    equ    $ - .lst
  6973 00002ECE 0A0D2D00                .prompt       db    0Ah, 0Dh, "-", 0    ;3Eh = >
  6974 00002ED2 2000                    .prompt2    db 20h,0
  6975 00002ED4 0A0D00                  .crlf       db    0Ah, 0Dh, 0
  6976                                  ;------------------------End of Interrupt------------------------
  6977                                  ;-------------------Restart Interrupt Int 39h--------------------
  6978                                  ;This interrupt allows the user to soft reboot
  6979                                  ;----------------------------------------------------------------
  6980                                  bootstrapInt:
  6981                                  ;Bootstrap loader, loads sector 88 of device 0 to 7C00h and jumps to it
  6982                                  ;If not found, will restart the machine, failing that, iretq with CF set
  6983 00002ED7 50                          push rax
  6984 00002ED8 53                          push rbx
  6985 00002ED9 51                          push rcx
  6986 00002EDA 52                          push rdx
  6987 00002EDB 56                          push rsi
  6988                                  
  6989 00002EDC B9000100C0                  mov ecx, 0C0000100h    ;Select fs register to load base addr
  6990 00002EE1 488B0425[CD010000]          mov rax, qword [userBase]    ;Load address to fs
  6991 00002EE9 31D2                        xor edx, edx        ;Zero upper bytes
  6992 00002EEB 0F30                        wrmsr                ;Write msr to load fs base
  6993                                  
  6994 00002EED BE0A000000                  mov esi, 10
  6995                                  ;Now load one sector of second prog from first device 
  6996                                  .e0:
  6997 00002EF2 6631D2                      xor dx, dx  ;This also clears carry flag so no checking ah
  6998 00002EF5 48BB007C0000000000-         mov rbx, 7c00h
  6998 00002EFE 00                 
  6999 00002EFF 488B0C25[BF010000]          mov rcx, qword [nextFilePtr]
  7000 00002F07 668B0425[C7010000]          mov ax, word [numSectors]
  7001 00002F0F B482                        mov ah, 82h ;LBA Sector Read 
  7002 00002F11 CD33                        int 33h     ;Read one sector
  7003 00002F13 730C                        jnc .e1
  7004                                  
  7005 00002F15 FFCE                        dec esi
  7006 00002F17 742F                        jz .efail
  7007                                  
  7008 00002F19 30D2                        xor dl, dl
  7009 00002F1B 30E4                        xor ah, ah  ;Reset the device
  7010 00002F1D CD33                        int 33h
  7011 00002F1F EBD1                        jmp short .e0
  7012                                  .e1:
  7013 00002F21 31D2                        xor edx, edx  ;Device number 0!
  7014 00002F23 66813C25007C000055-         cmp word [7c00h], 0AA55h ;The Boot signature
  7014 00002F2C AA                 
  7015 00002F2D 7519                        jne .efail
  7016                                  ;State when system transferred:
  7017                                  ; RSP = DFF8h, 1FFh qword stack from DFFFh to 7C00H + 42*200h sectors = D000h
  7018                                  ; FS MSR = userbase pointer, can be used for segment override.
  7019                                  ; DX = Int 33h boot device number
  7020                                  ; RBX = LBA of first Logical Block after SCP/BIOS
  7021                                  ; BDA and BIOS ready to go
  7022 00002F2F 48BCF8DF0000000000-         mov rsp, 0DFF8h ;Move Stack pointer to default init stack position
  7022 00002F38 00                 
  7023 00002F39 31D2                        xor edx, edx    ;Device boot number
  7024 00002F3B 488B1C25[BF010000]          mov rbx, qword [nextFilePtr]     ;First sector on device after SCP/BIOS
  7025 00002F43 E9(027C0000)                jmp 7C02h       ;New sector entry point
  7026                                  .efail:
  7027 00002F48 5E                          pop rsi
  7028 00002F49 5A                          pop rdx
  7029 00002F4A 59                          pop rcx
  7030 00002F4B 5B                          pop rbx
  7031 00002F4C 58                          pop rax
  7032 00002F4D 804C241001                  or byte [rsp + 2*8h], 1 ;Set carry flag
  7033 00002F52 48CF                        iretq
  7034                                  ;------------------------End of Interrupt------------------------
  7035                                  ;-----------------System Timer Interrupt Int 3Ah-----------------
  7036                                  ;System Timer functions:
  7037                                  ; ah=0 -> Get tick count
  7038                                  ; ah=1 -> Set tick count
  7039                                  ; ah=2 -> Read RTC time
  7040                                  ; ah=3 -> Set RTC time
  7041                                  ; ah=4 -> Read RTC date
  7042                                  ; ah=5 -> Set RTC date
  7043                                  ; ah=6 -> Set RTC alarm
  7044                                  ; ah=7 -> Reset RTC alarm
  7045                                  ; ah=80h -> Get PIT divisor
  7046                                  ; ah=81h -> Set PIT divisor
  7047                                  ;----------------------------------------------------------------
  7048                                  timerInt:
  7049 00002F54 80FC80                      cmp ah, 80h
  7050 00002F57 737B                        jae .tiext
  7051 00002F59 84E4                        test ah, ah
  7052 00002F5B 7444                        jz .gett
  7053 00002F5D 80FC01                      cmp ah, 1
  7054 00002F60 745E                        jz .sett
  7055 00002F62 80FC02                      cmp ah, 2
  7056 00002F65 0F8497000000                jz .readRTCtime
  7057 00002F6B 80FC03                      cmp ah, 3
  7058 00002F6E 0F84D8000000                jz .setRTCtime
  7059 00002F74 80FC04                      cmp ah, 4
  7060 00002F77 0F8431010000                jz .readRTCdate
  7061 00002F7D 80FC05                      cmp ah, 5
  7062 00002F80 0F845C010000                jz .setRTCdate
  7063 00002F86 80FC06                      cmp ah, 6
  7064 00002F89 0F84B4010000                jz .setRTCalarm
  7065 00002F8F 80FC07                      cmp ah, 7
  7066 00002F92 0F84F6010000                jz .resetRTCalarm
  7067                                  .bad:
  7068 00002F98 804C241001                  or byte [rsp + 2*8h], 1    ;Set Carry flag on for invalid function
  7069 00002F9D B480                        mov ah, 80h
  7070                                  .exit:
  7071 00002F9F 48CF                        iretq
  7072                                  .gett:
  7073                                  ;Returns:
  7074                                  ; al=Rolled over flag (0=not rolled)
  7075                                  ; cx=Hi count
  7076                                  ; dx=Lo count
  7077 00002FA1 8B0425[37010000]            mov eax, dword [pit_ticks]
  7078 00002FA8 6689C2                      mov dx, ax    ;Lo count
  7079 00002FAB C1E810                      shr eax, 10h    ;Bring high word down
  7080 00002FAE 30ED                        xor ch, ch
  7081 00002FB0 88C1                        mov cl, al
  7082 00002FB2 88E0                        mov al, ah
  7083 00002FB4 0FB6C0                      movzx eax, al    ;Zero upper bytes
  7084 00002FB7 882425[3A010000]            mov byte [pit_ticks + 3], ah    ;Move 0 into day OF counter
  7085 00002FBE 48CF                        iretq
  7086                                  .sett:
  7087                                  ;Called with:
  7088                                  ; cx=Hi count (bzw. cl)
  7089                                  ; dx=Lo count
  7090                                  ;Returns: Nothing
  7091 00002FC0 66891425[37010000]          mov word [pit_ticks], dx
  7092 00002FC8 30ED                        xor ch, ch    ;Reset the OF counter
  7093 00002FCA 66890C25[39010000]          mov word [pit_ticks + 2], cx
  7094 00002FD2 48CF                        iretq
  7095                                  
  7096                                  .tiext:    ;Extended Timer functions
  7097 00002FD4 80EC80                      sub ah, 80h
  7098 00002FD7 7406                        jz .getpitdiv
  7099 00002FD9 FECC                        dec ah
  7100 00002FDB 740C                        jz .setpitdiv
  7101 00002FDD EBB9                        jmp short .bad
  7102                                  .getpitdiv:
  7103                                  ;Returns:
  7104                                  ; ax=PIT divisor
  7105 00002FDF 668B0425[35010000]          mov ax, word [pit_divisor]
  7106 00002FE7 48CF                        iretq
  7107                                  .setpitdiv:
  7108                                  ;Called with:
  7109                                  ; dx=divsor
  7110                                  ;Returns: Nothing
  7111 00002FE9 66891425[35010000]          mov word [pit_divisor], dx
  7112 00002FF1 50                          push rax
  7113 00002FF2 B036                        mov al, 36h ;Bitmap for frequency write to channel 0 of PIT
  7114 00002FF4 E643                        out PITcommand, al
  7115 00002FF6 6689D0                      mov ax, dx
  7116 00002FF9 E640                        out PIT0, al    ;Send low byte of new divisor
  7117 00002FFB 88E0                        mov al, ah
  7118 00002FFD E640                        out PIT0, al    ;Send high byte of new divisor
  7119 00002FFF 58                          pop rax
  7120 00003000 48CF                        iretq
  7121                                  
  7122                                  .readRTCtime:
  7123                                  ; dh = Seconds
  7124                                  ; cl = Minutes
  7125                                  ; ch = Hours
  7126                                  ; dl = Daylight Savings   
  7127 00003002 50                          push rax
  7128 00003003 51                          push rcx
  7129 00003004 31C9                        xor ecx, ecx    ;Long counter
  7130                                  .rrt0:
  7131 00003006 FFC9                        dec ecx
  7132 00003008 743C                        jz .rrtbad
  7133 0000300A B08A                        mov al, 8Ah ;Disable NMI and and read bit 7. When 0, read
  7134 0000300C E89A010000                  call .readRTC
  7135 00003011 A880                        test al, 80h    ;Check bit 7 is zero
  7136 00003013 75F1                        jnz .rrt0   ;If zero, fall and read RTC registers
  7137                                  
  7138 00003015 59                          pop rcx         ;Pop upper word of ecx back
  7139 00003016 B080                        mov al, 80h     ;Get seconds
  7140 00003018 E88E010000                  call .readRTC
  7141 0000301D 88C6                        mov dh, al      ;Pack seconds in dh
  7142 0000301F B082                        mov al, 82h     ;Get minutes
  7143 00003021 E885010000                  call .readRTC
  7144 00003026 88C1                        mov cl, al      ;Pack minutes in cl
  7145 00003028 B084                        mov al, 84h     ;Get Hours
  7146 0000302A E87C010000                  call .readRTC
  7147 0000302F 88C5                        mov ch, al      ;Pack Hours in ch
  7148 00003031 B08B                        mov al, 8Bh     ;Get Status B for Daylight Savings
  7149 00003033 E873010000                  call .readRTC
  7150 00003038 2401                        and al, 1       ;Isolate bit 0
  7151 0000303A 88C2                        mov dl, al      ;Pack Daylight Savings bit in dl
  7152 0000303C B00D                        mov al, 0Dh     ;Enable NMI
  7153 0000303E E868010000                  call .readRTC
  7154 00003043 58                          pop rax
  7155 00003044 48CF                        iretq
  7156                                  .rrtbad:
  7157 00003046 59                          pop rcx
  7158 00003047 58                          pop rax
  7159 00003048 F9                          stc
  7160 00003049 C20800                      ret 8   ;Set carry and return
  7161                                  
  7162                                  .setRTCtime:
  7163                                  ; dh = Seconds
  7164                                  ; cl = Minutes
  7165                                  ; ch = Hours
  7166                                  ; dl = Daylight Savings 
  7167 0000304C 50                          push rax
  7168 0000304D 51                          push rcx
  7169 0000304E 31C9                        xor ecx, ecx
  7170                                  .srt0:
  7171 00003050 FFC9                        dec ecx
  7172 00003052 74F2                        jz .rrtbad
  7173 00003054 B08A                        mov al, 8Ah ;Disable NMI and and read bit 7. When 0, write
  7174 00003056 E850010000                  call .readRTC
  7175 0000305B A880                        test al, 80h    ;Check bit 7 is zero
  7176 0000305D 75F1                        jnz .srt0   ;If zero, fall and write RTC registers
  7177                                  
  7178 0000305F 59                          pop rcx
  7179 00003060 B08B                        mov al, 8Bh
  7180 00003062 E844010000                  call .readRTC
  7181 00003067 80E201                      and dl, 1   ;Ensure we only have the low bit of dl
  7182 0000306A 08D0                        or al, dl   ;Set the daylight savings bit of Status B
  7183 0000306C 0C80                        or al, 80h  ;Stop RTC updates
  7184 0000306E 88C4                        mov ah, al
  7185 00003070 B08B                        mov al, 8Bh ;Reset Status B Register, and daylight savings
  7186 00003072 E83D010000                  call .writeRTC
  7187                                  
  7188 00003077 88F4                        mov ah, dh  ;Pack seconds
  7189 00003079 B080                        mov al, 80h
  7190 0000307B E834010000                  call .writeRTC
  7191 00003080 88CC                        mov ah, cl  ;Pack minutes
  7192 00003082 B082                        mov al, 82h
  7193 00003084 E82B010000                  call .writeRTC
  7194 00003089 88EC                        mov ah, ch  ;Pack hours
  7195 0000308B B084                        mov al, 84h
  7196 0000308D E822010000                  call .writeRTC
  7197                                  
  7198 00003092 B08B                        mov al, 8Bh
  7199 00003094 E812010000                  call .readRTC
  7200 00003099 247F                        and al, 7Fh ;Clear the top bit
  7201 0000309B 88C4                        mov ah, al  ;Pack byte to send in ah
  7202 0000309D B08B                        mov al, 8Bh
  7203 0000309F E810010000                  call .writeRTC  ;Restart RTC
  7204                                  
  7205 000030A4 B00D                        mov al, 0Dh   ;Enable NMI
  7206 000030A6 E800010000                  call .readRTC
  7207                                  
  7208 000030AB 58                          pop rax
  7209 000030AC 48CF                        iretq
  7210                                      
  7211                                  .readRTCdate:
  7212                                  ; ch = Reserved, Century (19/20/21...), fixed 20h for now
  7213                                  ; cl = Year
  7214                                  ; dh = Month
  7215                                  ; dl = Day
  7216 000030AE 50                          push rax
  7217 000030AF 51                          push rcx
  7218 000030B0 31C9                        xor ecx, ecx
  7219                                  .rrd0:
  7220 000030B2 FFC9                        dec ecx
  7221 000030B4 7490                        jz .rrtbad
  7222 000030B6 B08A                        mov al, 8Ah     ;Disable NMI and and read bit 7. When 0, write
  7223 000030B8 E8EE000000                  call .readRTC
  7224 000030BD A880                        test al, 80h    ;Check bit 7 is zero
  7225 000030BF 75F1                        jnz .rrd0       ;If zero, fall and read RTC registers
  7226                                  
  7227 000030C1 59                          pop rcx
  7228 000030C2 B087                        mov al, 87h     ;Get Day of the Month
  7229 000030C4 E8E2000000                  call .readRTC
  7230 000030C9 88C2                        mov dl, al      ;Pack Day of the Month
  7231 000030CB B088                        mov al, 88h     ;Get Month of the Year
  7232 000030CD E8D9000000                  call .readRTC
  7233 000030D2 88C6                        mov dh, al      ;Pack Month of the Year
  7234 000030D4 B089                        mov al, 89h     ;Get bottom two digits of year
  7235 000030D6 E8D0000000                  call .readRTC
  7236 000030DB 88C1                        mov cl, al      ;Pack Year
  7237 000030DD B514                        mov ch, 20      ;BCD value for 20
  7238                                  
  7239 000030DF 58                          pop rax
  7240 000030E0 48CF                        iretq
  7241                                  
  7242                                  .setRTCdate:
  7243                                  ; ch = Reserved, Century (19/20/21...), fixed 20h for now
  7244                                  ; cl = Year
  7245                                  ; dh = Month
  7246                                  ; dl = Day
  7247 000030E2 50                          push rax
  7248 000030E3 51                          push rcx
  7249 000030E4 31C9                        xor ecx, ecx
  7250                                  .srd0:
  7251 000030E6 FFC9                        dec ecx
  7252 000030E8 0F8458FFFFFF                jz .rrtbad
  7253 000030EE B08A                        mov al, 8Ah     ;Disable NMI and and read bit 7. When 0, write
  7254 000030F0 E8B6000000                  call .readRTC
  7255 000030F5 A880                        test al, 80h    ;Check bit 7 is zero
  7256 000030F7 75ED                        jnz .srd0       ;If zero, fall and write RTC registers
  7257                                  
  7258 000030F9 59                          pop rcx
  7259 000030FA B08B                        mov al, 8Bh
  7260 000030FC E8AA000000                  call .readRTC
  7261 00003101 0C80                        or al, 80h      ;Stop RTC updates
  7262 00003103 88C4                        mov ah, al
  7263 00003105 B08B                        mov al, 8Bh
  7264 00003107 E8A8000000                  call .writeRTC
  7265 0000310C 88D4                        mov ah, dl      ;Pack Day of the Month
  7266 0000310E B087                        mov al, 87h
  7267 00003110 E89F000000                  call .writeRTC
  7268 00003115 88F4                        mov ah, dh      ;Pack Month of the Year
  7269 00003117 B088                        mov al, 88h
  7270 00003119 E896000000                  call .writeRTC
  7271 0000311E 88CC                        mov ah, cl      ;Pack Year
  7272 00003120 B089                        mov al, 89h
  7273 00003122 E88D000000                  call .writeRTC
  7274                                  
  7275 00003127 B08B                        mov al, 8Bh
  7276 00003129 E87D000000                  call .readRTC
  7277 0000312E 247F                        and al, 7Fh ;Clear the top bit
  7278 00003130 88C4                        mov ah, al  ;Pack byte to send in ah
  7279 00003132 B08B                        mov al, 8Bh
  7280 00003134 E87B000000                  call .writeRTC  ;Restart RTC
  7281                                  
  7282 00003139 B00D                        mov al, 0Dh   ;Enable NMI
  7283 0000313B E86B000000                  call .readRTC
  7284                                  
  7285 00003140 58                          pop rax
  7286 00003141 48CF                        iretq
  7287                                  
  7288                                  .setRTCalarm:
  7289                                  ; dh = Seconds for alarm
  7290                                  ; cl = Minutes for alarm
  7291                                  ; ch = Hours for alarm
  7292 00003143 50                          push rax
  7293 00003144 B08B                        mov al, 8BH ;Get status B
  7294 00003146 E860000000                  call .readRTC
  7295 0000314B A820                        test al, 20h
  7296 0000314D 7537                        jnz .srabad ;If The alarm bit is already set, exit CF=CY
  7297                                  
  7298 0000314F 88F4                        mov ah, dh      ;Pack Seconds for alarm
  7299 00003151 B081                        mov al, 81h     
  7300 00003153 E85C000000                  call .writeRTC
  7301 00003158 88CC                        mov ah, cl      ;Pack Minutes for alarm
  7302 0000315A B083                        mov al, 83h
  7303 0000315C E853000000                  call .writeRTC
  7304 00003161 88EC                        mov ah, ch      ;Pack Hours for alarm
  7305 00003163 B085                        mov al, 85h
  7306 00003165 E84A000000                  call .writeRTC
  7307                                  
  7308 0000316A B08B                        mov al, 8Bh     ;Get Status B
  7309 0000316C E83A000000                  call .readRTC
  7310 00003171 0C20                        or al, 20h      ;Set Bit 5 - Alarm Interrupt Enable
  7311 00003173 88C4                        mov ah, al      ;Pack new Status B
  7312 00003175 B08B                        mov al, 8Bh
  7313 00003177 E838000000                  call .writeRTC 
  7314                                  
  7315 0000317C B00D                        mov al, 0Dh     ;Enable NMI
  7316 0000317E E828000000                  call .readRTC
  7317                                  
  7318 00003183 58                          pop rax
  7319 00003184 48CF                        iretq
  7320                                  .srabad:
  7321 00003186 58                          pop rax
  7322 00003187 804C241001                  or byte [rsp + 2*8], 1 ;Set Carry Flag
  7323 0000318C 48CF                        iretq  
  7324                                  .resetRTCalarm:
  7325 0000318E 50                          push rax
  7326 0000318F B08B                        mov al, 8Bh     ;Get Status B
  7327 00003191 E815000000                  call .readRTC
  7328 00003196 24DF                        and al, 0DFh    ;Clear Alarm Interrupt Enable
  7329 00003198 88C4                        mov ah, al
  7330 0000319A B08B                        mov al, 8Bh
  7331 0000319C E813000000                  call .writeRTC
  7332                                  
  7333 000031A1 B00D                        mov al, 0Dh     ;Enable NMI
  7334 000031A3 E803000000                  call .readRTC 
  7335 000031A8 58                          pop rax
  7336 000031A9 48CF                        iretq
  7337                                  
  7338                                  .readRTC:
  7339                                  ;Reads an RTC port, interrupts disabled throughout
  7340                                  ;Input: al = I/O port to read
  7341                                  ;Output: al = I/O data
  7342 000031AB FA                          cli
  7343 000031AC E670                        out cmos_base, al
  7344 000031AE E680                        out waitp, al
  7345 000031B0 E471                        in al, cmos_data
  7346 000031B2 FB                          sti
  7347 000031B3 C3                          ret
  7348                                  .writeRTC:
  7349                                  ;Writes to an RTC port, interrupts disabled throughout 
  7350                                  ;Input: al = I/O port to read, ah = Data byte to send
  7351 000031B4 FA                          cli
  7352 000031B5 E670                        out cmos_base, al
  7353 000031B7 E680                        out waitp, al
  7354 000031B9 88E0                        mov al, ah
  7355 000031BB E671                        out cmos_data, al
  7356 000031BD FB                          sti
  7357 000031BE C3                          ret
  7358                                  ;------------------------End of Interrupt------------------------
  7359                                  ;-----------------CTRL+BREAK Interrupt Int 3Bh-------------------
  7360                                  ;CTRL+Break will call this!
  7361                                  ;----------------------------------------------------------------
  7362                                  ctrlbreak_io:
  7363 000031BF 48CF                        iretq
  7364                                  ;------------------------End of Interrupt-------------------------
  7365                                  ;------------Screen Mode Parameters Interrupt Int 3Dh-------------
  7366                                  ;This Interrupt returns in r8 the pointer to screen mode 
  7367                                  ; parameters. It replaces the nice pointers in the IVT of yore.
  7368                                  ;Returns in r8 to not conflict with ported apps
  7369                                  ;----------------------------------------------------------------
  7370                                  scr_params_io:
  7371 000031C1 49B8-                       mov r8, scr_mode_params
  7371 000031C3 [6001000000000000] 
  7372 000031CB 48CF                        iretq
  7373                                  ;------------------------End of Interrupt------------------------
  7374                                  ;-----------------Disk Params Interrupt Int 3Eh------------------
  7375                                  disk_params_io:
  7376 000031CD 4C8B0425[AF010000]          mov r8, qword [diskDptPtr]    
  7377 000031D5 4C8B0C25[B7010000]          mov r9, qword [fdiskDptPtr]
  7378 000031DD 48CF                        iretq
  7379                                  ;------------------------End of Interrupt------------------------
  7380                                  ;------------------CGA font Interrupt Int 3Fh--------------------
  7381                                  ;This Interrupt returns in r8 the pointer to the CGA font.
  7382                                  ;It replaces the nice pointers in the IVT of yore.
  7383                                  ;Returns in r8 to not conflict with ported apps
  7384                                  ;----------------------------------------------------------------
  7385                                  cga_ret_io: ;Get first pointer in list
  7386 000031DF 4C0FB70425-                 movzx r8, word [scr_vga_ptrs]
  7386 000031E4 [68010000]         
  7387 000031E8 49C1E004                    shl r8, 4
  7388 000031EC 6644030425-                 add r8w, word [scr_vga_ptrs + 2]
  7388 000031F1 [6A010000]         
  7389 000031F5 48CF                        iretq
  7390                                  ;------------------------End of Interrupt------------------------
  7391                                  ;--------------------IDE Driver and data area--------------------
  7392                                  IDE:
  7393                                  .addControllerTable:
  7394                                  ;Adds a PCI IDE controller to the internal data tables, if there is space
  7395                                  ; If there is no space, returns with carry set.
  7396                                  ;Input: eax = BAR5 address
  7397                                  ;       ebx = PCI IO address
  7398                                  ;Output: CF=NC, all ok, CF=CY, device not added.
  7399 000031F7 56                          push rsi
  7400 000031F8 803C25[5A030000]02          cmp byte [ideNumberOfControllers], 2
  7401 00003200 7428                        je .actfail ;If it is 2, fail
  7402 00003202 FE0425[5A030000]            inc byte [ideNumberOfControllers]
  7403 00003209 48BE-                       mov rsi, ideControllerTable
  7403 0000320B [5B03000000000000] 
  7404 00003213 803E00                      cmp byte [rsi], 0   ;Is the first entry empty?
  7405 00003216 7407                        jz .act0    ;If yes, write entry
  7406 00003218 4881C610000000              add rsi, ideTableEntrySize  ;Else, goto second entry space
  7407                                  .act0:
  7408 0000321F 891E                        mov dword [rsi], ebx    ;Move first PCI IO addr
  7409 00003221 C60600                      mov byte [rsi], 0       ;Zero the register index
  7410 00003224 894604                      mov dword [rsi + 4], eax    ;Move next data
  7411 00003227 F8                          clc
  7412                                  .actexit:
  7413 00003228 5E                          pop rsi
  7414 00003229 C3                          ret
  7415                                  .actfail:
  7416 0000322A F9                          stc
  7417 0000322B EBFB                        jmp short .actexit
  7418                                  .identifyDevice:
  7419                                  ;dx should contain the base register
  7420                                  ;al should contain either A0/B0 for master/slave
  7421                                  ;rdi points to the buffer
  7422                                  ;Carry set if failed.
  7423 0000322D 50                          push rax            ;save the master/slave bit temporarily
  7424 0000322E 6681C20700                  add dx, 7            ;dx at base + 7
  7425                                  .l1:
  7426 00003233 EC                          in al, dx
  7427 00003234 3CFF                        cmp al, 0FFh
  7428 00003236 7447                        je .exitfail
  7429 00003238 A880                        test al, 10000000b
  7430 0000323A 75F7                        jnz .l1
  7431                                  
  7432 0000323C EB00                        jmp short $ + 2            ;IO cycle kill
  7433 0000323E FA                          cli
  7434                                  .l2:
  7435 0000323F EC                          in al, dx
  7436 00003240 84C0                        test al, al
  7437 00003242 743B                        jz .exitfail
  7438 00003244 A840                        test al, 01000000b
  7439 00003246 74F7                        jz .l2
  7440                                  
  7441 00003248 30C0                        xor al, al
  7442 0000324A 6681EA0500                  sub dx, 5            ;dx at base + 2
  7443 0000324F EE                          out dx, al
  7444 00003250 66FFC2                      inc dx               ;dx at base + 3
  7445 00003253 EE                          out dx, al
  7446 00003254 66FFC2                      inc dx               ;dx at base + 4
  7447 00003257 EE                          out dx, al
  7448 00003258 66FFC2                      inc dx               ;dx at base + 5
  7449 0000325B EE                          out dx, al
  7450 0000325C 66FFC2                      inc dx               ;dx at base + 6
  7451 0000325F 58                          pop rax              ;Get the master/slave bit back
  7452 00003260 EE                          out dx, al            
  7453 00003261 66FFC2                      inc dx               ;dx at base + 7
  7454 00003264 B0EC                        mov al, 0ECh         ;ECh = Identify drive command
  7455 00003266 EE                          out dx, al
  7456                                  
  7457 00003267 EB00                        jmp short $ + 2      ;IO cycle kill
  7458                                  .l3:
  7459 00003269 EC                          in al, dx            ;get status byte
  7460 0000326A A808                        test al, 00001000b   ;Check DRQ, to be set for data ready
  7461 0000326C 74FB                        jz .l3
  7462                                  
  7463 0000326E 6681EA0700                  sub dx, 7            ;dx at base + 0
  7464 00003273 51                          push rcx
  7465 00003274 66B90001                    mov cx, 100h         ;100h words to be copied
  7466 00003278 F3666D                      rep insw
  7467 0000327B F8                          clc
  7468 0000327C FB                          sti
  7469 0000327D EB01                        jmp short .exit
  7470                                  
  7471                                  .exitfail:
  7472 0000327F F9                          stc
  7473                                  .exit:
  7474 00003280 58                          pop rax
  7475 00003281 C3                          ret
  7476                                  ;--------------------USB Driver and data area--------------------
  7477                                  USB:
  7478                                  ;------------------------EHCI functions--------------------------
  7479                                  ;eActiveCtrlr must be set with the offset of the controller
  7480                                  ; IFF the controller is about to enter a state in which it could
  7481                                  ; fire an interrupt. These functions must safeguard against it by
  7482                                  ; checking that this byte is -1 first and then setting the byte
  7483                                  ; with the selected controller index, ending by resetting this 
  7484                                  ; byte to -1 (even on fail). 
  7485                                  ;
  7486                                  ;Certain functions may be called to act upon the CURRENT ACTIVE
  7487                                  ; controller, these functions dont need these safeguards, though
  7488                                  ; they may need to ensure that there is a valid controller number 
  7489                                  ; in the eActiveCtrlr byte.
  7490                                  ;----------------------------------------------------------------
  7491                                  .ehciCriticalErrorWrapper:
  7492                                  ;Currently just jumps to the installed address.
  7493                                  ;Conditional error calls MUST call this wrapper to allow for
  7494                                  ; host operating systems to install their own USB error handlers
  7495                                  ; and have the system continue working.
  7496 00003282 FF2425[36020000]            jmp qword [eHCErrorHandler]
  7497                                  .ehciCriticalErrorHandler:
  7498                                  ;Currently just halts the system
  7499 00003289 BB07000000                  mov ebx, 07h
  7500 0000328E E864CEFFFF                  call cls
  7501 00003293 48BD-                       mov rbp, .ecehmsg
  7501 00003295 [B032000000000000] 
  7502 0000329D 66B80413                    mov ax, 1304h
  7503 000032A1 CD30                        int 30h
  7504 000032A3 B0FF                        mov al, 0FFh
  7505 000032A5 E621                        out pic1data, al
  7506 000032A7 E6A1                        out pic2data, al
  7507 000032A9 FA                          cli
  7508 000032AA F4                          hlt
  7509 000032AB E9F9FFFFFF                  jmp $ - 2
  7510 000032B0 454843492043686563-     .ecehmsg db "EHCI Check 1", 0
  7510 000032B9 6B203100           
  7511                                  .setupEHCIcontroller:
  7512                                  ;Resets, initialises variables to default
  7513                                  ;Input: al = Controller to setup (0 based)
  7514                                  ;Output: CF=CY - Controller failed to reset
  7515                                  ;        CF=NC - No problems
  7516                                  ; al = Controller that was reset
  7517 000032BD 51                          push rcx
  7518 000032BE 53                          push rbx
  7519 000032BF 55                          push rbp
  7520 000032C0 E80F010000                  call .ehciResetCtrlr    ;Reset the controller
  7521 000032C5 7215                        jc .secexit
  7522 000032C7 6631DB                      xor bx, bx ;No schedule, no interrupts
  7523 000032CA 31C9                        xor ecx, ecx
  7524 000032CC 48BD-                       mov rbp, ehciAschedule
  7524 000032CE [0000000000000000] 
  7525 000032D6 E8EB010000                  call .ehciInitCtrlrRegs    ;Initialise controller registers
  7526 000032DB F8                          clc
  7527                                  .secexit:
  7528 000032DC 5D                          pop rbp
  7529 000032DD 5B                          pop rbx
  7530 000032DE 59                          pop rcx
  7531 000032DF C3                          ret
  7532                                  
  7533                                  .ehciResetControllerPort:
  7534                                  ;A function that enacts an EHCI reset on a port.
  7535                                  ;Works ONLY on the current active controller.
  7536                                  ;Input:
  7537                                  ; al = Port number [0,N-1] (Checked against ctrlr struc params entry)
  7538                                  ;Returns:
  7539                                  ; CF set if failed, clear if success
  7540                                  ; ax=Error code, 0h=No active controller
  7541                                  ;             1h=Invalid port number
  7542                                  ;             2h=No device on port
  7543                                  ;             3h=Port not enabled (Low speed device)
  7544                                  ;             4h=Device not entering reset
  7545                                  ;             5h=Device not clearing reset
  7546                                  ;             6h=Port not enabled (Full speed device)
  7547                                  ; rax destroyed
  7548 000032E0 53                          push rbx
  7549 000032E1 51                          push rcx
  7550 000032E2 52                          push rdx
  7551 000032E3 55                          push rbp
  7552                                  
  7553 000032E4 6631ED                      xor bp, bp
  7554 000032E7 0FB6D0                      movzx edx, al    ;Save port number into dl (edx)
  7555 000032EA 0FB61C25[47020000]          movzx ebx, byte [eActiveCtrlr]
  7556 000032F2 80FBFF                      cmp bl, -1
  7557 000032F5 0F84D3000000                je .ercperr    ;Error, No active controller (ec=0)
  7558 000032FB 66FFC5                      inc bp        ;Inc error counter
  7559 000032FE 8B1CDD[19020000]            mov ebx, dword [eControllerList + 4 + 8*rbx]    ;get mmiobase into ebx
  7560 00003305 678B4304                    mov eax, dword [ebx+ehcistrucparams]    ;Get # of ports in al
  7561 00003309 247F                        and al, 7Fh    ;al contains port number, clear upper bit
  7562 0000330B FEC8                        dec al        ;Zero based port number
  7563 0000330D 0FB6C0                      movzx eax, al
  7564 00003310 38C2                        cmp dl, al    ;dl contains called port number
  7565 00003312 0F87B6000000                ja .ercperr    ;Error, invalid port number (ec=1)
  7566 00003318 66FFC5                      inc bp        ;Inc error counter
  7567                                  
  7568                                  
  7569 0000331B 670FB603                    movzx eax, byte [ebx]    ;Byte access for caplength!
  7570 0000331F 01C3                        add ebx, eax    ;eax now points to opregs    
  7571 00003321 66B90A00                    mov cx, 10
  7572                                  .erclp0:    ;Remember ebx=opregs, edx=port number    
  7573 00003325 67814C934400100000          or dword [ebx+4*edx+ehciportsc], 1000h ;Set power bit
  7574                                  
  7575 0000332E 51                          push rcx
  7576 0000332F B90A000000                  mov ecx, 10
  7577 00003334 B486                        mov ah, 86h
  7578 00003336 CD35                        int 35h        ;Wait for 10 ms
  7579 00003338 59                          pop rcx
  7580                                  
  7581                                  .erclp1:
  7582 00003339 66FFC9                      dec cx
  7583 0000333C 0F848C000000                jz .ercperr ;Error, No device on port (ec=2)
  7584 00003342 67F744934401000000          test dword [ebx+4*edx+ehciportsc], 1h    ;Test device on port
  7585 0000334B 74D8                        jz .erclp0
  7586 0000334D 66FFC5                      inc bp        ;Inc error counter
  7587                                  
  7588 00003350 678B449344                  mov eax, dword [ebx+4*edx+ehciportsc]
  7589 00003355 6625000C                    and ax, 0C00h
  7590 00003359 662D0004                    sub ax, 400h
  7591 0000335D 66FFC8                      dec ax
  7592 00003360 746C                        jz .ercperr    ;Error, Low speed device (ec=3)
  7593 00003362 66FFC5                      inc bp        ;Inc error counter
  7594                                  
  7595 00003365 66B90A00                    mov cx, 10
  7596                                  .erclp2:
  7597 00003369 66FFC9                      dec cx
  7598 0000336C 7460                        jz .ercperr ;Error, Device not entering reset (ec=4)
  7599 0000336E 67814C934400010000          or dword [ebx+4*edx+ehciportsc], 100h    ;Set bit 8, port reset bit
  7600                                      
  7601 00003377 51                          push rcx
  7602 00003378 B90A000000                  mov ecx, 10
  7603 0000337D B486                        mov ah, 86h
  7604 0000337F CD35                        int 35h        ;Wait for 10 ms
  7605 00003381 59                          pop rcx
  7606                                  
  7607 00003382 67F744934400010000          test dword [ebx+4*edx+ehciportsc], 100h    ;Check if entered reset
  7608 0000338B 74DC                        jz .erclp2
  7609                                  
  7610 0000338D 66FFC5                      inc bp        ;Inc error counter
  7611 00003390 66B90A00                    mov cx, 10
  7612 00003394 6781649344FFFEFFFF          and dword [ebx+4*edx+ehciportsc], 0FFFFFEFFh    ;Clear reset bit
  7613                                  .erclp3:
  7614 0000339D FFC9                        dec ecx
  7615 0000339F 742D                        jz .ercperr ;Error, Device not leaving reset (ec=5)
  7616                                  
  7617 000033A1 51                          push rcx
  7618 000033A2 B90A000000                  mov ecx, 10
  7619 000033A7 B486                        mov ah, 86h
  7620 000033A9 CD35                        int 35h        ;Wait for 10 ms
  7621 000033AB 59                          pop rcx
  7622                                  
  7623 000033AC 67F744934400010000          test dword [ebx+4*edx+ehciportsc], 100h
  7624 000033B5 75E6                        jnz .erclp3
  7625 000033B7 66FFC5                      inc bp        ;Inc error counter
  7626                                  
  7627 000033BA 67F744934404000000          test dword [ebx+4*edx+ehciportsc], 4h    ;Bit 2 is the port enabled bit
  7628 000033C3 7409                        jz .ercperr    ;Error, Full speed device (ec=6)
  7629                                  ;We get here IFF device on port is high speed
  7630                                      
  7631                                  ;High Speed Device successfully reset. Now print message or whatever
  7632 000033C5 4831C0                      xor rax, rax
  7633 000033C8 F8                          clc
  7634                                  .ercpexit:
  7635 000033C9 5D                          pop rbp
  7636 000033CA 5A                          pop rdx
  7637 000033CB 59                          pop rcx
  7638 000033CC 5B                          pop rbx
  7639 000033CD C3                          ret
  7640                                  .ercperr:
  7641 000033CE 6689E8                      mov ax, bp    ;Get error code in ax
  7642 000033D1 F9                          stc
  7643 000033D2 EBF5                        jmp short .ercpexit
  7644                                  
  7645                                  .ehciResetCtrlr:
  7646                                  ;A function that resets a controller. 
  7647                                  ;No other controllers may be running during a ctrlr reset
  7648                                  ;Input:
  7649                                  ; al = Offset into the ehci controller table
  7650                                  ;Returns:
  7651                                  ; CF=CY if failed, CF=NC if reset
  7652                                  ;All registers preserved
  7653 000033D4 50                          push rax
  7654 000033D5 51                          push rcx
  7655                                      ;cmp byte [eActiveCtrlr], -1
  7656                                      ;jne .erc2    ;A controller already active, exit fail (ec=0)
  7657                                      ;mov byte [eActiveCtrlr], al    ;For added security (may be removed later)
  7658 000033D6 E800180000                  call .ehciGetOpBase
  7659 000033DB 67C7400800000000            mov dword [eax + ehciintr], 0h    ;No interrupts
  7660 000033E3 67C740043F000000            mov dword [eax + ehcists], 3Fh    ;Clear any outstanding interrupts
  7661                                      ;Set the reset bit, check to see if run bit has cleared first!
  7662 000033EB 31C9                        xor ecx, ecx
  7663                                  .erc0:
  7664 000033ED 678120FEFFFFFF              and dword [eax + ehcicmd], 0FFFFFFFEh    ;Force stop the controller
  7665 000033F4 FFC9                        dec ecx
  7666 000033F6 743D                        jz .erc2    ;Controller not resetting, exit fail  (ec=1)
  7667                                  
  7668 000033F8 67F7400400100000            test dword [eax + ehcists], 1000h    ;Test if bit 12 has been set
  7669 00003400 74EB                        jz .erc0
  7670 00003402 67810802000000              or dword [eax + ehcicmd], 02h ;Set bit 1, reset HC
  7671                                      ;Spin and wait to give device time to respond and reset.
  7672 00003409 6631C9                      xor cx, cx
  7673                                  .erc1:
  7674 0000340C 66FFC9                      dec cx        ;Wait for reset to happen
  7675 0000340F 7424                        jz .erc2    ;Not resetting, exit fail (ec=2)
  7676                                  
  7677 00003411 50                          push rax
  7678 00003412 51                          push rcx
  7679 00003413 B486                        mov ah, 86h
  7680 00003415 B905000000                  mov ecx, 5    ;5ms wait
  7681 0000341A CD35                        int 35h
  7682 0000341C 59                          pop rcx
  7683 0000341D 58                          pop rax
  7684                                  
  7685 0000341E 67F70002000000              test dword [eax + ehcicmd], 2h    ;Whilst this bit is set, keep looping
  7686 00003425 75E5                        jnz .erc1
  7687 00003427 31C0                        xor eax, eax
  7688 00003429 F8                          clc
  7689                                  .ercexit:
  7690 0000342A C60425[47020000]FF          mov byte [eActiveCtrlr], -1    ;No controllers active
  7691 00003432 59                          pop rcx
  7692 00003433 58                          pop rax
  7693 00003434 C3                          ret
  7694                                  .erc2:
  7695 00003435 F9                          stc
  7696 00003436 EBF2                        jmp short .ercexit
  7697                                  
  7698                                  .ehciRunCtrlr:
  7699                                  ;A function that runs a controller to process set schedules
  7700                                  ;Input:
  7701                                  ;   al = Offset into the controller table
  7702                                  ;Returns:
  7703                                  ; CF = CY if failed, CF = NC if success
  7704 00003438 50                          push rax
  7705 00003439 51                          push rcx
  7706 0000343A E89C170000                  call .ehciGetOpBase
  7707 0000343F 67F7400400100000            test dword [eax + ehcists], 1000h    ;bit 12 must be set to write 1 in cmd
  7708 00003447 741E                        jz .esc2
  7709 00003449 67810801000000              or dword [eax + ehcicmd], 1h ;Set bit 0 to run
  7710 00003450 31C9                        xor ecx, ecx
  7711                                  .esc0:
  7712 00003452 66FFC9                      dec cx
  7713 00003455 7410                        jz .esc2
  7714 00003457 67F7400400100000            test dword [eax + ehcists], 1000h    ;bit 12 must be clear
  7715 0000345F 75F1                        jnz .esc0
  7716 00003461 31C0                        xor eax, eax
  7717 00003463 F8                          clc
  7718                                  .esc1:
  7719 00003464 59                          pop rcx
  7720 00003465 58                          pop rax
  7721 00003466 C3                          ret
  7722                                  .esc2:    ;Bad exit
  7723 00003467 F9                          stc
  7724 00003468 EBFA                        jmp short .esc1
  7725                                  
  7726                                  .ehciStopCtrlr:
  7727                                  ;A function that stops current active controller from running
  7728                                  ;Input:
  7729                                  ; al=Controller to stop processing
  7730                                  ;Returns:
  7731                                  ; CF set if failed to stop, clear if success
  7732 0000346A 50                          push rax
  7733 0000346B 51                          push rcx
  7734 0000346C 480FB60425-                 movzx rax, byte [eActiveCtrlr]
  7734 00003471 [47020000]         
  7735 00003475 E861170000                  call .ehciGetOpBase
  7736 0000347A 678120FEFFFFFF              and dword [eax + ehcicmd], 0FFFFFFFEh    ;Stop controller
  7737 00003481 31C9                        xor ecx, ecx
  7738                                  .estc0:
  7739 00003483 66FFC9                      dec cx
  7740 00003486 740E                        jz .estc1
  7741 00003488 67F7400400100000            test dword [eax + ehcists], 1000h    ;test hchalted until set
  7742 00003490 74F1                        jz .estc0
  7743 00003492 F8                          clc
  7744                                  .estcexit:
  7745 00003493 59                          pop rcx
  7746 00003494 58                          pop rax
  7747 00003495 C3                          ret
  7748                                  .estc1:
  7749 00003496 F9                          stc
  7750 00003497 EBFA                        jmp short .estcexit
  7751                                  .ehciAdjustAsyncSchedCtrlr:
  7752                                  ;This function checks the currently online controller and compares it to
  7753                                  ; the value provided in al. 
  7754                                  ;If they are equal, do nothing.
  7755                                  ;If not, turn off controller, update active ctrlr byte and indicate a new bus 
  7756                                  ; was activated.
  7757                                  ;If no controller active, update active ctrlr byte and indicate which bus 
  7758                                  ; has been activated.
  7759                                  ;
  7760                                  ; Input: al = Controller to activate, preserved.
  7761                                  ; Output: CF=CY: Error, turn off all controllers
  7762                                  ;         CF=NC: All ok, proceed
  7763 00003499 3A0425[47020000]            cmp al, byte [eActiveCtrlr]
  7764 000034A0 7420                        je .eacOkExit
  7765 000034A2 803C25[47020000]FF          cmp byte [eActiveCtrlr], -1
  7766 000034AA 7407                        je .eacStart
  7767 000034AC E8D8020000                  call .ehciStopAsyncSchedule ;Stop currently transacting controller
  7768 000034B1 7211                        jc .eacBad
  7769                                  .eacStart:
  7770 000034B3 880425[47020000]            mov byte [eActiveCtrlr], al ;Set new active controller
  7771 000034BA C60425[46020000]01          mov byte [eNewBus], 1   ;Set flag that a new bus has been selected
  7772                                  .eacOkExit:
  7773 000034C2 F8                          clc
  7774 000034C3 C3                          ret
  7775                                  .eacBad:
  7776 000034C4 F9                          stc
  7777 000034C5 C3                          ret
  7778                                  .ehciInitCtrlrRegs:
  7779                                  ;A function that initialises a given controllers registers as needed.
  7780                                  ;Controller is left ready to process data start schedules
  7781                                  ;MUST NOT BE CALLED ON A RUNNING CONTROLLER
  7782                                  ;Input:
  7783                                  ; al = Offset into the ehci controller table
  7784                                  ; bl = ehciintr mask
  7785                                  ; bh = Schedule mask, bits [7:2] reserved
  7786                                  ;        00b = No schedule, 01b=Periodic, 10b=Async, 11b=Both
  7787                                  ; ecx = Frame Index
  7788                                  ; rbp = Schedule address
  7789                                  ;Returns:
  7790                                  ; Nothing
  7791 000034C6 50                          push rax
  7792 000034C7 53                          push rbx
  7793 000034C8 51                          push rcx
  7794 000034C9 53                          push rbx
  7795 000034CA E80C170000                  call .ehciGetOpBase    ;Get opbase 
  7796 000034CF 0FB7DB                      movzx ebx, bx
  7797 000034D2 67C7400800000000            mov dword [eax + ehciintr], 0
  7798 000034DA 6789480C                    mov dword [eax + ehcifrindex], ecx
  7799 000034DE 67896818                    mov dword [eax + ehciasyncaddr], ebp
  7800 000034E2 48C1CD20                    ror rbp, 20h    ;Get upper dword low
  7801 000034E6 67896810                    mov dword [eax + ehcictrlseg], ebp
  7802 000034EA 5B                          pop rbx    ;Get back bh
  7803 000034EB 30DB                        xor bl, bl    ;Zero lo byte
  7804 000034ED 66C1EB04                    shr bx, 4    ;Shift to hi nybble of lo byte
  7805 000034F1 678120CF000000              and dword [eax + ehcicmd], 0CFh    ;Clear schedule enable bits
  7806 000034F8 670B18                      or ebx, dword [eax + ehcicmd]    ;Add ehcicmd to schedule mask
  7807 000034FB 81E3F3FF00FF                and ebx, 0FF00FFF3h    ;Clear the Int Threshold and Frame List bits
  7808 00003501 81CB00000800                or ebx, 000080000h ;Set 8 microframes (1 ms) per interrupt
  7809 00003507 678918                      mov dword [eax + ehcicmd], ebx    ;Write back
  7810 0000350A 67C7404001000000            mov dword [eax + ehciconfigflag], 1h    ;Route all ports to EHCI ctrlr
  7811 00003512 59                          pop rcx
  7812 00003513 5B                          pop rbx
  7813 00003514 58                          pop rax
  7814 00003515 C3                          ret
  7815                                  .ehciCtrlrGetNumberOfPorts:
  7816                                  ;Gets the number of ports on a Host Controller.
  7817                                  ;Ports are zero addressed so ports numbers are 0 to NUMBER_OF_PORTS - 1
  7818                                  ;Input:  al = Offset into the controller table
  7819                                  ;Output: rax = Number of ports on controller.
  7820                                  ;Warning, input NOT bounds checked.
  7821 00003516 0FB6C0                      movzx eax, al
  7822 00003519 8B04C5[19020000]            mov eax, dword [eControllerList + 4 + 8*rax]
  7823 00003520 678B4004                    mov eax, dword [eax + ehcistrucparams]
  7824 00003524 257F000000                  and eax, 7Fh    ;Clear upper bits
  7825 00003529 C3                          ret
  7826                                  .ehciGetNewQHeadAddr:
  7827                                  ;Picks which QHead position to put the new Qhead into
  7828                                  ;Input: Nothing
  7829                                  ;Output: rdi = Position in RAM for QHead
  7830                                  ;        r8  = Link to next QHead
  7831                                  ;           r8 NEEDS to be or'ed with 2 when used as a QHead pointer
  7832 0000352A 49B8-                       mov r8, ehciQHead1
  7832 0000352C [8000000000000000] 
  7833 00003534 48BF-                       mov rdi, ehciQHead0
  7833 00003536 [0000000000000000] 
  7834 0000353E 483B3C25[3E020000]          cmp rdi, qword [eCurrAsyncHead]   ;Compare head to start of buffer
  7835 00003546 7503                        jne .egnqaexit
  7836 00003548 4987F8                      xchg rdi, r8
  7837                                  .egnqaexit:
  7838 0000354B C3                          ret
  7839                                  
  7840                                  .ehciToggleTransactingQHead:
  7841                                  ;Toggles the transacting Qhead position
  7842                                  ;This is called AFTER the old Qhead has been delinked from the AsynchSchedule
  7843 0000354C 48813C25[3E020000]-         cmp qword [eCurrAsyncHead], ehciQHead0
  7843 00003554 [00000000]         
  7844 00003558 750D                        jne .ettqh0
  7845 0000355A 48C70425[3E020000]-         mov qword [eCurrAsyncHead], ehciQHead1
  7845 00003562 [80000000]         
  7846 00003566 C3                          ret
  7847                                  .ettqh0:
  7848 00003567 48C70425[3E020000]-         mov qword [eCurrAsyncHead], ehciQHead0
  7848 0000356F [00000000]         
  7849 00003573 C3                          ret
  7850                                  
  7851                                  .ehciDelinkOldQHead:
  7852                                  ;Delinks the old Qhead from the list async list
  7853 00003574 57                          push rdi
  7854 00003575 4150                        push r8
  7855 00003577 E8AEFFFFFF                  call .ehciGetNewQHeadAddr
  7856 0000357C 4989F8                      mov r8, rdi
  7857 0000357F 4981C802000000              or r8, 2
  7858 00003586 448907                      mov dword [rdi], r8d    ;Point the new qhead to itself
  7859 00003589 814F0400800000              or dword [rdi + 4], 8000h   ;Toggle H-bit in the current transacting QHead
  7860 00003590 4158                        pop r8
  7861 00003592 5F                          pop rdi
  7862 00003593 C3                          ret
  7863                                  
  7864                                  .ehciLinkNewQHead:
  7865                                  ;Links the inserted qhead into the async list
  7866 00003594 57                          push rdi
  7867 00003595 4150                        push r8
  7868 00003597 E88EFFFFFF                  call .ehciGetNewQHeadAddr   ;Get bus addresses
  7869 0000359C 803C25[46020000]01          cmp byte [eNewBus], 1
  7870 000035A4 740F                        je .elnqadjusted   ;If equal, exit
  7871 000035A6 4881CF02000000              or rdi, 2
  7872 000035AD 418938                      mov dword [r8], edi
  7873                                  .elnqhexit:
  7874 000035B0 F8                          clc
  7875 000035B1 4158                        pop r8
  7876 000035B3 5F                          pop rdi
  7877 000035B4 C3                          ret
  7878                                  ;Only here if a new bus was Adjusted
  7879                                  .elnqadjusted:
  7880                                  ;The first qhead in a new queue must always point to itself and be
  7881                                  ; the head of the reclaim list.
  7882                                  ;The same address is provided to the function which writes the qhead
  7883                                  ; and in the above function call into rdi, thus allowing us to point
  7884                                  ; the new qhead to itself and set the H-bit on, in ALL instances 
  7885 000035B5 4989F8                      mov r8, rdi
  7886 000035B8 4981C802000000              or r8, 2
  7887 000035BF 448907                      mov dword [rdi], r8d    ;Point the QHead to itself
  7888 000035C2 814F0400800000              or dword [rdi + 4], 8000h   ;Set H bit on
  7889 000035C9 50                          push rax
  7890 000035CA 8A0425[47020000]            mov al, byte [eActiveCtrlr]
  7891 000035D1 E805160000                  call .ehciGetOpBase
  7892 000035D6 67897818                    mov dword [eax + ehciasyncaddr], edi ;Set the address in the ctrlr register
  7893 000035DA 58                          pop rax
  7894 000035DB E87D010000                  call .ehciStartAsyncSchedule    ;Start schedule
  7895 000035E0 7209                        jc .elnqhbad
  7896 000035E2 FE0C25[46020000]            dec byte [eNewBus]  ;Reset back to zero if successfully onlined
  7897 000035E9 EBC5                        jmp short .elnqhexit
  7898                                  .elnqhbad:  ;If Async fails to start, exit
  7899 000035EB 4158                        pop r8
  7900 000035ED 5F                          pop rdi
  7901 000035EE F9                          stc
  7902 000035EF C3                          ret
  7903                                  
  7904                                  .ehciSetNoData:
  7905                                  ;A function that does a set request with no data phase to the device
  7906                                  ;at address al.
  7907                                  ;Input:
  7908                                  ; al = Address number (7 bit value)
  7909                                  ; rbx = Setup packet
  7910                                  ; cx = Max Packet Length 
  7911                                  ;Returns:
  7912                                  ; CF = NC if no Host error, CF = CY if Host error
  7913                                  ; Caller MUST check the schedule to ensure that the transfer was successful,
  7914                                  ; and without transaction errors as these dont constitute Host system errors.
  7915                                  ;
  7916                                  ; All registers except for CF preserved
  7917 000035F0 57                          push rdi
  7918 000035F1 4150                        push r8
  7919 000035F3 4151                        push r9
  7920 000035F5 4152                        push r10
  7921 000035F7 4153                        push r11
  7922 000035F9 51                          push rcx
  7923 000035FA 52                          push rdx
  7924 000035FB FC                          cld    ;Set right direction for string ops
  7925                                      
  7926                                      ;Write setup packet
  7927 000035FC 48891C25[80030000]          mov qword [ehciDataOut], rbx
  7928 00003604 E821FFFFFF                  call .ehciGetNewQHeadAddr
  7929 00003609 4981C802000000              or r8, 2    ;Process qH TDs
  7930 00003610 41B900600080                mov r9d, 80006000h  ;Bit 15 not set here!!!!! Important
  7931 00003616 0FB7C9                      movzx ecx, cx
  7932 00003619 C1E110                      shl ecx, 8*2
  7933 0000361C 4109C9                      or r9d, ecx
  7934 0000361F 247F                        and al, 7Fh    ;Force clear upper bit of al
  7935 00003621 4108C1                      or r9b, al    ;Set lower 8 bits of r9 correctly
  7936 00003624 41BA00000040                mov r10d, 40000000h    ;1 transaction/ms
  7937 0000362A 49BB-                       mov r11, ehciTDSpace  ;First TD is the head of the buffer
  7937 0000362C [0001000000000000] 
  7938                                  
  7939 00003634 E827080000                  call .ehciWriteQHead
  7940                                  
  7941 00003639 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  7942 0000363C 4C8D4740                    lea r8, qword [rdi + ehciSizeOfTD]    ;Point to next TD
  7943 00003640 49B901000000000000-         mov r9, 1
  7943 00003649 00                 
  7944 0000364A 41BA800E0800                mov r10d, 00080E80h ;Active TD, SETUP EP, Error ctr = 3, 8 byte transfer
  7945 00003650 49BB-                       mov r11, ehciDataOut ; Data out buffer
  7945 00003652 [8003000000000000] 
  7946                                  
  7947 0000365A E826080000                  call .ehciWriteQHeadTD
  7948                                  
  7949 0000365F 4881C740000000              add rdi, ehciSizeOfTD     ;Go to next TD space
  7950 00003666 49B801000000000000-         mov r8, 1
  7950 0000366F 00                 
  7951 00003670 4D89C1                      mov r9, r8
  7952 00003673 41BA808D0080                mov r10d, 80008D80h        ;Status stage opposite direction of last transfer
  7953 00003679 49BB-                       mov r11, msdCSW         ;Nothing should be returned but use this point
  7953 0000367B [C005000000000000] 
  7954                                  
  7955 00003683 E8FD070000                  call .ehciWriteQHeadTD
  7956 00003688 B103                        mov cl, 011b   ;Lock out internal buffer
  7957 0000368A E9BD000000                  jmp .egddproceed
  7958                                  
  7959                                  .ehciGetRequest:
  7960                                  ;A function which does a standard get request from a device at
  7961                                  ;address al.
  7962                                  ;Input:
  7963                                  ; al = Address number (7 bit value)
  7964                                  ; rbx = Setup packet
  7965                                  ; ecx = Max Packet Length 
  7966                                  ;Returns:
  7967                                  ; CF = NC if no Host error, CF = CY if Host error
  7968                                  ; Caller MUST check the schedule to ensure that the transfer was successful,
  7969                                  ; and without transaction errors as these dont constitute Host system errors.
  7970                                  ;
  7971                                  ; All registers except for CF preserved
  7972 0000368F 57                          push rdi
  7973 00003690 4150                        push r8
  7974 00003692 4151                        push r9
  7975 00003694 4152                        push r10
  7976 00003696 4153                        push r11
  7977 00003698 51                          push rcx
  7978 00003699 52                          push rdx
  7979 0000369A FC                          cld    ;Ensure right direction
  7980                                  
  7981                                      ;Write setup packet
  7982 0000369B 48891C25[80030000]          mov qword [ehciDataOut], rbx
  7983 000036A3 E882FEFFFF                  call .ehciGetNewQHeadAddr
  7984 000036A8 4981C802000000              or r8, 2    ;Process qH TDs
  7985 000036AF 41B900600080                mov r9d, 80006000h  ;Bit 15 not set here!!!!! Important
  7986 000036B5 0FB7C9                      movzx ecx, cx
  7987 000036B8 C1E110                      shl ecx, 8*2
  7988 000036BB 4109C9                      or r9d, ecx
  7989 000036BE 247F                        and al, 7Fh    ;Force clear upper bit of al
  7990 000036C0 4108C1                      or r9b, al    ;Set lower 8 bits of r9 correctly
  7991 000036C3 41BA00000040                mov r10d, 40000000h    ;1 transaction/ms
  7992 000036C9 49BB-                       mov r11, ehciTDSpace  ;First TD is the head of the buffer
  7992 000036CB [0001000000000000] 
  7993                                      
  7994 000036D3 E888070000                  call .ehciWriteQHead
  7995                                  
  7996 000036D8 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  7997 000036DB 4C8D4740                    lea r8, qword [rdi + ehciSizeOfTD]    ;Point to next TD
  7998 000036DF 49B901000000000000-         mov r9, 1
  7998 000036E8 00                 
  7999 000036E9 41BA800E0800                mov r10d, 00080E80h ;Active TD, SETUP EP, Error ctr = 3, 8 byte transfer
  8000 000036EF 49BB-                       mov r11, ehciDataOut ; Data out buffer
  8000 000036F1 [8003000000000000] 
  8001                                  
  8002 000036F9 E887070000                  call .ehciWriteQHeadTD
  8003                                  
  8004 000036FE 4881C740000000              add rdi, ehciSizeOfTD    ;Go to next TD space
  8005 00003705 4C8D4740                    lea r8, qword [rdi + ehciSizeOfTD]
  8006 00003709 4D89C1                      mov r9, r8    ;Alt pointer also points to next TD since this is expected!
  8007 0000370C 41BA800D4080                mov r10d, 80400D80h ;Active TD, IN EP, Error ctr = 3, max 64 byte transfer
  8008 00003712 49BB-                       mov r11, ehciDataIn
  8008 00003714 [C003000000000000] 
  8009                                  
  8010 0000371C E864070000                  call .ehciWriteQHeadTD
  8011                                  
  8012 00003721 4881C740000000              add rdi, ehciSizeOfTD     ;Go to next TD space
  8013 00003728 49B801000000000000-         mov r8, 1
  8013 00003731 00                 
  8014 00003732 4D89C1                      mov r9, r8
  8015 00003735 41BA808C0080                mov r10d, 80008C80h
  8016 0000373B 49BB-                       mov r11, msdCSW
  8016 0000373D [C005000000000000] 
  8017                                  
  8018 00003745 E83B070000                  call .ehciWriteQHeadTD
  8019                                  
  8020 0000374A B103                        mov cl, 11b    ;Lock out internal buffer, ignore one interrupt
  8021                                  ;Now set controller to process the schedule
  8022                                  .egddproceed:
  8023 0000374C E867000000                  call .ehciProcessCommand
  8024                                  ;The carry status of the previous function will propagate
  8025                                  .egddexit:
  8026 00003751 5A                          pop rdx
  8027 00003752 59                          pop rcx
  8028 00003753 415B                        pop r11
  8029 00003755 415A                        pop r10
  8030 00003757 4159                        pop r9
  8031 00003759 4158                        pop r8
  8032 0000375B 5F                          pop rdi
  8033 0000375C C3                          ret
  8034                                  
  8035                                  .ehciStartAsyncSchedule:
  8036 0000375D 50                          push rax
  8037 0000375E 51                          push rcx
  8038                                  
  8039 0000375F 8A0425[47020000]            mov al, byte [eActiveCtrlr]    ;Deals with current active controller
  8040 00003766 E870140000                  call .ehciGetOpBase            ;Return opregs ADDRESS in eax
  8041 0000376B 67810820000000              or dword [eax + ehcicmd], 20h    ;Process asyncschedule
  8042 00003772 31C9                        xor ecx, ecx
  8043                                  .esas0:
  8044 00003774 FFC9                        dec ecx
  8045 00003776 740E                        jz .esasfail
  8046 00003778 67F7400400800000            test dword [eax + ehcists], 08000h ;Asyncschedule bit should be on
  8047 00003780 74F2                        jz .esas0
  8048                                  
  8049 00003782 F8                          clc
  8050                                  .esasok:
  8051 00003783 59                          pop rcx
  8052 00003784 58                          pop rax
  8053 00003785 C3                          ret
  8054                                  .esasfail:
  8055 00003786 F9                          stc
  8056 00003787 EBFA                        jmp short .esasok
  8057                                  
  8058                                  .ehciStopAsyncSchedule:
  8059                                  ;This function stops the processing of the current active Async Schedule
  8060                                  ;Output: CF=CY: Failed to stop Async Schedule CF=NC: Stopped Async Schedule
  8061 00003789 50                          push rax
  8062 0000378A 51                          push rcx
  8063 0000378B 8A0425[47020000]            mov al, byte [eActiveCtrlr]    ;Deals with current active controller
  8064 00003792 E844140000                  call .ehciGetOpBase            ;Return opregs ADDRESS in eax
  8065 00003797 6631C9                      xor cx, cx
  8066 0000379A 678120DFFFFFFF              and dword [eax + ehcicmd], 0FFFFFFDFh ;Stop processing async
  8067                                  .espc0:
  8068 000037A1 66FFC9                      dec cx
  8069 000037A4 740E                        jz .espcfail
  8070 000037A6 67F7400400800000            test dword [eax + ehcists], 08000h
  8071 000037AE 75F1                        jnz .espc0
  8072                                  
  8073 000037B0 F8                          clc
  8074 000037B1 59                          pop rcx
  8075 000037B2 58                          pop rax
  8076 000037B3 C3                          ret
  8077                                  .espcfail:
  8078 000037B4 F9                          stc
  8079 000037B5 59                          pop rcx
  8080 000037B6 58                          pop rax
  8081 000037B7 C3                          ret
  8082                                  
  8083                                  .ehciProcessCommand:
  8084                                  ; Allows EHCI async schedule to process commands.
  8085                                  ; Preserves all registers except CF
  8086                                  ; Returns: CF=CY if error detected 
  8087                                  ;          CF=NC if no error detected
  8088                                  ;
  8089                                  ; If returned with CF=CY, caller must read the msdStatus byte
  8090 000037B8 50                          push rax
  8091 000037B9 53                          push rbx
  8092 000037BA 51                          push rcx
  8093 000037BB 57                          push rdi
  8094                                  
  8095 000037BC 880C25[49020000]            mov byte [eAsyncMutex], cl  ;Set mutex
  8096 000037C3 8A0425[47020000]            mov al, byte [eActiveCtrlr]    ;Deals with current active controller
  8097 000037CA E80C140000                  call .ehciGetOpBase            ;Return opregs ADDRESS in eax
  8098 000037CF 4889C3                      mov rbx, rax
  8099 000037D2 66BF8813                    mov di, 5000
  8100 000037D6 E8B9FDFFFF                  call .ehciLinkNewQHead
  8101 000037DB 0F82A1000000                jc .epcfailedstart
  8102                                  .epc1:
  8103 000037E1 67F7430413000000            test dword [ebx + ehcists], 13h
  8104 000037E9 7516                        jnz .epc2     ;If bits we care about are set, call IRQ proceedure
  8105 000037EB F390                        pause       
  8106 000037ED 66FFCF                      dec di
  8107 000037F0 0F849F000000                jz .epcfailtimeout
  8108 000037F6 B486                        mov ah, 86h
  8109 000037F8 B901000000                  mov ecx, 1    ;Max 5s in 1ms chunks
  8110 000037FD CD35                        int 35h
  8111 000037FF EBE0                        jmp short .epc1
  8112                                  .epc2:
  8113 00003801 89D8                        mov eax, ebx    ;Get opreg base into eax before we proceed into IRQ handler
  8114 00003803 E8BFD3FFFF                  call ehci_IRQ.nonIRQep ;Manually call IRQ
  8115 00003808 F60425[48020000]10          test byte [eActiveInt], 10h ;HC error bit
  8116 00003810 7578                        jnz .epcHostError   ;HC error detected
  8117 00003812 F60425[49020000]00          test byte [eAsyncMutex], 0
  8118 0000381A 75C5                        jnz .epc1    ;If the mutex isnt cleared, go back to sts check
  8119 0000381C E853FDFFFF                  call .ehciDelinkOldQHead   ;Perform delink
  8120 00003821 E826FDFFFF                  call .ehciToggleTransactingQHead    ;Toggle the active Qheads
  8121                                  ;Now set doorbell
  8122 00003826 67810B40000000              or dword [ebx + ehcicmd], 40h   ;Ring Doorbell
  8123 0000382D 66BF8813                    mov di, 5000
  8124                                  .epc3:
  8125 00003831 67F7430420000000            test dword [ebx + ehcists], 20h ;Test for doorbell set high
  8126 00003839 7512                        jnz .epc4
  8127 0000383B F390                        pause
  8128 0000383D 66FFCF                      dec di
  8129 00003840 7440                        jz .epcfaildelinked
  8130 00003842 B486                        mov ah, 86h
  8131 00003844 B901000000                  mov ecx, 1    ;Max 5s in 1ms chunks
  8132 00003849 CD35                        int 35h
  8133 0000384B EBE4                        jmp short .epc3
  8134                                  .epc4:
  8135                                  ;Clear once more to clear the doorbell bit
  8136 0000384D 678B4B04                    mov ecx, dword [ebx + ehcists]  
  8137 00003851 67094B04                    or dword  [ebx + ehcists], ecx    ;WC high bits
  8138                                  ;Check if it was a stall
  8139 00003855 F60425[48020000]02          test byte [eActiveInt], 2h  ;Check USBError bit
  8140 0000385D 7509                        jnz .epcexit
  8141 0000385F C60425[A9010000]00          mov byte [msdStatus], 00h   ;No error... yet
  8142 00003867 F8                          clc
  8143                                  .epcexit:
  8144 00003868 5F                          pop rdi
  8145 00003869 59                          pop rcx
  8146 0000386A 5B                          pop rbx
  8147 0000386B 58                          pop rax
  8148 0000386C C3                          ret 
  8149                                  .epcStall:
  8150 0000386D C60425[A9010000]21          mov byte [msdStatus], 21h   ;General Controller Failure - Stall
  8151 00003875 F9                          stc
  8152 00003876 EBF0                        jmp short .epcexit
  8153                                  .epcfail:
  8154 00003878 E8F7FCFFFF                  call .ehciDelinkOldQHead   ;Perform delink
  8155 0000387D E8CAFCFFFF                  call .ehciToggleTransactingQHead    ;Toggle the active Qheads
  8156                                  .epcfailedstart: ;No need to delink as that data structure is considered garbage
  8157                                  .epcfaildelinked:
  8158 00003882 678B4B04                    mov ecx, dword [ebx + ehcists]
  8159 00003886 67094B04                    or dword  [ebx + ehcists], ecx    ;WC selected bits
  8160                                  .epcHostError:  ;Host error detected in interrupt register
  8161 0000388A C60425[A9010000]20          mov byte [msdStatus], 20h   ;General Controller Error
  8162 00003892 F9                          stc
  8163 00003893 EBD3                        jmp short .epcexit
  8164                                  .epcfailtimeout:
  8165                                  ;Called in the event that the schedule fails to process the QHead.
  8166                                  ;Emergency stops the currently transacting schedule
  8167 00003895 E8DAFCFFFF                  call .ehciDelinkOldQHead   ;Perform delink
  8168 0000389A E8ADFCFFFF                  call .ehciToggleTransactingQHead    ;Toggle the active Qheads
  8169 0000389F 678B4B04                    mov ecx, dword [ebx + ehcists]
  8170 000038A3 67094B04                    or dword  [ebx + ehcists], ecx    ;WC selected bits
  8171 000038A7 C60425[A9010000]80          mov byte [msdStatus], 80h   ;Timeout Error
  8172 000038AF F9                          stc
  8173 000038B0 EBB6                        jmp short .epcexit  ;Delink
  8174                                  
  8175                                  .ehciEnumerateRootPort:
  8176                                  ;This function discovers whether a device is of a valid type
  8177                                  ;or not.
  8178                                  ;Input: dl=port number - 1 (0 based), dh = bus [0-3]
  8179                                  ;       r10b = Host hub address (if the device is on a hub, 0 else)
  8180                                  ;Output:     CF=CY if error, CF=NC if bus transaction occured 
  8181                                  ;           ZF=ZR if passed enum: ah = bus number, al = Address number
  8182                                  ;            ZF=NZ if the device failed enumeration: ax=error code
  8183                                  ;                ah = Enum stage, al = Sub function stage
  8184 000038B2 53                          push rbx
  8185 000038B3 51                          push rcx
  8186 000038B4 52                          push rdx
  8187 000038B5 55                          push rbp
  8188 000038B6 4150                        push r8
  8189 000038B8 4151                        push r9
  8190 000038BA 4152                        push r10
  8191 000038BC 4153                        push r11
  8192                                  
  8193                                  .eebinit:
  8194 000038BE 6631ED                      xor bp, bp    ;Use as error counter    (Stage 0)
  8195 000038C1 88D0                        mov al, dl
  8196 000038C3 E818FAFFFF                  call .ehciResetControllerPort    ;Reset port
  8197 000038C8 0F828C010000                jc .ehciedbadnotimeout
  8198                                  ;Power on debounce!
  8199 000038CE B9C8000000                  mov ecx, debounceperiod    ;debounce period
  8200 000038D3 B486                        mov ah, 86h
  8201 000038D5 CD35                        int 35h
  8202                                  
  8203 000038D7 66FFC5                      inc bp    ;Increment Error Counter    (Stage 1)
  8204                                  .eeb0:
  8205 000038DA 48BB80060001000008-         mov rbx, 00008000001000680h    ;Pass get minimal device descriptor
  8205 000038E3 00                 
  8206 000038E4 48891C25[80030000]          mov qword [ehciDataOut], rbx
  8207 000038EC 66B94000                    mov cx, 40h    ;Pass default endpoint size
  8208 000038F0 30C0                        xor al, al
  8209 000038F2 E898FDFFFF                  call .ehciGetRequest
  8210 000038F7 0F8245010000                jc .ehciedexit  ;Fast exit with carry set
  8211                                  .eeb1:
  8212 000038FD 66FFC5                      inc bp    ;Increment Error Counter    (Stage 2)
  8213 00003900 30C0                        xor al, al    ;Increment Error subcounter    (Substage 0)
  8214 00003902 48BB-                       mov rbx, ehciDataIn
  8214 00003904 [C003000000000000] 
  8215 0000390C 807B0101                    cmp byte [rbx + 1], 01h    ;Verify this is a valid dev descriptor
  8216 00003910 0F8539010000                jne .ehciedbad
  8217 00003916 FEC0                        inc al    ;Increment Error subcounter    (Substage 1)
  8218 00003918 66817B020002                cmp word [rbx + 2], 0200h    ;Verify this is a USB 2.0 device or above
  8219 0000391E 0F822B010000                jb .ehciedbad
  8220 00003924 FEC0                        inc al    ;Increment Error subcounter    (Substage 2)
  8221 00003926 807B0400                    cmp byte [rbx + 4], 0    ;Check interfaces
  8222 0000392A 7410                        je .eeb2
  8223 0000392C 807B0408                    cmp byte [rbx + 4], 08h    ;MSD?
  8224 00003930 740A                        je .eeb2
  8225 00003932 807B0409                    cmp byte [rbx + 4], 09h    ;Hub?
  8226 00003936 0F8513010000                jne .ehciedbad
  8227                                  .eeb2:
  8228 0000393C 66FFC5                      inc bp    ;Increment Error Counter    (Stage 3)
  8229 0000393F 440FB64307                  movzx r8d, byte [rbx + 7]    ;Byte 7 is MaxPacketSize0, save in r8b
  8230 00003944 88D0                        mov al, dl
  8231                                  
  8232 00003946 E895F9FFFF                  call .ehciResetControllerPort    ;Reset port again
  8233 0000394B 0F82FE000000                jc .ehciedbad
  8234 00003951 49BB0A000000000000-         mov r11, 10
  8234 0000395A 00                 
  8235                                  .ehciEnumCommonEp:
  8236 0000395B 66FFC5                      inc bp    ;Increment Error Counter    (Stage 4)
  8237 0000395E 88F0                        mov al, dh    ;Put bus number into al
  8238                                  
  8239 00003960 E825030000                  call .ehciGiveValidAddress    ;Get a valid address for device
  8240 00003965 3C80                        cmp al, 80h    
  8241 00003967 0F83E2000000                jae .ehciedbad    ;Invalid address
  8242                                  
  8243 0000396D 66FFC5                      inc bp    ;Increment Error Counter    (Stage 5)
  8244 00003970 4188C1                      mov r9b, al        ;Save the new device address number in r9b
  8245                                  .eeb3:
  8246 00003973 BB00050000                  mov ebx, 0500h    ;Set address function
  8247 00003978 410FB6C9                    movzx ecx, r9b    ;move new address into ecx
  8248 0000397C C1E110                      shl ecx, 8*2
  8249 0000397F 09CB                        or ebx, ecx    ;Add address number to ebx
  8250 00003981 664489C1                    mov cx, r8w    ;Move endpoint size into cx
  8251 00003985 30C0                        xor al, al    ;Device still talks on address 0, ax not preserved
  8252 00003987 E864FCFFFF                  call .ehciSetNoData    ;Set address
  8253 0000398C 0F82B0000000                jc .ehciedexit  ;Fast exit with carry set
  8254                                  .eeb4:
  8255 00003992 B486                        mov ah, 86h
  8256 00003994 4C89D9                      mov rcx, r11
  8257 00003997 CD35                        int 35h
  8258                                  
  8259 00003999 66FFC5                      inc bp    ;Increment Error Counter    (Stage 6)
  8260                                  .eeb5:
  8261 0000399C 48BB80060001000012-         mov rbx, 00012000001000680h    ;Now get full device descriptor
  8261 000039A5 00                 
  8262 000039A6 4488C8                      mov al, r9b    ;Get address
  8263 000039A9 664489C1                    mov cx, r8w
  8264 000039AD E8DDFCFFFF                  call .ehciGetRequest    ;Get full device descriptor and discard
  8265 000039B2 0F828A000000                jc .ehciedexit  ;Fast exit with carry set
  8266 000039B8 66FFC5                      inc bp    ;Increment Error Counter    (Stage 7/0Bh)
  8267                                  .eeb6:
  8268 000039BB 48BB80060002000000-         mov rbx, 00000000002000680h ;Get config descriptor
  8268 000039C4 00                 
  8269 000039C5 4489C1                      mov ecx, r8d    ;Adjust the packet data with bMaxPacketSize0
  8270 000039C8 48C1E130                    shl rcx, 8*6    ;cx contains bMaxPacketSize0
  8271 000039CC 4809CB                      or rbx, rcx
  8272 000039CF 4488C8                      mov al, r9b    ;Get address
  8273 000039D2 664489C1                    mov cx, r8w    ;Move endpoint size into cx
  8274 000039D6 E8B4FCFFFF                  call .ehciGetRequest
  8275 000039DB 7265                        jc .ehciedexit  ;Fast exit with carry set
  8276                                  .eeb7:
  8277 000039DD 66FFC5                      inc bp    ;Increment Error Counter    (Stage 8/0Ch)
  8278                                  ;Find a valid interface in this config
  8279 000039E0 E8CB020000                  call .ehciFindValidInterface
  8280 000039E5 7268                        jc .ehciedbad    ;Dont set config, exit bad
  8281                                  ;If success, ah has device type (0=msd, 1=hub), al = Interface to use
  8282                                  ;rbx points to interface descriptor
  8283 000039E7 66FFC5                      inc bp    ;Increment Error Counter    (Stage 9/0Dh)
  8284 000039EA E889000000                  call .ehciAddDeviceToTables
  8285 000039EF 725E                        jc .ehciedbad    ;Failed to be added to internal tables
  8286 000039F1 FE0425[35020000]            inc byte [usbDevices]   ;Device added successfully, inc byte
  8287                                  ;Set configuration 1 (wie OG Windows, consider upgrading soon)
  8288 000039F8 66FFC5                      inc bp    ;Increment Error Counter    (Stage 0Ah/0Ch)
  8289                                  .eeb8:
  8290 000039FB 48BB00090100000000-         mov rbx, 00000000000010900h    ;Set configuration 1 (function 09h)
  8290 00003A04 00                 
  8291 00003A05 4488C8                      mov al, r9b    ;Get address
  8292 00003A08 664489C1                    mov cx, r8w    ;Move endpoint size into cx
  8293 00003A0C E8DFFBFFFF                  call .ehciSetNoData
  8294 00003A11 722F                        jc .ehciedexit  ;Fast exit with carry set
  8295                                  .eeb9:
  8296 00003A13 66FFC5                      inc bp    ;Increment Error Counter    (Stage 0Bh/0Dh)
  8297                                  .eeb10:
  8298 00003A16 48BB80080000000001-         mov rbx, 0001000000000880h  ;Get device config (sanity check)
  8298 00003A1F 00                 
  8299 00003A20 410FB7C8                    movzx ecx, r8w              ;bMaxPacketSize0
  8300 00003A24 4488C8                      mov al, r9b                 ;Get device address
  8301 00003A27 E863FCFFFF                  call .ehciGetRequest
  8302 00003A2C 7214                        jc .ehciedexit  ;Fast exit with carry set
  8303                                  .eeb11:
  8304 00003A2E 66FFC5                      inc bp    ;Increment Error Counter    (Stage 0Ch/0Eh)
  8305 00003A31 803C25[C0030000]01          cmp byte [ehciDataIn], 01
  8306 00003A39 7531                        jne .ehcibadremtables
  8307                                  ;Device is now configured and ready to go to set/reset
  8308 00003A3B 88F4                        mov ah, dh  ;Move bus number
  8309 00003A3D 4488C8                      mov al, r9b ;Move address number
  8310 00003A40 31D2                        xor edx, edx  ;This will always set the zero flag
  8311                                  .ehciedexit:
  8312 00003A42 415B                        pop r11
  8313 00003A44 415A                        pop r10
  8314 00003A46 4159                        pop r9
  8315 00003A48 4158                        pop r8
  8316 00003A4A 5D                          pop rbp
  8317 00003A4B 5A                          pop rdx
  8318 00003A4C 59                          pop rcx
  8319 00003A4D 5B                          pop rbx
  8320 00003A4E C3                          ret
  8321                                  .ehciedbad:
  8322                                  .ehciedbadnoport:
  8323 00003A4F 50                          push rax
  8324 00003A50 B486                        mov ah, 86h
  8325 00003A52 B9F4010000                  mov ecx, 500    ;500 ms wait between failed attempts
  8326 00003A57 CD35                        int 35h
  8327 00003A59 58                          pop rax
  8328                                  .ehciedbadnotimeout:
  8329 00003A5A 88C4                        mov ah, al    ;Save subproc error code
  8330 00003A5C 30C0                        xor al, al    ;Zero byte
  8331 00003A5E 6609E8                      or ax, bp    ;Add proc error stage code into al
  8332 00003A61 86E0                        xchg ah, al
  8333 00003A63 6631ED                      xor bp, bp
  8334 00003A66 66FFC5                      inc bp      ;This will always clear the Zero flag
  8335 00003A69 F8                          clc         ;This will force clear the Carry flag
  8336 00003A6A EBD6                        jmp short .ehciedexit
  8337                                  .ehcibadremtables:
  8338 00003A6C 4488C8                      mov al, r9b ;Get address low
  8339 00003A6F 88F4                        mov ah, dh  
  8340 00003A71 E87F010000                  call .ehciRemoveDevFromTables
  8341 00003A76 EBE2                        jmp short .ehciedbadnotimeout
  8342                                  
  8343                                  .ehciAddDeviceToTables:
  8344                                  ;This function adds a valid device to the internal tables.
  8345                                  ;Interrupts are off for this to avoid dead entries
  8346                                  ;Input: ah = device type (0=msd, 1=hub)
  8347                                  ;       al = Interface Value to use (USB bInterfaceNumber)
  8348                                  ;       rbx = Ptr to valid Interface descriptor
  8349                                  ;       r8b = MaxPacketSize0
  8350                                  ;       r9b = Device Address
  8351                                  ;       dh = Bus number
  8352                                  ;       dl = Physical Port number - 1
  8353                                  ;       r10b = Host hub address
  8354 00003A78 4153                        push r11
  8355 00003A7A 55                          push rbp    ;Error counter
  8356 00003A7B 57                          push rdi
  8357 00003A7C 53                          push rbx
  8358 00003A7D 52                          push rdx
  8359 00003A7E 9C                          pushfq
  8360 00003A7F FEC2                        inc dl      ;Add one to the Physical port number (kludge for root hub enum)
  8361 00003A81 6631ED                      xor bp, bp  ;Zero error counter (Stage 0)
  8362 00003A84 B90A000000                  mov ecx, usbMaxDevices
  8363 00003A89 380C25[35020000]            cmp byte [usbDevices], cl   ;Max number of devices, check
  8364 00003A90 0F8458010000                je .eadttbad        ;If max, fail
  8365 00003A96 66FFC5                      inc bp      ;Increment error counter (Stage 1)
  8366 00003A99 48BF-                       mov rdi, usbDevTbl
  8366 00003A9B [4C02000000000000] 
  8367 00003AA3 B10A                        mov cl, usbDevTblE  ;Within the length of the table
  8368                                  ;Write Common table first
  8369                                  .eadtt0:
  8370 00003AA5 800F00                      or byte [rdi], 0   ;Check if there exists a free entry
  8371 00003AA8 7411                        jz .eadtt1
  8372 00003AAA 4881C703000000              add rdi, usbDevTblEntrySize ;Go to next entry
  8373 00003AB1 FEC9                        dec cl
  8374 00003AB3 0F8435010000                jz .eadttbad
  8375 00003AB9 EBEA                        jmp short .eadtt0
  8376                                  .eadtt1:
  8377 00003ABB 66FFC5                      inc bp      ;Increment error counter (Stage 2)
  8378 00003ABE 80C408                      add ah, 08h ;hub is 09h
  8379                                  ;Add device here, rdi points to entry
  8380 00003AC1 44880F                      mov byte [rdi], r9b
  8381 00003AC4 887701                      mov byte [rdi + 1], dh
  8382 00003AC7 886702                      mov byte [rdi + 2], ah
  8383                                  ;Entry written
  8384 00003ACA 66FFC5                      inc bp      ;Increment error counter (Stage 3)
  8385                                  ;Individual Device table writing
  8386 00003ACD 80FC08                      cmp ah, 08h
  8387 00003AD0 740E                        je .eadttmsd
  8388 00003AD2 80FC09                      cmp ah, 09h
  8389 00003AD5 0F84C9000000                je .eadtthub
  8390 00003ADB E90E010000                  jmp .eadttbad
  8391                                  .eadttmsd:
  8392 00003AE0 48BF-                       mov rdi, msdDevTbl
  8392 00003AE2 [BA02000000000000] 
  8393 00003AEA B10A                        mov cl, msdDevTblE  ;Max entries possible
  8394 00003AEC 66FFC5                      inc bp      ;Increment error counter (Stage 4)
  8395                                  .eadttmsd0:
  8396 00003AEF 800F00                      or byte [rdi], 0
  8397 00003AF2 7411                        jz .eadttmsd1
  8398 00003AF4 4881C710000000              add rdi, msdDevTblEntrySize
  8399 00003AFB FEC9                        dec cl
  8400 00003AFD 0F84EB000000                jz .eadttbad
  8401 00003B03 EBEA                        jmp short .eadttmsd0
  8402                                  .eadttmsd1:
  8403                                  ;rdi points to correct offset into table
  8404                                  ;rbx points to interface
  8405 00003B05 8A4B04                      mov cl, byte [rbx + 4]   ;Get number of endpoints to check
  8406 00003B08 88CD                        mov ch, cl
  8407 00003B0A 66FFC5                      inc bp      ;Increment error counter (Stage 5)
  8408 00003B0D 4989DB                      mov r11, rbx    ;Save Interface Pointer in r11
  8409 00003B10 4881C309000000              add rbx, 9  ;Go to first IF
  8410                                  .eadttmsd11:
  8411 00003B17 50                          push rax
  8412 00003B18 668B4302                    mov ax, word [rbx + 2]
  8413 00003B1C 66C1E804                    shr ax, 4   ;Remove low 4 bits
  8414 00003B20 663D2800                    cmp ax, 28h     ;Bulk/In bits
  8415 00003B24 58                          pop rax         ;Doesnt ruin flags
  8416 00003B25 7411                        je .eadttmsd2   ;Not zero only if valid
  8417 00003B27 4881C307000000              add rbx, 7   ;Go to next endpoint
  8418 00003B2E FEC9                        dec cl
  8419 00003B30 0F84B8000000                jz .eadttbad
  8420 00003B36 EBDF                        jmp short .eadttmsd11
  8421                                  .eadttmsd2:
  8422 00003B38 44880F                      mov byte [rdi], r9b      ;Device Address
  8423 00003B3B 887701                      mov byte [rdi + 1], dh   ;Root hub/bus
  8424 00003B3E 44885702                    mov byte [rdi + 2], r10b ;Address of parent device if not root
  8425 00003B42 885703                      mov byte [rdi + 3], dl   ;Port number we are inserted in
  8426 00003B45 884704                      mov byte [rdi + 4], al   ;Save Interface number
  8427 00003B48 418A4306                    mov al, byte [r11 + 6]   ;bInterfaceSubclass is +6
  8428 00003B4C 884705                      mov byte [rdi + 5], al
  8429 00003B4F 418A4307                    mov al, byte [r11 + 7]   ;Protocol
  8430 00003B53 884706                      mov byte [rdi + 6], al
  8431 00003B56 44884707                    mov byte [rdi + 7], r8b  ;MaxPacketSize0
  8432                                  ;Valid In EP found, write table entries
  8433 00003B5A 8A4302                      mov al, byte [rbx + 2]  ;Get address
  8434 00003B5D 884708                      mov byte [rdi + 8], al
  8435 00003B60 668B4304                    mov ax, word [rbx + 4]  ;Get maxPacketSizeIn
  8436 00003B64 66894709                    mov word [rdi + 9], ax
  8437                                  
  8438 00003B68 498D5B09                    lea rbx, qword [r11 + 9]   ;Return rbx to first IF
  8439 00003B6C 66FFC5                      inc bp      ;Increment error counter (Stage 6)
  8440                                  .eadttmsd21:
  8441 00003B6F 668B4302                    mov ax, word [rbx + 2]  ;Bulk/Out bits
  8442 00003B73 66C1E804                    shr ax, 4
  8443 00003B77 663D2000                    cmp ax, 20h
  8444 00003B7B 740D                        je .eadttmsd3   ;Not zero only if valid
  8445 00003B7D 4881C307000000              add rbx, 7   ;Go to next endpoint
  8446 00003B84 FECD                        dec ch
  8447 00003B86 7466                        jz .eadttbad
  8448 00003B88 EBE5                        jmp short .eadttmsd21
  8449                                  .eadttmsd3:
  8450 00003B8A 8A4302                      mov al, byte [rbx + 2]  ;Get address
  8451 00003B8D 88470B                      mov byte [rdi + 11], al
  8452 00003B90 668B4304                    mov ax, word [rbx + 4]  ;Get maxPacketSizeIn
  8453 00003B94 6689470C                    mov word [rdi + 12], ax
  8454 00003B98 6631C0                      xor ax, ax  ;Zero ax
  8455 00003B9B 6689470E                    mov word [rdi + 14], ax ;Make dt bits for I/O EPs zero
  8456                                  ;Table entry written for MSD device
  8457 00003B9F E93F000000                  jmp .eadttpass
  8458                                  .eadtthub:
  8459 00003BA4 48BF-                       mov rdi, hubDevTbl
  8459 00003BA6 [6A02000000000000] 
  8460 00003BAE B10A                        mov cl,  hubDevTblE ;Max entries possible
  8461 00003BB0 66BD0700                    mov bp, 7      ;Increment error counter (Stage 7)
  8462                                  .eadtthub0:
  8463 00003BB4 800F00                      or byte [rdi], 0
  8464 00003BB7 740D                        jz .eadtthub1
  8465 00003BB9 4881C708000000              add rdi, hubDevTblEntrySize
  8466 00003BC0 FEC9                        dec cl
  8467 00003BC2 742A                        jz .eadttbad
  8468 00003BC4 EBEE                        jmp short .eadtthub0
  8469                                  .eadtthub1:
  8470                                  ;Valid table space found
  8471 00003BC6 44880F                      mov byte [rdi], r9b      ;Device Address
  8472 00003BC9 887701                      mov byte [rdi + 1], dh   ;Root hub/bus
  8473 00003BCC 44885702                    mov byte [rdi + 2], r10b ;Address of parent device if not root
  8474 00003BD0 885703                      mov byte [rdi + 3], dl   ;Port number we are inserted in
  8475 00003BD3 44884704                    mov byte [rdi + 4], r8b  ;MaxPacketSize0
  8476 00003BD7 66B800FF                    mov ax, 0FF00h  ;Res byte is 0FFh, Num ports (byte 6) is 0
  8477 00003BDB 66894705                    mov word [rdi + 5], ax   ;Number of ports and PowerOn2PowerGood
  8478 00003BDF C64707FF                    mov byte [rdi + 7], 0FFh    ;EP address, currently reserved
  8479                                  .eadttpass:
  8480 00003BE3 9D                          popfq   ;If IF was clear, it will be set clear by popf
  8481 00003BE4 6631C0                      xor ax, ax  ;Clear ax and clc
  8482                                  .eadttexit:
  8483 00003BE7 5A                          pop rdx
  8484 00003BE8 5B                          pop rbx
  8485 00003BE9 5F                          pop rdi
  8486 00003BEA 5D                          pop rbp
  8487 00003BEB 415B                        pop r11
  8488 00003BED C3                          ret
  8489                                  .eadttbad:
  8490 00003BEE 9D                          popfq   ;If IF was clear, it will be set clear by popf
  8491 00003BEF F9                          stc
  8492 00003BF0 6689E8                      mov ax, bp
  8493 00003BF3 EBF2                        jmp short .eadttexit
  8494                                  .ehciRemoveDevFromTables:
  8495                                  ;This function removes a function from internal tables
  8496                                  ;Input: al = Address number, ah = Bus number
  8497                                  ;Output: Internal tables zeroed out, ax destroyed, Carry clear
  8498                                  ;    If invalid argument, Carry set
  8499 00003BF5 57                          push rdi
  8500 00003BF6 51                          push rcx
  8501 00003BF7 53                          push rbx
  8502 00003BF8 48BF-                       mov rdi, usbDevTbl
  8502 00003BFA [4C02000000000000] 
  8503 00003C02 B10A                        mov cl, usbDevTblE    ;10 entries possible
  8504                                  .erdft0:
  8505 00003C04 66AF                        scasw
  8506 00003C06 7409                        je .erdft1    ;Device signature found
  8507 00003C08 48FFC7                      inc rdi
  8508 00003C0B FEC9                        dec cl
  8509 00003C0D 7478                        jz .erdftbad
  8510 00003C0F EBF3                        jmp short .erdft0
  8511                                  .erdft1:
  8512 00003C11 4881EF02000000              sub rdi, 2  ;scasw pointers to the next word past the comparison
  8513 00003C18 8A6702                      mov ah, byte [rdi + 2]    ;Save class code in ah
  8514 00003C1B 80FC08                      cmp ah, 08h ;USB MSD Class device
  8515 00003C1E 7507                        jne .erdft11    ;Skip the dec if it is a hub class device
  8516 00003C20 FE0C25[4B020000]            dec byte [numMSD]   ;Device is being removed from tables, decrement count
  8517                                  .erdft11:
  8518                                  ;Clear usbDevTbl entry for usb device
  8519 00003C27 50                          push rax
  8520 00003C28 B903000000                  mov ecx, usbDevTblEntrySize    ;Table entry size
  8521 00003C2D 30C0                        xor al, al
  8522 00003C2F F3AA                        rep stosb    ;Store zeros for entry
  8523 00003C31 58                          pop rax
  8524                                  
  8525 00003C32 48BB-                       mov rbx, hubDevTbl
  8525 00003C34 [6A02000000000000] 
  8526 00003C3C 48B9-                       mov rcx, msdDevTbl
  8526 00003C3E [BA02000000000000] 
  8527 00003C46 80FC09                      cmp ah, 09h
  8528 00003C49 480F44CB                    cmove rcx, rbx ;If 09h (Hub), change table pointed to by rcx
  8529 00003C4D 4889CF                      mov rdi, rcx    ;Point rdi to appropriate table
  8530 00003C50 BB08000000                  mov ebx, hubDevTblEntrySize    ;Size of hub table entry
  8531 00003C55 B910000000                  mov ecx, msdDevTblEntrySize    ;Size of msd table entry
  8532 00003C5A 80FC09                      cmp ah, 09h
  8533 00003C5D 0F44CB                      cmove ecx, ebx    ;If hub, move size into cx
  8534                                  ;cx has entry size, rdi points to appropriate table
  8535 00003C60 4889FB                      mov rbx, rdi
  8536 00003C63 31FF                        xor edi, edi
  8537 00003C65 29CF                        sub edi, ecx
  8538 00003C67 B411                        mov ah, 11h
  8539                                  .erdft2:
  8540 00003C69 FECC                        dec ah
  8541 00003C6B 741A                        jz .erdftbad    ;Somehow, address not found
  8542 00003C6D 01CF                        add edi, ecx
  8543 00003C6F 3A043B                      cmp al, byte [rbx + rdi]
  8544 00003C72 75F5                        jne .erdft2
  8545 00003C74 4801DF                      add rdi, rbx    ;point rdi to table entry
  8546 00003C77 30C0                        xor al, al
  8547 00003C79 F3AA                        rep stosb    ;ecx contains table entry size in bytes
  8548 00003C7B FE0C25[35020000]            dec byte [usbDevices]   ;Decrement total usb devices
  8549 00003C82 F8                          clc
  8550                                  .erdftexit:
  8551 00003C83 5B                          pop rbx
  8552 00003C84 59                          pop rcx
  8553 00003C85 5F                          pop rdi
  8554 00003C86 C3                          ret
  8555                                  .erdftbad:
  8556 00003C87 F9                          stc
  8557 00003C88 EBF9                        jmp short .erdftexit 
  8558                                  .ehciGiveValidAddress:
  8559                                  ;This function will return a valid value to use as an address
  8560                                  ;for a new device.
  8561                                  ;Input: al = Controller number [0-3]
  8562                                  ;Output: al = Address, or 80h => No valid available address
  8563 00003C8A 57                          push rdi
  8564 00003C8B 51                          push rcx
  8565 00003C8C 88C4                        mov ah, al    ;Move bus number high
  8566 00003C8E B000                        mov al, 0 ;Address 0, start at addr 1
  8567                                  .egva0:
  8568 00003C90 FEC0                        inc al
  8569 00003C92 3C80                        cmp al, 80h
  8570 00003C94 7317                        jae .egvaexit
  8571 00003C96 48BF-                       mov rdi, usbDevTbl
  8571 00003C98 [4C02000000000000] 
  8572 00003CA0 B10A                        mov cl, usbDevTblE    ;10 entries possible
  8573                                  .egva1:
  8574 00003CA2 66AF                        scasw
  8575 00003CA4 74EA                        je .egva0
  8576 00003CA6 48FFC7                      inc rdi    ;Pass third byte in table entry
  8577 00003CA9 FEC9                        dec cl
  8578 00003CAB 75F5                        jnz .egva1    ;Check every entry for any addresses being used
  8579                                  .egvaexit:
  8580 00003CAD 59                          pop rcx
  8581 00003CAE 5F                          pop rdi
  8582 00003CAF C3                          ret 
  8583                                  .ehciFindValidInterface:
  8584                                  ;A proc to check a valid interface descriptor is present. 
  8585                                  ;Input: Nothing [Assumes Get Config was called in standard buffer]
  8586                                  ;Output: Carry set if invalid. Carry clear if valid.
  8587                                  ;    On success: ah = device type (0 is msd, 1 is hub)
  8588                                  ;                al = interface number to set
  8589                                  ;               rbx = Pointer to Interface Descriptor
  8590                                  ;   On fail: al contains error code, registers rbx, cx, dx destroyed
  8591 00003CB0 56                          push rsi
  8592 00003CB1 57                          push rdi
  8593 00003CB2 51                          push rcx
  8594 00003CB3 52                          push rdx
  8595                                  
  8596 00003CB4 48BE-                       mov rsi, ehciDataIn    ;Shift to buffer
  8596 00003CB6 [C003000000000000] 
  8597 00003CBE 30D2                        xor dl, dl    ;Error code counter
  8598 00003CC0 807E0102                    cmp byte [rsi + 1], 02h    ;Check if valid config descriptor
  8599 00003CC4 753F                        jne .ecvifail
  8600 00003CC6 FEC2                        inc dl
  8601                                  ;cl counts ep's per interface, ch counts possible interfaces
  8602 00003CC8 8A6E05                      mov ch, byte [rsi + 5]        ;Get number of interfaces
  8603                                  .ecvi0:
  8604 00003CCB 84ED                        test ch, ch
  8605 00003CCD 7436                        jz .ecvifail    ;Zero interfaces is invalid for us
  8606 00003CCF FEC2                        inc dl
  8607                                  
  8608 00003CD1 4889F3                      mov rbx, rsi    ;Save this descriptor in rbx
  8609 00003CD4 480FB633                    movzx rsi, byte [rbx]    ;get the size of the config to skip
  8610 00003CD8 4801DE                      add rsi, rbx    ;point rsi to head of first interface descriptor
  8611 00003CDB 807E0104                    cmp byte [rsi + 1], 04h    ;Check if valid interface descriptor
  8612 00003CDF 7524                        jne .ecvifail
  8613 00003CE1 FEC2                        inc dl
  8614 00003CE3 8A4E04                      mov cl, byte [rsi + 4]
  8615                                  ;Cmp IF has valid class/prototcol
  8616 00003CE6 4831C0                      xor rax, rax    ;Device signature, 0 is msd, 1 is hub
  8617 00003CE9 E859000000                  call .ehciCheckMsdIf
  8618 00003CEE 7309                        jnc    .ecviif    ;Not clear => valid interface
  8619 00003CF0 FEC4                        inc ah    ;Device signature, 0 is msd, 1 is hub
  8620 00003CF2 E831000000                  call .ehciCheckHubIf
  8621 00003CF7 7213                        jc    .ecvibadif    ;Clear => bad interface
  8622                                  .ecviif:    ;Valid interface found
  8623 00003CF9 8A4602                      mov al, byte [rsi + 2]    ;Get interface number into al
  8624 00003CFC 4889F3                      mov rbx, rsi    ;Save pointer in rbx for return
  8625 00003CFF F8                          clc ;Clear carry
  8626                                  .ecviexit:
  8627 00003D00 5A                          pop rdx
  8628 00003D01 59                          pop rcx
  8629 00003D02 5F                          pop rdi
  8630 00003D03 5E                          pop rsi
  8631 00003D04 C3                          ret
  8632                                  .ecvifail:
  8633 00003D05 31DB                        xor ebx, ebx    ;Zero rbx for bad returns
  8634 00003D07 F9                          stc
  8635 00003D08 88D0                        mov al, dl    ;Move error code
  8636 00003D0A EBF4                        jmp short .ecviexit
  8637                                  .ecvibadif:    ;Bad interface, goto next interface
  8638 00003D0C 84C9                        test cl, cl
  8639 00003D0E 740B                        jz .ecvibadif1
  8640 00003D10 FEC9                        dec cl
  8641 00003D12 4881C607000000              add rsi, 7
  8642 00003D19 EBF1                        jmp short .ecvibadif
  8643                                  .ecvibadif1:
  8644 00003D1B 4881C609000000              add rsi, 9
  8645 00003D22 FECD                        dec ch
  8646 00003D24 B201                        mov dl, 1
  8647 00003D26 EBA3                        jmp short .ecvi0
  8648                                  .ehciCheckHubIf:
  8649                                  ;Input: rsi points to interface descriptor
  8650                                  ;Output: All registers preserved, carry set if NOT valid hub
  8651 00003D28 56                          push rsi
  8652 00003D29 807E0509                    cmp byte [rsi + 5], 09h
  8653 00003D2D 7515                        jne .ecdhfail
  8654 00003D2F 807E0600                    cmp byte [rsi + 6], 0
  8655 00003D33 750F                        jne .ecdhfail
  8656 00003D35 807E0702                    cmp byte [rsi + 7], 2
  8657 00003D39 7709                        ja .ecdhfail
  8658 00003D3B 807E0401                    cmp byte [rsi + 4], 1    ;One endpoint to rule them all
  8659 00003D3F 7503                        jne .ecdhfail
  8660 00003D41 F8                          clc 
  8661                                  .ecdhexit:
  8662 00003D42 5E                          pop rsi
  8663 00003D43 C3                          ret
  8664                                  .ecdhfail:
  8665 00003D44 F9                          stc
  8666 00003D45 EBFB                        jmp short .ecdhexit
  8667                                  .ehciCheckMsdIf:
  8668                                  ;Input: rsi points to interface descriptor
  8669                                  ;Output: Carry set if fail, ax destroyed
  8670                                  ;    rsi points to good descriptor if all ok
  8671                                  ;Note we only accept 09/00/50 and 09/06/50
  8672 00003D47 56                          push rsi
  8673 00003D48 53                          push rbx
  8674 00003D49 51                          push rcx
  8675 00003D4A 807E0508                    cmp byte [rsi + 5], 08h    ;MSD class
  8676 00003D4E 7517                        jne .ecdmfail
  8677                                  ;Subclass check
  8678 00003D50 807E0606                    cmp byte [rsi + 6], 06h    ;SCSI actual
  8679 00003D54 7406                        je .ecdmprot
  8680 00003D56 807E0600                    cmp byte [rsi + 6], 00h    ;SCSI defacto
  8681 00003D5A 750B                        jne .ecdmfail
  8682                                  .ecdmprot:
  8683 00003D5C 807E0750                    cmp byte [rsi + 7], 50h    ;BBB
  8684 00003D60 7505                        jne .ecdmfail
  8685                                  .ecdmprotUAF:   ;Dummy label to find where to add this later
  8686                                  .ecdmpass:
  8687 00003D62 F8                          clc
  8688                                  .ecdmexit:
  8689 00003D63 59                          pop rcx
  8690 00003D64 5B                          pop rbx
  8691 00003D65 5E                          pop rsi
  8692 00003D66 C3                          ret
  8693                                  .ecdmfail:
  8694 00003D67 F9                          stc
  8695 00003D68 EBF9                        jmp short .ecdmexit
  8696                                  .ehciGetDevicePtr:
  8697                                  ;Gets address/bus pair and returns in rax a pointer to the data
  8698                                  ;structure of the device, in the data table.
  8699                                  ;Input: ah = bus number, al = Address number
  8700                                  ;Output: ax = Preserved, rsi = Pointer to table structure, bl = USB Class Code
  8701 00003D6A 51                          push rcx
  8702 00003D6B 52                          push rdx
  8703 00003D6C 55                          push rbp
  8704 00003D6D B90A000000                  mov ecx, usbMaxDevices
  8705 00003D72 48BE-                       mov rsi, usbDevTbl
  8705 00003D74 [4C02000000000000] 
  8706                                  .egdp0:
  8707 00003D7C 663B06                      cmp ax, word [rsi]
  8708 00003D7F 740E                        je .egdp1   ;Device found
  8709 00003D81 4881C603000000              add rsi, usbDevTblEntrySize
  8710 00003D88 66FFC9                      dec cx
  8711 00003D8B 7447                        jz .egdpfail    ;Got to the end with no dev found, exit
  8712 00003D8D EBED                        jmp short .egdp0
  8713                                  .egdp1:
  8714 00003D8F 48BD-                       mov rbp, hubDevTbl
  8714 00003D91 [6A02000000000000] 
  8715 00003D99 B908000000                  mov ecx, hubDevTblEntrySize
  8716 00003D9E 0FB65E02                    movzx ebx, byte [rsi + 2]  ;Return bl for device type
  8717 00003DA2 80FB09                      cmp bl, 09h ;Are we hub?
  8718 00003DA5 48BE-                       mov rsi, msdDevTbl  ;Set to msd
  8718 00003DA7 [BA02000000000000] 
  8719 00003DAF BA10000000                  mov edx, msdDevTblEntrySize
  8720 00003DB4 480F44F5                    cmove rsi, rbp  ;If hub, reload rsi pointer to hub table
  8721 00003DB8 0F44D1                      cmove edx, ecx    ;If hub, reload dx with hub table size
  8722 00003DBB B90A000000                  mov ecx, usbMaxDevices
  8723                                  .egdp2:
  8724 00003DC0 663B06                      cmp ax, word [rsi]
  8725 00003DC3 740A                        je .egdp3
  8726 00003DC5 4801D6                      add rsi, rdx    ;rdx contains size of entry for either table
  8727 00003DC8 66FFC9                      dec cx
  8728 00003DCB 7407                        jz .egdpfail
  8729 00003DCD EBF1                        jmp short .egdp2
  8730                                  .egdp3:
  8731 00003DCF F8                          clc
  8732                                  .egdpexit:
  8733 00003DD0 5D                          pop rbp
  8734 00003DD1 5A                          pop rdx
  8735 00003DD2 59                          pop rcx
  8736 00003DD3 C3                          ret
  8737                                  .egdpfail:
  8738 00003DD4 6631DB                      xor bx, bx
  8739 00003DD7 F9                          stc
  8740 00003DD8 EBF6                        jmp short .egdpexit
  8741                                  
  8742                                  .ehciProbeQhead:
  8743                                  ;A proc that returns a Queue Heads' status byte in bl.
  8744                                  ;Input:
  8745                                  ;   rbx = Address of QHead to probe
  8746                                  ;Output: 
  8747                                  ;   bl = Status byte, if 0, successful transfer!
  8748 00003DDA 8A5B18                      mov bl, byte [rbx + 18h]  ;08h is offset in qTD
  8749 00003DDD C3                          ret
  8750                                  .ehciStandardErrorHandler:
  8751                                  ;Attempts to verify if something went wrong in previous transaction.
  8752                                  ;May only be called if eActiveInt has bit USBSTS bit set
  8753                                  ;Input:  al = Device Address
  8754                                  ;        cx = Default Endpoint Size
  8755                                  ;Output: CF=CY: Host error, Reset host system
  8756                                  ;        CF=NC: Proceed with below
  8757                                  ;        al = 0 => Benign error, Make request again/Verify data.
  8758                                  ;        al = 1 => Stall, Transaction error or Handshake error, corrected.
  8759                                  ;        al = 80h => Fatal error, EPClear errored out, but no clear reason why
  8760                                  ;        al > 80h => Bits 6-0 give the status byte for the error on EP Clear.
  8761                                  ;                  Bit 7 is the fatal error bit. 
  8762                                  ;                  If set, recommend device is port reset.
  8763                                  ;All other registers preserved
  8764 00003DDE 53                          push rbx
  8765 00003DDF 4150                        push r8
  8766 00003DE1 4151                        push r9
  8767                                  
  8768 00003DE3 4989C0                      mov r8, rax
  8769 00003DE6 4989C9                      mov r9, rcx
  8770 00003DE9 30C0                        xor al, al                  ;Set error counter and clear CF
  8771 00003DEB F60425[48020000]02          test byte [eActiveInt], 2   ;Error Interrupt
  8772 00003DF3 744B                        jz .esehexit                ;No error found, should not have been called
  8773 00003DF5 488B1C25[3E020000]          mov rbx, qword [eCurrAsyncHead] ;Get the current transacting QHead address
  8774 00003DFD E8D8FFFFFF                  call .ehciProbeQhead    ;Ret in bl status byte
  8775 00003E02 80E378                      and bl, 01111000b       ;Check if it is something we should clear EP for
  8776 00003E05 7439                        jz .esehexit            ;If it is not, benign error. al = 0
  8777                                  
  8778 00003E07 488B1C25[3E020000]          mov rbx, qword [eCurrAsyncHead] ;Get current AsyncHead again
  8779 00003E0F 4488C0                      mov al, r8b        ;Device Address
  8780 00003E12 664489C9                    mov cx, r9w        ;EP size
  8781 00003E16 8A5B05                      mov bl, byte [rbx + 05h]  ;Get Endpoint to reset
  8782 00003E19 80E30F                      and bl, 0Fh ;Lo nybble only
  8783 00003E1C E828000000                  call .ehciClearEpStallHalt
  8784 00003E21 721D                        jc .esehexit        ;HC error!
  8785 00003E23 B001                        mov al, 1           ;Stall cleared
  8786 00003E25 F60425[48020000]02          test byte [eActiveInt], 2   ;Check if interrupt returned an error
  8787 00003E2D 7411                        jz .esehexit                ;No error found, return al=1, stall cleared
  8788 00003E2F B080                        mov al, 80h                 ;Fatal error indication
  8789 00003E31 488B1C25[3E020000]          mov rbx, qword [eCurrAsyncHead] ;Get the current transacting QHead address
  8790 00003E39 E89CFFFFFF                  call .ehciProbeQhead   
  8791 00003E3E 08D8                        or al, bl          ;Add error bits to al for Fatal error indication.
  8792                                  .esehexit:
  8793 00003E40 4C89C9                      mov rcx, r9
  8794 00003E43 4159                        pop r9
  8795 00003E45 4158                        pop r8
  8796 00003E47 5B                          pop rbx
  8797 00003E48 C3                          ret
  8798                                  
  8799                                  .ehciClearEpStallHalt:
  8800                                  ;Clears a halt or stall on an endpoint.
  8801                                  ;Input: bl=Endpoint (0 for control)
  8802                                  ;       al=Device Address
  8803                                  ;       cx=Ctrl Endpoint Size
  8804                                  ;Output:
  8805                                  ;   CF=CY: Host error, Reset host system
  8806                                  ;   CF=NC: Transaction succeeded, check interrupt error bit for confirmation
  8807 00003E49 53                          push rbx
  8808 00003E4A 480FB6DB                    movzx rbx, bl
  8809 00003E4E 48C1E320                    shl rbx, 2*10h  ;Shift wIndex by two words
  8810 00003E52 4881CB02010000              or rbx, 0102h   ;01=bRequest(CLEAR_FEATURE) 02h=bmRequestType (Endpoint)
  8811 00003E59 E892F7FFFF                  call .ehciSetNoData
  8812 00003E5E 5B                          pop rbx ;Get original bx
  8813 00003E5F C3                          ret
  8814                                  
  8815                                  .ehciWriteQHead:
  8816                                  ;Writes a Queue head at rdi, and clears the space for the transfer descriptor
  8817                                  ;rdi points at the head of the qhead on return
  8818                                  ;All non argument registers preserved
  8819                                  ;r8d=Horizontal Ptr + Typ + T
  8820                                  ;r9d=Endpoint Characteristics
  8821                                  ;r10d=Endpoint Capabilities
  8822                                  ;r11d=Next qTD Pointer
  8823 00003E60 50                          push rax
  8824 00003E61 51                          push rcx
  8825 00003E62 57                          push rdi
  8826 00003E63 31C0                        xor eax, eax
  8827 00003E65 4489C0                      mov eax, r8d
  8828 00003E68 AB                          stosd
  8829 00003E69 4489C8                      mov eax, r9d
  8830 00003E6C AB                          stosd
  8831 00003E6D 4489D0                      mov eax, r10d
  8832 00003E70 AB                          stosd
  8833 00003E71 31C0                        xor eax, eax
  8834 00003E73 AB                          stosd            ;Enter 0 for the current qTD pointer entry
  8835 00003E74 4489D8                      mov eax, r11d
  8836 00003E77 AB                          stosd
  8837 00003E78 B90A000000                  mov ecx, 10
  8838 00003E7D 31C0                        xor eax, eax
  8839 00003E7F F3AB                        rep stosd
  8840 00003E81 5F                          pop rdi
  8841 00003E82 59                          pop rcx
  8842 00003E83 58                          pop rax
  8843 00003E84 C3                          ret
  8844                                  .ehciWriteQHeadTD:
  8845                                  ;Writes a transfer descriptor at the location pointed at by rdi
  8846                                  ;rdi points at the head of the qheadTD on return
  8847                                  ;All registers except passed arguments, preserved
  8848                                  ;rdi=location for current linked list element
  8849                                  ;r8d=Next qTD ptr
  8850                                  ;r9d=Alternate Next qTD ptr
  8851                                  ;r10d=Transfer Descriptor Token
  8852                                  ;r11=Buffer Ptr 0 + Current Offset
  8853 00003E85 50                          push rax
  8854 00003E86 57                          push rdi
  8855 00003E87 4489C0                      mov eax, r8d
  8856 00003E8A AB                          stosd
  8857 00003E8B 4489C8                      mov eax, r9d
  8858 00003E8E AB                          stosd
  8859 00003E8F 4489D0                      mov eax, r10d
  8860 00003E92 AB                          stosd
  8861 00003E93 4489D8                      mov eax, r11d
  8862 00003E96 AB                          stosd
  8863 00003E97 2500F0FFFF                  and eax, 0FFFFF000h
  8864 00003E9C 0500100000                  add eax, 1000h
  8865 00003EA1 AB                          stosd
  8866 00003EA2 0500100000                  add eax, 1000h
  8867 00003EA7 AB                          stosd
  8868 00003EA8 0500100000                  add eax, 1000h
  8869 00003EAD AB                          stosd
  8870 00003EAE 0500100000                  add eax, 1000h
  8871 00003EB3 AB                          stosd
  8872                                  
  8873 00003EB4 4C89D8                      mov rax, r11
  8874 00003EB7 48C1C820                    ror rax, 20h
  8875 00003EBB AB                          stosd
  8876 00003EBC 48C1C820                    ror rax, 20h
  8877 00003EC0 482500F0FFFF                and rax, 0FFFFFFFFFFFFF000h
  8878 00003EC6 480500100000                add rax, 1000h
  8879 00003ECC 48C1C820                    ror rax, 20h
  8880 00003ED0 AB                          stosd
  8881 00003ED1 48C1C820                    ror rax, 20h
  8882 00003ED5 480500100000                add rax, 1000h
  8883 00003EDB 48C1C820                    ror rax, 20h
  8884 00003EDF AB                          stosd  
  8885 00003EE0 48C1C820                    ror rax, 20h
  8886 00003EE4 480500100000                add rax, 1000h
  8887 00003EEA 48C1C820                    ror rax, 20h
  8888 00003EEE AB                          stosd
  8889 00003EEF 48C1C820                    ror rax, 20h
  8890 00003EF3 480500100000                add rax, 1000h
  8891 00003EF9 48C1C820                    ror rax, 20h
  8892 00003EFD AB                          stosd
  8893 00003EFE 5F                          pop rdi
  8894 00003EFF 58                          pop rax
  8895 00003F00 C3                          ret
  8896                                  
  8897                                  
  8898                                  .ehciDevSetupHub:
  8899                                  ;Device specific setup. Takes rsi as a ptr to the 
  8900                                  ; specific device parameter block.
  8901 00003F01 53                          push rbx
  8902 00003F02 51                          push rcx
  8903 00003F03 56                          push rsi
  8904 00003F04 55                          push rbp
  8905 00003F05 6631ED                      xor bp, bp    ;Error Stage 0
  8906                                  .edshub:
  8907 00003F08 E839030000                  call .ehciHubClassDescriptor
  8908 00003F0D 0F82DA000000                jc .edsfail
  8909 00003F13 66FFC5                      inc bp  ;Error Stage 1
  8910 00003F16 8A4E05                      mov cl, byte [rsi + 5] ;Get number of ports here
  8911 00003F19 B201                        mov dl, 1   ;Start port number to begin enum on (hub ports start at 1)
  8912                                  .edshub1:
  8913 00003F1B 49BC03000000000000-         mov r12, 3
  8913 00003F24 00                 
  8914                                  .edshub11:
  8915 00003F25 E8CB000000                  call .ehciEnumerateHubPort    ;dl for port to scan/enumerate
  8916 00003F2A 7413                        jz .edshub13    ;If ZF=ZR, valid device found!
  8917 00003F2C 803C25[A9010000]20          cmp byte [msdStatus], 20h  ;General Controller Failure
  8918 00003F34 0F8448F3FFFF                je USB.ehciCriticalErrorWrapper
  8919 00003F3A 49FFCC                      dec r12
  8920 00003F3D 75E6                        jnz .edshub11   ;Still not zero but failed, try again.
  8921                                  .edshub13:
  8922 00003F3F FEC2                        inc dl  ;Start with port 1
  8923 00003F41 38D1                        cmp cl, dl
  8924 00003F43 73D6                        jae .edshub1
  8925                                  .edshub2:
  8926                                  ;Need to write bHostHub for any detected devices here
  8927 00003F45 F8                          clc    ;Common success exit
  8928 00003F46 5D                          pop rbp
  8929 00003F47 5E                          pop rsi
  8930 00003F48 59                          pop rcx
  8931 00003F49 5B                          pop rbx
  8932 00003F4A C3                          ret
  8933                                  
  8934                                  .ehciDeviceSetupMsd:
  8935                                  ; Input:  rsi = MSD Device Parameter Block
  8936                                  ; Output: CF=CY if catastrophic host error.
  8937                                  ;         CF=NC then ax = Return code
  8938                                  ;         ax = 0 if successful setup
  8939                                  ;         ax = 1 if device did not reset the first time
  8940                                  ;         ax = 2 if device did not return a valid LUN
  8941                                  ;         ax = 3 if device did not reset the second time
  8942                                  ;         Device must me removed from tables and port reset if ax != 0
  8943 00003F4B 51                          push rcx
  8944 00003F4C 55                          push rbp
  8945 00003F4D 4150                        push r8
  8946 00003F4F 6631ED                      xor bp, bp    ;Error Stage 0
  8947                                  .edsmsd:
  8948 00003F52 49B810000000000000-         mov r8, 10h ;Loop counter setup
  8948 00003F5B 00                 
  8949                                  .edsm1:
  8950 00003F5C E8BD030000                  call .ehciMsdDeviceReset
  8951 00003F61 0F8281000000                jc .edsexit
  8952                                  ;Check eActiveInterrupt for confirmation if we need to handle error
  8953 00003F67 F60425[48020000]02          test byte [eActiveInt], 2   ;If this is set, handle error
  8954 00003F6F 7416                        jz .edsms2
  8955 00003F71 668B4E07                    mov cx, word [rsi + 7]    ;Pass endpoint size
  8956 00003F75 8A06                        mov al, byte [rsi]  ;Device address
  8957 00003F77 E862FEFFFF                  call .ehciStandardErrorHandler
  8958 00003F7C A880                        test al, 80h 
  8959 00003F7E 756D                        jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  8960 00003F80 49FFC8                      dec r8                ;Dec loop counter
  8961 00003F83 7468                        jz .edsfail           ;Fatal error if after 16 goes nothing was resolved
  8962 00003F85 EBD5                        jmp short .edsm1
  8963                                  .edsms2:
  8964 00003F87 66FFC5                      inc bp  ;Error Stage 1
  8965                                  .edsms3:
  8966 00003F8A E8B9030000                  call .ehciMsdGetMaxLun  ;If stall, clear endpoint and proceed. No loop
  8967 00003F8F 7257                        jc .edsexit
  8968 00003F91 F60425[48020000]02          test byte [eActiveInt], 2   ;If this is set, handle error
  8969 00003F99 740F                        jz .edsms4
  8970                                  
  8971 00003F9B 668B4E07                    mov cx, word [rsi + 7]    ;Pass endpoint size
  8972 00003F9F 8A06                        mov al, byte [rsi]  ;Device address
  8973 00003FA1 E838FEFFFF                  call .ehciStandardErrorHandler
  8974 00003FA6 A880                        test al, 80h 
  8975 00003FA8 7543                        jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  8976                                  .edsms4:
  8977 00003FAA 66FFC5                      inc bp  ;Error Stage 2
  8978 00003FAD 49B810000000000000-         mov r8, 10h ;Loop counter setup
  8978 00003FB6 00                 
  8979                                  .edsms5:
  8980 00003FB7 E862030000                  call .ehciMsdDeviceReset  ;Reset once again to clear issues
  8981 00003FBC 722A                        jc .edsexit
  8982 00003FBE F60425[48020000]02          test byte [eActiveInt], 2   ;If this is set, handle error
  8983 00003FC6 7416                        jz .edsms6
  8984                                  
  8985 00003FC8 668B4E07                    mov cx, word [rsi + 7]    ;Pass endpoint size
  8986 00003FCC 8A06                        mov al, byte [rsi]  ;Device address
  8987 00003FCE E80BFEFFFF                  call .ehciStandardErrorHandler
  8988 00003FD3 A880                        test al, 80h 
  8989 00003FD5 7516                        jnz .edsfail   ;If bit 7 is set, something is seriously wrong, fail dev!
  8990 00003FD7 49FFC8                      dec r8                 ;Dec loop counter
  8991 00003FDA 7411                        jz .edsfail           ;Fatal error if after 16 goes nothing was resolved
  8992 00003FDC EBD9                        jmp short .edsms5
  8993                                  .edsms6:
  8994 00003FDE FE0425[4B020000]            inc byte [numMSD] 
  8995 00003FE5 6631C0                      xor ax, ax  ;Note that xor also clears CF
  8996                                  .edsexit:
  8997 00003FE8 4158                        pop r8
  8998 00003FEA 5D                          pop rbp
  8999 00003FEB 59                          pop rcx
  9000 00003FEC C3                          ret
  9001                                  .edsfail:
  9002                                  ;If a fail occurs, then the entry needs to be removed from the data tables
  9003 00003FED 6689E8                      mov ax, bp
  9004 00003FF0 E9F3FFFFFF                  jmp .edsexit
  9005                                  
  9006                                  .ehciEnumerateHubPort:
  9007                                  ;Enumerates devices on an external Hub.
  9008                                  ;Use rsi to get device properties
  9009                                  ;Input: rsi = ptr to hub device block
  9010                                  ;       dl = Port number to reset
  9011                                  ;Output: None, CF
  9012                                  
  9013 00003FF5 53                          push rbx
  9014 00003FF6 51                          push rcx
  9015 00003FF7 52                          push rdx
  9016 00003FF8 55                          push rbp
  9017 00003FF9 4150                        push r8
  9018 00003FFB 4151                        push r9
  9019 00003FFD 4152                        push r10
  9020 00003FFF 4153                        push r11
  9021                                  
  9022 00004001 0FB6D2                      movzx edx, dl
  9023 00004004 48C1E220                    shl rdx, 4*8    ;Shift port number to right bits
  9024                                  .eehdeinit:
  9025 00004008 6631ED                      xor bp, bp  ;Error counter
  9026 0000400B 4C0FB70E                    movzx r9, word [rsi]        ;Save hub bus/addr in r9w
  9027 0000400F 4C0FB64604                  movzx r8, byte [rsi + 4]    ;Get MaxPacketSize0
  9028                                  
  9029                                  .eehde0:
  9030 00004014 48BB23030800000000-         mov rbx, 0000000000080323h  ;Set port power feature
  9030 0000401D 00                 
  9031 0000401E 4809D3                      or rbx, rdx ;Add port number into descriptor
  9032 00004021 664489C1                    mov cx, r8w
  9033 00004025 4488C8                      mov al, r9b
  9034 00004028 E8C3F5FFFF                  call .ehciSetNoData   ;Turn on power to port on device in addr al
  9035 0000402D 0F829F010000                jc .eehdecritical  ;Fast exit with carry set
  9036                                  .eehde1:
  9037                                  ;Power on debounce!
  9038 00004033 B486                        mov ah, 86h
  9039 00004035 0FB64E06                    movzx ecx, byte [rsi + 6]   ;poweron2powergood
  9040 00004039 D1E1                        shl ecx, 1
  9041 0000403B CD35                        int 35h
  9042                                  
  9043 0000403D 66FFC5                      inc bp      ;Increment Error Counter    (Stage 1)
  9044                                  .eehde2:
  9045 00004040 48BB23011000000000-         mov rbx, 0000000000100123h  ;Clear port set connection bit
  9045 00004049 00                 
  9046 0000404A 4809D3                      or rbx, rdx ;Add port number into descriptor
  9047 0000404D 4488C1                      mov cl, r8b
  9048 00004050 4488C8                      mov al, r9b
  9049 00004053 E898F5FFFF                  call .ehciSetNoData
  9050 00004058 0F8274010000                jc .eehdecritical  ;Fast exit with carry set
  9051                                  .eehde3:
  9052                                  
  9053 0000405E 66FFC5                      inc bp      ;Increment Error Counter    (Stage 2)
  9054                                  .eehde31:
  9055 00004061 48BBA3000000000004-         mov rbx, 00040000000000A3h ;Get port status
  9055 0000406A 00                 
  9056 0000406B 4809D3                      or rbx, rdx
  9057 0000406E 4488C1                      mov cl, r8b
  9058 00004071 4488C8                      mov al, r9b
  9059 00004074 E816F6FFFF                  call .ehciGetRequest
  9060 00004079 0F8253010000                jc .eehdecritical  ;Fast exit with carry set
  9061                                  .eehde4:
  9062 0000407F 66FFC5                      inc bp      ;Increment Error Counter    (Stage 3)
  9063                                  
  9064 00004082 8A0C25[C0030000]            mov cl, byte [ehciDataIn]   ;Get the first byte in into cx
  9065 00004089 F6C101                      test cl, 1  ;Check device in port
  9066 0000408C 0F8436010000                jz .eehdebadnotimeout
  9067                                  
  9068                                  .eehde41:   ;EP for first port reset state
  9069 00004092 66FFC5                      inc bp      ;Increment Error Counter    (Stage 4)
  9070 00004095 E83D010000                  call .eehdereset    ;First port reset
  9071 0000409A 0F8232010000                jc .eehdecritical  ;Fast exit with carry set
  9072                                  
  9073 000040A0 66FFC5                      inc bp      ;Increment Error Counter    (Stage 5)
  9074                                  
  9075 000040A3 49BB10000000000000-         mov r11, 10h
  9075 000040AC 00                 
  9076                                  .eehde5:
  9077 000040AD 48BBA3000000000004-         mov rbx, 00040000000000A3h ;Get port status again
  9077 000040B6 00                 
  9078 000040B7 4809D3                      or rbx, rdx
  9079 000040BA 4488C1                      mov cl, r8b
  9080 000040BD 4488C8                      mov al, r9b
  9081 000040C0 E8CAF5FFFF                  call .ehciGetRequest
  9082 000040C5 0F8207010000                jc .eehdecritical  ;Fast exit with carry set
  9083                                  .eehde6:
  9084 000040CB 66FFC5                      inc bp      ;Increment Error Counter    (Stage 6)
  9085                                  ;Now check for high speed
  9086                                  
  9087 000040CE 668B0C25[C0030000]          mov cx, word [ehciDataIn]
  9088 000040D6 6681E1FF07                  and cx, 7FFh    ;Zero upper bits
  9089 000040DB 66C1E909                    shr cx, 9   ;Bring bits [10:9] low
  9090 000040DF 6681F90200                  cmp cx, 2   ;2 is High Speed device
  9091 000040E4 0F85DE000000                jne .eehdebadnotimeout
  9092 000040EA 48C70425[C0030000]-         mov qword [ehciDataIn], 0
  9092 000040F2 00000000           
  9093                                  
  9094 000040F6 66FFC5                      inc bp      ;Increment Error Counter    (Stage 7)
  9095                                  
  9096 000040F9 57                          push rdi
  9097 000040FA 48BF-                       mov rdi, ehciDataIn
  9097 000040FC [C003000000000000] 
  9098 00004104 B908000000                  mov ecx, 8
  9099 00004109 31C0                        xor eax, eax
  9100 0000410B F348AB                      rep stosq
  9101 0000410E 5F                          pop rdi
  9102                                  .eehde7:
  9103 0000410F 48BB23011200000000-         mov rbx, 0000000000120123h  ;Clear port suspend
  9103 00004118 00                 
  9104 00004119 4809D3                      or rbx, rdx ;Add port number into descriptor
  9105 0000411C 4488C1                      mov cl, r8b
  9106 0000411F 4488C8                      mov al, r9b
  9107 00004122 E8C9F4FFFF                  call .ehciSetNoData
  9108 00004127 0F82A5000000                jc .eehdecritical  ;Fast exit with carry set
  9109                                  
  9110                                  .eehde10:
  9111 0000412D 48BB80060001000008-         mov rbx, 00008000001000680h    ;Pass get minimal device descriptor
  9111 00004136 00                 
  9112 00004137 66B94000                    mov cx, 40h    ;Pass default endpoint size
  9113 0000413B 30C0                        xor al, al
  9114 0000413D E84DF5FFFF                  call .ehciGetRequest
  9115 00004142 0F828A000000                jc .eehdecritical  ;Fast exit with carry set
  9116                                  .eehde101:
  9117 00004148 66FFC5                      inc bp      ;Increment Error Counter    (Stage 8)
  9118                                  
  9119 0000414B 803C25[C1030000]01          cmp byte [ehciDataIn + 1], 01h    ;Verify this is a valid dev descriptor
  9120 00004153 756E                        jne .eehdebad       ;ehciDataIn contains error signature
  9121                                  
  9122                                  ;Sanity check the returned descriptor here
  9123                                  .eehde11:
  9124 00004155 66813C25[C2030000]-         cmp word [ehciDataIn + 2], 0200h    ;Verify this is a USB 2.0+ device or
  9124 0000415D 0002               
  9125 0000415F 7262                        jb .eehdebad
  9126 00004161 803C25[C4030000]00          cmp byte [ehciDataIn + 4], 0    ;Check interfaces
  9127 00004169 7414                        je .eehde12
  9128 0000416B 803C25[C4030000]08          cmp byte [ehciDataIn + 4], 08h    ;MSD?
  9129 00004173 740A                        je .eehde12
  9130 00004175 803C25[C4030000]09          cmp byte [ehciDataIn + 4], 09h    ;Hub?
  9131 0000417D 7544                        jne .eehdebad
  9132                                  
  9133                                  .eehde12:    ;Valid device detected
  9134 0000417F 440FB60425-                 movzx r8d, byte [ehciDataIn + 7]   ;Save attached device max ep size
  9134 00004184 [C7030000]         
  9135                                  .eehde13: 
  9136 00004188 E84A000000                  call .eehdereset    ;Do second reset
  9137 0000418D 7243                        jc .eehdecritical  ;Fast exit with carry set
  9138                                  ;Clear the data in buffer
  9139 0000418F 57                          push rdi
  9140 00004190 48BF-                       mov rdi, ehciDataIn
  9140 00004192 [C003000000000000] 
  9141 0000419A B908000000                  mov ecx, 8
  9142 0000419F 31C0                        xor eax, eax
  9143 000041A1 F348AB                      rep stosq
  9144 000041A4 5F                          pop rdi
  9145                                  
  9146                                  ;Device on port now ready to have an address set to it, and be enumerated
  9147 000041A5 48C1EA20                    shr rdx, 4*8    ;Shift port number back down to dl
  9148 000041A9 668B06                      mov ax, word [rsi]  ;Get hub bus/addr pair
  9149 000041AC 88E6                        mov dh, ah          ;Move the bus number into dh
  9150 000041AE 440FB6D0                    movzx r10d, al      ;Move hub address into r10b
  9151                                  ;Ensure dl=port number - 1, dh=Root hub (Bus) number, r10b=Host hub number
  9152                                  ;       r8b=Max Control EP endpoint size
  9153 000041B2 49BB64000000000000-         mov r11, 100    ;Address settle time
  9153 000041BB 00                 
  9154 000041BC FECA                        dec dl
  9155 000041BE E998F7FFFF                  jmp .ehciEnumCommonEp
  9156                                  
  9157                                  .eehdebad:
  9158                                  .eehdebadnoport:    ;EP if done without disabling port
  9159 000041C3 E987F8FFFF                  jmp .ehciedbadnoport
  9160                                  .eehdebadnotimeout:
  9161 000041C8 E98DF8FFFF                  jmp .ehciedbadnotimeout
  9162                                  .eehdebadremtables:
  9163 000041CD E99AF8FFFF                  jmp .ehcibadremtables
  9164                                  .eehdecritical:
  9165 000041D2 E96BF8FFFF                  jmp .ehciedexit  ;Fast exit with carry set
  9166                                  .eehdereset:
  9167                                  ;rsi must point to valid Hub device block
  9168 000041D7 48BB23030400000000-         mov rbx, 0000000000040323h  ;Reset port 
  9168 000041E0 00                 
  9169 000041E1 4809D3                      or rbx, rdx ;Add device address
  9170 000041E4 4488C1                      mov cl, r8b
  9171 000041E7 4488C8                      mov al, r9b
  9172 000041EA E801F4FFFF                  call .ehciSetNoData
  9173 000041EF 7254                        jc .eehcritexit
  9174                                  
  9175 000041F1 49BB88130000000000-         mov r11, 5000 ;Just keep trying
  9175 000041FA 00                 
  9176                                  .eehder1:
  9177 000041FB B486                        mov ah, 86h
  9178 000041FD B914000000                  mov ecx, 20     ;20 ms is max according to USB 2.0 standard
  9179 00004202 CD35                        int 35h
  9180                                  
  9181 00004204 48BBA3000000000004-         mov rbx, 00040000000000A3h ;Get port status
  9181 0000420D 00                 
  9182 0000420E 4809D3                      or rbx, rdx
  9183 00004211 4488C1                      mov cl, r8b
  9184 00004214 4488C8                      mov al, r9b
  9185 00004217 E873F4FFFF                  call .ehciGetRequest
  9186 0000421C 8A0C25[C0030000]            mov cl, byte [ehciDataIn]   ;Get low byte of in data
  9187 00004223 F6C110                      test cl, 10h    ;If bit not set, reset over, proceed
  9188 00004226 7405                        jz .eehder2
  9189 00004228 49FFCB                      dec r11
  9190 0000422B 75CE                        jnz .eehder1
  9191                                  .eehder2:
  9192 0000422D 48BB23011400000000-         mov rbx, 0000000000140123h ;Clear port reset bit
  9192 00004236 00                 
  9193 00004237 4809D3                      or rbx, rdx
  9194 0000423A 4488C1                      mov cl, r8b
  9195 0000423D 4488C8                      mov al, r9b
  9196 00004240 E8ABF3FFFF                  call .ehciSetNoData
  9197                                  .eehcritexit:
  9198 00004245 C3                          ret
  9199                                  
  9200                                  .ehciHubClassDescriptor:
  9201                                  ;Gets the Hub class descriptor
  9202                                  ;Get Hub descriptor for device pointed to by rsi
  9203                                  ;If invalid data, returns error
  9204                                  ;Input: rsi = Ptr to hub data block
  9205                                  ;Output:
  9206                                  ;   Carry Clear if success
  9207                                  ;   Carry Set if fail, al contains error code
  9208 00004246 53                          push rbx
  9209 00004247 51                          push rcx
  9210 00004248 55                          push rbp
  9211 00004249 66BD0300                    mov bp, 3
  9212                                  
  9213 0000424D 48BBA0060029000007-         mov rbx, 00070000290006A0h  ;Get Hub descriptor (only first 7 bytes)
  9213 00004256 00                 
  9214 00004257 0FB64E04                    movzx ecx, byte [rsi + 4]  ;bMaxPacketSize0
  9215 0000425B 8A06                        mov al, byte [rsi]      ;Get device address
  9216 0000425D E82DF4FFFF                  call .ehciGetRequest
  9217 00004262 7226                        jc .ehcdfail    ;Errors 0-2 live here
  9218                                  
  9219 00004264 66FFC5                      inc bp
  9220 00004267 803C25[C1030000]29          cmp byte [ehciDataIn + 1], 29h  ;Is this a valid hub descriptor
  9221 0000426F 7519                        jne .ehcdfail
  9222                                  
  9223 00004271 8A0C25[C2030000]            mov cl, byte [ehciDataIn + 2]   ;Get number of downstream ports
  9224 00004278 884E05                      mov byte [rsi + 5], cl  ;Store in variable, marking device as configured
  9225                                  
  9226 0000427B 8A0C25[C5030000]            mov cl, byte [ehciDataIn + 5]   ;Get PowerOn2PowerGood
  9227 00004282 884E06                      mov byte [rsi + 6], cl  ;Store in variable
  9228 00004285 F8                          clc
  9229                                  .ehcdexit:
  9230 00004286 5D                          pop rbp
  9231 00004287 59                          pop rcx
  9232 00004288 5B                          pop rbx
  9233 00004289 C3                          ret
  9234                                  .ehcdfail:
  9235 0000428A 4088E8                      mov al, bpl
  9236 0000428D F9                          stc
  9237 0000428E EBF6                        jmp short .ehcdexit
  9238                                  ;                        ---------MSD functions---------
  9239                                  .ehciMsdInitialise:
  9240                                  ;Initialises an MSD device.
  9241                                  ;Input: rsi = Valid MSD device block
  9242                                  ;Output: CF=CY: Init did not complete
  9243                                  ;        al = 0 => Device initialised
  9244                                  ;        al = 1 => Host/Schedule error
  9245                                  ;        al = 2 => Device failed to initialise
  9246                                  ;        CF=NC: Init complete, rsi points to complete USB MSD device block
  9247 00004290 51                          push rcx
  9248 00004291 8A4601                      mov al, byte [rsi + 1]  ;Get the bus number into al
  9249 00004294 E800F2FFFF                  call .ehciAdjustAsyncSchedCtrlr
  9250 00004299 B001                        mov al, 1
  9251 0000429B 7249                        jc .ehciMsdInitFail
  9252 0000429D E8A9FCFFFF                  call .ehciDeviceSetupMsd
  9253 000042A2 B002                        mov al, 2
  9254 000042A4 7240                        jc .ehciMsdInitFail
  9255 000042A6 E8EB040000                  call .ehciMsdBOTInquiry
  9256 000042AB 7239                        jc .ehciMsdInitFail
  9257 000042AD B905000000                  mov ecx, 5
  9258                                  .emi0:
  9259 000042B2 E82C050000                  call .ehciMsdBOTReadFormatCapacities
  9260 000042B7 803C25[A9010000]20          cmp byte [msdStatus], 20h   ;Host error
  9261 000042BF 7439                        je .ehciMsdInitialisePfail  ;Protocol fail
  9262 000042C1 E88C010000                  call .ehciMsdBOTCheckTransaction
  9263 000042C6 6685C0                      test ax, ax
  9264 000042C9 7538                        jnz .emipf0
  9265 000042CB E8F6060000                  call .ehciMsdBOTModeSense6
  9266 000042D0 803C25[A9010000]20          cmp byte [msdStatus], 20h   ;Host error
  9267 000042D8 7420                        je .ehciMsdInitialisePfail  ;Protocol fail
  9268 000042DA E873010000                  call .ehciMsdBOTCheckTransaction
  9269 000042DF 6685C0                      test ax, ax     ;Also clears CF if zero
  9270 000042E2 751F                        jnz .emipf0
  9271                                  .ehciMsdInitExit:
  9272 000042E4 59                          pop rcx
  9273 000042E5 C3                          ret
  9274                                  .ehciMsdInitFail:
  9275 000042E6 668B06                      mov ax, word [rsi]
  9276 000042E9 E807F9FFFF                  call .ehciRemoveDevFromTables
  9277 000042EE FE0C25[4B020000]            dec byte [numMSD]   ;Device was removed from tables, decrement
  9278 000042F5 F9                          stc
  9279 000042F6 B002                        mov al, 2
  9280 000042F8 EBEA                        jmp short .ehciMsdInitExit
  9281                                  .ehciMsdInitialisePfail:
  9282 000042FA E873000000                  call .ehciMsdBOTResetRecovery
  9283 000042FF FFC9                        dec ecx
  9284 00004301 74E3                        jz .ehciMsdInitFail
  9285                                  .emipf0:
  9286 00004303 E836060000                  call .ehciMsdBOTRequestSense
  9287 00004308 803C25[A9010000]20          cmp byte [msdStatus], 20h
  9288 00004310 74E8                        je .ehciMsdInitialisePfail
  9289 00004312 E83B010000                  call .ehciMsdBOTCheckTransaction
  9290 00004317 6685C0                      test ax, ax
  9291 0000431A 7496                        jz .emi0
  9292 0000431C EBDC                        jmp short .ehciMsdInitialisePfail
  9293                                  
  9294                                  .ehciMsdDeviceReset:
  9295                                  ;Reset an MSD device on current active EHCI bus
  9296                                  ;Input: rsi = Pointer to table data structure
  9297                                  ;Output:
  9298                                  ;   CF=CY: Host error, Reset host system
  9299                                  ;   CF=NC: Transaction succeeded, check reset occurred successfully 
  9300                                  ;          (If eActiveIntr AND 2 != 0, then error in transfer)
  9301 0000431E 51                          push rcx
  9302 0000431F 52                          push rdx
  9303 00004320 53                          push rbx
  9304 00004321 50                          push rax
  9305                                  
  9306 00004322 0FB64E07                    movzx ecx, byte [rsi + 7]  ;Get bMaxPacketSize0
  9307 00004326 480FB65604                  movzx rdx, byte [rsi + 4]  ;Get Interface Number
  9308 0000432B 48C1E228                    shl rdx, 5*8 ;Send to 5th byte
  9309 0000432F 48BB21FF0000000000-         mov rbx, 0FF21h            ;MSD Reset
  9309 00004338 00                 
  9310 00004339 4809D3                      or rbx, rdx                ;And those bytes
  9311 0000433C 8A06                        mov al, byte [rsi]
  9312 0000433E E8ADF2FFFF                  call .ehciSetNoData
  9313                                  
  9314 00004343 58                          pop rax
  9315 00004344 5B                          pop rbx
  9316 00004345 5A                          pop rdx
  9317 00004346 59                          pop rcx
  9318 00004347 C3                          ret
  9319                                  
  9320                                  .ehciMsdGetMaxLun:
  9321                                  ;Get max LUN of an MSD device on current active EHCI bus
  9322                                  ;Input: rsi = Pointer to table data structure
  9323                                  ;       al = Address
  9324                                  ;Output:
  9325                                  ;   CF=CY: Host error, Reset host system
  9326                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9327                                  ;   Max Lun saved at DataIn Buffer (first byte)
  9328                                  ;   Check this was transferred, by checking total data transferred value
  9329 00004348 51                          push rcx
  9330 00004349 52                          push rdx
  9331 0000434A 53                          push rbx
  9332 0000434B 50                          push rax
  9333                                  
  9334 0000434C 0FB64E07                    movzx ecx, byte [rsi + 7]  ;Get bMaxPacketSize0
  9335 00004350 480FB65604                  movzx rdx, byte [rsi + 4]  ;Get Interface Number
  9336 00004355 48C1E228                    shl rdx, 5*8 ;Send to 5th byte
  9337 00004359 48BBA1FE0000000001-         mov rbx, 000100000000FEA1h            ;MSD Get Max LUN
  9337 00004362 00                 
  9338 00004363 4809D3                      or rbx, rdx                ;And those bytes
  9339 00004366 8A06                        mov al, byte [rsi]
  9340 00004368 E822F3FFFF                  call .ehciGetRequest
  9341                                  
  9342 0000436D 58                          pop rax
  9343 0000436E 5B                          pop rbx
  9344 0000436F 5A                          pop rdx
  9345 00004370 59                          pop rcx
  9346 00004371 C3                          ret
  9347                                  
  9348                                  .ehciMsdBOTResetRecovery:
  9349                                  ;----------------------------------------------------------------
  9350                                  ;Calls the reset recovery procedure on a device ptd to by rsi   :
  9351                                  ;Input:  rsi = Pointer to MSD device parameter block            :
  9352                                  ;Output: CF=CY if something went wrong. Else CF=NC              :
  9353                                  ;----------------------------------------------------------------
  9354                                  ;Calls an MSDBBB reset then calls StandardErrorHandler AFTER    : 
  9355                                  ; writing the Qhead for each Bulk EP.                           :
  9356                                  ;----------------------------------------------------------------
  9357 00004372 50                          push rax
  9358 00004373 53                          push rbx
  9359 00004374 51                          push rcx
  9360 00004375 66C7460E0000                mov word [rsi + 14], 00h    ;Reset clear both endpoint dt bits 
  9361                                  
  9362 0000437B E89EFFFFFF                  call .ehciMsdDeviceReset    ;Call the device reset
  9363 00004380 721E                        jc .embrrexit
  9364                                  ;Now clear stall on IN EP
  9365 00004382 8A06                        mov al, byte [rsi]          ;Get the address
  9366 00004384 8A5E08                      mov bl, byte [rsi + 8]      ;Get the 4 byte EP address
  9367 00004387 0FB64E07                    movzx ecx, byte [rsi + 7]   ;Get the Max packet size for the ctrl EP
  9368 0000438B E8B9FAFFFF                  call .ehciClearEpStallHalt
  9369 00004390 720E                        jc .embrrexit
  9370                                  ;Now clear stall on OUT EP
  9371 00004392 8A06                        mov al, byte [rsi]          ;Get the address
  9372 00004394 8A5E0B                      mov bl, byte [rsi + 11]     ;Get the 4 byte EP address
  9373 00004397 0FB64E07                    movzx ecx, byte [rsi + 7]   ;Get the Max packet size for the ctrl EP
  9374 0000439B E8A9FAFFFF                  call .ehciClearEpStallHalt
  9375                                  .embrrexit:
  9376 000043A0 59                          pop rcx
  9377 000043A1 5B                          pop rbx
  9378 000043A2 58                          pop rax
  9379 000043A3 C3                          ret
  9380                                  .ehciMsdBOTCheckValidCSW:
  9381                                  ; This function checks that the recieved CSW was valid.
  9382                                  ; If this function returns a non-zero value in al, 
  9383                                  ; a reset recovery of the device is required
  9384                                  ; Output: al = 0 : valid CSW
  9385                                  ;         If CSW not valid, al contains a bitfield describing what failed
  9386                                  ;         al = 1h   : CSW is not 13 bytes in length
  9387                                  ;         al = 2h   : dCSWSignature is not equal to 053425355h
  9388                                  ;         al = 4h   : dCSWTag does not match the dCBWTag
  9389                                  ;         al = 0F8h : Reserved
  9390                                  ;   rax destroyed
  9391 000043A4 53                          push rbx
  9392 000043A5 51                          push rcx
  9393 000043A6 31C0                        xor eax, eax
  9394 000043A8 66B90100                    mov cx, 1
  9395 000043AC 668B1C25[8A010000]          mov bx, word [ehciTDSpace + 2*ehciSizeOfTD + 0Ah]   
  9396                                  ;Get total bytes to transfer from third QHeadTD to see if 13h bytes were 
  9397                                  ; transferred
  9398 000043B4 6681E3FF7F                  and bx, 7FFFh   ;Clear upper bit
  9399 000043B9 660F45C1                    cmovnz ax, cx   ;If the result for the and is not zero, <>13 bytes were sent
  9400                                  
  9401 000043BD 66D1E1                      shl cx, 1     
  9402 000043C0 6609C1                      or cx, ax
  9403 000043C3 813C25[C0050000]55-         cmp dword [msdCSW], CSWSig
  9403 000043CB 534253             
  9404 000043CE 660F45C1                    cmovne ax, cx
  9405                                  
  9406 000043D2 66B90400                    mov cx, 4h
  9407 000043D6 6609C1                      or cx, ax
  9408 000043D9 0FB61C25[4A020000]          movzx ebx, byte [cbwTag]
  9409 000043E1 FECB                        dec bl
  9410 000043E3 3A1C25[C4050000]            cmp bl, byte [msdCSW + 4h]
  9411 000043EA 660F45C1                    cmovne ax, cx
  9412                                  
  9413 000043EE 59                          pop rcx
  9414 000043EF 5B                          pop rbx
  9415 000043F0 C3                          ret
  9416                                  
  9417                                  .ehciMsdBOTCheckMeaningfulCSW:
  9418                                  ; This function checks if the CSW was meaningful.
  9419                                  ; If this function returns a non-zero value in al, it is up to the
  9420                                  ; caller to decide what action to take. The possible set of actions that
  9421                                  ; can be taken is outlined in Section 6.7 of the USB MSC BOT Revision 1.0 
  9422                                  ; specification.
  9423                                  ; Output :  al = 0h  : Invalid
  9424                                  ;           al = 1h  : bCSWStatus = 0
  9425                                  ;           al = 2h  : bCSWStatus = 1
  9426                                  ;           al = 4h  : bCSWStatus = 2
  9427                                  ;           al = 8h  : bCSWStatus > 2
  9428                                  ;           al = 10h : dCSWDataResidue = 0
  9429                                  ;           al = 20h : dCSWDataResidue < dCBWDataTransferLength
  9430                                  ;           al = 40h : dCSWDataResidue > dCBWDataTransferLength
  9431                                  ;           al = 80h : Reserved
  9432                                  ;   rax destroyed
  9433 000043F1 53                          push rbx
  9434 000043F2 51                          push rcx
  9435                                  
  9436 000043F3 31C0                        xor eax, eax  ;In the event that things go completely wrong
  9437 000043F5 66BB0800                    mov bx, 8h
  9438 000043F9 8A0C25[CC050000]            mov cl, byte [msdCSW + 0Ch]
  9439                                  
  9440 00004400 80F902                      cmp cl, 2
  9441 00004403 660F47C3                    cmova ax, bx
  9442 00004407 7718                        ja .embcmcResidueCheck
  9443                                  
  9444 00004409 66D1EB                      shr bx, 1       ;Shift it down to 4
  9445 0000440C 660F44C3                    cmove ax, bx    ;If bCSWStatus = 2, move it in
  9446 00004410 740F                        je .embcmcResidueCheck
  9447                                  
  9448 00004412 66D1EB                      shr bx, 1       ;Shift down to 2
  9449 00004415 80F901                      cmp cl, 1
  9450 00004418 660F44C3                    cmove ax, bx    ;If bCSWStatus = 1, move bx into ax
  9451 0000441C 7403                        je .embcmcResidueCheck
  9452                                  
  9453 0000441E 66FFC0                      inc ax          ;Otherwise bCSWStatus = 0
  9454                                  .embcmcResidueCheck:
  9455 00004421 8B0C25[C8050000]            mov ecx, dword [msdCSW + 8] ;Get dCSWDataResidue
  9456                                  
  9457 00004428 66BB1000                    mov bx, 10h
  9458 0000442C 6609C3                      or bx, ax   
  9459 0000442F 85C9                        test ecx, ecx
  9460 00004431 660F44C3                    cmovz ax, bx    ;If its zero, move bx with added bit from ax into ax
  9461 00004435 7418                        jz .embcmcExit
  9462                                  
  9463 00004437 66BB2000                    mov bx, 20h
  9464 0000443B 6609C3                      or bx, ax 
  9465 0000443E 3B0C25[88030000]            cmp ecx, dword [ehciDataOut + 8];ehciDataOut + 8 = dCBWDataTransferLength
  9466 00004445 660F42C3                    cmovb ax, bx
  9467 00004449 7204                        jb .embcmcExit
  9468                                  
  9469 0000444B 660D4000                    or ax, 40h  ;Else, it must be above, fail
  9470                                  .embcmcExit:
  9471 0000444F 59                          pop rcx
  9472 00004450 5B                          pop rbx
  9473 00004451 C3                          ret
  9474                                  
  9475                                  .ehciMsdBOTCheckTransaction:
  9476                                  ;Check successful return data here
  9477                                  ;Output: ax = 0                                 : CSW Valid and Meaningful
  9478                                  ;        ah = 1, al = CSW Validity bitfield     : CSW NOT valid
  9479                                  ;        ah = 2, al = CSW Meaningful bitfield   : CSW NOT meaningful
  9480                                  ;   rax destroyed
  9481 00004452 30E4                        xor ah, ah
  9482 00004454 E84BFFFFFF                  call .ehciMsdBOTCheckValidCSW
  9483 00004459 84C0                        test al, al
  9484 0000445B 7407                        jz .embhiehcswmeaningful
  9485 0000445D B401                        mov ah, 1       ; CSW Not Valid signature
  9486 0000445F E90B000000                  jmp .embhiehexit
  9487                                  .embhiehcswmeaningful:
  9488 00004464 E888FFFFFF                  call .ehciMsdBOTCheckMeaningfulCSW
  9489 00004469 244C                        and al, 4Ch     ;Check bad bits first and bCSWStatus=02 40h|08h|04h
  9490 0000446B 7402                        jz .embhiehexit
  9491 0000446D B402                        mov ah, 2       ; CSW Not Meaningful signature
  9492                                  .embhiehexit:
  9493 0000446F C3                          ret
  9494                                  .ehciMsdBOTOO64I:   ;For devices with 64 byte max packet size
  9495                                  .ehciMsdBOTOI64I:   ;For devices with 64 byte max packet size
  9496 00004470 C60425[A9010000]BB          mov byte [msdStatus], 0BBh   ;Undefined error
  9497 00004478 C3                          ret
  9498                                  .ehciMsdBOTOOI:     ;Out Out In transfer
  9499                                  ;Input - rsi = MSD device parameter block
  9500                                  ;        rbx = Input buffer for Data In
  9501                                  ;        ecx = Number of milliseconds to wait between Out and In packets
  9502                                  ;        r8  = Number of bytes to be transferred (for the DATA phase)
  9503                                  ;        r10 = LUN Value
  9504                                  ;        r11 = Length of CBW command block
  9505 00004479 57                          push rdi
  9506 0000447A 4150                        push r8
  9507 0000447C 4151                        push r9
  9508 0000447E 4152                        push r10
  9509 00004480 4153                        push r11
  9510 00004482 4154                        push r12
  9511 00004484 51                          push rcx
  9512 00004485 FC                          cld
  9513                                  
  9514 00004486 4D89C4                      mov r12, r8     ;Save number of bytes to transfer to MSD device
  9515 00004489 51                          push rcx
  9516                                  ;Write QHead for CBW
  9517 0000448A 49BB-                       mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  9517 0000448C [0001000000000000] 
  9518 00004494 E840020000                  call .ehciMsdWriteOutQHead
  9519                                  ;Write TD for CBW send
  9520 00004499 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  9521 0000449C 49B801000000000000-         mov r8, 1
  9521 000044A5 00                 
  9522 000044A6 4D89C1                      mov r9, r8
  9523 000044A9 440FB6560F                  movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  9524 000044AE 80760F01                    xor byte [rsi + 15], 1  ;Toggle bit
  9525 000044B2 41D1CA                      ror r10d, 1 ;Roll dt bit to upper bit of dword
  9526 000044B5 4181CA808C1F00              or r10d, 001F8C80h 
  9527                                  ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  9528 000044BC 49BB-                       mov r11, ehciDataOut ; Data out buffer
  9528 000044BE [8003000000000000] 
  9529 000044C6 E8BAF9FFFF                  call .ehciWriteQHeadTD
  9530                                  
  9531 000044CB B103                        mov cl, 11b    ;Lock out internal buffer
  9532 000044CD E8E6F2FFFF                  call .ehciProcessCommand        ;Run controller
  9533 000044D2 59                          pop rcx    ;Wait ecx ms for "motors to spin up"
  9534 000044D3 0F824B010000                jc .emboexit    ;If catastrophic Host system error, exit!
  9535                                  
  9536 000044D9 50                          push rax
  9537 000044DA B486                        mov ah, 86h
  9538 000044DC CD35                        int 35h
  9539 000044DE 58                          pop rax
  9540                                  ;Write Qhead to Send data
  9541 000044DF 49BB80000000000000-         mov r11, ehciSizeOfTD + ehciSizeOfTD
  9541 000044E8 00                 
  9542 000044E9 E8EB010000                  call .ehciMsdWriteOutQHead
  9543                                  ;Write TD for data send
  9544 000044EE 4C89DF                      mov rdi, r11
  9545 000044F1 49B801000000000000-         mov r8, 1
  9545 000044FA 00                 
  9546 000044FB 4D89C1                      mov r9, r8
  9547 000044FE 4D89E2                      mov r10, r12     ;Get back number of bytes to transfer
  9548 00004501 49C1E210                    shl r10, 8*2    ;Shift into 3rd byte
  9549 00004505 4181CA808C0000              or r10d, 00008C80h ;Add control bits: Active TD, OUT EP, Error ctr = 3
  9550 0000450C 0FB64E0F                    movzx ecx, byte [rsi + 15]  ;Get Out EP dt bit in r9d
  9551 00004510 80760F01                    xor byte [rsi + 15], 1  ;Toggle bit
  9552 00004514 D1C9                        ror ecx, 1 ;Roll dt bit to upper bit of dword
  9553 00004516 4109CA                      or r10d, ecx    ;Add dt bit to r10d
  9554 00004519 4989DB                      mov r11, rbx    ;Get the address of Data buffer
  9555 0000451C E864F9FFFF                  call .ehciWriteQHeadTD
  9556                                  
  9557 00004521 B103                        mov cl, 11b    ;Lock out internal buffer
  9558 00004523 E890F2FFFF                  call .ehciProcessCommand        ;Run controller
  9559 00004528 0F82F6000000                jc .emboexit    ;If catastrophic Host system error, exit!
  9560                                  ;Write Qhead for CSW
  9561 0000452E 49BB-                       mov r11, ehciTDSpace + 2*ehciSizeOfTD ;Third TD
  9561 00004530 [8001000000000000] 
  9562 00004538 E8DB010000                  call .ehciMsdWriteInQHead
  9563 0000453D 4C89DF                      mov rdi, r11
  9564 00004540 E9A9000000                  jmp .emboiicommonep
  9565                                  .ehciMsdBOTOII: ;Out In In transfer
  9566                                  ;Input - rsi = MSD device parameter block
  9567                                  ;        rbx = Input buffer for Data In
  9568                                  ;        ecx = Number of milliseconds to wait between Out and In packets
  9569                                  ;        r8  = Number of bytes to be transferred (for the DATA phase)
  9570                                  ;        r10 = LUN Value
  9571                                  ;        r11 = Length of CBW command block
  9572                                  
  9573 00004545 57                          push rdi
  9574 00004546 4150                        push r8
  9575 00004548 4151                        push r9
  9576 0000454A 4152                        push r10
  9577 0000454C 4153                        push r11
  9578 0000454E 4154                        push r12
  9579 00004550 51                          push rcx
  9580 00004551 FC                          cld
  9581                                  
  9582 00004552 4D89C4                      mov r12, r8 ;Save the number of bytes to be transferred
  9583 00004555 51                          push rcx
  9584                                  
  9585                                  ;Write the OUT Queue Head
  9586 00004556 49BB-                       mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  9586 00004558 [0001000000000000] 
  9587 00004560 E874010000                  call .ehciMsdWriteOutQHead
  9588                                  
  9589 00004565 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  9590 00004568 49B801000000000000-         mov r8, 1
  9590 00004571 00                 
  9591 00004572 4D89C1                      mov r9, r8
  9592 00004575 440FB6560F                  movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  9593 0000457A 80760F01                    xor byte [rsi + 15], 1  ;Toggle bit
  9594 0000457E 41D1CA                      ror r10d, 1 ;Roll dt bit to upper bit of dword
  9595 00004581 4181CA808C1F00              or r10d, 001F8C80h 
  9596                                  ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  9597 00004588 49BB-                       mov r11, ehciDataOut ; Data out buffer
  9597 0000458A [8003000000000000] 
  9598 00004592 E8EEF8FFFF                  call .ehciWriteQHeadTD
  9599                                  
  9600 00004597 B103                        mov cl, 11b    ;Lock out internal buffer
  9601 00004599 E81AF2FFFF                  call .ehciProcessCommand        ;Run controller
  9602 0000459E 59                          pop rcx    ;Wait ecx ms for "motors to spin up"
  9603 0000459F 0F827F000000                jc .emboexit    ;If catastrophic Host system error, exit!
  9604                                           
  9605 000045A5 50                          push rax
  9606 000045A6 B486                        mov ah, 86h
  9607 000045A8 CD35                        int 35h
  9608 000045AA 58                          pop rax
  9609                                  ;Write the IN Queue Head
  9610 000045AB 49BB-                       mov r11, ehciTDSpace + ehciSizeOfTD ;Move to position 2 to preserve OUT TD
  9610 000045AD [4001000000000000] 
  9611 000045B5 E85E010000                  call .ehciMsdWriteInQHead
  9612                                  
  9613 000045BA 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  9614 000045BD 4C8D4740                    lea r8, qword [rdi + ehciSizeOfTD]  ;Point to next TD
  9615 000045C1 4D89C1                      mov r9, r8
  9616 000045C4 4D89E2                      mov r10, r12     ;Get back number of bytes to transfer from the stack
  9617 000045C7 49C1E210                    shl r10, 8*2    ;Shift into 3rd byte
  9618 000045CB 4181CA800D0000              or r10d, 00000D80h ;Add control bits: Active TD, IN EP, Error ctr = 3
  9619 000045D2 0FB64E0E                    movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  9620 000045D6 80760E01                    xor byte [rsi + 14], 1  ;Toggle bit
  9621 000045DA D1C9                        ror ecx, 1 ;Roll dt bit to upper bit of dword
  9622 000045DC 4109CA                      or r10d, ecx    ;Add dt bit to r10d
  9623 000045DF 4989DB                      mov r11, rbx ; Data out buffer, default ehciDataIn
  9624 000045E2 E89EF8FFFF                  call .ehciWriteQHeadTD
  9625                                  
  9626 000045E7 4881C740000000              add rdi, ehciSizeOfTD     ;Go to next TD space
  9627                                  .emboiicommonep:
  9628 000045EE 49B801000000000000-         mov r8, 1
  9628 000045F7 00                 
  9629 000045F8 4D89C1                      mov r9, r8
  9630 000045FB 41BA808D0D00                mov r10d, 000D8D80h     ;Active TD, IN EP, Error ctr = 3, 0Dh = 13 byte CSW
  9631 00004601 0FB64E0E                    movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  9632 00004605 80760E01                    xor byte [rsi + 14], 1  ;Toggle bit
  9633 00004609 D1C9                        ror ecx, 1 ;Roll dt bit to upper bit of dword
  9634 0000460B 4109CA                      or r10d, ecx    ;Add dt bit to r10d
  9635 0000460E 49BB-                       mov r11, msdCSW
  9635 00004610 [C005000000000000] 
  9636                                  
  9637 00004618 E868F8FFFF                  call .ehciWriteQHeadTD
  9638                                  
  9639 0000461D B103                        mov cl, 11b    ;Lock out internal buffer
  9640 0000461F E894F1FFFF                  call .ehciProcessCommand        ;Run controller
  9641                                  .emboexit:
  9642 00004624 59                          pop rcx
  9643 00004625 415C                        pop r12
  9644 00004627 415B                        pop r11
  9645 00004629 415A                        pop r10
  9646 0000462B 4159                        pop r9
  9647 0000462D 4158                        pop r8
  9648 0000462F 5F                          pop rdi
  9649 00004630 C3                          ret
  9650                                  .ehciMsdBOTOI: ;Out In transfer
  9651                                  ;Input - rsi = MSD device parameter block
  9652                                  ;        rbx = Input buffer for Data In
  9653                                  ;        ecx = Number of milliseconds to wait between Out and In packets
  9654                                  ;        r8  = Number of bytes to be transferred (for the DATA phase)
  9655                                  ;        r10 = LUN Value
  9656                                  ;        r11 = Length of CBW command block
  9657                                  
  9658 00004631 57                          push rdi
  9659 00004632 4150                        push r8
  9660 00004634 4151                        push r9
  9661 00004636 4152                        push r10
  9662 00004638 4153                        push r11
  9663 0000463A 51                          push rcx
  9664 0000463B FC                          cld
  9665                                  
  9666                                  
  9667                                  ;Write the OUT Queue Head
  9668 0000463C 49BB-                       mov r11, ehciTDSpace ;First TD is the head of the Out buffer
  9668 0000463E [0001000000000000] 
  9669 00004646 E88E000000                  call .ehciMsdWriteOutQHead
  9670                                  
  9671 0000464B 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  9672 0000464E 49B801000000000000-         mov r8, 1
  9672 00004657 00                 
  9673 00004658 4D89C1                      mov r9, r8
  9674 0000465B 440FB6560F                  movzx r10d, byte [rsi + 15]   ;Get Out EP dt bit
  9675 00004660 80760F01                    xor byte [rsi + 15], 1  ;Toggle bit
  9676 00004664 41D1CA                      ror r10d, 1 ;Roll dt bit to upper bit of dword
  9677 00004667 4181CA808C1F00              or r10d, 001F8C80h 
  9678                                  ; Active TD, OUT EP, Error ctr = 3, 01Fh = 31 byte transfer
  9679 0000466E 49BB-                       mov r11, ehciDataOut ; Data out buffer
  9679 00004670 [8003000000000000] 
  9680 00004678 E808F8FFFF                  call .ehciWriteQHeadTD
  9681                                  
  9682 0000467D B103                        mov cl, 11b    ;Lock out internal buffer
  9683 0000467F E834F1FFFF                  call .ehciProcessCommand        ;Run controller
  9684 00004684 7248                        jc .emboiexit    ;If catastrophic Host system error, exit!
  9685                                           
  9686                                  ;Write the IN Queue Head
  9687 00004686 49BB-                       mov r11, ehciTDSpace + ehciSizeOfTD ;Move to position 2 to preserve OUT TD
  9687 00004688 [4001000000000000] 
  9688 00004690 E883000000                  call .ehciMsdWriteInQHead
  9689                                  
  9690 00004695 4C89DF                      mov rdi, r11    ;Move pointer to TD buffer head
  9691 00004698 49B801000000000000-         mov r8, 1
  9691 000046A1 00                 
  9692 000046A2 4D89C1                      mov r9, r8
  9693 000046A5 41BA808D0D00                mov r10d, 000D8D80h     ;Active TD, IN EP, Error ctr = 3, 0Dh = 13 byte CSW
  9694 000046AB 0FB64E0E                    movzx ecx, byte [rsi + 14]  ;Get IN EP dt bit in r9d
  9695 000046AF 80760E01                    xor byte [rsi + 14], 1  ;Toggle bit
  9696 000046B3 D1C9                        ror ecx, 1 ;Roll dt bit to upper bit of dword
  9697 000046B5 4109CA                      or r10d, ecx    ;Add dt bit to r10d
  9698 000046B8 49BB-                       mov r11, msdCSW
  9698 000046BA [C005000000000000] 
  9699                                  
  9700 000046C2 E8BEF7FFFF                  call .ehciWriteQHeadTD
  9701                                  
  9702 000046C7 B103                        mov cl, 11b    ;Lock out internal buffer
  9703 000046C9 E8EAF0FFFF                  call .ehciProcessCommand        ;Run controller
  9704                                  .emboiexit:
  9705 000046CE 59                          pop rcx
  9706 000046CF 415B                        pop r11
  9707 000046D1 415A                        pop r10
  9708 000046D3 4159                        pop r9
  9709 000046D5 4158                        pop r8
  9710 000046D7 5F                          pop rdi
  9711 000046D8 C3                          ret
  9712                                  .ehciMsdWriteOutQHead:
  9713                                  ;Input: rsi = Valid MSD device
  9714                                  ;       r11 = Ptr to First QHTD
  9715 000046D9 E84CEEFFFF                  call .ehciGetNewQHeadAddr
  9716 000046DE 4181C802000000              or r8d, 2    ;Process QHs
  9717 000046E5 41B900600000                mov r9d, 00006000h  ;Default mask, no nak counter
  9718 000046EB 0FB74E0C                    movzx ecx, word [rsi + 12]  ;wMaxPacketSizeOut
  9719 000046EF C1E110                      shl ecx, 8*2
  9720 000046F2 4109C9                      or r9d, ecx
  9721 000046F5 0FB64E0B                    movzx ecx, byte [rsi + 11]  ;EP address
  9722 000046F9 81E10F000000                and ecx, 0Fh
  9723 000046FF C1E108                      shl ecx, 8  ;Shift to second byte 
  9724 00004702 4109C9                      or r9d, ecx ;Add bits
  9725 00004705 8A06                        mov al, byte [rsi]  ;Get device address
  9726 00004707 247F                        and al, 7Fh    ;Force clear upper bit of al
  9727 00004709 4108C1                      or r9b, al    ;Set lower 8 bits of r9 correctly
  9728 0000470C 41BA00000040                mov r10d, 40000000h    ;1 transaction/ms
  9729 00004712 E849F7FFFF                  call .ehciWriteQHead
  9730 00004717 C3                          ret
  9731                                  .ehciMsdWriteInQHead:
  9732                                  ;Input: rsi = Valid MSD device
  9733                                  ;       r11 = Ptr to First QHTD
  9734 00004718 E80DEEFFFF                  call .ehciGetNewQHeadAddr
  9735 0000471D 4981C802000000              or r8, 2
  9736 00004724 41B900600000                mov r9d, 00006000h  ;Default mask
  9737 0000472A 0FB74E09                    movzx ecx, word [rsi + 9]  ;wMaxPacketSizeIn
  9738 0000472E C1E110                      shl ecx, 8*2
  9739 00004731 4109C9                      or r9d, ecx
  9740 00004734 0FB64E08                    movzx ecx, byte [rsi + 8]  ;EP address
  9741 00004738 81E10F000000                and ecx, 0Fh
  9742 0000473E C1E108                      shl ecx, 8  ;Shift to second byte 
  9743 00004741 4109C9                      or r9d, ecx ;Add bits
  9744 00004744 8A06                        mov al, byte [rsi]  ;Get device address
  9745 00004746 247F                        and al, 7Fh    ;Force clear upper bit of al
  9746 00004748 4108C1                      or r9b, al    ;Set lower 8 bits of r9 correctly
  9747 0000474B 41BA00000040                mov r10d, 40000000h    ;1 transaction/ms
  9748 00004751 E80AF7FFFF                  call .ehciWriteQHead
  9749 00004756 C3                          ret
  9750                                  .ehciMsdBOTRequest:
  9751                                  ;Input: ecx = Number of miliseconds to wait between Out and In requests
  9752                                  ;       rbx = Data in Buffer
  9753                                  ;       r8  = Number of bytes to be returned by command
  9754                                  ;       r11 = Length of SCSI command block
  9755                                  ;       r14 = Pointer to EHCI(USB) transaction function
  9756                                  ;       r15 = Pointer to SCSI command function
  9757                                  ;Output:
  9758                                  ;   CF=CY: Host error, Reset host system
  9759                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9760 00004757 50                          push rax
  9761 00004758 51                          push rcx
  9762 00004759 57                          push rdi
  9763 0000475A 4151                        push r9
  9764 0000475C 4152                        push r10
  9765                                  ;Clear the previous CSW
  9766 0000475E 48BF-                       mov rdi, msdCSW
  9766 00004760 [C005000000000000] 
  9767 00004768 30C0                        xor al, al
  9768 0000476A B90D000000                  mov ecx, 13
  9769 0000476F F3AA                        rep stosb
  9770                                  ;Write the CBW
  9771 00004771 48BF-                       mov rdi, ehciDataOut    ;Write the CBW at the data out point
  9771 00004773 [8003000000000000] 
  9772                                  
  9773 0000477B 41B180                      mov r9b, 80h            ;Recieve an IN packet
  9774 0000477E 4D31D2                      xor r10, r10            ;LUN 0
  9775 00004781 E865030000                  call .msdWriteCBW       ;Write the 15 byte CBW
  9776                                  ;Append the Command Block to the CBW
  9777 00004786 30C0                        xor al, al              ;LUN 0 device
  9778 00004788 41FFD7                      call r15                ;Write the valid CBW Command block
  9779                                  ;Enact transaction
  9780 0000478B 41FFD6                      call r14
  9781                                  
  9782 0000478E 415A                        pop r10
  9783 00004790 4159                        pop r9
  9784 00004792 5F                          pop rdi
  9785 00004793 59                          pop rcx
  9786 00004794 58                          pop rax
  9787 00004795 C3                          ret
  9788                                  
  9789                                  .ehciMsdBOTInquiry:
  9790                                  ;Input: 
  9791                                  ; rsi = Pointer to MSD table data structure that we want to Inqure
  9792                                  ;Output:
  9793                                  ;   CF=CY: Host error, Reset host system
  9794                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9795 00004796 53                          push rbx
  9796 00004797 51                          push rcx
  9797 00004798 4150                        push r8
  9798 0000479A 4153                        push r11
  9799 0000479C 4156                        push r14
  9800 0000479E 4157                        push r15
  9801 000047A0 48BB-                       mov rbx, ehciDataIn
  9801 000047A2 [C003000000000000] 
  9802 000047AA B900000000                  mov ecx, 0
  9803 000047AF 41B824000000                mov r8d, 024h           ;36 bytes to be returned
  9804 000047B5 49BB0C000000000000-         mov r11, 0Ch            ;The command block is 12 bytes (As per Bootability)
  9804 000047BE 00                 
  9805 000047BF 49BF-                       mov r15, .scsiInquiry
  9805 000047C1 [1C4B000000000000] 
  9806 000047C9 49BE-                       mov r14, .ehciMsdBOTOII
  9806 000047CB [4545000000000000] 
  9807 000047D3 E87FFFFFFF                  call .ehciMsdBOTRequest
  9808 000047D8 415F                        pop r15
  9809 000047DA 415E                        pop r14
  9810 000047DC 415B                        pop r11
  9811 000047DE 4158                        pop r8
  9812 000047E0 59                          pop rcx
  9813 000047E1 5B                          pop rbx
  9814 000047E2 C3                          ret
  9815                                  
  9816                                  .ehciMsdBOTReadFormatCapacities:
  9817                                  ;Input: 
  9818                                  ; rsi = Pointer to MSD table data structure
  9819                                  ;Output:
  9820                                  ;   CF=CY: Host error, Reset host system
  9821                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9822 000047E3 53                          push rbx
  9823 000047E4 51                          push rcx
  9824 000047E5 4150                        push r8
  9825 000047E7 4153                        push r11
  9826 000047E9 4156                        push r14
  9827 000047EB 4157                        push r15
  9828 000047ED 48BB-                       mov rbx, ehciDataIn
  9828 000047EF [C003000000000000] 
  9829 000047F7 B900000000                  mov ecx, 0
  9830 000047FC 49B8FC000000000000-         mov r8, 0FCh            ;Return 252 bytes
  9830 00004805 00                 
  9831 00004806 49BB0A000000000000-         mov r11, 0Ah            ;The command block is 10 bytes
  9831 0000480F 00                 
  9832 00004810 49BF-                       mov r15, .scsiReadFormatCapacities
  9832 00004812 [7B4B000000000000] 
  9833 0000481A 49BE-                       mov r14, .ehciMsdBOTOII
  9833 0000481C [4545000000000000] 
  9834 00004824 E82EFFFFFF                  call .ehciMsdBOTRequest
  9835 00004829 415F                        pop r15
  9836 0000482B 415E                        pop r14
  9837 0000482D 415B                        pop r11
  9838 0000482F 4158                        pop r8
  9839 00004831 59                          pop rcx
  9840 00004832 5B                          pop rbx
  9841 00004833 C3                          ret
  9842                                  
  9843                                  .ehciMsdBOTReadCapacity10:
  9844                                  ;Input: 
  9845                                  ; rsi = Pointer to MSD table data structure that we want to Read Capcities
  9846                                  ;Output:
  9847                                  ;   CF=CY: Host error, Reset host system
  9848                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9849 00004834 53                          push rbx
  9850 00004835 51                          push rcx
  9851 00004836 4150                        push r8
  9852 00004838 4153                        push r11
  9853 0000483A 4156                        push r14
  9854 0000483C 4157                        push r15
  9855 0000483E 48BB-                       mov rbx, ehciDataIn
  9855 00004840 [C003000000000000] 
  9856 00004848 B900000000                  mov ecx, 0
  9857 0000484D 49B808000000000000-         mov r8, 8
  9857 00004856 00                 
  9858 00004857 49BB0A000000000000-         mov r11, 0Ah
  9858 00004860 00                 
  9859 00004861 49BF-                       mov r15, .scsiReadCap10
  9859 00004863 [8B4B000000000000] 
  9860 0000486B 49BE-                       mov r14, .ehciMsdBOTOII
  9860 0000486D [4545000000000000] 
  9861 00004875 E8DDFEFFFF                  call .ehciMsdBOTRequest
  9862 0000487A 415F                        pop r15
  9863 0000487C 415E                        pop r14
  9864 0000487E 415B                        pop r11
  9865 00004880 4158                        pop r8
  9866 00004882 59                          pop rcx
  9867 00004883 5B                          pop rbx
  9868 00004884 C3                          ret
  9869                                  .ehciMsdBOTFormatUnit:
  9870                                  ;Input: 
  9871                                  ; rsi = Pointer to MSD table data structure that we want to Format
  9872                                  ;Output:
  9873                                  ;   CF=CY: Host error, Reset host system
  9874                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9875 00004885 50                          push rax
  9876 00004886 4150                        push r8
  9877 00004888 4153                        push r11
  9878 0000488A 4156                        push r14
  9879 0000488C 4157                        push r15
  9880 0000488E 4D31C0                      xor r8, r8  ;Request no data
  9881 00004891 49BB06000000000000-         mov r11, 06h  ;Command length is 6 bytes
  9881 0000489A 00                 
  9882 0000489B 49BE-                       mov r14, .ehciMsdBOTOI
  9882 0000489D [3146000000000000] 
  9883 000048A5 49BF-                       mov r15, .scsiFormatUnit
  9883 000048A7 [954B000000000000] 
  9884 000048AF E8A3FEFFFF                  call .ehciMsdBOTRequest
  9885 000048B4 7236                        jc .embfuerror
  9886 000048B6 E897FBFFFF                  call .ehciMsdBOTCheckTransaction
  9887 000048BB 6685C0                      test ax, ax
  9888 000048BE 752C                        jnz .embfuerror
  9889                                  .embfu0:
  9890 000048C0 E8CA000000                  call .ehciMsdBOTTestReady
  9891 000048C5 7225                        jc .embfuerror
  9892 000048C7 E886FBFFFF                  call .ehciMsdBOTCheckTransaction
  9893 000048CC 6685C0                      test ax, ax
  9894 000048CF 7411                        jz .embfuexit
  9895 000048D1 E868000000                  call .ehciMsdBOTRequestSense
  9896 000048D6 7214                        jc .embfuerror
  9897 000048D8 E875FBFFFF                  call .ehciMsdBOTCheckTransaction
  9898 000048DD 6685C0                      test ax, ax
  9899 000048E0 75DE                        jnz .embfu0
  9900                                  .embfuexit:
  9901 000048E2 415F                        pop r15
  9902 000048E4 415E                        pop r14
  9903 000048E6 415B                        pop r11
  9904 000048E8 4158                        pop r8
  9905 000048EA 58                          pop rax
  9906 000048EB C3                          ret
  9907                                  .embfuerror:
  9908 000048EC F9                          stc
  9909 000048ED EBF3                        jmp short .embfuexit
  9910                                  .ehciMsdBOTVerify:
  9911                                  ;Input: 
  9912                                  ; rsi = Pointer to MSD table data structure that we want to Verify Sectors
  9913                                  ; edx = Starting LBA to verify
  9914                                  ;Output:
  9915                                  ;   CF=CY: Host error, Reset host system
  9916                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9917 000048EF 50                          push rax
  9918 000048F0 4150                        push r8
  9919 000048F2 4153                        push r11
  9920 000048F4 4154                        push r12
  9921 000048F6 4156                        push r14
  9922 000048F8 4157                        push r15
  9923 000048FA 4D31C0                      xor r8, r8  ;Request no data
  9924 000048FD 49BB0A000000000000-         mov r11, 0Ah  ;Command length is 10 bytes
  9924 00004906 00                 
  9925 00004907 4189D4                      mov r12d, edx
  9926 0000490A 49BE-                       mov r14, .ehciMsdBOTOI
  9926 0000490C [3146000000000000] 
  9927 00004914 49BF-                       mov r15, .scsiVerify
  9927 00004916 [AA4B000000000000] 
  9928 0000491E E834FEFFFF                  call .ehciMsdBOTRequest
  9929 00004923 7216                        jc .embvbad
  9930 00004925 E828FBFFFF                  call .ehciMsdBOTCheckTransaction
  9931 0000492A 6685C0                      test ax, ax
  9932 0000492D 750C                        jnz .embvbad
  9933                                  .embvexit:
  9934 0000492F 415F                        pop r15
  9935 00004931 415E                        pop r14
  9936 00004933 415C                        pop r12
  9937 00004935 415B                        pop r11
  9938 00004937 4158                        pop r8
  9939 00004939 59                          pop rcx
  9940 0000493A C3                          ret
  9941                                  .embvbad:
  9942 0000493B F9                          stc
  9943 0000493C EBF1                        jmp short .embvexit
  9944                                  .ehciMsdBOTRequestSense:
  9945                                  ;Input: 
  9946                                  ; rsi = Pointer to device MSD table data structure
  9947                                  ;Output:
  9948                                  ;   CF=CY: Host error, Reset host system
  9949                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9950 0000493E 53                          push rbx
  9951 0000493F 51                          push rcx
  9952 00004940 4150                        push r8
  9953 00004942 4153                        push r11
  9954 00004944 4156                        push r14
  9955 00004946 4157                        push r15
  9956 00004948 48BB-                       mov rbx, ehciDataIn
  9956 0000494A [C003000000000000] 
  9957 00004952 B900000000                  mov ecx, 0
  9958 00004957 49B812000000000000-         mov r8, 12h         ;Request 18 bytes
  9958 00004960 00                 
  9959 00004961 49BB06000000000000-         mov r11, 6          ;Command length is 6
  9959 0000496A 00                 
  9960 0000496B 49BF-                       mov r15, .scsiRequestSense
  9960 0000496D [5E4B000000000000] 
  9961 00004975 49BE-                       mov r14, .ehciMsdBOTOII
  9961 00004977 [4545000000000000] 
  9962 0000497F E8D3FDFFFF                  call .ehciMsdBOTRequest
  9963 00004984 415F                        pop r15
  9964 00004986 415E                        pop r14
  9965 00004988 415B                        pop r11
  9966 0000498A 4158                        pop r8
  9967 0000498C 59                          pop rcx
  9968 0000498D 5B                          pop rbx
  9969 0000498E C3                          ret
  9970                                  
  9971                                  .ehciMsdBOTTestReady:
  9972                                  ;Input: 
  9973                                  ; rsi = Pointer to MSD table data structure that we want to Test Ready
  9974                                  ;Output:
  9975                                  ;   CF=CY: Host error, Reset host system
  9976                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9977 0000498F 4150                        push r8
  9978 00004991 4153                        push r11
  9979 00004993 4156                        push r14
  9980 00004995 4157                        push r15
  9981 00004997 4D31C0                      xor r8, r8  ;Request no data
  9982 0000499A 49BB06000000000000-         mov r11, 6  ;Command length is 6
  9982 000049A3 00                 
  9983 000049A4 49BE-                       mov r14, .ehciMsdBOTOI
  9983 000049A6 [3146000000000000] 
  9984 000049AE 49BF-                       mov r15, .scsiTestUnitReady
  9984 000049B0 [714B000000000000] 
  9985 000049B8 E89AFDFFFF                  call .ehciMsdBOTRequest
  9986 000049BD 415F                        pop r15
  9987 000049BF 415E                        pop r14
  9988 000049C1 415B                        pop r11
  9989 000049C3 4158                        pop r8
  9990 000049C5 C3                          ret
  9991                                  .ehciMsdBOTModeSense6:
  9992                                  ;Input: 
  9993                                  ; rsi = Pointer to MSD table data structure that we want to Test Ready
  9994                                  ;Output:
  9995                                  ;   CF=CY: Host error, Reset host system
  9996                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
  9997 000049C6 53                          push rbx
  9998 000049C7 51                          push rcx
  9999 000049C8 4150                        push r8
 10000 000049CA 4153                        push r11
 10001 000049CC 4156                        push r14
 10002 000049CE 4157                        push r15
 10003 000049D0 48BB-                       mov rbx, ehciDataIn
 10003 000049D2 [C003000000000000] 
 10004 000049DA B900000000                  mov ecx, 0
 10005 000049DF 49B8C0000000000000-         mov r8, 0C0h        ;Request 192 bytes
 10005 000049E8 00                 
 10006 000049E9 49BB06000000000000-         mov r11, 6          ;Command length is 6
 10006 000049F2 00                 
 10007 000049F3 49BF-                       mov r15, .scsiModeSense6
 10007 000049F5 [CB4B000000000000] 
 10008 000049FD 49BE-                       mov r14, .ehciMsdBOTOII
 10008 000049FF [4545000000000000] 
 10009 00004A07 E84BFDFFFF                  call .ehciMsdBOTRequest
 10010 00004A0C 415F                        pop r15
 10011 00004A0E 415E                        pop r14
 10012 00004A10 415B                        pop r11
 10013 00004A12 4158                        pop r8
 10014 00004A14 59                          pop rcx
 10015 00004A15 5B                          pop rbx
 10016 00004A16 C3                          ret
 10017                                  
 10018                                  ;.ehciMsdBOTOutSector64:
 10019                                  .ehciMsdBOTOutSector512:
 10020                                  ;Input: 
 10021                                  ; rsi = Pointer to MSD table data structure that we want to read
 10022                                  ; rbx = Address of the buffer to read the segment from
 10023                                  ; edx = Starting LBA to read to
 10024                                  ;Output:
 10025                                  ;   CF=CY: Host error, Reset host system
 10026                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
 10027 00004A17 4151                        push r9
 10028 00004A19 4156                        push r14
 10029 00004A1B 4157                        push r15
 10030 00004A1D 50                          push rax
 10031 00004A1E 4D31C9                      xor r9, r9 ;Send an OUT packet
 10032 00004A21 49BE-                       mov r14, .ehciMsdBOTOOI
 10032 00004A23 [7944000000000000] 
 10033 00004A2B 49BF-                       mov r15, .scsiWrite10
 10033 00004A2D [374B000000000000] 
 10034 00004A35 E860000000                  call .ehciMsdBOTSector512
 10035 00004A3A 7223                        jc .emboseerror
 10036 00004A3C E811FAFFFF                  call .ehciMsdBOTCheckTransaction
 10037 00004A41 6685C0                      test ax, ax
 10038 00004A44 7519                        jnz .emboseerror
 10039 00004A46 E844FFFFFF                  call .ehciMsdBOTTestReady   ;Seems to flush data onto disk
 10040 00004A4B 7212                        jc .emboseerror
 10041 00004A4D E800FAFFFF                  call .ehciMsdBOTCheckTransaction
 10042 00004A52 6685C0                      test ax, ax
 10043 00004A55 7508                        jnz .emboseerror
 10044                                  .embosexit:
 10045 00004A57 58                          pop rax
 10046 00004A58 415F                        pop r15
 10047 00004A5A 415E                        pop r14
 10048 00004A5C 4159                        pop r9
 10049 00004A5E C3                          ret
 10050                                  .emboseerror:
 10051 00004A5F F9                          stc
 10052 00004A60 EBF5                        jmp short .embosexit
 10053                                  ;.ehciMsdBOTInSector64:
 10054                                  .ehciMsdBOTInSector512:
 10055                                  ;Input: 
 10056                                  ; rsi = Pointer to MSD table data structure that we want to read
 10057                                  ; rbx = Address of the buffer to read the segment into
 10058                                  ; edx = Starting LBA to read from
 10059                                  ;Output:
 10060                                  ;   CF=CY: Host error, Reset host system
 10061                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
 10062 00004A62 4151                        push r9
 10063 00004A64 4156                        push r14
 10064 00004A66 4157                        push r15
 10065 00004A68 50                          push rax
 10066 00004A69 49B980000000000000-         mov r9, 80h ;Recieve an IN packet
 10066 00004A72 00                 
 10067 00004A73 49BE-                       mov r14, .ehciMsdBOTOII
 10067 00004A75 [4545000000000000] 
 10068 00004A7D 49BF-                       mov r15, .scsiRead10
 10068 00004A7F [3B4B000000000000] 
 10069 00004A87 E80E000000                  call .ehciMsdBOTSector512
 10070 00004A8C 72D1                        jc .emboseerror
 10071 00004A8E E8BFF9FFFF                  call .ehciMsdBOTCheckTransaction
 10072 00004A93 6685C0                      test ax, ax
 10073 00004A96 75C7                        jnz .emboseerror
 10074 00004A98 EBBD                        jmp short .embosexit
 10075                                  .ehciMsdBOTSector512:
 10076                                  ;Input: 
 10077                                  ; rsi = Pointer to MSD table data structure that we want to read
 10078                                  ; rbx = Address of the buffer to read the segment into
 10079                                  ; edx = Starting LBA to read to/from
 10080                                  ; r9  = CBW flag (IN or OUT transaction)
 10081                                  ; r15 = SCSI function
 10082                                  ;Output:
 10083                                  ;   CF=CY: Host error, Reset host system
 10084                                  ;   CF=NC: Transaction succeeded, check data transferred successfully
 10085 00004A9A 57                          push rdi
 10086 00004A9B 4150                        push r8
 10087 00004A9D 4152                        push r10
 10088 00004A9F 4153                        push r11
 10089                                  
 10090 00004AA1 48BF-                       mov rdi, ehciDataOut    ;Write the CBW at the data out point
 10090 00004AA3 [8003000000000000] 
 10091 00004AAB 41B800020000                mov r8d, 200h           ;512 bytes to be transferred
 10092 00004AB1 4D31D2                      xor r10, r10            ;LUN 0
 10093 00004AB4 49BB0C000000000000-         mov r11, 0Ch            ;The command block is 10 bytes long
 10093 00004ABD 00                 
 10094 00004ABE E828000000                  call .msdWriteCBW     ;Write the CBW
 10095                                  
 10096 00004AC3 50                          push rax                ;Temp push ax
 10097 00004AC4 4150                        push r8                 ;Temp save # of bytes for transfer
 10098 00004AC6 30C0                        xor al, al              ;LUN 0 device
 10099 00004AC8 4189D0                      mov r8d, edx            ;Starting LBA to read from
 10100 00004ACB 49B901000000000000-         mov r9, 1               ;Number of LBAs to read
 10100 00004AD4 00                 
 10101 00004AD5 41FFD7                      call r15                ;Write the valid CBW Command block
 10102 00004AD8 4158                        pop r8
 10103 00004ADA 58                          pop rax
 10104                                  
 10105 00004ADB B90A000000                  mov ecx, 10              ;Wait for data preparation, 10ms
 10106 00004AE0 41FFD6                      call r14
 10107                                  
 10108 00004AE3 415B                        pop r11
 10109 00004AE5 415A                        pop r10
 10110 00004AE7 4158                        pop r8
 10111 00004AE9 5F                          pop rdi
 10112 00004AEA C3                          ret
 10113                                  .msdWriteCBW:
 10114                                  ;Writes a Command Block Wrapper at the location pointed to by rdi
 10115                                  ; without a functional command block. Must be appended by user.
 10116                                  ; Input:  rdi=Pointer to CBW buffer
 10117                                  ;         r8d=Command Block Wrapper Data Transfer Length
 10118                                  ;         r9b=Command Block Wrapper Flags
 10119                                  ;         r10b=Command Block Wrapper LUN nybble
 10120                                  ;         r11b=Command Block Wrapper Command Block Length
 10121                                  ; Output: rdi = Pointer to CBW's (SCSI) Command Descriptor Block buffer
 10122 00004AEB 50                          push rax
 10123 00004AEC B855534243                  mov eax, CBWSig
 10124 00004AF1 AB                          stosd
 10125 00004AF2 0FB60425[4A020000]          movzx eax, byte [cbwTag]
 10126 00004AFA FE0425[4A020000]            inc byte [cbwTag]
 10127 00004B01 AB                          stosd
 10128 00004B02 4489C0                      mov eax, r8d
 10129 00004B05 AB                          stosd
 10130 00004B06 4488C8                      mov al, r9b
 10131 00004B09 AA                          stosb
 10132 00004B0A 4488D0                      mov al, r10b
 10133 00004B0D AA                          stosb
 10134 00004B0E 4488D8                      mov al, r11b
 10135 00004B11 AA                          stosb
 10136 00004B12 31C0                        xor eax, eax
 10137 00004B14 57                          push rdi
 10138 00004B15 48AB                        stosq   ;16 bytes in csw command block
 10139 00004B17 48AB                        stosq   ;Clear memory
 10140 00004B19 5F                          pop rdi
 10141 00004B1A 58                          pop rax
 10142 00004B1B C3                          ret
 10143                                  
 10144                                  ;                        --------SCSI functions---------
 10145                                  
 10146                                  .scsiInquiry:
 10147                                  ;Writes an inquiry scsi command block to the location pointed to by rdi
 10148                                  ;al contains the LUN of the device we are accessing. (lower 3 bits considered)
 10149                                  ;al not preserved
 10150 00004B1C B412                        mov ah, 12h        ;Move inquiry command value high
 10151 00004B1E C0E005                      shl al, 5        ;Shift left by five to align LUN properly
 10152 00004B21 86E0                        xchg ah, al        ;swap ah and al
 10153 00004B23 66AB                        stosw            ;Store command and shifted LUN together
 10154 00004B25 4831C0                      xor rax, rax
 10155 00004B28 66AB                        stosw            ;Store two zeros (reserved fields)
 10156 00004B2A 48B824000000000000-         mov rax, 24h    ;Allocation length (36 bytes)
 10156 00004B33 00                 
 10157 00004B34 48AB                        stosq
 10158 00004B36 C3                          ret
 10159                                  ;NOTE! Using read/write 10 means can't read beyond the first 4 Gb of Medium.
 10160                                  .scsiWrite10:
 10161                                  ;Writes a scsi write 10 transfer command to the location pointed at by rdi
 10162                                  ;al contains the LUN of the device we are accessing
 10163                                  ;r8d contains the LBA start address
 10164                                  ;r9w contains the Verification Length
 10165 00004B37 B42A                        mov ah, 2Ah        ;Operation code for command
 10166 00004B39 EB02                        jmp short .scsirw
 10167                                  .scsiRead10:
 10168                                  ;Writes a scsi Read 10 command to the location pointed to by rdi
 10169                                  ;al contains the LUN of the device we are accessing.
 10170                                  ;r8d contains the LBA to read from
 10171                                  ;r9w contains the number of contiguous blocks to read (should be 1 for us)
 10172 00004B3B B428                        mov ah, 28h        ;Move read(10) command value high
 10173                                  .scsirw:
 10174 00004B3D C0E005                      shl al, 5        ;Shift left by five to align LUN properly
 10175 00004B40 86E0                        xchg ah, al        ;swap ah and al
 10176 00004B42 66AB                        stosw            ;Store command and shifted LUN together
 10177 00004B44 410FC8                      bswap r8d        ;swap endianness of r8d
 10178 00004B47 4489C0                      mov eax, r8d
 10179 00004B4A AB                          stosd
 10180 00004B4B 4831C0                      xor rax, rax    ;Clear for a Reserved byte
 10181 00004B4E AA                          stosb
 10182 00004B4F 664489C8                    mov ax, r9w        ;move into ax to use xchg on upper and lower bytes
 10183 00004B53 86C4                        xchg al, ah        ;MSB first, yuck yuck yuck
 10184 00004B55 66AB                        stosw
 10185 00004B57 C1E810                      shr eax, 16        ;Bring zeros down onto lower word
 10186 00004B5A 66AB                        stosw            ;Store one reserved byte and two padding bytes
 10187 00004B5C AA                          stosb            
 10188 00004B5D C3                          ret
 10189                                  .scsiRequestSense:
 10190                                  ;Writes a scsi Request Sense command to the location pointer to by rdi
 10191                                  ;al contains the LUN of the device we are accessing.
 10192 00004B5E B403                        mov ah, 03h        ;Move reqsense command value high
 10193 00004B60 C0E005                      shl al, 5        ;Shift left by five to align LUN properly
 10194 00004B63 86E0                        xchg ah, al        ;swap ah and al
 10195 00004B65 66AB                        stosw            ;Store command and shifted LUN together
 10196 00004B67 4831C0                      xor rax, rax    
 10197 00004B6A 66AB                        stosw            ;Reserved word
 10198 00004B6C B012                        mov al, 12h    ;Move alloc length byte into al
 10199 00004B6E 48AB                        stosq
 10200 00004B70 C3                          ret
 10201                                  .scsiTestUnitReady:
 10202                                  ;Writes a scsi test unit ready command to the location pointed to by rdi
 10203                                  ;al contains the LUN of the device we are accessing.
 10204 00004B71 30E4                        xor ah, ah        ;Operation code zero
 10205 00004B73 C0E005                      shl al, 5
 10206 00004B76 86E0                        xchg ah, al
 10207 00004B78 66AB                        stosw            ;Store shifted LUN and command code
 10208 00004B7A C3                          ret
 10209                                  .scsiReadFormatCapacities:
 10210                                  ;al contains the LUN of the device
 10211 00004B7B 88C4                        mov ah, al
 10212 00004B7D B023                        mov al, 23h        ;Operation code for command
 10213 00004B7F 66AB                        stosw            ;Store shifted LUN and command code
 10214 00004B81 4831C0                      xor rax, rax
 10215 00004B84 AB                          stosd          ;Reserved dword    
 10216 00004B85 66AB                        stosw           ;Reserved word
 10217 00004B87 B0FC                        mov al, 0FCh    ;Move alloc length byte into al
 10218 00004B89 AA                          stosb
 10219 00004B8A C3                          ret
 10220                                  .scsiReadCap10:
 10221                                  ;Writes a scsi read capacity command to the location pointed to by rdi
 10222                                  ;al contains the LUN of the device we are accessing
 10223 00004B8B B425                        mov ah, 25h        ;Operation code for command
 10224 00004B8D C0E005                      shl al, 5
 10225 00004B90 86E0                        xchg ah, al
 10226 00004B92 66AB                        stosw            ;Store shifted LUN and command code
 10227 00004B94 C3                          ret
 10228                                  .scsiFormatUnit:
 10229                                  ;Writes a scsi format unit command to the location pointed to by rdi
 10230                                  ;al contains the LUN of the device we are accessing
 10231 00004B95 B404                        mov ah, 04h        ;Operation code for format command
 10232 00004B97 C0E005                      shl al, 5
 10233 00004B9A 0C17                        or al, 17h      ;Set bits [3:0] and 5, keep bit 4 clear
 10234 00004B9C 86E0                        xchg ah, al
 10235 00004B9E 66AB                        stosw
 10236 00004BA0 30C0                        xor al, al
 10237 00004BA2 66AB                        stosw            ;Vender specific, set to 0!!
 10238 00004BA4 4831C0                      xor rax, rax
 10239 00004BA7 48AB                        stosq            ;Store LSB byte and all the 0 padding
 10240 00004BA9 C3                          ret
 10241                                  .scsiVerify:
 10242                                  ;Writes a scsi verify transfer command to the location pointed at by rdi
 10243                                  ;al contains the LUN of the device we are accessing
 10244                                  ;r12d contains the LBA for the sector address
 10245                                  ;Verifies one sector
 10246 00004BAA B42F                        mov ah, 2Fh        ;Operation code for command
 10247 00004BAC C0E005                      shl al, 5        ;Hardcode bytecheck (byte [1]) to 0
 10248 00004BAF 86E0                        xchg ah, al
 10249 00004BB1 66AB                        stosw            ;Store shifted LUN and command code
 10250 00004BB3 410FCC                      bswap r12d        ;swap endianness of r12d
 10251 00004BB6 4489E0                      mov eax, r12d
 10252 00004BB9 AB                          stosd
 10253 00004BBA 4831C0                      xor rax, rax    ;Clear for a Reserved byte
 10254 00004BBD AA                          stosb
 10255 00004BBE 66B80001                    mov ax, 0100h    ;Write the number 1 in Big endian
 10256 00004BC2 66AB                        stosw
 10257 00004BC4 C1E810                      shr eax, 16        ;Bring zeros down onto lower word
 10258 00004BC7 66AB                        stosw            ;Store one reserved byte and two padding bytes
 10259 00004BC9 AA                          stosb        
 10260 00004BCA C3                          ret
 10261                                  .scsiModeSense6:
 10262                                  ;al contains the LUN of the device we are accessing
 10263 00004BCB B41A                        mov ah, 1Ah     ;Operation code for Mode Sense 6
 10264 00004BCD C0E005                      shl al, 5       ;Move LUN
 10265 00004BD0 86E0                        xchg ah, al
 10266 00004BD2 66AB                        stosw
 10267 00004BD4 B83F00C000                  mov eax, 0C0003Fh    
 10268                                      ;Request all pages, reserve byte, 192 bytes and 0 end byte
 10269 00004BD9 AB                          stosd
 10270 00004BDA C3                          ret
 10271                                  ;                    -------------------------------
 10272                                  .ehciGetOpBase:
 10273                                  ;Gets opbase from mmio base (aka adds caplength) into eax
 10274                                  ;Input:
 10275                                  ; al = offset into ehci table
 10276                                  ;Return:
 10277                                  ; eax = opbase (low 4Gb)
 10278 00004BDB 53                          push rbx
 10279 00004BDC 4831DB                      xor rbx, rbx
 10280 00004BDF 480FB6C0                    movzx rax, al
 10281 00004BE3 8B04C5[19020000]            mov eax, dword [eControllerList + 4 + 8*rax]    ;get mmiobase into eax
 10282 00004BEA 85C0                        test eax, eax             ;addrress of 0 means no controller
 10283 00004BEC 7406                        jz .egob1
 10284 00004BEE 670FB618                    movzx ebx, byte [eax]    ;get the offset to opbase into ebx
 10285 00004BF2 01D8                        add eax, ebx            ;add this offset to mmiobase to get opbase
 10286                                  .egob1:
 10287 00004BF4 5B                          pop rbx
 10288 00004BF5 C3                          ret
 10289                                  
 10290                                  ;====================================CPU Interrupts=============================
 10291                                  i0:
 10292 00004BF6 4831C0                      xor rax, rax
 10293 00004BF9 E936010000                  jmp cpu_2args
 10294                                  i1:
 10295 00004BFE 48B801000000000000-         mov rax, 1
 10295 00004C07 00                 
 10296 00004C08 E927010000                  jmp cpu_2args
 10297                                  i2:
 10298 00004C0D 48B802000000000000-         mov rax, 2
 10298 00004C16 00                 
 10299 00004C17 E918010000                  jmp cpu_2args
 10300                                  i3:
 10301 00004C1C 48B803000000000000-         mov rax, 3
 10301 00004C25 00                 
 10302 00004C26 E909010000                  jmp cpu_2args
 10303                                  i4:
 10304 00004C2B 48B804000000000000-         mov rax, 4
 10304 00004C34 00                 
 10305 00004C35 E9FA000000                  jmp cpu_2args
 10306                                  i5:
 10307 00004C3A 48B805000000000000-         mov rax, 5
 10307 00004C43 00                 
 10308 00004C44 E9EB000000                  jmp cpu_2args
 10309                                  i6:
 10310 00004C49 48B806000000000000-         mov rax, 6
 10310 00004C52 00                 
 10311 00004C53 E9DC000000                  jmp cpu_2args
 10312                                  i7:
 10313 00004C58 48B807000000000000-         mov rax, 7
 10313 00004C61 00                 
 10314 00004C62 E9CD000000                  jmp cpu_2args
 10315                                  i8:
 10316 00004C67 48B808000000000000-         mov rax, 8
 10316 00004C70 00                 
 10317 00004C71 E9B2000000                  jmp cpu_3args
 10318                                  i9:
 10319 00004C76 48B809000000000000-         mov rax, 9
 10319 00004C7F 00                 
 10320 00004C80 E9AF000000                  jmp cpu_2args
 10321                                  i10:
 10322 00004C85 48B80A000000000000-         mov rax, 0Ah
 10322 00004C8E 00                 
 10323 00004C8F E994000000                  jmp cpu_3args
 10324                                  i11:
 10325 00004C94 48B80B000000000000-         mov rax, 0Bh
 10325 00004C9D 00                 
 10326 00004C9E E985000000                  jmp cpu_3args
 10327                                  i12:
 10328 00004CA3 48B80C000000000000-         mov rax, 0Ch
 10328 00004CAC 00                 
 10329 00004CAD E976000000                  jmp cpu_3args
 10330                                  i13:
 10331 00004CB2 48B80D000000000000-         mov rax, 0Dh
 10331 00004CBB 00                 
 10332 00004CBC EB6A                        jmp short cpu_3args
 10333                                  i14:
 10334 00004CBE 48B80E000000000000-         mov rax, 0Eh
 10334 00004CC7 00                 
 10335 00004CC8 EB52                        jmp short cpu_4args
 10336                                  i15:
 10337 00004CCA 48B80F000000000000-         mov rax, 0Fh
 10337 00004CD3 00                 
 10338 00004CD4 EB5E                        jmp short cpu_2args
 10339                                  i16:
 10340 00004CD6 48B810000000000000-         mov rax, 10h
 10340 00004CDF 00                 
 10341 00004CE0 EB52                        jmp short cpu_2args
 10342                                  i17:
 10343 00004CE2 48B811000000000000-         mov rax, 11h
 10343 00004CEB 00                 
 10344 00004CEC EB3A                        jmp short cpu_3args
 10345                                  i18:
 10346 00004CEE 48B812000000000000-         mov rax, 12h
 10346 00004CF7 00                 
 10347 00004CF8 EB3A                        jmp short cpu_2args
 10348                                  i19:
 10349 00004CFA 48B813000000000000-         mov rax, 13h
 10349 00004D03 00                 
 10350 00004D04 EB2E                        jmp short cpu_2args
 10351                                  i20:
 10352 00004D06 48B814000000000000-         mov rax, 14h
 10352 00004D0F 00                 
 10353 00004D10 EB22                        jmp short cpu_2args
 10354                                  i21:
 10355 00004D12 48B815000000000000-         mov rax, 15h
 10355 00004D1B 00                 
 10356                                  cpu_4args:
 10357 00004D1C 48B903000000000000-         mov rcx, 3
 10357 00004D25 00                 
 10358 00004D26 EB16                        jmp short cpu_exception
 10359                                  cpu_3args:
 10360 00004D28 48B902000000000000-         mov rcx, 2
 10360 00004D31 00                 
 10361 00004D32 EB0A                        jmp short cpu_exception
 10362                                  cpu_2args:
 10363 00004D34 48B901000000000000-         mov rcx, 1
 10363 00004D3D 00                 
 10364                                  cpu_exception:
 10365 00004D3E 50                          push rax
 10366 00004D3F 51                          push rcx
 10367 00004D40 66BB1F00                    mov bx, 001Fh    ;cls attribs
 10368 00004D44 E8AEB3FFFF                  call cls
 10369                                  
 10370 00004D49 48B800020000000000-         mov rax, 0200h
 10370 00004D52 00                 
 10371 00004D53 4831DB                      xor rbx, rbx
 10372 00004D56 48BA22070000000000-         mov rdx, 0722h    ;7 Rows down, 24 columns across
 10372 00004D5F 00                 
 10373 00004D60 48BD-                       mov rbp, .fatalt0
 10373 00004D62 [AB4E000000000000] 
 10374 00004D6A 66BB7100                    mov bx, 0071h     ;blue grey attribs, page 0
 10375 00004D6E 66B80113                    mov ax, 1301h     ;print zero 8 chars, with bh attrib
 10376 00004D72 48B908000000000000-         mov rcx, 8
 10376 00004D7B 00                 
 10377 00004D7C CD30                        int 30h
 10378                                  
 10379 00004D7E 48B800020000000000-         mov rax, 0200h
 10379 00004D87 00                 
 10380 00004D88 30FF                        xor bh, bh
 10381 00004D8A 48BA040A0000000000-         mov rdx, 0A04h    ;11 Rows down, 24 columns across
 10381 00004D93 00                 
 10382 00004D94 CD30                        int 30h
 10383 00004D96 48BD-                       mov rbp, .fatal1
 10383 00004D98 [B34E000000000000] 
 10384 00004DA0 30FF                        xor bh, bh        ;blue grey attribs, page 0
 10385 00004DA2 66B80413                    mov ax, 1304h            ;print zero terminated string
 10386 00004DA6 CD30                        int 30h
 10387                                  
 10388 00004DA8 59                          pop rcx
 10389 00004DA9 58                          pop rax                ;pop the exception number back into rax
 10390 00004DAA E8DF000000                  call .printbyte
 10391                                  
 10392 00004DAF 48B804130000000000-         mov rax, 1304h
 10392 00004DB8 00                 
 10393 00004DB9 30FF                        xor bh, bh
 10394 00004DBB 48BD-                       mov rbp, .fatal2
 10394 00004DBD [F44F000000000000] 
 10395 00004DC5 CD30                        int 30h
 10396                                  
 10397 00004DC7 80F901                      cmp cl, 1
 10398 00004DCA 773A                        ja .cpuextendederror    ;rax contains error code, or extra cr2 value
 10399                                  .cpurollprint:
 10400 00004DCC 488B1424                    mov rdx, qword [rsp]    ;Get address
 10401                                  ;Takes whats in rdx, rols left by one byte, prints al
 10402 00004DD0 B108                        mov cl, 8    ;8 bytes
 10403                                  .cpurollprint1:
 10404 00004DD2 48C1C208                    rol rdx, 8
 10405 00004DD6 88D0                        mov al, dl
 10406 00004DD8 52                          push rdx
 10407 00004DD9 E8B0000000                  call .printbyte
 10408 00004DDE 5A                          pop rdx
 10409 00004DDF FEC9                        dec cl
 10410 00004DE1 75EF                        jnz .cpurollprint1
 10411                                  
 10412                                  .cpuexendloop:
 10413 00004DE3 6631C0                      xor ax, ax
 10414 00004DE6 CD36                        int 36h
 10415 00004DE8 3C1B                        cmp al, 1Bh    ;Check for escape pressed (unlikely?)
 10416 00004DEA 740F                        je .cpu_exception_appret
 10417 00004DEC 3C0D                        cmp al, 0Dh ;Check for enter pressed
 10418 00004DEE 75F3                        jne .cpuexendloop
 10419                                  
 10420 00004DF0 66BB0700                    mov bx, 0007h    ;cls attribs
 10421 00004DF4 E8FEB2FFFF                  call cls
 10422 00004DF9 CD38                        int 38h    ;Jump to debugger
 10423                                  .cpu_exception_appret:
 10424 00004DFB 66BB0700                    mov bx, 0007h    ;cls attribs
 10425 00004DFF E8F3B2FFFF                  call cls
 10426 00004E04 48CF                        iretq ;Return to address on stack
 10427                                  
 10428                                  .cpuextendederror:
 10429 00004E06 5A                          pop rdx
 10430 00004E07 48FFC9                      dec rcx
 10431 00004E0A 51                          push rcx
 10432 00004E0B B102                        mov cl, 2    ;CAN CHANGE TO 4 BYTES IN THE FUTURE
 10433                                  .pr1:
 10434 00004E0D C1C208                      rol edx, 8    ;Print just edx
 10435 00004E10 88D0                        mov al, dl
 10436 00004E12 52                          push rdx
 10437 00004E13 E876000000                  call .printbyte
 10438 00004E18 5A                          pop rdx
 10439 00004E19 FEC9                        dec cl
 10440 00004E1B 75F0                        jnz .pr1
 10441                                  
 10442 00004E1D 48B804130000000000-         mov rax, 1304h
 10442 00004E26 00                 
 10443 00004E27 48BB17000000000000-         mov rbx, 17h
 10443 00004E30 00                 
 10444 00004E31 48BD-                       mov rbp, .fatal2
 10444 00004E33 [F44F000000000000] 
 10445 00004E3B CD30                        int 30h
 10446 00004E3D 59                          pop rcx    ;Bring the comparison value back into rcx
 10447                                      
 10448 00004E3E 48FFC9                      dec rcx
 10449 00004E41 7489                        jz .cpurollprint
 10450                                  
 10451 00004E43 B108                        mov cl, 8
 10452 00004E45 0F20D2                      mov rdx, cr2    ;Get page fault address
 10453                                  .pr2:
 10454 00004E48 48C1C208                    rol rdx, 8    ;Print rdx
 10455 00004E4C 88D0                        mov al, dl
 10456 00004E4E 52                          push rdx
 10457 00004E4F E83A000000                  call .printbyte
 10458 00004E54 5A                          pop rdx
 10459 00004E55 FEC9                        dec cl
 10460 00004E57 75EF                        jnz .pr2
 10461                                  
 10462 00004E59 48B804130000000000-         mov rax, 1304h
 10462 00004E62 00                 
 10463 00004E63 48BB17000000000000-         mov rbx, 17h
 10463 00004E6C 00                 
 10464 00004E6D 48BD-                       mov rbp, .fatal2
 10464 00004E6F [F44F000000000000] 
 10465 00004E77 CD30                        int 30h
 10466                                      
 10467 00004E79 E94EFFFFFF                  jmp .cpurollprint
 10468                                  
 10469                                  
 10470                                  .char:    ;Print a single character
 10471 00004E7E 48BB-                       mov rbx, .ascii
 10471 00004E80 [F84F000000000000] 
 10472 00004E88 D7                          xlatb    ;point al to entry in ascii table, using al as offset into table
 10473                                      ;xor bh, bh
 10474 00004E89 B40E                        mov ah, 0Eh
 10475 00004E8B CD30                        int 30h    ;print char
 10476 00004E8D C3                          ret
 10477                                  .printbyte:
 10478 00004E8E 88C2                        mov dl, al            ;save byte in dl
 10479 00004E90 6625F000                    and ax, 00F0h        ;Hi nybble
 10480 00004E94 6681E20F00                  and dx, 000Fh        ;Lo nybble
 10481 00004E99 66C1E804                    shr ax, 4            ;shift one hex place value pos right
 10482 00004E9D E8DCFFFFFF                  call .char
 10483 00004EA2 6689D0                      mov ax, dx            ;mov lo nybble, to print
 10484 00004EA5 E8D4FFFFFF                  call .char
 10485 00004EAA C3                          ret    
 10486 00004EAB 5343502F42494F53        .fatalt0:  db "SCP/BIOS"
 10487 00004EB3 4120706F74656E7469-     .fatal1:   db "A potentially fatal error has occured. To continue: ",0Ah,0Ah,0Dh
 10487 00004EBC 616C6C792066617461-
 10487 00004EC5 6C206572726F722068-
 10487 00004ECE 6173206F6363757265-
 10487 00004ED7 642E20546F20636F6E-
 10487 00004EE0 74696E75653A200A0A-
 10487 00004EE9 0D                 
 10488 00004EEA 202020205072657373-     db "    Press Enter to launch SYSDEBUG, or",0Ah,0Ah,0Dh 
 10488 00004EF3 20456E74657220746F-
 10488 00004EFC 206C61756E63682053-
 10488 00004F05 595344454255472C20-
 10488 00004F0E 6F720A0A0D         
 10489 00004F13 202020205072657373-     db "    Press ESC to try and return to the application which caused the error," 
 10489 00004F1C 2045534320746F2074-
 10489 00004F25 727920616E64207265-
 10489 00004F2E 7475726E20746F2074-
 10489 00004F37 6865206170706C6963-
 10489 00004F40 6174696F6E20776869-
 10489 00004F49 636820636175736564-
 10489 00004F52 20746865206572726F-
 10489 00004F5B 722C               
 10490 00004F5D 6F720A0A0D              db "or", 0Ah, 0Ah,0Dh,
 10491 00004F62 202020205072657373-     db "    Press CTRL+ALT+DEL to restart your system. If you do this,",0Ah,0Dh
 10491 00004F6B 204354524C2B414C54-
 10491 00004F74 2B44454C20746F2072-
 10491 00004F7D 65737461727420796F-
 10491 00004F86 75722073797374656D-
 10491 00004F8F 2E20496620796F7520-
 10491 00004F98 646F20746869732C0A-
 10491 00004FA1 0D                 
 10492 00004FA2 20202020796F752077-     db "    you will lose any unsaved information in all open applications.",0Ah, 
 10492 00004FAB 696C6C206C6F736520-
 10492 00004FB4 616E7920756E736176-
 10492 00004FBD 656420696E666F726D-
 10492 00004FC6 6174696F6E20696E20-
 10492 00004FCF 616C6C206F70656E20-
 10492 00004FD8 6170706C6963617469-
 10492 00004FE1 6F6E732E0A         
 10493 00004FE6 0A0D                    db 0Ah, 0Dh
 10494 00004FE8 202020204572726F72-     db "    Error: ",0
 10494 00004FF1 3A2000             
 10495 00004FF4 203A2000                .fatal2:   db " : ",0
 10496 00004FF8 303132333435363738-     .ascii:    db '0123456789ABCDEF'
 10496 00005001 39414243444546     
 10497                                  ;==========================Dummy Interrupts======================
 10498                                  dummy_interrupt:
 10499                                  .pic2:
 10500 00005008 50                          push rax
 10501 00005009 B020                        mov al, EOI
 10502 0000500B E6A0                        out pic2command, al    ;EOI to pic2
 10503 0000500D EB01                        jmp short .p1
 10504                                  .pic1:
 10505 0000500F 50                          push rax
 10506                                  .p1:
 10507 00005010 B020                        mov al, EOI
 10508 00005012 E620                        out pic1command, al    ;EOI to pic2
 10509 00005014 58                          pop rax
 10510                                  dummy_return_64:
 10511 00005015 48CF                        iretq
 10512                                  ;----------------------------------------------------------------
 10513 00005017 76302E392053435042-     signature:    db "v0.9 SCPBIOS"    ;12 byte signature
 10513 00005020 494F53             
 10514 00005023 436F70797269676874-     signature2:   db "Copyright (C) Yll Buzoku"
 10514 0000502C 2028432920596C6C20-
 10514 00005035 42757A6F6B75       
 10515 0000503B 30332F31322F323032-                   db "03/12/2021"
 10515 00005044 31                 
 10516                                  
 10517                                  codeResidentEndPtr:
 10518                                  residentLength  equ $-$$
